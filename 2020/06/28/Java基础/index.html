<!DOCTYPE html>
<html lang="zh-CH">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="光说不做假把式">
  <meta name="author" content="杨玉杰">
  <meta name="keywords" content="">
  <title>Java基础 - 杨玉杰|个人博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/agate.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>杨玉杰|个人博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友情链接
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bgi.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-06-28 16:49">
      June 28, 2020 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      58
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h1><h2 id="1-JVM、JRE和JDK的关系"><a href="#1-JVM、JRE和JDK的关系" class="headerlink" title="1. JVM、JRE和JDK的关系"></a>1. JVM、JRE和JDK的关系</h2><p><strong>JVM</strong><br>Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。<br><strong>JRE</strong><br>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包<br>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。<br><strong>JDK</strong><br>Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等<br><img src="https://img-blog.csdnimg.cn/20200626145717665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<h2 id="2-Java与C-的区别与联系"><a href="#2-Java与C-的区别与联系" class="headerlink" title="2. Java与C#的区别与联系"></a>2. Java与C#的区别与联系</h2><p>相同点：都是面向对象编程的语言，都能够实现面向对象的思想（封装，继承，多态）；都具有垃圾自动回收机制；Java站在C++的肩膀上，而C#站在了Java的肩膀上。<br>不同点：<br>语法特性：  Java抛弃了指针，使用了包（package）的概念，导入包使用import语句；C#没有完全抛弃指针（在unsafe状态下还可以操作指针），对于类的管理采用了名称空间（namespace）的概念，并且还使用了out、ref等关键字，便于从一个方法返回多个结果。<br>功能方面：C#有一些由编译器提供的特性，如：委托、属性、真正的泛型等，在Java中实现起来有点麻烦，同样Java中也有C#不具备的功能，如匿名内部类，动态代理等，另外Java实现了真正的跨平台性，而C#的跨平台性是建立在跨windows平台的基础上的。</p>
<h2 id="3-Java与C-C-的异同"><a href="#3-Java与C-C-的异同" class="headerlink" title="3. Java与C/C++的异同"></a>3. Java与C/C++的异同</h2><ol>
<li>Java是解释性语言，C/C++为编译型语言，源代码经过编译和链接后生成可执行的二进制代码，Java执行速度比C/C++慢，但Java能够跨平台执行；</li>
<li>Java为纯面向对象语言，不存在全局变量或全局函数；</li>
<li>Java没有指针的概念；</li>
<li>Java不支持多重继承</li>
<li>Java提供了垃圾回收器来实现垃圾的自动回收，C++通常会把需要释放资源的代码放到析构函数中；</li>
<li>Java具有平台无关性，即对每种数据类型都分配固定长度。</li>
</ol>
<h2 id="4-Oracle-JDK和OpenJDK的对比"><a href="#4-Oracle-JDK和OpenJDK的对比" class="headerlink" title="4. Oracle JDK和OpenJDK的对比"></a>4. Oracle JDK和OpenJDK的对比</h2><p>OpenJDk版本每三个月发布一次，而OracleJDK每三年发布一次；<br>OpenJDK是一个参考模型并且完全开源，而OracleJDK是OpenJDK的一个实现，并不是完全开源的；<br>OracleJDK比OpenJDK更稳定，性能更好</p>
<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="1、-switch能否作用在byte上，是否能作用在long上，是否能作用在String上？"><a href="#1、-switch能否作用在byte上，是否能作用在long上，是否能作用在String上？" class="headerlink" title="1、 switch能否作用在byte上，是否能作用在long上，是否能作用在String上？"></a>1、 switch能否作用在byte上，是否能作用在long上，是否能作用在String上？</h2><p>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</p>
<p>原因是switch在编译时被编译成对应的两个实现方式的指令，而这两个指令只支持int类型。</p>
<h2 id="2、Java语言采用何种编码方式，有什么特点？"><a href="#2、Java语言采用何种编码方式，有什么特点？" class="headerlink" title="2、Java语言采用何种编码方式，有什么特点？"></a>2、Java语言采用何种编码方式，有什么特点？</h2><p>Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p>
<p>Unicode 编码共有三种具体实现，分别为utf-8,utf-16,utf-32，其中utf-8占用一到四个字节，utf-16占用二或四个字节，utf-32占用四个字节</p>
<h2 id="3、-super关键字的用法"><a href="#3、-super关键字的用法" class="headerlink" title="3、 super关键字的用法"></a>3、 super关键字的用法</h2><p>super可以理解为是指向自己超（父）类对象的一个指针。<br>A：可以利用super关键字代表父类对象访问父类的属性和方法；<br>    super.属性 —-&gt; 访问父类的属性<br>    super.方法名()—- &gt; 调用父类的方法<br>B：可以使用super关键字调用父类的构造函数，必须出现在构造函数的第一行；<br>C：super不能和static混用，因为super指的是对象，而static代表的是类。</p>
<h2 id="4、static关键字的意义"><a href="#4、static关键字的意义" class="headerlink" title="4、static关键字的意义"></a>4、static关键字的意义</h2><p>主要意义是在于创建独立于具体对象的域变量或者方法，以至于即使没有创建对象，也能使用属性和调用方法！<br>另外还可以用来形成静态代码块用来优化程序性能，因为static块在类加载的时候仅会执行一次，所以可以将一些只需要进行一次的初始化操作都放在static代码块中进行;</p>
<p>利用static实现单例模式：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span></span>&#123;
		<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;
	&#125;
	
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;
		<span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;
	&#125;
&#125;</code></pre></div>


<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="1、面向对象和面向过程的区别"><a href="#1、面向对象和面向过程的区别" class="headerlink" title="1、面向对象和面向过程的区别"></a>1、面向对象和面向过程的区别</h2><p>面向过程注重的是性能，因为面向对象万物皆对象，而类调用时需要实例化，开销比较大，比较消耗资源；<br>面向对象易维护，易复用，易扩展，主要是得益于面向对象的封装，继承，多态特性，可以设计出低耦合的系统；</p>
<h2 id="2、什么是多态机制？Java中是如何实现多态的？"><a href="#2、什么是多态机制？Java中是如何实现多态的？" class="headerlink" title="2、什么是多态机制？Java中是如何实现多态的？"></a>2、什么是多态机制？Java中是如何实现多态的？</h2><p>对于面向对象而言，多态分为编译时多态和运行时多态，其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，而运行时多态是动态的，通过动态绑定来实现，多态性就是相同的消息使得不同的类做出不同的响应。<br>多态性体现在父类中定义的属性和方法被子类继承后，可以具有不同的属性或表现方式，多态性允许一个接口被多个同类使用，弥补了单继承的不足。</p>
<p>Java的多态是通过继承、重写、重载来实现的。</p>
<h2 id="3、面向对象的五大基本原则？"><a href="#3、面向对象的五大基本原则？" class="headerlink" title="3、面向对象的五大基本原则？"></a>3、面向对象的五大基本原则？</h2><p>单一职责原则：类的功能要单一<br>开放封闭原则：对扩展开放，对修改关闭<br>里氏替换原则：子类可以替换父类出现在父类能够出现的地方<br>依赖倒置原则：高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象<br>接口分离原则：设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好</p>
<h2 id="4、对象实例和对象引用有什么不同？"><a href="#4、对象实例和对象引用有什么不同？" class="headerlink" title="4、对象实例和对象引用有什么不同？"></a>4、对象实例和对象引用有什么不同？</h2><p>对象实例存储在堆上，对象引用存储在栈中，要访问对象实例可以通过对象引用来访问。</p>
<h2 id="5、成员变量和局部变量的区别有哪些？"><a href="#5、成员变量和局部变量的区别有哪些？" class="headerlink" title="5、成员变量和局部变量的区别有哪些？"></a>5、成员变量和局部变量的区别有哪些？</h2><p><strong>作用域</strong><br>成员变量：针对整个类有效<br>局部变量：只在某个范围内有效<br><strong>存储位置</strong><br>成员变量：存储在堆中<br>局部变量：存储在栈内存中<br><strong>生命周期</strong><br>成员变量：随着对象的创建而存在，随着对象的消失而消失<br>局部变量：当方法调用完，或者语句结束后，就自动释放<br><strong>初始值</strong><br>成员变量：有默认初始值<br>局部变量：没有默认初始值，使用前必须赋值</p>
<h2 id="6、在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#6、在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="6、在Java中定义一个不做事且没有参数的构造方法的作用"></a>6、在Java中定义一个不做事且没有参数的构造方法的作用</h2><p>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”，因此，如果父类中只定义了有参数的构造方法，而在子类中的构造方法中又没有用super()来调用父类中特定的构造方法，则会在编译时发生错误。</p>
<h2 id="7、在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是什么"><a href="#7、在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是什么" class="headerlink" title="7、在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是什么"></a>7、在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是什么</h2><p>帮助子类做初始化工作，因为子类拥有弗雷德成员变量和成员方法，如果不调用，则从父类继承而来的成员变量和成员方法得不到正确的初始化。</p>
<h2 id="8、构造方法有哪些特性？"><a href="#8、构造方法有哪些特性？" class="headerlink" title="8、构造方法有哪些特性？"></a>8、构造方法有哪些特性？</h2><p>方法名和类名相同<br>没有返回值，但不能用void声明构造函数<br>生成类的对象时自动执行，无需调用</p>
<h2 id="9、静态变量、实例变量的区别"><a href="#9、静态变量、实例变量的区别" class="headerlink" title="9、静态变量、实例变量的区别"></a>9、静态变量、实例变量的区别</h2><p>静态变量：静态变量不属于任何实例对象，而属于类，所以在内存中只会存在一份，在类的加载过程中，JVM只为静态变量分配一次内存空间；<br>实例变量：每次创建对象，都会为每个对象分配成员变量内存空间，实例变量属于实例对象，在内存中创建几次对象，就会有几份成员变量</p>
<h2 id="10、内部类的优点？有哪些应用场景"><a href="#10、内部类的优点？有哪些应用场景" class="headerlink" title="10、内部类的优点？有哪些应用场景"></a>10、内部类的优点？有哪些应用场景</h2><p><strong>优点</strong>：<br>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据<br>内部类不为同一包的其他类所见，具有很好的封装性<br>内部类有效实现了“多重继承”，优化Java单继承的缺陷<br>匿名内部类可以很方便的实现回调</p>
<p><strong>应用场景</strong>：<br>一些多算法场合<br>解决一些非面向对象的语句块<br>适当使用内部类，使得代码更加灵活和富有扩展性<br>当某个类除了它的外部类，不再被其他的类使用时</p>
<h2 id="11、匿名内部类"><a href="#11、匿名内部类" class="headerlink" title="11、匿名内部类"></a>11、匿名内部类</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> i)</span> </span>&#123;
        <span class="hljs-keyword">new</span> Service() &#123;
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;
                    System.out.println(<span class="hljs-string">"匿名内部类"</span> );
                &#125;
            &#125;
        &#125;.method();
    &#125;
 &#125;
 <span class="hljs-comment">//匿名内部类必须继承或实现一个已有的接口 </span>
 <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Service</span></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;
&#125;</code></pre></div>
<p><strong>特点</strong>：</p>
<ul>
<li>匿名内部类必须继承一个抽象类或者实现一个接口</li>
<li>匿名内部类不能定义任何静态成员和静态方法</li>
<li>当所在的方法的形参需要被匿名内部类使用时，必须声明为final</li>
<li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现接口的所有方法</li>
</ul>
<h2 id="11、局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加final"><a href="#11、局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加final" class="headerlink" title="11、局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加final"></a>11、局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加final</h2><p>用final修饰实际上是为了保护数据的一致性，因为如果局部变量发生变化后，匿名内部类或局部内部类是不知道的（因为它只是拷贝了局部变量的值，并不是直接使用的局部变量），如果过了一段时间后局部变量的值指向另外一个对象，或是值发生了改变，那么程序运行的结果和预期的会不一致。<br><img src="https://img-blog.csdnimg.cn/20200627000517571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>JDK1.8中虽然局部变量不需要用final修饰符修饰，但是我们在试图改变这个局部变量的时候会提示编译出错。</p>
<h2 id="12、重载的方法能否根据返回类型进行区分"><a href="#12、重载的方法能否根据返回类型进行区分" class="headerlink" title="12、重载的方法能否根据返回类型进行区分"></a>12、重载的方法能否根据返回类型进行区分</h2><p>重载发生在同一个类中，方法名相同但参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关。</p>
<h2 id="13、hashcode和equals"><a href="#13、hashcode和equals" class="headerlink" title="13、hashcode和equals"></a>13、hashcode和equals</h2><p>这个问题应该是有个前提，就是你需要用到 HashMap、HashSet 等 Java 集合，用不到哈希表的话，其实仅仅重写 equals() 方法也可以。而工作中的场景是常常用到 Java 集合，所以 Java 官方建议重写 equals() 就一定要重写 hashCode() 方法。<br>对于对象集合的判重，如果一个集合含有 10000 个对象实例，仅仅使用 equals() 方法的话，那么对于一个对象判重就需要比较 10000 次，随着集合规模的增大，时间开销是很大的。但是同时使用哈希表的话，就能快速定位到对象的大概存储位置，并且在定位到大概存储位置后，后续比较过程中，如果两个对象的 hashCode 不相同，也不再需要调用 equals() 方法，从而大大减少了 equals() 比较次数。 </p>
<p>hashCode()与equals()的相关规定：<br>1、如果两个对象相等，则 hashCode 一定也是相同的；<br>2、两个对象相等，对两个对象分别调用 equals 方法都返回 true；<br>3、两个对象有相同的 hashCode 值，它们也不一定是相等的；<br>4、因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖；<br>5、hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</p>
<h2 id="14、当一个对象被当作参数传递到一个方法后，此方法可改变整个对象的属性，并返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#14、当一个对象被当作参数传递到一个方法后，此方法可改变整个对象的属性，并返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="14、当一个对象被当作参数传递到一个方法后，此方法可改变整个对象的属性，并返回变化后的结果，那么这里到底是值传递还是引用传递"></a>14、当一个对象被当作参数传递到一个方法后，此方法可改变整个对象的属性，并返回变化后的结果，那么这里到底是值传递还是引用传递</h2><p>是值传递。Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的，也就是说这个引用还是会指向之前的对象，而不会指向其他对象。之所以能修改引用数据是因为它们同时指向了一个对象。</p>
<h2 id="15、值传递和引用传递的区别"><a href="#15、值传递和引用传递的区别" class="headerlink" title="15、值传递和引用传递的区别"></a>15、值传递和引用传递的区别</h2><p>所谓的按值调用表示方法接收的是调用者提供的值，而按引用调用则表示方法接收的是调用者提供的变量地址，一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</p>
<h2 id="16、import-java和javax有什么区别"><a href="#16、import-java和javax有什么区别" class="headerlink" title="16、import java和javax有什么区别"></a>16、import java和javax有什么区别</h2><p>实际上java和javax没有区别。这都是一个名字。</p>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="1-同步、异步、阻塞、非阻塞的区别"><a href="#1-同步、异步、阻塞、非阻塞的区别" class="headerlink" title="1.同步、异步、阻塞、非阻塞的区别"></a>1.同步、异步、阻塞、非阻塞的区别</h2><p><strong>同步和异步</strong>：<br>同步：同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。<br>异步：异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但此时结果并没有返回，此时调用者可以处理其他的请求，被调用者通常依靠事件、回调等机制来通知调用者其返回结果。<br><strong>同步和异步最大区别在于异步的话不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果</strong></p>
<p><strong>阻塞和非阻塞</strong>：<br>阻塞：阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续<br>非阻塞：非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。</p>
<p><strong>同步和异步关注的是消息通信机制</strong>：<br>所谓同步，就是在发出一个<strong>调用</strong>时，在没有得到结果之前，该<strong>调用</strong>就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由<strong>调用者</strong>主动等待这个<strong>调用</strong>的结果。而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>
<p>比如说：<br>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p>
<p><strong>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态</strong>：<br>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<p>还是上面的例子，你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。</p>
<h2 id="2-BIO、NIO、AIO有什么区别"><a href="#2-BIO、NIO、AIO有什么区别" class="headerlink" title="2.BIO、NIO、AIO有什么区别"></a>2.BIO、NIO、AIO有什么区别</h2><h3 id="BIO：同步阻塞I-O模型，数据的读取写入必须阻塞在一个线程内等待其完成"><a href="#BIO：同步阻塞I-O模型，数据的读取写入必须阻塞在一个线程内等待其完成" class="headerlink" title="BIO：同步阻塞I/O模型，数据的读取写入必须阻塞在一个线程内等待其完成"></a>BIO：同步阻塞I/O模型，数据的读取写入必须阻塞在一个线程内等待其完成</h3><p>采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，我们一般通过在while(true)循环中服务端会调用accept()方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就建立通信套接字来进行读写操作，如果要让BIO通信模型能够同时处理多个客户端的请求，就必须使用多线程，也就是说它在接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理。为了减少线程创建和销毁带来的开销，可以采用线程池的方式来管理线程。</p>
<h3 id="NIO：同步非阻塞的I-O模型"><a href="#NIO：同步非阻塞的I-O模型" class="headerlink" title="NIO：同步非阻塞的I/O模型"></a>NIO：同步非阻塞的I/O模型</h3><p>Java NIO使我们可以进行非阻塞IO操作，比如单线程从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程在继续处理数据，写数据同样如此。<br>NIO类库中加入了<strong>Buffer</strong>对象，在NIO库中，所有数据都是用缓冲区处理的，每种Java基本类型（除了Boolean）都对应一种缓冲区。<br><strong>Channel（通道）</strong>：NIO通过Channel进行读写，通道是双向的，可读也可写，而IO中的流是单向的，Channel只能和Buffer交互，因为Buffer，通道可以异步地读写。<br><strong>Selector（选择器）</strong>：选择器用于使用单个线程处理多个通道。<br><img src="https://img-blog.csdnimg.cn/20200627012154414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<h3 id="AIO：异步IO"><a href="#AIO：异步IO" class="headerlink" title="AIO：异步IO"></a>AIO：异步IO</h3><p>步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
<h2 id="3-Files常用方法有哪些"><a href="#3-Files常用方法有哪些" class="headerlink" title="3.Files常用方法有哪些"></a>3.Files常用方法有哪些</h2><p>Files. exists()：检测文件路径是否存在。<br>Files. createFile()：创建文件。<br>Files. createDirectory()：创建文件夹。<br>Files. delete()：删除一个文件或目录。<br>Files. copy()：复制文件。<br>Files. move()：移动文件。<br>Files. size()：查看文件个数。<br>Files. read()：读取文件。<br>Files. write()：写入文件。</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="什么是反射机制"><a href="#什么是反射机制" class="headerlink" title="什么是反射机制"></a>什么是反射机制</h2><p>JAVA反射机制是在<strong>运行状态</strong>中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<h2 id="反射机制的优缺点"><a href="#反射机制的优缺点" class="headerlink" title="反射机制的优缺点"></a>反射机制的优缺点</h2><p>优点：可以动态执行，在运行期间根据业务功能动态执行方法、访问属性，最大限度发挥了java的灵活性。<br>缺点：对性能有影响，这类操作总是慢于直接执行java代码；使内部暴露，破坏封装；反射技术要求程序必须在一个没有安全限制的环境中运行。</p>
<h2 id="反射机制的应用场景"><a href="#反射机制的应用场景" class="headerlink" title="反射机制的应用场景"></a>反射机制的应用场景</h2><p>在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；<br>Spring框架也用到很多反射机制，最经典的就是xml的配置模式；<br>Web服务器中利用反射调用了Sevlet的服务方法。<br>IDEA等开发工具利用反射动态剖析对象的类型与结构，动态提示对象的属性和方法。</p>
<h2 id="Java获取反射的三种方法"><a href="#Java获取反射的三种方法" class="headerlink" title="Java获取反射的三种方法"></a>Java获取反射的三种方法</h2><p>1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Get</span> </span>&#123;
    <span class="hljs-comment">//获取反射机制三种方式</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;
        <span class="hljs-comment">//方式一(通过建立对象)</span>
        Student stu = <span class="hljs-keyword">new</span> Student();
        Class classobj1 = stu.getClass();
        System.out.println(classobj1.getName());
        <span class="hljs-comment">//方式二（所在通过路径-相对路径）</span>
        Class classobj2 = Class.forName(<span class="hljs-string">"fanshe.Student"</span>);
        System.out.println(classobj2.getName());
        <span class="hljs-comment">//方式三（通过类名）</span>
        Class classobj3 = Student<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;
        System.out.println(classobj3.getName());
    &#125;
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;
    String name;
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> sex;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> score;
&#125;</code></pre></div>
            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java%E9%9D%A2%E8%AF%95/">Java面试</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java%E9%9D%A2%E8%AF%95/">Java面试</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/06/28/Java%E9%9B%86%E5%90%88/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java集合</span>
                        <span class="visible-mobile">前の記事</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/06/24/Tomcat%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%B5%85%E8%B0%88/">
                        <span class="hidden-mobile">Tomcat系统架构浅谈</span>
                        <span class="visible-mobile">次の記事</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <script defer src="https://utteranc.es/client.js"
          repo="gavin-yyj/commit-utterance"
          issue-term="pathname"
  
          theme="github-light"
          crossorigin="anonymous"
  >
  </script>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;ディレクトリ</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">検索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">キーワード</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Java基础&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
