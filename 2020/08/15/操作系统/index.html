<!DOCTYPE html>
<html lang="zh-CH">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="光说不做假把式">
  <meta name="author" content="杨玉杰">
  <meta name="keywords" content="">
  <title>操作系统 - 杨玉杰|个人博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/agate.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>杨玉杰|个人博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友情链接
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bgi.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-08-15 13:21">
      August 15, 2020 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      13.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      142
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><ul>
<li>并发是指宏观上在一段时间内能同时运行多个程序；</li>
<li>并行是指同一时刻有多个指令在运行；</li>
<li>并行需要硬件支持，如：多流水线，多核处理器或者分布式计算系统；<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3>共享是指系统中的资源可以被多个并发进程共同使用，分为互斥共享和同时共享。</li>
<li>互斥共享的资源称为临界资源，例如打印机，在同一时刻只允许一个进程访问，需要用同步机制来实现对临界资源的访问。</li>
<li>同时共享允许一个时间段内由多个进程“同时”对它们进行访问，如：打游戏的时候，可以边打游戏，边听歌。<h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3>虚拟技术把一个物理实体转换为多个逻辑实体，主要分为时分复用技术和空分复用技术。</li>
<li>时分复用技术用于多个进程在同一个处理器上并发执行，让每个进程轮流占有处理器，每次只执行一小个时间片并快速切换。</li>
<li>空分复用技术用于空间管理，利用存储器的空闲空间分区域存放和运行多道程序，可以提高存储空间的利用率。<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3>在多道程序环境中，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进。</li>
</ul>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>其主要工作是进程调度，在多道程序或多用户的情况下，组织多个作业或任务时，就要解决处理器的调度、分配和回收等问题。</p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>主要是指针对内存储器的管理，主要任务是分配内存空间，保证各作业占用的存储空间不发生矛盾，并使各作业在自己所属存储区中不互相干扰。</p>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>指对信息资源的管理，包括对文件的存储、检索和修改等操作以及文件的保护等。</p>
<h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><p>指负责管理各类外围设备，包括分配、启动和故障处理等，主要任务是当用户使用外部设备时，必须提出要求，待操作系统进行统一分配后方可使用。</p>
<h3 id="作业管理"><a href="#作业管理" class="headerlink" title="作业管理"></a>作业管理</h3><p>从用户的角度看，作业是系统为完成一个用户的计算任务（或一次事务处理）所做的工作总和。<br>从系统的角度来看，作业则是一个比程序更广的概念，它由程序，数据和作业说明书组成，系统通过作业说明书控制文件形式的程序和数据，使之执行和操作，而且，在批处理系统中，作业是占据内存的基本单位。<br><img src="https://img-blog.csdnimg.cn/20200815114148779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用就是应用程序与系统内核之间的接口，通过系统调用访问系统资源。<br><img src="https://img-blog.csdnimg.cn/20200815114318766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<h3 id="常见的Linux系统调用"><a href="#常见的Linux系统调用" class="headerlink" title="常见的Linux系统调用"></a>常见的Linux系统调用</h3><h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><ul>
<li>fork：创建一个新进程</li>
<li>exit：终止进程</li>
<li>wait：等待子进程终止<h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4></li>
<li>pipe：创建管道</li>
<li>shmget：获取共享内存</li>
<li>mmap：映射虚拟内存页<h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4></li>
<li>open：打开文件</li>
<li>read：读文件</li>
<li>write：写文件<h4 id="信息维护"><a href="#信息维护" class="headerlink" title="信息维护"></a>信息维护</h4></li>
<li>getpid：获取进程标识符</li>
<li>alarm：设置进程的闹钟</li>
<li>sleep：使进程睡眠指定时间<h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4></li>
<li>chmod：改变文件权限</li>
<li>umask：设置文件权限掩码</li>
<li>chown：改变文件的属主或用户主<h4 id="设备操作"><a href="#设备操作" class="headerlink" title="设备操作"></a>设备操作</h4></li>
<li>ioctl：IO总控制函数</li>
</ul>
<h2 id="大内核和微内核"><a href="#大内核和微内核" class="headerlink" title="大内核和微内核"></a>大内核和微内核</h2><h3 id="大内核"><a href="#大内核" class="headerlink" title="大内核"></a>大内核</h3><p>大内核系统将操作系统大内核系统将操作系统的主要功能模块都作为一个紧密联系的整体，运行在核心态，从而为应用提供高性能的系统服务。因为各管理模块之间共享信息，能有效利用相互之间的有效特性，所以具有无可比拟的<strong>性能优势</strong>。</p>
<h3 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h3><p>解决操作系统的内核代码难以维护的问题。将内核中最基本的功能（如进程管理等）保留在内核，而将那些不需要在核心态执行的功能移到用户态执行，从而降低了内核的设计复杂性。微内核结构有效地分离了内核与服务、服务与服务，使得它们之间的接口更加清晰，维护的代价大大降低，各部分可以独立地优化和演进，从而保证了操作系统的可靠性。其最大的问题是<strong>性能问题</strong>，因为需要频繁地在核心态和用户态之间进行切换，操作系统的执行开销偏大。<br><img src="https://img-blog.csdnimg.cn/20200815115157234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><ul>
<li>第一类是由CPU<strong>外部</strong>引起的，称作<strong>中断</strong>，如I/O中断、时钟中断、控制台中断等。</li>
<li>第二类是来自CPU的<strong>内部</strong>事件或程序执行中的事件引起的过程，称作<strong>异常</strong>，如由于CPU本身故障（电源电压低于1.05V或频率在47～63Hz之外）、程序故障（非法操作码、地址越界、浮点溢出等）等引起的过程。</li>
<li>第三类由于在程序中使用了请求系统服务的系统调用而引发的过程，称作“<strong>陷入</strong>”(trap,或者陷阱)。前两类通常都称作中断，它们的产生往往是无意、被动的，而<strong>陷入是有意和主动的</strong>。</li>
</ul>
<h1 id="进程管理-1"><a href="#进程管理-1" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><ul>
<li>根本区别：进程是操作系统<strong>资源分配</strong>和<strong>任务调度</strong>的基本单位，而线程是<strong>程序执行</strong>的最小单位。</li>
<li>开销方面：每个进程都有独立的代码和数据空间（程序上下文），进程之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</li>
<li>所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</li>
<li>内存分配：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源）<strong>，线程组之间只能共享资源</strong>。</li>
<li>包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li>
<li>不同进程地址空间相互独立，<strong>同一进程内的线程共享同一地址空间</strong>。一个进程的线程在另一个进程内是不可见的；</li>
<li>进程间不会相互影响，而一个线程挂掉将可能导致整个进程挂掉；</li>
</ul>
<h2 id="为什么有了进程，还要有线程呢？"><a href="#为什么有了进程，还要有线程呢？" class="headerlink" title="为什么有了进程，还要有线程呢？"></a>为什么有了进程，还要有线程呢？</h2><p>进程可以使多个程序并发执行，以提高资源的利用率和系统的吞吐量，但是其带来了一些缺点：</p>
<ul>
<li>进程在同一时间只能干一件事情；</li>
<li>进程在执行的过程中如果阻塞，整个进程就会被挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行。</li>
</ul>
<p>基于以上的缺点，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而<strong>减少程序在并发执行时所付出的时间和空间开销，提高并发性能。</strong></p>
<h2 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h2><p><img src="https://img-blog.csdnimg.cn/20200815120646614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>阻塞和就绪的区别：阻塞是等待除CPU以外的资源，而就绪等待的是CPU资源。<br>1）就绪——执行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了CPU时间片后，该进程便由就绪状态变为执行状态；<br>2）执行——阻塞：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如进程提出输入/输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等；<br>3）阻塞——就绪：处于阻塞状态的进程，在其等待的事件已经发生，如输入/输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；<br>4）执行——就绪：正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中，当有更高优先级的进程要运行而被迫让出CPU时，该进程便由执行状态转变为就绪状态。</p>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><table>
<thead>
<tr>
<th>调度算法名称</th>
<th>概念</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>先来先服务（FCFS, First Come First Serve）</td>
<td>按照作业提交或进程变为就绪状态的先后次序，分派CPU；当前作业或进程占用CPU，直到执行完或阻塞，才出让CPU（非抢占方式）</td>
<td>比较有利于长作业，而不利于短作业。 有利于CPU繁忙的作业，而不利于I/O繁忙的作业。</td>
</tr>
<tr>
<td>轮转法(Round Robin)</td>
<td>系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片，如100ms。在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺）处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。</td>
<td>时间片轮转算法的效率和时间片的大小有很大关系：因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。而如果时间片过长，那么实时性就不能得到保证。</td>
</tr>
<tr>
<td>短作业(SJF)优先</td>
<td>从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。</td>
<td>非抢占策略，对长作业不利，可能出现“饥饿”现象</td>
</tr>
<tr>
<td>最短剩余时间优先</td>
<td>进程调度总是选择预期剩余时间最短的进程</td>
<td>调度程序正在执行选择函数是必须有关于处理时间的估计，并且存在长进程饥饿的危险。</td>
</tr>
<tr>
<td>多级反馈队列调度算法</td>
<td>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100次。多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</td>
<td>终端型作业用户：短作业优先。短批处理作业用户：周转时间较短。长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理。</td>
</tr>
<tr>
<td>## 进程同步</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>每个进程中访问临界资源的那段代码称为临界区，临界资源是一次只允许一个进程使用的共享资源，每次只准许一个进程进入临界区，进入后不允许其他进程进入，不论是硬件临界资源还是软件临界资源，多个进程必须互斥的对它进行访问。</p>
<h3 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h3><ul>
<li>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。</li>
<li>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3>信号量的值大于或等于0时表示可供并发进程使用的资源实体数；小于0时代表正在等待使用临界资源的进程数。<h3 id="管程（Monitor）"><a href="#管程（Monitor）" class="headerlink" title="管程（Monitor）"></a>管程（Monitor）</h3><h4 id="引入管程的原因："><a href="#引入管程的原因：" class="headerlink" title="引入管程的原因："></a>引入管程的原因：</h4>信号量机制的缺陷，如：进程自备同步操作，P（通过）和V（释放）操作大量分散在各个进程中，<strong>不易管理，易发生死锁</strong>。<br>管程特点：管程封装了同步操作，对进程隐蔽了同步细节，简化了同步功能的调用界面。用户编写并发程序如同编写串行程序。<h4 id="引入管程机制的目的："><a href="#引入管程机制的目的：" class="headerlink" title="引入管程机制的目的："></a>引入管程机制的目的：</h4>1、把分散在各进程中的临界区集中起来进行管理；<br>2、防止进程有意或无意的违法同步操作；<br>3、便于用高级语言来书写程序，也便于程序正确性验证。<h4 id="管程的定义："><a href="#管程的定义：" class="headerlink" title="管程的定义："></a>管程的定义：</h4>管程是由局部于自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块。<h4 id="组成部分："><a href="#组成部分：" class="headerlink" title="组成部分："></a>组成部分：</h4>1）局部于管程的共享变量；<br>2）对数据结构进行操作的一组过程；<br>3）对局部于管程的数据进行初始化的语句。<h4 id="管程的属性"><a href="#管程的属性" class="headerlink" title="管程的属性"></a>管程的属性</h4></li>
<li>共享性：管程可被系统范围内的进程互斥访问，属于共享资源</li>
<li>安全性：管程的局部变量只能由管程的过程访问，不允许进程或其它管程直接访问，管程也不能访问非局部于它的变量。</li>
<li>互斥性：多个进程对管程的访问是互斥的。任一时刻，管程中只能有一个活跃进程。</li>
<li>封装性：管程内的数据结构是私有的，只能在管程内使用，管程内的过程也只能使用管程内的数据结构。进程通过调用管程的过程使用临界资源。管程在Java中已实现。</li>
</ul>
<p>管程引入了条件变量以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p>
<p>临界区和互斥量与信号量的区别在于，互斥量和信号量在系统中任何进程里都是可见的，也就是说，一个进程创建了一个互斥量或信号量，另一个进程试图去获取该锁是合法的。然而，临界区的作用范围仅限于本进程，其他的进程无法获取该锁。除此之外，临界区具有和互斥量相同的性质。</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p><img src="https://img-blog.csdnimg.cn/20200816090435649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>每个进程的用户空间都是独立的，一般而言不能相互访问，但内核空间是每个进程都共享的，所以进程之间通信必须通过内核空间。<br><img src="https://img-blog.csdnimg.cn/2020081609070968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<h3 id="管道：通常指无名管道。"><a href="#管道：通常指无名管道。" class="headerlink" title="管道：通常指无名管道。"></a>管道：通常指无名管道。</h3><h4 id="1、特点："><a href="#1、特点：" class="headerlink" title="1、特点："></a>1、特点：</h4><ul>
<li>它是<strong>半双工</strong>的（即数据只能在一个方向上流动），具有固定的读端和写端。</li>
<li>它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间），一般使用<code>fork</code>函数实现父子进程的通信。</li>
<li>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且<strong>只存在于内存中</strong>。</li>
</ul>
<h4 id="2、匿名管道的创建："><a href="#2、匿名管道的创建：" class="headerlink" title="2、匿名管道的创建："></a>2、匿名管道的创建：</h4><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd[<span class="hljs-number">2</span>])</span></span>;    <span class="hljs-comment">// 返回值：若成功返回0，失败返回-1</span></code></pre></div>

<p>当一个管道创建时，它会创建两个文件描述符：fd[0]为读而打开，fd[1]为写而打开。如下图：<br><img src="https://img-blog.csdnimg.cn/20200815130209195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>所谓的管道，就是内核里面的一串缓存，要关闭管道只需将这两个文件描述符关闭即可。</p>
<h4 id="3、管道如何实现跨进程？"><a href="#3、管道如何实现跨进程？" class="headerlink" title="3、管道如何实现跨进程？"></a>3、管道如何实现跨进程？</h4><p>通过使用fork函数创建子进程，创建的子进程会复制父进程的文件描述符，这样就做到了两个进程各有一个fd[0]和fd[1]，两个进程就可以通过各自的fd写入和读取同一个管道文件实现跨进程通信了。<br><img src="https://img-blog.csdnimg.cn/20200816091643695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>管道只能一端写入，另一端读出，为了避免父进程和子进程同时写入或同时读出这种情况发生，通常的做法是：</p>
<ul>
<li>父进程关闭读取的fd[0]，只保留写入的fd[1]；</li>
<li>子进程关闭写入的fd[1]，只保留读取的fd[0]；</li>
</ul>
<p>如果要实现双向通信，则应该创建两个管道。</p>
<h3 id="FIFO：又称命名管道。"><a href="#FIFO：又称命名管道。" class="headerlink" title="FIFO：又称命名管道。"></a>FIFO：又称命名管道。</h3><p>概念：在内核中申请一块固定大小的缓冲区，程序拥有写入和读取的权利，<strong>没有血缘关系的进程也可以进程间通信。</strong><br>常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。 </p>
<div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ps auxf | grep mysql</span></code></pre></div>
<p>上面命令行里的「|」竖线就是一个管道，它的功能是将前一个命令（ps auxf）的输出，作为后一个命令（grep mysql）的输入。<br>在shell里面执行<code>A | B</code>命令的时候，A进程和B进程都是shell创建出来的子进程，A和B之间不存在父子关系，它俩的父进程都是shell。<br><img src="https://img-blog.csdnimg.cn/20200816092107260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在shell中通过<code>|</code>匿名管道将多个命令连接起来，实际上就是创建了多个子进程，在编写shell脚本的时候，能使用一个管道搞定的事情，就不要多用一个管道，这样就可以减少创建子进程的系统开销。</p>
<p>对于命令管道，它可以在不相关的进程间也能相互通信，这是因为命令管道提前创建了一个类型为管道的设备文件，在进程里只要使用了这个设备文件，就可以相互通信。</p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>1、面向字节流，<br>2、生命周期随内核<br>3、自带同步互斥机制<br>4、半双工，单向通信，两个管道实现双向通信</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>管道的通信方式最大的缺点是效率低，因此管道不适合进程间频繁地交换数据。</p>
<h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><p>“消息队列”是在消息的传输过程中保存消息的容器。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</p>
<p>消息队列保存在内核中的消息链表，在发送数据时，会分成一个个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p>
<p>消息队列生命周期随内核，如果没有释放消息队列或没有关闭操作系统，消息队列会一直存在，而匿名管道的声明周期是随着进程的创建而建立，随进程的结束而销毁。</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>
<li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。<h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4></li>
<li>通信不及时</li>
<li>不适合比较大数据的传输</li>
<li>存在用户态和内核态之间的数据拷贝开销</li>
</ul>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>消息队列的读取和写入的过程，都会有发生用户态和内核态之间的消息拷贝过程，共享内存能很好的解决这一问题。</p>
<p>现代操作系统，对于内存管理采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中，所以即使进程A和进程B的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删改查互不影响。</p>
<p>共享内存（Shared Memory），就是拿出一块虚拟地址空间来，映射到相同的物理内存中，这两个或多个进程共享这个物理内存。这样这个进程写入的东西，另外一个进程马上就能看到，大大提高了进程间通信的速度。<br><img src="https://img-blog.csdnimg.cn/20200816095316674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>共享内存是最快的一种 IPC（Inter-Process Communication，进程间通信），因为进程是直接对内存进行存取。</li>
<li>因为多个进程可以同时操作，所以需要进行同步。</li>
<li>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问<h3 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h3>有了共享内存通信方式，带来了新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了，例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。<br>为了防止多进程竞争共享资源而造成的数据错乱，所以需要保护机制，使得共享的资源在任意时刻只能被一个进程访问，信号量就实现了这一保护机制。</li>
</ul>
<p>信号量其实是一个整型的计数器，主要用于实现进程间的互斥和同步，而不是用于缓存进程间通信的数据。<br>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p>
<ul>
<li>一个是P操作，这个操作会把信号量减去1，相减后如果信号量&lt;0，则表示资源已被占用，进程需要阻塞等待，相减后如果信号量&gt;=0，表明还有资源可以使用，进程可正常继续执行；</li>
<li>另一个是V操作，这个操作会把信号量加1，相加后如果信号量&lt;=0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行，相加后如果信号量&gt;0，则表明当前没有阻塞中的进程。</li>
</ul>
<p>P操作是用在进入共享资源之前，V操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p>
<p>特点：</p>
<ul>
<li>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</li>
<li>信号量基于操作系统的 PV 操作（用PV操作实现进程同步时，调用P操作测试消息是否到达，调用V操作发送消息），程序对信号量的操作都是原子操作。</li>
<li>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</li>
<li>支持信号量组。</li>
</ul>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>前面提到的管道、消息队列、共享内存、信号量都是在同一台主机上进行进程间通信，那要想跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。</p>
<p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。</p>
<p>我们来看看创建 socket 的系统调用：</p>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-keyword">int</span> domain, <span class="hljs-keyword">int</span> type, <span class="hljs-keyword">int</span> protocal)</span></span></code></pre></div>
<ul>
<li>domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL/AF_UNIX 用于本机；</li>
<li>type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM  表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；</li>
<li>protocal 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；</li>
</ul>
<p>根据创建 socket 类型的不同，通信的方式也就不同：</p>
<ul>
<li>实现 TCP 字节流通信：socket 类型是 AF_INET 和 SOCK_STREAM；</li>
<li>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；</li>
<li>实现本地进程间通信：「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；</li>
</ul>
<p>接下来，简单说一下这三种通信的编程模式。</p>
<blockquote>
<p>针对 TCP 协议通信的 socket 编程模型</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200816101625778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<ul>
<li>服务端和客户端初始化 socket，得到文件描述符；</li>
<li>服务端调用 bind，将绑定在 IP 地址和端口;</li>
<li>服务端调用 listen，进行监听；</li>
<li>服务端调用 accept，等待客户端连接；</li>
<li>客户端调用 connect，向服务器端的地址和端口发起连接请求；</li>
<li>服务端 accept 返回用于传输的 socket 的文件描述符；</li>
<li>客户端调用 write 写入数据；服务端调用 read 读取数据；</li>
<li>客户端断开连接时，会调用 close，那么服务端 read 读取数据的时候，就会读取到了 EOF，待处理完数据后，服务端调用 close，表示连接关闭。</li>
</ul>
<p>这里需要注意的是，服务端调用 accept 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p>
<p>所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作监听 socket，一个叫作已完成连接 socket。</p>
<p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p>
<blockquote>
<p>针对 UDP 协议通信的 socket 编程模型</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200816101815772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<p>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。</p>
<p>对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。</p>
<p>另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。</p>
<blockquote>
<p>针对本地进程间通信的 socket 编程模型</p>
</blockquote>
<p>本地 socket  被用于在同一台主机上进程间通信的场景：</p>
<ul>
<li>本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，可以支持「字节流」和「数据报」两种协议；</li>
<li>本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；</li>
</ul>
<p>对于本地字节流 socket，其 socket 类型是 AF_LOCAL 和 SOCK_STREAM。<br>对于本地数据报 socket，其 socket 类型是 AF_LOCAL 和 SOCK_DGRAM。</p>
<p>本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是绑定一个本地文件，这也就是它们之间的最大区别。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。</p>
<p>Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。</p>
<p><strong>匿名管道</strong>顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「|」竖线就是匿名管道，通信的数据是无格式的流并且大小受限，通信的方式是单向的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来匿名管道是只能用于存在父子关系的进程间通信，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。</p>
<p><strong>命名管道</strong>突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则，不支持 lseek 之类的文件定位操作。</p>
<p><strong>消息队列</strong>克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</p>
<p><strong>共享内存</strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，它直接分配一个共享空间，每个进程都可以直接访问，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有最快的进程间通信方式之名。但是便捷高效的共享内存通信，带来新的问题，多进程竞争同个共享资源会造成数据的错乱。</p>
<p>那么，就需要<strong>信号量</strong>来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。信号量不仅可以实现访问的互斥性，还可以实现进程间的同步，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 P 操作和 V 操作。</p>
<p>与信号量名字很相似的叫<strong>信号</strong>，它俩名字虽然相似，但功能一点儿都不一样。信号是进程间通信机制中唯一的异步通信机制，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP，这是为了方便我们能在任何时候结束或停止某个进程。</p>
<p>前面说到的通信机制，都是工作于同一台主机，如果要与不同主机的进程间通信，那么就需要 <strong>Socket</strong> 通信了。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。</p>
<p>以上，就是进程间通信的主要机制了。你可能会问了，那线程通信间的方式呢？</p>
<p>同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：</p>
<ul>
<li>互斥的方式，可保证任意时刻只有一个线程访问共享资源；</li>
<li>同步的方式，可保证线程 A 应在线程 B 之前执行；</li>
</ul>
<h2 id="同步、异步、阻塞、非阻塞的概念"><a href="#同步、异步、阻塞、非阻塞的概念" class="headerlink" title="同步、异步、阻塞、非阻塞的概念"></a>同步、异步、阻塞、非阻塞的概念</h2><p>同步：当一个同步调用发出后，调用者要一直等待返回结果。通知后，才能进行后续的执行。<br>异步：当一个异步过程调用发出后，调用者不能立刻得到返回结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。<br>阻塞：是指调用结果返回前，当前线程会被挂起，即阻塞。<br>非阻塞：是指即使调用结果没返回，也不会阻塞当前线程。</p>
<h2 id="同步、异步、阻塞、非阻塞的区别？"><a href="#同步、异步、阻塞、非阻塞的区别？" class="headerlink" title="同步、异步、阻塞、非阻塞的区别？"></a>同步、异步、阻塞、非阻塞的区别？</h2><p>同步和异步关注的是消息通信机制</p>
<ul>
<li>同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；</li>
<li>异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。 </li>
</ul>
<p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</p>
<ul>
<li>阻塞调用：是指调用结果返回之前，当前线程会被挂起。一直处于等待消息通知，不能够执行其他业务，调用线程只有在得到结果之后才会返回。</li>
<li>非阻塞调用：指在不能立刻得到结果之前，该调用不会阻塞当前线程，而会立刻返回。</li>
</ul>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="概念及产生原理"><a href="#概念及产生原理" class="headerlink" title="概念及产生原理"></a>概念及产生原理</h2><p>概念：多个并发进程因争夺系统资源而产生相互等待的现象。<br>原理：当一组进程中的每个进程都在等待某个事件发生，而只有这组进程中的其他进程才能触发该事件，这就称这组进程发生了死锁。<br>本质原因：<br>1）、系统资源有限。<br>2）、进程推进顺序不合理。</p>
<h2 id="产生的必要条件"><a href="#产生的必要条件" class="headerlink" title="产生的必要条件"></a>产生的必要条件</h2><ul>
<li>互斥：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。</li>
<li>占有且保持：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。</li>
<li>不可抢占：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。</li>
<li>循环等待：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。</li>
</ul>
<h2 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h2><h3 id="1、死锁预防-—–-确保系统永远不会进入死锁状态"><a href="#1、死锁预防-—–-确保系统永远不会进入死锁状态" class="headerlink" title="1、死锁预防 —– 确保系统永远不会进入死锁状态"></a>1、死锁预防 —– 确保系统永远不会进入死锁状态</h3><p>产生死锁需要四个条件（互斥条件、占有且等待、不可抢占、循环等待），那么，只要这四个条件中至少有一个条件得不到满足，就不可能发生死锁了。由于互斥条件是非共享资源所必须的，不仅不能改变，还应加以保证，所以，主要是破坏产生死锁的其他三个条件。</p>
<h4 id="a、破坏“占有且保持”条件"><a href="#a、破坏“占有且保持”条件" class="headerlink" title="a、破坏“占有且保持”条件"></a>a、破坏“占有且保持”条件</h4><p>方法1：所有的进程在开始运行之前，必须一次性地申请其在整个运行过程中所需要的全部资源。<br>优点：简单易实施且安全。<br>缺点：因为某项资源不满足，进程无法启动，而其他已经满足了的资源也不会得到利用，严重降低了资源的利用率，造成资源浪费，使进程经常发生饥饿现象。<br>方法2：该方法是对第一种方法的改进，允许进程只获得运行初期需要的资源，便开始运行，在运行过程中逐步释放掉分配到的已经使用完毕的资源，然后再去请求新的资源。这样的话，资源的利用率会得到提高，也会减少进程的饥饿问题。</p>
<h4 id="b、破坏“不可抢占”条件（不建议）"><a href="#b、破坏“不可抢占”条件（不建议）" class="headerlink" title="b、破坏“不可抢占”条件（不建议）"></a>b、破坏“不可抢占”条件（不建议）</h4><p>当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。这就意味着进程已占有的资源会被短暂地释放或者说是被抢占了。<br>    该种方法实现起来比较复杂，且代价也比较大。释放已经保持的资源很有可能会导致进程之前的工作失效等，反复的申请和释放资源会导致进程的执行被无限的推迟，这不仅会延长进程的周转周期，还会影响系统的吞吐量。</p>
<h4 id="c、破坏“循环等待”条件（不建议）"><a href="#c、破坏“循环等待”条件（不建议）" class="headerlink" title="c、破坏“循环等待”条件（不建议）"></a>c、破坏“循环等待”条件（不建议）</h4><p>可以通过定义资源类型的线性顺序来预防，可将每个资源编号，当一个进程占有编号为i的资源时，那么它下一次申请资源只能申请编号大于i的资源。如图所示：<br><img src="https://img-blog.csdnimg.cn/20200815130850543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<h3 id="2、避免死锁-—–-在使用前进行判断，只允许不会产生死锁的进程申请资源"><a href="#2、避免死锁-—–-在使用前进行判断，只允许不会产生死锁的进程申请资源" class="headerlink" title="2、避免死锁 —– 在使用前进行判断，只允许不会产生死锁的进程申请资源"></a>2、避免死锁 —– 在使用前进行判断，只允许不会产生死锁的进程申请资源</h3><p>预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全的状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法。</p>
<p>银行家算法：首先需要定义状态和安全状态的概念。系统的状态是当前给进程分配的资源情况。因此，状态包含两个向量Resource（系统中每种资源的总量）和Available（未分配给进程的每种资源的总量）及两个矩阵Claim（表示进程对资源的需求）和Allocation（表示当前分配给进程的资源）。安全状态是指至少有一个资源分配序列不会导致死锁。当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程知道同意该请求后系统状态仍然是安全的。</p>
<h3 id="3、鸵鸟策略"><a href="#3、鸵鸟策略" class="headerlink" title="3、鸵鸟策略"></a>3、鸵鸟策略</h3><p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
<h2 id="死锁检测与恢复"><a href="#死锁检测与恢复" class="headerlink" title="死锁检测与恢复"></a>死锁检测与恢复</h2><h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><h4 id="检测时机"><a href="#检测时机" class="headerlink" title="检测时机"></a>检测时机</h4><ul>
<li>定时检测</li>
<li>当进程阻塞时检测死锁（其缺点是系统的开销大）</li>
<li>系统资源利用率下降时检测死锁<h4 id="检测方法（资源分配图法）"><a href="#检测方法（资源分配图法）" class="headerlink" title="检测方法（资源分配图法）"></a>检测方法（资源分配图法）</h4>如果资源分配图中没有环路，则系统中没有死锁，如果图中存在环路则系统中可能存在死锁。<br>如果每个资源类中只包含一个资源实例，则环路是死锁存在的充分必要条件。<br>有环有死锁<br><img src="https://img-blog.csdnimg.cn/2020081513110529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>有环无死锁<br><img src="https://img-blog.csdnimg.cn/20200815131120580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><h4 id="死锁的恢复"><a href="#死锁的恢复" class="headerlink" title="死锁的恢复"></a>死锁的恢复</h4>重要的是以最小的代价解除死锁，恢复系统运行。方法如下：</li>
<li>撤消所有的死锁进程</li>
<li>连续撤消死锁进程直至不再存在死锁</li>
<li>连续剥夺资源直到不再存在死锁</li>
<li>把每个死锁进程备份到前面定义的某个检查点，并重新启动所有进程</li>
</ul>
<h1 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。<br>虚拟内存的基本思想是，每个进程有独立的逻辑地址空间，内存被分为大小相等的多个块,称为页(Page)。每个页都是一段连续的地址。对于进程来看,逻辑上貌似有很多内存空间，其中一部分对应物理内存上的一块(称为页框，通常页和页框大小相等)，还有一些没加载在内存中的对应在硬盘上。<br><img src="https://img-blog.csdnimg.cn/2020081513121516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<h2 id="分页系统地址映射"><a href="#分页系统地址映射" class="headerlink" title="分页系统地址映射"></a>分页系统地址映射</h2><p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。当访问虚拟内存时，会通过MMU（内存管理单元）去匹配对应的物理地址，而如果虚拟内存的页并不存在于物理内存中，会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。<br>而虚拟内存和物理内存的匹配是通过页表实现，页表存在MMU中，页表中每个项通常为32位，即4byte，除了存储虚拟地址和页框地址之外，还会存储一些标志位，比如是否缺页，是否修改过，写保护等。可以把MMU想象成一个接收虚拟地址项返回物理地址的方法。</p>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="最优页面置换算法-Optimal-Page-Replacement-Algorithm"><a href="#最优页面置换算法-Optimal-Page-Replacement-Algorithm" class="headerlink" title="最优页面置换算法(Optimal Page Replacement Algorithm)"></a>最优页面置换算法(Optimal Page Replacement Algorithm)</h3><p>将未来最久不使用的页替换出去，这听起来很简单，但是无法实现。根据页面被访问前所需要的指令数作为标记，根据指令数的由多到少进行置换，这个方法对评价页面置换算法很有用，但它在实际系统中却不能使用，因为无法真正的实现。这种算法可以作为衡量其它算法的基准。</p>
<h3 id="最近最少使用页面置换算法-LRU：Least-Recently-Used"><a href="#最近最少使用页面置换算法-LRU：Least-Recently-Used" class="headerlink" title="最近最少使用页面置换算法(LRU：Least Recently Used)"></a>最近最少使用页面置换算法(LRU：Least Recently Used)</h3><p>通常在前几条指令中使用频繁的页面很可能在后面几条指令中页频繁使用。LRU算法就是在缺页发生时首先置换最长时间未被使用的页面。优秀但是难以实现。</p>
<h3 id="最近未使用页面置换算法-Not-Recently-Used-Replacement-Algorithm"><a href="#最近未使用页面置换算法-Not-Recently-Used-Replacement-Algorithm" class="headerlink" title="最近未使用页面置换算法(Not Recently Used Replacement Algorithm)"></a>最近未使用页面置换算法(Not Recently Used Replacement Algorithm)</h3><p>在最近的一个时钟周期内，淘汰一个没有被访问的已修改页面，近似 LRU 算法，NRU 只是更粗略些。<br>这种算法给每个页一个标志位，R表示最近被访问过，M表示被修改过。定期对R进行清零。这个算法的思路是首先淘汰那些未被访问过R=0的页，其次是被访问过R=1,未被修改过M=0的页，最后是R=1,M=1的页。</p>
<h3 id="先进先出的页面置换算法-FIFO：First-In-First-Out-Page-Replacement-Algorithm"><a href="#先进先出的页面置换算法-FIFO：First-In-First-Out-Page-Replacement-Algorithm" class="headerlink" title="先进先出的页面置换算法(FIFO：First-In First-Out Page Replacement Algorithm)"></a>先进先出的页面置换算法(FIFO：First-In First-Out Page Replacement Algorithm)</h3><p>这种算法的思想是淘汰在内存中最久的页，这种算法的性能接近于随机淘汰。可能抛弃重要的页面，并不好。</p>
<h3 id="第二次机会页面置换算法-Second-Chance-Page-Replacement-Algorithm"><a href="#第二次机会页面置换算法-Second-Chance-Page-Replacement-Algorithm" class="headerlink" title="第二次机会页面置换算法(Second Chance Page Replacement Algorithm)"></a>第二次机会页面置换算法(Second Chance Page Replacement Algorithm)</h3><p>这种算法是在FIFO的基础上，为了避免置换出经常使用的页，增加一个标志位R，如果最近使用过将R置1，当页将会淘汰时，如果R为1，则不淘汰页，将R置0.而那些R=0的页将被淘汰时，直接淘汰。这种算法避免了经常被使用的页被淘汰。</p>
<h3 id="时钟替换算法-Clock-Page-Replacement-Algorithm"><a href="#时钟替换算法-Clock-Page-Replacement-Algorithm" class="headerlink" title="时钟替换算法(Clock Page Replacement Algorithm)"></a>时钟替换算法(Clock Page Replacement Algorithm)</h3><p>虽然改进型FIFO算法避免置换出常用的页，但由于需要经常移动页，效率并不高。因此在改进型FIFO算法的基础上，将队列首位相连形成一个环路，当缺页中断产生时，从当前位置开始找R=0的页，而所经过的R=1的页被置0，并不需要移动页。</p>
<h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>分页管理方式是从计算机的角度考虑设计的，以提高内存的利用率，提升计算机的性能, 且分页通过硬件机制实现，对用户完全透明；而分段管理方式的提出则是考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。<br>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p>
<h2 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h2><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p>
<h3 id="分页与分段的比较"><a href="#分页与分段的比较" class="headerlink" title="分页与分段的比较"></a>分页与分段的比较</h3><ul>
<li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</li>
<li>地址空间的维度：分页是一维地址空间，分段是二维的。</li>
<li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li>
<li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。<h2 id="什么是缓冲区溢出，有什么危害，原因是什么？"><a href="#什么是缓冲区溢出，有什么危害，原因是什么？" class="headerlink" title="什么是缓冲区溢出，有什么危害，原因是什么？"></a>什么是缓冲区溢出，有什么危害，原因是什么？</h2>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。<br>危害有以下两点：</li>
</ul>
<ol>
<li>程序崩溃，导致拒绝服务</li>
<li>跳转并且执行一段恶意代码造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</li>
</ol>
<h1 id="设备管理-1"><a href="#设备管理-1" class="headerlink" title="设备管理"></a>设备管理</h1><h2 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h2><ul>
<li>盘面（Platter）：一个磁盘有多个盘面；</li>
<li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li>
<li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有512 bytes 与 4 K 两种大小；</li>
<li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li>
<li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li>
<li>主轴（Spindle）：使整个盘面转动。<br><img src="https://img-blog.csdnimg.cn/20200815131640663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2>读写一个磁盘块的时间的影响因素有：<br>  • 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）<br>  • 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）<br>  • 实际的数据传输时间<br>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</li>
</ul>
<ol>
<li>先来先服务（FCFS, First Come First Served）<br>按照磁盘请求的顺序进行调度。<br>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</li>
<li>最短寻道时间优先（SSTF, Shortest Seek Time First）<br>优先调度与当前磁头所在磁道距离最近的磁道。<br>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</li>
<li>电梯算法（SCAN）<br>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。<br>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。<br>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h2 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h2>以下是一个 hello.c 程序：</li>
</ol>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt; </span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; 
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello, world\n"</span>); 
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; 
&#125;</code></pre></div>

<p>在Unix 系统上，由编译器把源文件转换为目标文件。</p>
<div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">gcc</span> <span class="hljs-selector-tag">-o</span> <span class="hljs-selector-tag">hello</span> <span class="hljs-selector-tag">hello</span><span class="hljs-selector-class">.c</span></code></pre></div>

<p>这个过程大致如下：<img src="https://img-blog.csdnimg.cn/20200815131740550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<ul>
<li>预处理阶段：处理以 # 开头的预处理命令；</li>
<li>编译阶段：翻译成汇编文件；</li>
<li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li>
<li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2></li>
<li>可执行目标文件：可以直接在内存中执行；</li>
<li>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</li>
<li>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。<br>链接器主要完成以下两个任务：</li>
<li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li>
<li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。<br><img src="https://img-blog.csdnimg.cn/20200815131912908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2>静态库有以下两个问题：</li>
<li>当静态库更新时那么整个程序都要重新进行链接；</li>
<li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。<br>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。<br>它具有以下特点：<br>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；<br>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。<br><img src="https://img-blog.csdnimg.cn/20200815131949923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><h3 id="动态链接库和静态链接库的区别："><a href="#动态链接库和静态链接库的区别：" class="headerlink" title="动态链接库和静态链接库的区别："></a>动态链接库和静态链接库的区别：</h3><h4 id="一、指代不同"><a href="#一、指代不同" class="headerlink" title="一、指代不同"></a>一、指代不同</h4>1、动态链接库：是微软公司在微软Windows操作系统中，实现共享函数库概念的一种方式。<br>2、静态链接库：函数和数据被编译进一个二进制文件（通常扩展名为*.LIB），Visual C++的编译器在链接过程中将从静态库中恢复这些函数和数据并把他们和应用程序中的其他模块组合在一起生成可执行文件。<br><img src="https://img-blog.csdnimg.cn/20200815132016308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></li>
</ul>
<h4 id="二、特点不同"><a href="#二、特点不同" class="headerlink" title="二、特点不同"></a>二、特点不同</h4><p>1、动态链接库：库函数的扩展名是 ”.dll”、”.ocx”（包含ActiveX控制的库）或者 “.drv”（旧式的系统驱动程序）。<br>2、静态链接库：使用的.lib文件，库中的代码最后需要连接到可执行文件中去。</p>
<h4 id="三、调用方法不同"><a href="#三、调用方法不同" class="headerlink" title="三、调用方法不同"></a>三、调用方法不同</h4><p>1、动态链接库：提供了一种使进程可以调用不属于其可执行代码的函数。函数的可执行代码位于一个 DLL 文件中，该 DLL 包含一个或多个已被编译、链接并与使用它们的进程分开存储的函数。<br>2、静态链接库：应用程序所需的全部内容都是从库中复制了出来，所以静态库本身并不需要与可执行文件一起发行。</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/08/16/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%8E%9F%E7%90%86%E4%B8%8E%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">单点登录原理与简单实现</span>
                        <span class="visible-mobile">前の記事</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/08/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                        <span class="hidden-mobile">计算机网络</span>
                        <span class="visible-mobile">次の記事</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <script defer src="https://utteranc.es/client.js"
          repo="gavin-yyj/commit-utterance"
          issue-term="pathname"
  
          theme="github-light"
          crossorigin="anonymous"
  >
  </script>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;ディレクトリ</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">検索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">キーワード</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "操作系统&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
