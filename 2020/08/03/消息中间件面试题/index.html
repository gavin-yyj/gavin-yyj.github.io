<!DOCTYPE html>
<html lang="zh-CH">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="光说不做假把式">
  <meta name="author" content="杨玉杰">
  <meta name="keywords" content="">
  <title>消息中间件面试题 - 杨玉杰|个人博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/agate.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>杨玉杰|个人博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友情链接
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bgi.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-08-03 15:21">
      August 3, 2020 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      68
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="为什么使用MQ？MQ的优点"><a href="#为什么使用MQ？MQ的优点" class="headerlink" title="为什么使用MQ？MQ的优点"></a>为什么使用MQ？MQ的优点</h1><p>简答</p>
<ul>
<li>异步处理：相比于传统的串行，并行方式，提高了系统吞吐量；</li>
<li>应用解耦：系统间通过消息通信，不用关心其它系统的处理；</li>
<li>流量削峰：可以通过消息队列长度控制请求量，可以缓解短时间内的高并发请求；</li>
<li>日志处理：解决大量日志传输；</li>
<li>消息通讯：消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯，比如实现点对点消息队列，或者聊天室等。</li>
</ul>
<p>详答：<br>主要是：解耦、异步、削峰<br><strong>解耦</strong><br>传统情况：A系统发送数据到BCD三个系统，通过接口调用发送，如果E系统也要这个数据呢？那如果C系统现在不需要了呢？。。。A系统跟其他各种乱七八糟的系统严重耦合，A系统产生一条比较关键的数据，很多系统都需要A系统将这个数据发送过来，如果使用MQ，A系统产生一条数据，发送到MQ里面去，哪个系统需要数据自己去MQ里面消费，如果新系统需要数据，直接从MQ里面消费即可，如果某个系统不需要这条数据了，就取消对MQ消息的消费即可，这样下来，A系统根本不用考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功，失败超时等情况。</p>
<p>通俗来讲，就是一个系统或一个模块，调用了多个系统或模块，互相之间的调用很复杂，维护起来很麻烦，但是其实这个调用是不需要直接同步调用接口的，如果用MQ给它异步化解耦。</p>
<p><strong>异步</strong><br>A系统接收一个请求，需要在自己本地写库，还需要在BCD三个系统写库，自己本地写库要３ms，BCD三个系统分别写库要300ms，450ms，200ms，最终请求总延时是3+300+450+200=953ms，接近1s，给人的感觉就是慢，如果使用MQ，那么A系统连续发送3条消息到MQ队列中，假如耗时5ms，A系统从接受一个请求到返回响应给用户，总时长是3+5 = 8ms。</p>
<p><strong>削峰</strong><br>减少高峰时期对服务器压力</p>
<h1 id="消息队列有什么优缺点？RabbitMQ有什么优缺点？"><a href="#消息队列有什么优缺点？RabbitMQ有什么优缺点？" class="headerlink" title="消息队列有什么优缺点？RabbitMQ有什么优缺点？"></a>消息队列有什么优缺点？RabbitMQ有什么优缺点？</h1><p>优点是在特殊场景下有以下好处：解耦，异步，削峰</p>
<p>缺点：<br><strong>系统可用性降低</strong><br>如果消息队列挂了，系统可用性也会降低；<br><strong>系统复杂度提高</strong><br>加入了消息队列，要考虑很多方面的问题，比如：一致性问题，如何保证消息不被重复消费，如何保证消息可靠性传输等，因此需要考虑的东西更多，复杂性增大。<br><strong>一致性问题</strong><br>A系统处理完了直接返回成功了，但是有可能BCD三个系统中有系统写库失败，从而导致数据不一致。</p>
<p>所以消息队列实际上是一种非常复杂的架构，虽然有好处，但是需要针对它带来的坏处做各种额外的技术方案和架构来规避掉。</p>
<h1 id="你们公司生产环境用的是什么消息中间件？"><a href="#你们公司生产环境用的是什么消息中间件？" class="headerlink" title="你们公司生产环境用的是什么消息中间件？"></a>你们公司生产环境用的是什么消息中间件？</h1><p>首先你可以说下你们公司选用的是什么消息中间件，比如用的是RabbitMQ，然后可以初步给一些你对不同MQ中间件技术的选型分析。</p>
<p>比如：ActiveMQ是老牌的消息中间件，功能很强大，但是问题在于没法确认ActiveMQ可以支撑互联网公司的高并发，高负载以及高吞并的复杂场景，使用较多的是一些传统企业，用ActiveMQ做异步调用和系统解耦。</p>
<p>然后RabbitMQ，它的好处在于可以支撑高并发、高吞吐、性能很高，同时有非常完善便捷的后台管理界面可以使用，另外它还支持集群化，高可用部署架构，消息高可靠性支持，功能较为完善。</p>
<p>通过调研，RabbitMQ在国内各大互联网公司都有广泛使用，此外，RabbitMQ的开源社区很活跃，较高频率的迭代版本来修复发现的bug以及进行各种优化，因此综合考虑过后，公司采用了RabbitMQ。</p>
<p>但是RabbitMQ也有一点缺陷，就是它自身是基于erlang语言开发的，所以导致较为难以分析里面的源码，也较难进行深层次的源码定制和改造。</p>
<p>RocketMQ是阿里开源的，经过阿里的生产环境的超高并发，高吞吐的考验，性能卓越，同时还支持分布式事务等特殊场景，而且RocketMQ是基于Java语言开发的，适合深入阅读源码，有需要可以站在源码层面解决线上生产问题，包括源码的二次开发和改造。</p>
<p>Kafka提供的消息中间件的功能明显较少一些，其优势在于转为超高吞吐量的实时日志采集、实时数据同步、实时数据计算等场景来设计，因此Kafka在大数据领域中配合实时计算技术使用的比较多，但是在传统的MQ中间件使用场景中较少采用。</p>
<h1 id="消息中间件的选择"><a href="#消息中间件的选择" class="headerlink" title="消息中间件的选择"></a>消息中间件的选择</h1><p>对于中小型公司，技术实力较为一般，技术挑战不是特别高，用RabbitMQ是不错的选择；<br>大型公司，基础架构研发实力较强，用RocketMQ是很好的选择。<br>如果是大数据领域的实时计算，日志采集等场景，用Kafka。</p>
<h1 id="MQ有哪些常见问题？如何解决这些问题？"><a href="#MQ有哪些常见问题？如何解决这些问题？" class="headerlink" title="MQ有哪些常见问题？如何解决这些问题？"></a>MQ有哪些常见问题？如何解决这些问题？</h1><ul>
<li>消息的顺序问题</li>
<li>消息的重复问题</li>
</ul>
<p><strong>消息的顺序问题</strong><br>消息有序指的是可以按照消息的发送顺序来消费。</p>
<p>加入生产者产生了2条消息：M1、M2，假定M1发送到S1，M2发送到S2，如果要保证M1先于M2被消费，怎么做？<br><img src="https://img-blog.csdnimg.cn/20200728213831282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>解决方案：</p>
<p>（1）保证生产者-MQServer-消费者是一对一对一的关系<br><img src="https://img-blog.csdnimg.cn/20200728214908926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>缺陷：</p>
<ul>
<li>并行度就会成为消息系统的瓶颈（吞吐量不够）</li>
<li>更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞。</li>
</ul>
<p>（2）通过合理的设计或者将问题分解来规避</p>
<ul>
<li>不关注乱序的应用实际大量存在</li>
<li>队列无序并不意味着消息无序，所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是一种更合理的方式。</li>
</ul>
<p><strong>消息的重复问题</strong><br>造成消息重复的根本原因是：网络不可达</p>
<p>解决这个问题的办法就是绕过这个问题，那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</p>
<p>消费端处理消息的业务逻辑保持幂等性，只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样，保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现，利用一张日志表来记录已经处理成功的消息的ID，如果新到的ID已经在日志表中，那么就不再处理这条消息。</p>
<h1 id="什么是RabbitMQ"><a href="#什么是RabbitMQ" class="headerlink" title="什么是RabbitMQ"></a>什么是RabbitMQ</h1><p>RabbitMQ是一款开源的，Erlang编写的，基于AMQP协议的消息中间件。</p>
<h1 id="RabbitMQ的使用场景"><a href="#RabbitMQ的使用场景" class="headerlink" title="RabbitMQ的使用场景"></a>RabbitMQ的使用场景</h1><ul>
<li>服务间异步通信</li>
<li>顺序消费</li>
<li>定时任务</li>
<li>请求削峰</li>
</ul>
<h1 id="RabbitMQ基本概念"><a href="#RabbitMQ基本概念" class="headerlink" title="RabbitMQ基本概念"></a>RabbitMQ基本概念</h1><ul>
<li>Broker：简单来说就是消息队列服务器实体</li>
<li>Exchange：消息交换机，它指定消息按照什么规则，路由到哪个队列；</li>
<li>Queue：消息队列载体，每个消息都会被投入到一个或多个队列；</li>
<li>Binding：绑定，它的作用是把exchange和queue按照路由规则绑定起来；</li>
<li>Routing Key：路由关键字，exchange根据这关键字进行消息投递；</li>
<li>VHost：VHost可以理解为虚拟Broker，即mini-RabbitMQ server，其内部均含有独立的queue，exchange和binding等，但最最重要的是，其拥有独立的权限系统，可以做到VHost范围的用户控制，当然，从RabbitMQ的全局角度，VHost可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的VHost中）。</li>
<li>Producer：消息生产者，就是投递消息的程序；</li>
<li>Consumer：消息消费者，就是接受消息的程序；</li>
<li>Channel：消息通道，在客户端的每个连接里，可建立多个Channel，每个Channel代表一个会话任务。</li>
</ul>
<p>由Exchange，Queue，RoutingKey三个才能决定一个从Exchange到Queue的唯一的线路。</p>
<h1 id="RabbitMQ的工作模式"><a href="#RabbitMQ的工作模式" class="headerlink" title="RabbitMQ的工作模式"></a>RabbitMQ的工作模式</h1><h2 id="simple模式（即最简单的收发模式）"><a href="#simple模式（即最简单的收发模式）" class="headerlink" title="simple模式（即最简单的收发模式）"></a>simple模式（即最简单的收发模式）</h2><p><img src="https://img-blog.csdnimg.cn/20200728222931954.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>消息产生消息，将消息放入队列<br>消息的消费者监听消息队列，如果队列中有消息，消息被拿走后，自动从队列中删除（隐患：消息可能没有被消费者正确处理，已经从队列中消失了，造成消息的丢失，这里可以设置成手动的ack，但如果设置成手动ack，处理完要及时发送ack消息给队列，否则会造成内存溢出）。</p>
<h2 id="work工作模式（资源的竞争）"><a href="#work工作模式（资源的竞争）" class="headerlink" title="work工作模式（资源的竞争）"></a>work工作模式（资源的竞争）</h2><p> <img src="https://img-blog.csdnimg.cn/20200728224817834.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>消息产生者将消息放入队列消费者可以有多个，消费者C1，消费者C2同时监听同一个队列，消费者被消费。C1，C2共同争抢当前的消息队列内容，谁先拿到谁负责消费消息（隐患：高并发情况下，默认会产生某一个消息被多个消费者共同使用，可以设置一个开关（synchronized）保证一条消息只能被一个消费者使用）。</p>
<h2 id="发布订阅（资源共享）"><a href="#发布订阅（资源共享）" class="headerlink" title="发布订阅（资源共享）"></a>发布订阅（资源共享）</h2><p><img src="https://img-blog.csdnimg.cn/20200729085309490.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<ul>
<li>每个消费者监听自己的队列；</li>
<li>生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息；</li>
</ul>
<h2 id="routing路由模式"><a href="#routing路由模式" class="headerlink" title="routing路由模式"></a>routing路由模式</h2><p><img src="https://img-blog.csdnimg.cn/20200729085455642.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<ol>
<li>消息生产者按照路由判断将消息发送给交换机，路由是字符串（info）当前产生的消息携带路由字符（对象的方法），交换机根据路由的key，只能匹配上路由key对应的消息队列，对应的消费者才能消费消息；</li>
<li>根据业务功能定义路由字符串</li>
<li>从系统的代码逻辑中获取对应的功能字符串，将消息任务扔到对应的队列中；</li>
<li>业务场景：error通知；EXCEPTION；错误通知的功能；传统意义的错误通知；客户通知；利用key路由可以讲程序中的错误封装成消息传入到消息队列中，开发者可以自定义消费者，实时接收错误。</li>
</ol>
<h2 id="topic主题模式（路由模式的一种）"><a href="#topic主题模式（路由模式的一种）" class="headerlink" title="topic主题模式（路由模式的一种）"></a>topic主题模式（路由模式的一种）</h2><p><img src="https://img-blog.csdnimg.cn/20200729085937455.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<ol>
<li>星号井号代表通配符；</li>
<li>星号代表一个单词，井号代表多个单词；</li>
<li>路由功能添加模糊匹配；</li>
<li>消息生产者产生消息，把消息交给交换机；</li>
<li>交换机根据key的规则模糊匹配到对应的队列，由队列的监听消费者接收消息消费；<br>（类似sql的模糊查询方式）</li>
</ol>
<h1 id="如何保证RabbitMQ消息的顺序性"><a href="#如何保证RabbitMQ消息的顺序性" class="headerlink" title="如何保证RabbitMQ消息的顺序性"></a>如何保证RabbitMQ消息的顺序性</h1><p>拆分多个queue，每个queue一个consumer，或者就一个queue对应一个consumer，然后这个consumer内部用内存队列做排序，然后分发给底层不同的worker来处理；</p>
<h1 id="消息如何分发？"><a href="#消息如何分发？" class="headerlink" title="消息如何分发？"></a>消息如何分发？</h1><p>若该队列至少有一个消费者订阅，消息将以循环的方式发送给消费者，每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认），通过路由可实现多消费的功能。</p>
<h1 id="消息怎么路由？"><a href="#消息怎么路由？" class="headerlink" title="消息怎么路由？"></a>消息怎么路由？</h1><p>消息提供方 -&gt; 路由 -&gt; 一至多个队列消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定，通过队列路由键，可以把队列绑定到交换器上，消息到达交换器后，RabbitMQ会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）</p>
<p>常用的交换器有以下三种：</p>
<ul>
<li>fanout：如果交换器收到消息，将会广播到所有绑定的队列上；</li>
<li>direct：如果路由键完全匹配，消息就被投递到相应的队列；</li>
<li>topic：可以使来自不同源头的消息能够到达同一个队列，使用topic交换器时，可以使用通配符。</li>
</ul>
<h1 id="消息基于什么传输？"><a href="#消息基于什么传输？" class="headerlink" title="消息基于什么传输？"></a>消息基于什么传输？</h1><p>由于TCP连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈，RabbitMQ使用信道的方式来传输数据，信道是建立在真实的TCP连接内的虚拟连接，且每条TCP连接上信道数没有限制。</p>
<h1 id="如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？"><a href="#如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？" class="headerlink" title="如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？"></a>如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？</h1><p>先说为什么会重复消费？<br>正常情况下，消费者在消费消息的时候，消费完毕后，会发送一个确认消息给消息队列，消息队列就知道该消息被消费了，就会将消息从消息队列中删除；<br>但是因为网络传输等故障，确认消息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将消息分发给其他的消费者。</p>
<p>针对以上问题，一个解决思路是：保证消息的唯一性，就算是多次传输，不要让消息的多次消费带来影响，保证消息等幂性；</p>
<p>比如：在写入消息队列的数据做唯一标识，消费消息时，根据唯一标识来判断是否消费过；</p>
<p>假设你有一个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，可能就会造成错误，解决办法是在第二次消费的时候，自己判断是否已经消费过，如果是就直接扔掉，只保留之前的那条数据，从而保证了数据的正确性。</p>
<h1 id="如何确保消息正确地发送至RabbitMQ，如何确保消息接收方消费了消息？"><a href="#如何确保消息正确地发送至RabbitMQ，如何确保消息接收方消费了消息？" class="headerlink" title="如何确保消息正确地发送至RabbitMQ，如何确保消息接收方消费了消息？"></a>如何确保消息正确地发送至RabbitMQ，如何确保消息接收方消费了消息？</h1><p><strong>发送方确认模式</strong><br>将信道设置为confirm模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID；</p>
<p>一旦消息被投递到目的队列后，或是消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一ID）；</p>
<p>如果RabbitMQ发生内部错误从而导致消息丢失，会发送一条nack（notacknowledged，未确认）消息。</p>
<p>发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息，当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。</p>
<p><strong>接收方确认机制</strong><br>消费者接收到每条消息后都必须进行确认（消息接收和消息确认是两个不同操作），只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除。</p>
<p>这里并没有用到超时机制，RabbitMQ仅通过Consumer的连接中断来确认是否需要重新发送消息，也就是说，只要连接不中断，RabbitMQ给了Consumer足够长的时间来处理消息，保证数据的最终一致性。</p>
<p>下面罗列了几种特殊情况：</p>
<ul>
<li>如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ会认为消息没有被分发，然后重新发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要去重）</li>
<li>如果消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该消费者分发更多的消息。</li>
</ul>
<h1 id="如何保证RabbitMQ消息的可靠传输？"><a href="#如何保证RabbitMQ消息的可靠传输？" class="headerlink" title="如何保证RabbitMQ消息的可靠传输？"></a>如何保证RabbitMQ消息的可靠传输？</h1><p>消息不可靠的情况可能是消息丢失、劫持等原因；<br>丢失又分为：生产者丢失消息，消息队列丢失消息，消费者丢失消息；</p>
<p><strong>生产者丢失消息</strong><br>从生产者丢失消息的角度来看，RabbitMQ提供了transaction和confirm模式来确保生产者不丢消息；</p>
<p>transaction机制：发送消息前开启事务，然后发送消息，如果发送过程中出现什么异常，事务就会回滚，如果发送成功就提交事务，缺点是吞吐量下降；</p>
<p>confirm模式：一旦channel进入confirm模式，所有在该信道上发布的消息都将会被指派一个唯一的ID，一旦消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个ack给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了；</p>
<p>如果RabbitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。</p>
<p><strong>消息队列丢数据</strong><br>消息持久化</p>
<p>处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。</p>
<p>这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个ack信号，这样，如果消息持久化磁盘之前，RabbitMQ阵亡了，那么生产者收不到ack信号，生产者会自动重发。</p>
<p>如何持久化呢？</p>
<ul>
<li>将queue的持久化标识durable设置为true，则代表是一个持久的队列；</li>
<li>发送消息的时候将deliveryMode = 2</li>
</ul>
<p>这样设置以后，即使RabbitMQ挂了，重启后也能恢复数据。</p>
<p><strong>消费者丢失消息</strong><br>消费者丢数据一般是因为采用了自动确认消息模式，改为手动确认消息即可。</p>
<p>消费者在收到消息之后，处理消息之前，会自动回复RabbitMQ已收到的消息；</p>
<p>如果这时处理消息失败，就会丢失该消息；</p>
<p>解决方案：处理消息成功后，手动回复确认消息。</p>
<h1 id="为什么不应该对所有的message都使用持久化机制？"><a href="#为什么不应该对所有的message都使用持久化机制？" class="headerlink" title="为什么不应该对所有的message都使用持久化机制？"></a>为什么不应该对所有的message都使用持久化机制？</h1><p>首先必然导致性能的下降，因为写磁盘比写RAM慢得多，message的吞吐量可能有10倍的差距；</p>
<p>其次，message的持久化机制用在RabbitMQ的内置cluster方案时会出现一些问题，矛盾点在于，若message设置了persistent属性，但queue未设置durable属性，那么当该queue的owner node出现异常后，在未重建该queue之前，发往该queue的message将被blackholed，若message设置了persistent属性，同时queue也设置了durable属性，那么当queue的owner node异常且无法重启的情况下，则该queue无法在其他node上重建，只能等待其owner node重启后，才能恢复该queue的使用，而在这段时间内发送给该queue的message加你干杯blackholed。</p>
<p>所以是否要对message进行持久化，需要综合考虑性能需要，以及可能遇到的问题，若想达到10万条/s以上的消息吞吐量（单RabbitMQ），则要么使用其他方式来确保message的可靠delivery，要么使用非常快速的存储系统以支持全持久化（例如使用SSD），另外一种处理原则是：仅对关键消息做持久化处理（根据业务重要程度），且应该保证关键消息的量不会导致性能瓶颈。</p>
<h1 id="如何保证高可用？"><a href="#如何保证高可用？" class="headerlink" title="如何保证高可用？"></a>如何保证高可用？</h1><p>RabbitMQ上比较有代表性的，因为是基于主从（非分布式）做高可用性的。RabbitMQ有三种模式来实现高可用，分别是：单机模式，普通集群模式，镜像集群模式。</p>
<p><strong>单机模式</strong>：一般生产中不会使用；</p>
<p><strong>普通集群模式</strong>：在多台机器上启动多个RabbitMQ实例，每个机器启动一个，你创建的queue只会放在一个RabbitMQ实例上，但是每个实例都同步queue的元数据（元数据可以认为是queue的一些配置信息，通过元数据，可以找到queue所在实例），你消费的时候，实际上如果连接到另外一个实例，那么那个实例会从queue所在实例上拉取数据过来，这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个queue的读写操作。</p>
<p><strong>镜像集群模式</strong><br>这种模式才是所谓的RabbitMQ的高可用模式，跟普通集群模式不一样的是，在镜像集群模式下，你创建的queue，无论元数据还是queue里的消息都会存在于多个实例上，就是说，每个RabbitMQ节点都有这个queue的一个完整镜像，包含queue的全部数据的意思，然后每次你写消息到queue的时候，都会自动把消息同步到多个实例的queue上，RabbitMQ有很好的的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建queue的时候，应用这个策略，就会自动将数据同步到其他的节点上去了，这样的话，好处在于你任何一个机器宕机了，其他机器还包含了这个queue的完整数据，别的consumer都可以到其他节点上去消费数据，坏处在于开销大，消息需要同步到所有机器上，导致网络带宽压力和消耗很重。</p>
<h1 id="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？"><a href="#如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？" class="headerlink" title="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？"></a>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</h1><p>消息积压处理办法：临时紧急扩容</p>
<p>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 cnosumer 都停掉。<br>新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。<br>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。<br>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。<br>等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。</p>
<p>MQ中消息失效：假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</p>
<p>mq消息队列块满了：如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。</p>
<h1 id="设计MQ思路"><a href="#设计MQ思路" class="headerlink" title="设计MQ思路"></a>设计MQ思路</h1><p>首先这个MQ得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量。<br>实现：设计个分布式的系统，参照一下Kafka的设计理念，broker -&gt; topic -&gt; partition，每个partition放一个机器，就存一部分数据，如果现在资源不够了，简单啊，给topic增加partition，然后做数据迁移，增加机器，不就可以存放更多数据，提高更高的吞吐量了？</p>
<p>其次，你得考虑一下这个MQ的数据要不要写入磁盘？<br>可以通过顺序写的方式来将数据写入磁盘，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能很高，这就是Kafka的思路；</p>
<p>其次考虑MQ的可用性。多副本 -&gt; leader $ follower -&gt; broker挂了重新选举leader即可对外服务。</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/08/03/HTTPS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">HTTPS核心知识点</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/08/03/HTTP%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/">
                        <span class="hidden-mobile">HTTP请求过程详解</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <script defer src="https://utteranc.es/client.js"
          repo="gavin-yyj/commit-utterance"
          issue-term="pathname"
  
          theme="github-light"
          crossorigin="anonymous"
  >
  </script>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "消息中间件面试题&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
