<!DOCTYPE html>
<html lang="zh-CH">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="光说不做假把式">
  <meta name="author" content="杨玉杰">
  <meta name="keywords" content="">
  <title>JVM浅析 - 杨玉杰|个人博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/agate.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>杨玉杰|个人博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友情链接
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bgi.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-07-01 20:26">
      July 1, 2020 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      49
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><h2 id="JVM的主要组成部分及作用"><a href="#JVM的主要组成部分及作用" class="headerlink" title="JVM的主要组成部分及作用"></a>JVM的主要组成部分及作用</h2><p><img src="https://img-blog.csdnimg.cn/20200630215753963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>JVM主要由四个部分组成：</p>
<div class="hljs"><pre><code>1. 类加载器（ClassLoader）
2. 运行时数据区（Runtime Data Area）
3. 执行引擎（Execution Engine）
4. 本地库接口（Native Interface）</code></pre></div><p>各组件的作用：首先通过编译器把 Java 代码转换成字节码，<strong>类加载器</strong>（ClassLoader）再把字节码加载到内存中，将其放在<strong>运行时数据区</strong>（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器<strong>执行引擎</strong>（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的<strong>本地库接口</strong>（Native Interface）来实现整个程序的功能。</p>
<h2 id="Java程序运行机制步骤"><a href="#Java程序运行机制步骤" class="headerlink" title="Java程序运行机制步骤"></a>Java程序运行机制步骤</h2><p><img src="https://img-blog.csdnimg.cn/20200630222445455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<ul>
<li>首先利用IDE集成开发工具编写Java源代码，源文件的后缀名为.java</li>
<li>编译器(javac)将源代码编译成字节码文件，后缀名.class</li>
<li>解释器（java命令）运行字节码</li>
</ul>
<p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。</p>
<h2 id="JVM运行时数据区"><a href="#JVM运行时数据区" class="headerlink" title="JVM运行时数据区"></a>JVM运行时数据区</h2><p><img src="https://img-blog.csdnimg.cn/20200630223135269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<ul>
<li>程序计数器：字节码解释器工作就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成；</li>
<li>Java虚拟机栈：生命周期和线程一致，每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用直到执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程；</li>
<li>本地方法栈：与Java虚拟机栈不同的是，Java虚拟机栈是为执行Java方法（字节码）服务，而本地方法栈是为虚拟机使用到的本地方法服务。<br>Java虚拟机栈和本地方法栈都有可能抛出StackOverFlowError【线程请求的栈深度大于虚拟机所允许的深度】和OutOfMemoryError【如果虚拟机可以动态扩展，而扩展时无法申请到足够的内存】。</li>
<li>Java堆：主要用来存放对象实例和数组，垃圾回收的主要区域；</li>
<li>方法区：用来存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；</li>
<li>运行时常量池：方法区的一部分，编译器生成的字面量和符号引用会在类加载后放入这个区域。</li>
</ul>
<h2 id="堆栈的区别"><a href="#堆栈的区别" class="headerlink" title="堆栈的区别"></a>堆栈的区别</h2><ul>
<li>可见度：堆线程共享，栈线程私有；</li>
<li>存储内容：堆中主要存放对象实例，数组，栈中主要存放基本数据类型，对象的引用；</li>
<li>作用：栈主要解决程序的运行问题，堆主要解决的是数据的存储问题；</li>
<li>内存分配：堆是不连续的，分配的内存是在运行期确定的，大小不固定，栈是连续的，分配的内存大小要在编译期确定，大小固定。</li>
</ul>
<h1 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h1><h2 id="对象创建的几种方式"><a href="#对象创建的几种方式" class="headerlink" title="对象创建的几种方式"></a>对象创建的几种方式</h2><ul>
<li>使用new关键字</li>
<li>使用Class的newInstance方法</li>
<li>使用Constructor类的newInstance方法</li>
<li>使用clone方法</li>
<li>使用反序列化</li>
</ul>
<h2 id="对象创建的主要流程"><a href="#对象创建的主要流程" class="headerlink" title="对象创建的主要流程"></a>对象创建的主要流程</h2><p>虚拟机遇到一条new指令时，先检查常量池是否已经加载相应的类，如果没有，必须先执行相应的<code>类加载</code>，类加载通过后，接下来<code>分配内存</code>，若Java堆中内存是绝对规整的，使用“<strong>指针碰撞</strong>”方式分配内存；如果不是规整的，就从空闲列表中分配，叫做“<strong>空闲列表</strong>”方式。划分内存时还需要考虑一个<code>并发问题</code>，也有两种方式：<strong>CAS同步处理</strong>或者<strong>本地线程分配缓冲</strong>，然后内存空间初始化操作，接着是做一些必要的<code>对象设置</code>，最后执行&lt;init&gt;方法。</p>
<p><img src="https://img-blog.csdnimg.cn/20200701163823266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200701164113114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>Java程序需要通过 JVM 栈上的引用访问堆中的具体对象。对象的访问方式取决于 JVM 虚拟机的实现。目前主流的访问方式有 <strong>句柄</strong> 和 <strong>直接指针</strong> 两种方式。</p>
<blockquote>
<p>指针： 指向对象，代表一个对象在内存中的起始地址。<br>句柄： 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。</p>
</blockquote>
<p><strong>句柄访问</strong><br>Java堆中划分出一块内存来作为句柄池，Java栈的局部变量表中存储对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息，具体构造如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200701164940774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>优势：引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。</p>
<p><strong>直接指针</strong><br>如果使用直接指针访问，引用中存储的直接就是对象地址，那么Java堆对象内部的布局中就必须考虑如何放置访问类型数据的相关信息。<br>优势：速度更快，节省了一次指针定位的时间开销。由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。</p>
<h1 id="内存溢出异常"><a href="#内存溢出异常" class="headerlink" title="内存溢出异常"></a>内存溢出异常</h1><h2 id="Java会存在内存泄漏吗？"><a href="#Java会存在内存泄漏吗？" class="headerlink" title="Java会存在内存泄漏吗？"></a>Java会存在内存泄漏吗？</h2><p>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中，虽然Java由GC垃圾回收机制，不再被使用的对象会被GC自动回收，但是还是存在内存泄漏问题，比如：</p>
<ul>
<li>长生命周期的对象持有短生命周期对象的引用，尽管短生命周期已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收。</li>
<li>监听器：释放对象的时候没有删除监听器；</li>
<li>各种连接：比如数据库连接（dataSourse.getConnection()），网络连接(socket) 和 IO 连接，除非其显式的调用了其 close() 方法将其连接关闭，否则是不会自动被 GC 回收的；</li>
</ul>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><h2 id="Java中都有哪些引用类型"><a href="#Java中都有哪些引用类型" class="headerlink" title="Java中都有哪些引用类型"></a>Java中都有哪些引用类型</h2><ul>
<li>强引用：发生GC的时候不会回收</li>
<li>软引用：在发生内存溢出之前会被回收</li>
<li>弱引用：在下一次GC时会被回收</li>
<li>虚引用：又称幽灵引用，无法通过虚引用来获得对象，主要用于在GC时返回一个通知</li>
</ul>
<h2 id="怎么判断对象是否可以被回收"><a href="#怎么判断对象是否可以被回收" class="headerlink" title="怎么判断对象是否可以被回收"></a>怎么判断对象是否可以被回收</h2><ul>
<li>引用计数器法：缺点是不能解决循环引用问题</li>
<li>可达性分析：从GC Roots开始向下搜素，搜素所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是可以被回收的。</li>
</ul>
<h2 id="JVM的永久代中会发生垃圾回收吗？"><a href="#JVM的永久代中会发生垃圾回收吗？" class="headerlink" title="JVM的永久代中会发生垃圾回收吗？"></a>JVM的永久代中会发生垃圾回收吗？</h2><p>垃圾回收不会发生在永久代，如果永久代满了或是超过了临界值，会触发完全垃圾回收（Full GC），另外，Java8中已经移除了永久代。</p>
<h2 id="JVM的垃圾回收算法"><a href="#JVM的垃圾回收算法" class="headerlink" title="JVM的垃圾回收算法"></a>JVM的垃圾回收算法</h2><ul>
<li>标记-清除算法：标记无用对象，然后进行清除回收<br>优点：实现简单，不需要对象进行移动；<br>缺点：标记、清除过程效率低，会产生大量不连续的内存碎片；</li>
<li>复制算法：把内存空间划分为两个相等的区域，每次只使用其中一个区域，垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后将当前使用区域的可回收对象进行回收。<br>优点：按顺序分配内存即可，实现简单，运行高效，不用考虑内存碎片；<br>缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制；</li>
<li>标记-整理算法：在标记可回收的对象后将所有存活的对象压缩到内存的一端，使它们紧凑地排列在一起，然后对端边界以外的内存进行回收，回收后，已用和未用的内存都各自一边。<br>优点：解决了标记-清理算法存在的内存碎片问题<br>缺点：仍需要进行局部对象移动，一定程度上降低了效率</li>
<li>分代收集算法：针对不同情况采用不同的垃圾回收算法。</li>
</ul>
<h2 id="分代收集下的年轻代和老年代采用的垃圾回收算法"><a href="#分代收集下的年轻代和老年代采用的垃圾回收算法" class="headerlink" title="分代收集下的年轻代和老年代采用的垃圾回收算法"></a>分代收集下的年轻代和老年代采用的垃圾回收算法</h2><p><strong>新生代</strong>：主要以复制算法为主</p>
<ul>
<li>年轻代内存按照8：1：1的比例分为一个Eden区和两个Survivor(Survivor0、Survivor1)区，大部分对象在Eden区中生成，回收时先将Eden区存活对象复制到一个Survivor0区，然后清空Eden区，当这个Survivor0区也存满了时，则将Eden区和Survivor0区存活的对象复制到另一个Survivor1区，然后清空Eden区和这个Survivor0区，此时Survivor0区是空的，然后将Survivor0区和Survivor1区交换，即保持Survivor1区为空，如此往复。</li>
<li>当Survivor1区不足以存放Eden区和Survivor0区存活的对象时，则将存活对象直接放到老年代，若是老年代也满了，就会触发一次Full GC（Major GC），年轻代和老年代都进行回收。</li>
<li>年轻代发生的GC叫做Minor GC，Minor GC发生的频率比较高（不一定等Eden区满了才触发）</li>
<li>每次从Survivor0到Survivor1移动存活的对象，年龄就加1，当年龄到达15时（默认值），升级为老年代；</li>
<li>大对象直接进入老年代<br><strong>老年代</strong>：主要以标记整理为主</li>
<li>在年轻代中经历了N次垃圾回收仍然存活的对象就会被放到老年代中，因此，可以认为老年代中存放的都是一些生命周期比较长的对象；</li>
<li>老年代内存比年轻代内存大很多，当老年代内存满时会触发Major GC（Full GC）。</li>
</ul>
<h2 id="JVM常见的垃圾回收器"><a href="#JVM常见的垃圾回收器" class="headerlink" title="JVM常见的垃圾回收器"></a>JVM常见的垃圾回收器</h2><p><img src="https://img-blog.csdnimg.cn/20200701183738540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<ul>
<li>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li>
<li>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li>
<li>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；</li>
<li>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li>
<li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li>
<li>G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li>
</ul>
<h2 id="详细介绍一下CMS垃圾回收器"><a href="#详细介绍一下CMS垃圾回收器" class="headerlink" title="详细介绍一下CMS垃圾回收器"></a>详细介绍一下CMS垃圾回收器</h2><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。</p>
<p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
<h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><h2 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a>Java类加载机制</h2><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的Java类型。<br>注意：类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类，如果一次性加载所有类，那么会占用很大的内存。</p>
<p>类的加载方式有两种：</p>
<ol>
<li>隐式加载，程序在运行过程中遇到new等方式生成对象时，隐式调用类加载器来加载对应的类到JVM中；</li>
<li>显式加载：通过class.forName()等方法显式加载需要加载的类。</li>
</ol>
<h2 id="类的生命周期（前5个步骤是类加载过程）"><a href="#类的生命周期（前5个步骤是类加载过程）" class="headerlink" title="类的生命周期（前5个步骤是类加载过程）"></a>类的生命周期（前5个步骤是类加载过程）</h2><p><img src="https://img-blog.csdnimg.cn/20200701191958528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<ol>
<li><p>加载：<br>完成以下三件事：</p>
<ul>
<li>通过类的完全限定名称获取定义该类的二进制字节流；</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构；</li>
<li>在内存中生成一个代表该类的Class对象，作为方法区中该类各种数据的访问入口；</li>
</ul>
<p>获取二进制字节流有以下几种方式：</p>
<ul>
<li>从ZIP包读取，常见的有：JAR，WAR</li>
<li>从网络中获取，如：Applet</li>
<li>运行时计算生成，如：动态代理技术，使用ProxyGenerator.generateProxyClass的代理类的二进制字节流</li>
</ul>
</li>
<li><p>验证：<br>确保Class文件的字节流中包含的信息是符合当前虚拟机的要求，不会危害虚拟机自身的安全</p>
</li>
<li><p>准备：<br>为类变量分配内存并设置初始值，使用的是方法区的内存。<br>注意：实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中，<strong>类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。</strong>（单例实现，为什么非静态方法中不能引用静态方法，等等）</p>
</li>
<li><p>解析：<br>将常量池的符号引用替换为直接引用的过程。</p>
</li>
<li><p>初始化：<br>初始化阶段才是真正开始执行类中定义的Java程序代码，初始化阶段是虚拟机执行类构造器方法的过程，并且根据程序去初始化类变量和其他资源。<br>注意的是：静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
	<span class="hljs-keyword">static</span> &#123;
		i = <span class="hljs-number">0</span>; <span class="hljs-comment">// 给变量赋值可以正常编译通过</span>
		System.out.print(i); <span class="hljs-comment">// 这句编译器会提示“非法向前引用”</span>
	&#125; 
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;
&#125;</code></pre></div>
</li>
<li><p>使用：</p>
</li>
<li><p>卸载：</p>
</li>
</ol>
<h2 id="什么是类加载器，类加载器有哪些？"><a href="#什么是类加载器，类加载器有哪些？" class="headerlink" title="什么是类加载器，类加载器有哪些？"></a>什么是类加载器，类加载器有哪些？</h2><p>类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。</p>
<p>主要有以下四种类加载器：</p>
<ol>
<li>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。</li>
<li>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li>
<li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li>
<li>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。</li>
</ol>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确定在JVM中的唯一性，每个类加载器都有一个独立的类名称空间，类加载器就是根据指定的全限定名称将class文件加载到JVM内存，然后再转化为java.lang.Class对象。<br><img src="https://img-blog.csdnimg.cn/20200701201941588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成(<strong>注意：这里的父子关系一般是通过组合关系来实现的，而不是继承实现的)</strong>，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p>
<h1 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h1><h2 id="说一下-JVM-调优的工具？"><a href="#说一下-JVM-调优的工具？" class="headerlink" title="说一下 JVM 调优的工具？"></a>说一下 JVM 调优的工具？</h2><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>
<p>jconsole：用于对 JVM 中的内存、线程和类等进行监控；<br>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</p>
<h2 id="常用的-JVM-调优的参数都有哪些？"><a href="#常用的-JVM-调优的参数都有哪些？" class="headerlink" title="常用的 JVM 调优的参数都有哪些？"></a>常用的 JVM 调优的参数都有哪些？</h2><p>-Xms2g：初始化推大小为 2g；<br>-Xmx2g：堆最大内存为 2g；<br>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；<br>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；<br>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；<br>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；<br>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；<br>-XX:+PrintGC：开启打印 gc 信息；<br>-XX:+PrintGCDetails：打印 gc 详细信息。</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java%E9%9D%A2%E8%AF%95/">Java面试</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java%E9%9D%A2%E8%AF%95/">Java面试</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/07/07/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MySQL数据库</span>
                        <span class="visible-mobile">前の記事</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/06/28/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">
                        <span class="hidden-mobile">Java并发编程</span>
                        <span class="visible-mobile">次の記事</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <script defer src="https://utteranc.es/client.js"
          repo="gavin-yyj/commit-utterance"
          issue-term="pathname"
  
          theme="github-light"
          crossorigin="anonymous"
  >
  </script>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;ディレクトリ</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">検索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">キーワード</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "JVM浅析&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
