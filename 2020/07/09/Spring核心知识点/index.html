<!DOCTYPE html>
<html lang="zh-CH">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="光说不做假把式">
  <meta name="author" content="杨玉杰">
  <meta name="keywords" content="">
  <title>Spring核心知识点 - 杨玉杰|个人博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/agate.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>杨玉杰|个人博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友情链接
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bgi.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-07-09 19:33">
      July 9, 2020 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      57
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <hr>
<h1 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h1><h2 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h2><p>Spring是一个轻量级的Java开发框架，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题，<strong>简化Java开发</strong>，其设计理念是通过IoC容器实现对象耦合关系的管理，从而实现<strong>解耦</strong>。</p>
<h2 id="Spring的优缺点"><a href="#Spring的优缺点" class="headerlink" title="Spring的优缺点"></a>Spring的优缺点</h2><p>优点：</p>
<ul>
<li>方便解耦，简化开发（将所有对象的创建和依赖关系的维护交给Spring管理）</li>
<li>AOP编程的支持（方便实现对程序进行权限拦截、运行监控等功能）</li>
<li>声明式事务的支持（只要通过配置就可以完成对事务的管理，无需手动编程）</li>
<li>方便程序的测试（Junit4支持，通过注解方便测试Spring程序）</li>
<li>方便集成各种优秀框架（MyBatis、Redis等）</li>
<li>降低JavaEE API的使用难度</li>
</ul>
<p>缺点：</p>
<ul>
<li>Spring依赖反射，影响性能</li>
<li>使用门槛较高</li>
<li>配置较复杂</li>
</ul>
<h2 id="Spring由哪些模块组成"><a href="#Spring由哪些模块组成" class="headerlink" title="Spring由哪些模块组成"></a>Spring由哪些模块组成</h2><p><img src="https://img-blog.csdnimg.cn/20200709145013402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<ul>
<li>Core：提供了框架的基本组成部分，包括控制反转和依赖注入功能；</li>
<li>Beans：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean；</li>
<li>Context：Spring上下文，向Spring框架提供上下文信息，其他程序也可以通过Context访问Spring的Bean资源。</li>
<li>JDBC：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析， 用于简化JDBC</li>
<li>AOP：提供面向切面的编程实现，可以自定义拦截器、切点等；</li>
<li>Web：Web开发相关的组件</li>
<li>Test：为测试提供支持</li>
</ul>
<h2 id="Spring框架中的设计模式"><a href="#Spring框架中的设计模式" class="headerlink" title="Spring框架中的设计模式"></a>Spring框架中的设计模式</h2><ol>
<li>工厂模式：BeanFactory创建对象的实例</li>
<li>单例模式：Bean默认是单例模式</li>
<li>代理模式：AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</li>
<li>模板方法模式：用来解决代码重复的问题，如：JpaTemplate，RestTemplate</li>
<li>观察者模式：当一个对象的状态发生改变时，所有依赖于它的对象都能得到通知，如监听器功能。</li>
</ol>
<h1 id="Spring控制反转（IoC）"><a href="#Spring控制反转（IoC）" class="headerlink" title="Spring控制反转（IoC）"></a>Spring控制反转（IoC）</h1><h2 id="什么是Spring-IoC容器"><a href="#什么是Spring-IoC容器" class="headerlink" title="什么是Spring IoC容器"></a>什么是Spring IoC容器</h2><p>控制反转是将传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理，所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，实现了<strong>解耦</strong>。</p>
<p>Spring IoC负责创建对象，并管理这些对象的整个生命周期。</p>
<h2 id="Spring-IoC的实现机制"><a href="#Spring-IoC的实现机制" class="headerlink" title="Spring IoC的实现机制"></a>Spring IoC的实现机制</h2><p>工厂模式+反射机制</p>
<h2 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h2><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。<br><strong>区别：</strong><br>依赖关系：</p>
<ul>
<li><p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p>
</li>
<li><p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p>
<ul>
<li>继承MessageSource，因此支持国际化（i18n）。</li>
<li>统一的资源文件访问方式。</li>
<li>提供在监听器中注册bean的事件。</li>
<li>同时加载多个配置文件。</li>
<li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li>
</ul>
</li>
</ul>
<p>加载方式：</p>
<ul>
<li>BeanFactory采用的是延迟加载的形式来注入Bean</li>
<li>ApplicationContext在容器启动时一次性创建所有的Bean。这样在容器启动时，就可以发现Spring中存在的配置错误，但是不足之处在于占用内存空间，从而导致程序启动较慢。</li>
</ul>
<p>创建方式：</p>
<ul>
<li>BeanFactory通常以编程的方式被创建</li>
<li>ApplicationContext还能以<strong>声明</strong>的方式创建，如使用ContextLoader。</li>
</ul>
<h2 id="ApplicationContext通常的实现是什么？"><a href="#ApplicationContext通常的实现是什么？" class="headerlink" title="ApplicationContext通常的实现是什么？"></a>ApplicationContext通常的实现是什么？</h2><ul>
<li>FileSystemXmlApplicationContext：通过程序在初始化的时候，导入Bean配置文件，然后得到Bean实例。</li>
<li>ClassPathXmlApplicationContext：从类路径下的xml文件中加载bean的配置文件；</li>
<li>XmlWebApplicationContext：在B/S系统中,通常在web.xml初始化bean的配置文件，然后由WebAppliCationContextUtil得到ApplicationContext</li>
</ul>
<h2 id="什么是依赖注入（DI）"><a href="#什么是依赖注入（DI）" class="headerlink" title="什么是依赖注入（DI）"></a>什么是依赖注入（DI）</h2><p>依赖注入（Dependency Injection，DI），是组件之间依赖关系由容器在运行期决定，即由容器动态地将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了<strong>提升组件重用的频率</strong>，并为系统搭建一个<strong>灵活</strong>、<strong>可扩展</strong>的平台。通过依赖注入机制，只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。<br><strong>依赖注入是实现控制反转的方法和手段。</strong></p>
<h2 id="依赖注入的常见实现方式"><a href="#依赖注入的常见实现方式" class="headerlink" title="依赖注入的常见实现方式"></a>依赖注入的常见实现方式</h2><ul>
<li><p>setter注入</p>
</li>
<li><p>构造方法注入</p>
</li>
<li><p>注解注入</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;
    <span class="hljs-comment">// 使用注解自动注入</span>
    <span class="hljs-meta">@Autowired</span>()
    <span class="hljs-keyword">private</span> UserService userService;
    <span class="hljs-comment">// do something</span>
&#125;
<span class="hljs-comment">// 创建依赖对象</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;
   <span class="hljs-comment">// do something </span>
&#125;</code></pre></div>

</li>
</ul>
<h1 id="Spring-Beans"><a href="#Spring-Beans" class="headerlink" title="Spring Beans"></a>Spring Beans</h1><h2 id="Bean的5种作用域"><a href="#Bean的5种作用域" class="headerlink" title="Bean的5种作用域"></a>Bean的5种作用域</h2><ul>
<li>singleton：bean在每个Spring ioc 容器中只有一个实例。</li>
<li>prototype：一个bean的定义可以有多个实例。</li>
<li>request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring<br>ApplicationContext情形下有效。</li>
<li>session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
<li>global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
</ul>
<p>对于有状态的bean使用prototype，对于无状态的bean则使用singleton。</p>
<blockquote>
<p>有状态就是有数据存储功能，有状态对象就是有实例变量的对象，可以保存数据，是非线程安全的，所以要使用prototype保证安全；</p>
<p>无状态就是一次操作，不能保存数据，无状态对象就是没有实例变量的对象，线程安全，因此使用singleton性能更好。</p>
</blockquote>
<h3 id="Spring配置bean实例化有哪些方式？"><a href="#Spring配置bean实例化有哪些方式？" class="headerlink" title="Spring配置bean实例化有哪些方式？"></a>Spring配置bean实例化有哪些方式？</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-number">1</span>）使用类构造器实例化(默认无参数)
&lt;bean id="bean1" class="cn.itcast.spring.b_instance.Bean1"&gt;&lt;/bean&gt;
<span class="hljs-number">2</span>）使用静态工厂方法实例化(简单工厂模式)
<span class="hljs-comment">//下面这段配置的含义：调用Bean2Factory的getBean2方法得到bean2</span>
&lt;bean id=<span class="hljs-string">"bean2"</span> 
<span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"cn.itcast.spring.b_instance.Bean2Factory"</span> factory-method=<span class="hljs-string">"getBean2"</span>&gt;
&lt;/bean&gt;
<span class="hljs-number">3</span>）使用实例工厂方法实例化(工厂方法模式)
<span class="hljs-comment">//先创建工厂实例bean3Facory，再通过工厂实例创建目标bean实例</span>
&lt;bean id=<span class="hljs-string">"bean3Factory"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"cn.itcast.spring.b_instance.Bean3Factory"</span>&gt;
&lt;/bean&gt;
&lt;bean id=<span class="hljs-string">"bean3"</span> factory-bean=<span class="hljs-string">"bean3Factory"</span> factory-method=<span class="hljs-string">"getBean3"</span>&gt;
&lt;/bean&gt;</code></pre></div>
<h3 id="Spring配置bean实例化有哪些方式"><a href="#Spring配置bean实例化有哪些方式" class="headerlink" title="Spring配置bean实例化有哪些方式"></a>Spring配置bean实例化有哪些方式</h3><p>1）使用类构造器实例化(默认无参数)</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bean1"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.itcast.spring.b_instance.Bean1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>2）使用静态工厂方法实例化(简单工厂模式)<br>下面这段配置的含义：调用Bean2Factory的getBean2方法得到bean2</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bean2"</span> </span>
<span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">"cn.itcast.spring.b_instance.Bean2Factory"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"getBean2"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>3）使用实例工厂方法实例化(工厂方法模式)<br>先创建工厂实例bean3Facory，再通过工厂实例创建目标bean实例</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bean3Factory"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.itcast.spring.b_instance.Bean3Factory"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bean3"</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"bean3Factory"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"getBean3"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>
<h2 id="Spring如何解决线程并发问题"><a href="#Spring如何解决线程并发问题" class="headerlink" title="Spring如何解决线程并发问题"></a>Spring如何解决线程并发问题</h2><p>在Spring中，绝大部分Bean都可以声明为singleton作用域（不是线程安全的），因为Spring对一些Bean中非线程安全状态采用<strong>ThreadLocal</strong>进行处理，解决线程安全问题。<br>ThreadLocal会为每个线程提供一个独立的变量副本，从而隔离多个线程对数据的访问冲突，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>
<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><ol>
<li>实例化：Spring对Bean进行实例化；</li>
<li>属性赋值：Spring将值和Bean的引用注入到Bean对应的属性中；</li>
<li>初始化：<ul>
<li>如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，此处传递的就是Spring配置文件中Bean的id值；</li>
<li>如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory(setBeanFactory(BeanFactory)传递的是Spring工厂自身（可以用这个方式来获取其它Bean，只需在Spring配置文件中配置一个普通的Bean就可以）；</li>
<li>如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文（同样这个方式也可以实现步骤4的内容，但比4更好，因为ApplicationContext是BeanFactory的子接口，有更多的实现方法）；</li>
<li>如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术；</li>
<li>如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。</li>
<li>如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法；</li>
</ul>
</li>
<li>销毁：当容器关闭时，调用Bean的销毁方法（A：使用配置文件指定的destroy-method属性；B：实现org.springframwork.bean.factory.DisposeableBean接口）</li>
</ol>
<p>注意：Spring 容器可以管理 singleton 作用域下 bean 的生命周期，在此作用域下，Spring 能够精确地知道bean何时被创建，何时初始化完成，以及何时被销毁。而<strong>对于 prototype 作用域的bean，Spring只负责创建</strong>，当容器创建了 bean 的实例后，bean 的实例就交给了客户端的代码管理，Spring容器将不再跟踪其生命周期，并且不会管理那些被配置成prototype作用域的bean的生命周期。  </p>
<h2 id="Bean生命周期方法"><a href="#Bean生命周期方法" class="headerlink" title="Bean生命周期方法"></a>Bean生命周期方法</h2><p>bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。相应的注解是@PostConstruct和@PreDestroy。</p>
<h2 id="Bean注入属性有几种方式？"><a href="#Bean注入属性有几种方式？" class="headerlink" title="Bean注入属性有几种方式？"></a>Bean注入属性有几种方式？</h2><p>接口注入、构造器注入、set注入。</p>
<h2 id="Component-和-Bean-有什么区别？"><a href="#Component-和-Bean-有什么区别？" class="headerlink" title="@Component 和 @Bean 有什么区别？"></a>@Component 和 @Bean 有什么区别？</h2><p>它们的作用对象不同：@Component 作用于类，而 @Bean 注解作用于方法。</p>
<p>@Component 通常是通过类路径扫描来自动侦测和装配对象到 Spring 容器中，比如 @ComponentScan 注解就是定义扫描路径中的类装配到 Spring 的 Bean 容器中；@Bean 注解是告诉 Spring 这是某个类的实例，当我需要用它时把它给我，@Bean 注解比 @Component 注解自定义性更强，很多地方我们只能通过 @Bean 注解来注册 Bean，比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean 来实现。</p>
<h2 id="使用-Autowired注解自动装配的过程是怎样的？"><a href="#使用-Autowired注解自动装配的过程是怎样的？" class="headerlink" title="使用@Autowired注解自动装配的过程是怎样的？"></a>使用@Autowired注解自动装配的过程是怎样的？</h2><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config /&gt;。</p>
<p>在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p>
<ul>
<li>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</li>
<li>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</li>
<li>如果上述查找的结果为空，那么会抛出异常。解决方法是使用required=false。</li>
</ul>
<h1 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h1><p>@Required 注解有什么作用<br>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。示例：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-meta">@Required</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;
        <span class="hljs-keyword">this</span>.name=name;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> string <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> name;
    &#125;
&#125;</code></pre></div>

<h2 id="Autowired和-Resource之间的区别"><a href="#Autowired和-Resource之间的区别" class="headerlink" title="@Autowired和@Resource之间的区别"></a>@Autowired和@Resource之间的区别</h2><p>@Autowired可用于：构造函数、成员变量、Setter方法<br>@Autowired和@Resource之间的区别</p>
<ul>
<li>@Autowired默认是按照<strong>类型</strong>装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</li>
<li>@Resource默认是按照<strong>名称</strong>来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</li>
</ul>
<h2 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h2><p>用来标识 http 请求地址与 Controller 类的方法之间的映射，可以注释到类上，也可以注释到方法上。</p>
<h1 id="Spring数据访问"><a href="#Spring数据访问" class="headerlink" title="Spring数据访问"></a>Spring数据访问</h1><h2 id="Spring-DAO有什么用"><a href="#Spring-DAO有什么用" class="headerlink" title="Spring DAO有什么用"></a>Spring DAO有什么用</h2><p>Spring DAO（数据访问对象）使得JDB、Hibernate或JDO这样的数据访问技术更容易以一种统一的方式工作，使得用户容易在持久层技术之间切换，而无需考虑捕获每种技术不同的异常。</p>
<h2 id="JdbcTemplate是什么"><a href="#JdbcTemplate是什么" class="headerlink" title="JdbcTemplate是什么"></a>JdbcTemplate是什么</h2><p>JdbcTemplate类提供了很多便利的方法解决诸如把数据库数据编程基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p>
<h2 id="Spring的事务管理"><a href="#Spring的事务管理" class="headerlink" title="Spring的事务管理"></a>Spring的事务管理</h2><p>事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。</p>
<p>Spring有自己的事务管理机制，一般是使用TransactionManager进行管理，可以通过Spring的注入来完成此功能，Spring提供了几个有关事务处理的类：</p>
<ul>
<li>TransactionDefinition：事务属性定义；</li>
<li>TransactionStatus：代表了当前事务，可以提交、回滚；</li>
<li>PlatformTransactionManager：Spring提供用于管理事务的基础接口，其下有一个实现的抽象类AbstractPlatformTransactionManager，我们使用的事务管理类如：DataSourceTransactionManager等都是这个类的子类。</li>
</ul>
<p>一般事务定义步骤：</p>
<div class="hljs"><pre><code class="hljs java">TransactionDefinition td = newTransactionDefinition();
TransactionStatus ts = transactionManager.getTransaction(td);
<span class="hljs-keyword">try</span>&#123; 
    <span class="hljs-comment">//do sth</span>
    transactionManager.commit(ts);
&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;
    transactionManager.rollback(ts);
&#125;</code></pre></div>

<h2 id="Spring支持的事务管理类型及其实现方式"><a href="#Spring支持的事务管理类型及其实现方式" class="headerlink" title="Spring支持的事务管理类型及其实现方式"></a>Spring支持的事务管理类型及其实现方式</h2><p>Spring支持两种类型的事务管理：</p>
<ul>
<li>编程式事务管理：通过编程的方式管理事务，灵活但难以维护；</li>
<li><strong>声明式事务管理</strong>：将业务代码和事务管理分离，只需用注解或xml配置文件来管理事务，非侵入性。</li>
</ul>
<p>声明式事务管理建立在AOP上，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或加入一个事务，执行完目标方法之后根据执行的情况进行提交或回滚。</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><ul>
<li>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，可以读到未提交的内容；</li>
<li>READ-COMMITTED(读取已提交)： 通过“快照读”的机制，保证只能读到已经提交的内容；</li>
<li>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，因为事务开启后，不允许进行“修改，删除”操作；</li>
<li>SERIALIZABLE(可串行化)：<br>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，但是效率太差，性能开销也大，几乎不使用。</li>
</ul>
<h2 id="事务的传播属性"><a href="#事务的传播属性" class="headerlink" title="事务的传播属性"></a>事务的传播属性</h2><p>　<strong>PROPAGATION_REQUIRED</strong> – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。<br>　<strong>PROPAGATION_SUPPORTS</strong> – 支持当前事务，如果当前没有事务，就以非事务方式执行。<br>　<strong>PROPAGATION_MANDATORY</strong> – 支持当前事务，如果当前没有事务，就抛出异常。<br>　<strong>PROPAGATION_REQUIRES_NEW</strong> – 新建事务，如果当前存在事务，把当前事务挂起。<br>　<strong>PROPAGATION_NOT_SUPPORTED</strong> – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>　<strong>PROPAGATION_NEVER</strong> – 以非事务方式执行，如果当前存在事务，则抛出异常。<br>　<strong>PROPAGATION_NESTED</strong>–如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED</p>
<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><p>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，用于<strong>将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块</strong>，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于<strong>权限认证</strong>、日志、事务处理等。</p>
<h2 id="AOP的名词解释"><a href="#AOP的名词解释" class="headerlink" title="AOP的名词解释"></a>AOP的名词解释</h2><ul>
<li>通知（Advice）：在切面的某个特定的连接点（Joinpoint）上执行的动作。通知有各种类型，其中包括“around”、“before”和“after”等通知。<br>通知的类型将在后面部分进行讨论。许多AOP框架，包括Spring，都是以拦截器做通知模型， 并维护一个以连接点为中心的拦截器链。</li>
<li>连接点（JoinPoint）：Spring<strong>允许</strong>你使用通知的地方，一般是方法前后；</li>
<li>切入点（Pointcut）：连接点是可以使用通知的地方，而切入点是你<strong>想要</strong>使用通知的地方；</li>
<li>切面（Aspect）：<strong>通知</strong>和<strong>切入点</strong>的结合，通知说明了<strong>干什么和什么时候干</strong>（时间是通过方法名中的before、after、around等确定的），切入点说明了<strong>在哪干</strong>（指定使用通知的方法）；</li>
<li>目标（target）：被通知的对象，也就是真正的业务逻辑，被通知的对象可以在毫不知情的情况下，被织入切面，而自己专注于业务本身的逻辑；</li>
<li>织入（weaving）：把切面应用到目标对象来创建新的代理对象的过程；</li>
</ul>
<h2 id="Spring-AOP和AspectJ-AOP有什么区别"><a href="#Spring-AOP和AspectJ-AOP有什么区别" class="headerlink" title="Spring AOP和AspectJ AOP有什么区别"></a>Spring AOP和AspectJ AOP有什么区别</h2><p>AOP实现的关键在于代理模式，AOP代理主要分为静态代理和动态代理，静态代理的代表是AspectJ，动态代理则有Spring AOP和CGLIB。<br>区别：</p>
<ul>
<li>AspectJ是静态代理的增强，AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，它会在编译阶段将Aspect（切面）织入到Java字节码中，运行的时候就是增强后的AOP对象。</li>
<li>Spring AOP使用的动态代理，AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</li>
</ul>
<p>静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p>
<h2 id="JDK动态代理和CGLIB动态代理的区别"><a href="#JDK动态代理和CGLIB动态代理的区别" class="headerlink" title="JDK动态代理和CGLIB动态代理的区别"></a>JDK动态代理和CGLIB动态代理的区别</h2><ul>
<li>JDK动态代理只提供接口的代理，不支持类的代理，核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。</li>
<li>如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library）是一个代码生成的类库，可以在运行时动态地生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</li>
</ul>
<h2 id="Spring通知类型"><a href="#Spring通知类型" class="headerlink" title="Spring通知类型"></a>Spring通知类型</h2><p>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中，代理封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean，当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。<br>Spring切面有5种类型的通知：</p>
<ul>
<li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li>
<li>后置通知（After）：在目标方法完成之后调用通知，不关心方法的输出结果；</li>
<li>返回通知（After-returning）：在目标方法成功执行之后调用通知；</li>
<li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li>
<li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li>
</ul>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/SSM%E6%A1%86%E6%9E%B6/">SSM框架</a>
                    
                      <a class="hover-with-bg" href="/categories/SSM%E6%A1%86%E6%9E%B6/Spring/">Spring</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Spring/">Spring</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/07/10/MyBatis%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MyBatis核心知识点</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/07/07/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/">
                        <span class="hidden-mobile">MySQL数据库</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <script defer src="https://utteranc.es/client.js"
          repo="gavin-yyj/commit-utterance"
          issue-term="pathname"
  
          theme="github-light"
          crossorigin="anonymous"
  >
  </script>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Spring核心知识点&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
