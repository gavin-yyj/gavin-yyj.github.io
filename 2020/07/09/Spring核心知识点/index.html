<!DOCTYPE html>
<html lang="zh-CH">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="光说不做假把式">
  <meta name="author" content="杨玉杰">
  <meta name="keywords" content="">
  <title>Spring核心知识点 - 杨玉杰|个人博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/agate.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>杨玉杰|个人博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友情链接
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bgi.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-07-09 19:33">
      July 9, 2020 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      95
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <hr>
<h1 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h1><h2 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h2><p>Spring是一个轻量级的Java开发框架，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题，<strong>简化Java开发</strong>，其设计理念是通过IoC容器实现对象耦合关系的管理，从而实现<strong>解耦</strong>。</p>
<h2 id="Spring的优缺点"><a href="#Spring的优缺点" class="headerlink" title="Spring的优缺点"></a>Spring的优缺点</h2><p>优点：</p>
<ul>
<li>方便解耦，简化开发（将所有对象的创建和依赖关系的维护交给Spring管理）</li>
<li>AOP编程的支持（方便实现对程序进行权限拦截、运行监控等功能）</li>
<li>声明式事务的支持（只要通过配置就可以完成对事务的管理，无需手动编程）</li>
<li>方便程序的测试（Junit4支持，通过注解方便测试Spring程序）</li>
<li>方便集成各种优秀框架（MyBatis、Redis等）</li>
<li>降低JavaEE API的使用难度</li>
</ul>
<p>缺点：</p>
<ul>
<li>Spring依赖反射，影响性能</li>
<li>使用门槛较高</li>
<li>配置较复杂</li>
</ul>
<h2 id="Spring由哪些模块组成"><a href="#Spring由哪些模块组成" class="headerlink" title="Spring由哪些模块组成"></a>Spring由哪些模块组成</h2><p><img src="https://img-blog.csdnimg.cn/20200709145013402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<ul>
<li>Core：提供了框架的基本组成部分，包括控制反转和依赖注入功能；</li>
<li>Beans：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean；</li>
<li>Context：Spring上下文，向Spring框架提供上下文信息，其他程序也可以通过Context访问Spring的Bean资源。</li>
<li>JDBC：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析， 用于简化JDBC</li>
<li>AOP：提供面向切面的编程实现，可以自定义拦截器、切点等；</li>
<li>Web：Web开发相关的组件</li>
<li>Test：为测试提供支持</li>
</ul>
<h2 id="Spring框架中的设计模式"><a href="#Spring框架中的设计模式" class="headerlink" title="Spring框架中的设计模式"></a>Spring框架中的设计模式</h2><ol>
<li>工厂模式：BeanFactory创建对象的实例</li>
<li>单例模式：Bean默认是单例模式</li>
<li>代理模式：AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</li>
<li>模板方法模式：用来解决代码重复的问题，如：JpaTemplate，RestTemplate</li>
<li>观察者模式：当一个对象的状态发生改变时，所有依赖于它的对象都能得到通知，如监听器功能。</li>
</ol>
<h1 id="Spring控制反转（IoC）"><a href="#Spring控制反转（IoC）" class="headerlink" title="Spring控制反转（IoC）"></a>Spring控制反转（IoC）</h1><h2 id="什么是Spring-IoC容器"><a href="#什么是Spring-IoC容器" class="headerlink" title="什么是Spring IoC容器"></a>什么是Spring IoC容器</h2><p>控制反转是将传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理，所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，实现了<strong>解耦</strong>。</p>
<p>Spring IoC负责创建对象，并管理这些对象的整个生命周期。</p>
<h2 id="Spring-IoC的实现机制"><a href="#Spring-IoC的实现机制" class="headerlink" title="Spring IoC的实现机制"></a>Spring IoC的实现机制</h2><p>工厂模式+反射机制</p>
<h2 id="IOC容器的加载流程-refresh方法"><a href="#IOC容器的加载流程-refresh方法" class="headerlink" title="IOC容器的加载流程(refresh方法)"></a>IOC容器的加载流程(refresh方法)</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>&#123;
    Object var1 = <span class="hljs-keyword">this</span>.startupShutdownMonitor;
    <span class="hljs-comment">// 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span>
    <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>.startupShutdownMonitor) &#123;
        
        <span class="hljs-comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span>
        <span class="hljs-keyword">this</span>.prepareRefresh();
        
        <span class="hljs-comment">// 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span>
        <span class="hljs-comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span>
        <span class="hljs-comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span>
        ConfigurableListableBeanFactory beanFactory = <span class="hljs-keyword">this</span>.obtainFreshBeanFactory();
        
        <span class="hljs-comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span>
        <span class="hljs-keyword">this</span>.prepareBeanFactory(beanFactory);

        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span>
            <span class="hljs-comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span>

            <span class="hljs-comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span>
            <span class="hljs-comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span>
            <span class="hljs-keyword">this</span>.postProcessBeanFactory(beanFactory);
            
            <span class="hljs-comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法</span>
            <span class="hljs-keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);
            
            <span class="hljs-comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span>
            <span class="hljs-comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span>
            <span class="hljs-comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机</span>
            <span class="hljs-keyword">this</span>.registerBeanPostProcessors(beanFactory);
            
         	<span class="hljs-comment">// 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了    </span>
            <span class="hljs-keyword">this</span>.initMessageSource();
            
            <span class="hljs-comment">// 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span>
            <span class="hljs-keyword">this</span>.initApplicationEventMulticaster();
            
            <span class="hljs-comment">// 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说</span>
         	<span class="hljs-comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span>
            <span class="hljs-keyword">this</span>.onRefresh();
            
            <span class="hljs-comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span>
            <span class="hljs-keyword">this</span>.registerListeners();
            
            <span class="hljs-comment">// 重点，重点，重点</span>
            <span class="hljs-comment">// 初始化所有的 singleton beans</span>
            <span class="hljs-comment">//（lazy-init 的除外）</span>
            <span class="hljs-keyword">this</span>.finishBeanFactoryInitialization(beanFactory);
            
            <span class="hljs-comment">// 最后，广播事件，ApplicationContext 初始化完成，不展开</span>
            <span class="hljs-keyword">this</span>.finishRefresh();
        &#125; <span class="hljs-keyword">catch</span> (BeansException var9) &#123;
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logger.isWarnEnabled()) &#123;
                <span class="hljs-keyword">this</span>.logger.warn(<span class="hljs-string">"Exception encountered during context initialization - cancelling refresh attempt: "</span> + var9);
            &#125;

            <span class="hljs-comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span>
            <span class="hljs-keyword">this</span>.destroyBeans();
            <span class="hljs-keyword">this</span>.cancelRefresh(var9);
            <span class="hljs-comment">// 把异常往外抛</span>
            <span class="hljs-keyword">throw</span> var9;
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-keyword">this</span>.resetCommonCaches();
        &#125;

    &#125;
&#125;</code></pre></div>

<h3 id="1-加锁"><a href="#1-加锁" class="headerlink" title="1. 加锁"></a>1. 加锁</h3><p>首先是一个synchronized加锁，不然你先调用一次refresh()，然后这次还没处理完，有调用一次，就会乱套。</p>
<h3 id="2-prepareRefresh"><a href="#2-prepareRefresh" class="headerlink" title="2. prepareRefresh()"></a>2. prepareRefresh()</h3><p>做准备工作，记录容器的启动时间，标记“已启动”状态，处理配置文件中的占位符。</p>
<h3 id="3-注册BeanDefinition到BeanFactory"><a href="#3-注册BeanDefinition到BeanFactory" class="headerlink" title="3. 注册BeanDefinition到BeanFactory"></a>3. 注册BeanDefinition到BeanFactory</h3><div class="hljs"><pre><code class="hljs java">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</code></pre></div>

<p>将配置文件解析成一个个Bean，并且注册到BeanFactory中，注意这里只是注册进去，并没有初始化。</p>
<h4 id="注册实现原理"><a href="#注册实现原理" class="headerlink" title="注册实现原理"></a>注册实现原理</h4><p><strong>BeanDefinition(Bean定义)</strong></p>
<p>在IOC实现中，我们在XML中描述的Bean信息最后都将保存至BeanDefinition对象中，xml-bean中设置的属性最后都会体现在BeanDefinition中，如：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18628873-7553de4d8ddfbb11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1136/format/webp" srcset="/img/loading.gif" alt="img"></p>
<p><strong>BeanDefinitionRegistry(Bean注册器)</strong></p>
<p>xml-bean中的id作为当前Bean的存储key注册到了BeanDefinitionRegistry注册器中，name作为别名key注册到了AliasRegistry注册中心，最后都是指向其对应的BeanDefinition。</p>
<p><strong>BeanDefinitionReader（Bean定义读取）</strong></p>
<p>BeanDefinition中存储了xml-bean信息，而BeanDefinitionRegister基于ID和name保存了Bean的定义，下图是从xml-Bean到BeanDefinition然后再注册至BeanDefinitionRegister的整个过程。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18628873-50f575074eb4c65c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/687/format/webp" srcset="/img/loading.gif" alt="img"></p>
<p>从上图可以看出，Bean的定义是由BeanDefinitionReader从xml中读取配置并构建出BeanDefinition，然后再基于别名注册BeanDefinitionRegister中。</p>
<h3 id="4-prepareBeanFactory（beanFactory）"><a href="#4-prepareBeanFactory（beanFactory）" class="headerlink" title="4. prepareBeanFactory（beanFactory）"></a>4. prepareBeanFactory（beanFactory）</h3><p>设置BeanFactory的类加载器，然后添加几个BeanPostProcessor，手动注册几个特殊的bean，这里都是Spring里面的特殊处理。</p>
<h3 id="5-postProcessBeanFactory（beanFactory）"><a href="#5-postProcessBeanFactory（beanFactory）" class="headerlink" title="5. postProcessBeanFactory（beanFactory）"></a>5. postProcessBeanFactory（beanFactory）</h3><p>提供给子类的扩展点，到这里所有的Bean都加载，注册完成了，但是都还没有初始化，具体的子类可以在这步的时候添加一些特殊的BeanFactoryPostProcessor的实现类，来完成一些其他的操作。</p>
<p><strong>BeanPostProcessor接口</strong>：如果我们想在Spring容器中完成Bean实例化、配置以及其他初始化方法前后要添加一些自己逻辑处理，我们需要定义一个或多个BeanPostProcessor接口实现类，然后注册到Spring IOC容器中。</p>
<h3 id="6-执行容器中实现的BeanFactoryPostProcessor的子类（如果有的话）"><a href="#6-执行容器中实现的BeanFactoryPostProcessor的子类（如果有的话）" class="headerlink" title="6. 执行容器中实现的BeanFactoryPostProcessor的子类（如果有的话）"></a>6. 执行容器中实现的BeanFactoryPostProcessor的子类（如果有的话）</h3><div class="hljs"><pre><code class="hljs java">invokeBeanFactoryPostProcessors(beanFactory);</code></pre></div>

<p>这个方法是调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法；</p>
<h3 id="7-后置处理器的实现BeanPostProcessors"><a href="#7-后置处理器的实现BeanPostProcessors" class="headerlink" title="7. 后置处理器的实现BeanPostProcessors"></a>7. 后置处理器的实现BeanPostProcessors</h3><div class="hljs"><pre><code class="hljs java">registerBeanPostProcessors(beanFactory);</code></pre></div>

<p>这个方法注册 BeanPostProcessor 的实现类，和上面的BeanFactoryPostProcessor 是有区别的，这个方法调用的其实是PostProcessorRegistrationDelegate类的registerBeanPostProcessors方法；这个类里面有个内部类BeanPostProcessorChecker，BeanPostProcessorChecker里面有两个方法<strong>postProcessBeforeInitialization和postProcessAfterInitialization</strong>，这两个方法分别在 Bean 初始化之前和初始化之后得到执行。</p>
<h3 id="8-国际化"><a href="#8-国际化" class="headerlink" title="8. 国际化"></a>8. 国际化</h3><div class="hljs"><pre><code class="hljs java">initMessageSource();</code></pre></div>

<h3 id="9-初始化事件广播器"><a href="#9-初始化事件广播器" class="headerlink" title="9. 初始化事件广播器"></a>9. 初始化事件广播器</h3><div class="hljs"><pre><code class="hljs java">initApplicationEventMulticaster();</code></pre></div>

<h3 id="10-初始化一些特殊的Bean"><a href="#10-初始化一些特殊的Bean" class="headerlink" title="10. 初始化一些特殊的Bean"></a>10. 初始化一些特殊的Bean</h3><div class="hljs"><pre><code class="hljs java">onRefresh();</code></pre></div>

<p>方法初始化一些特殊的 Bean（在初始化 singleton beans 之前）</p>
<h3 id="11-注册事件监听器"><a href="#11-注册事件监听器" class="headerlink" title="11. 注册事件监听器"></a>11. 注册事件监听器</h3><div class="hljs"><pre><code class="hljs java">registerListeners();</code></pre></div>

<p>方法注册事件监听器，监听器需要实现 ApplicationListener 接口</p>
<h3 id="12-初始化Bean"><a href="#12-初始化Bean" class="headerlink" title="12. 初始化Bean"></a>12. 初始化Bean</h3><div class="hljs"><pre><code class="hljs java">finishBeanFactoryInitialization(beanFactory);</code></pre></div>

<p>初始化所有的 singleton beans（单例bean），懒加载（non-lazy-init）的除外（spring默认不是懒加载，如果设定了懒加载，则bean的初始化由getbean方法触发）。</p>
<p>从调用过程可以总结出以下几点：<br> 1.调用BeanFactory.getBean() 会触发Bean的实例化。<br> 2.DefaultSingletonBeanRegistry 中缓存了单例Bean<br> 3.Bean的创建与初始化是由AbstractAutowireCapableBeanFactory 完成的。</p>
<h3 id="13-广播事件，告诉上下文，容器已经创建好，随时可以调用"><a href="#13-广播事件，告诉上下文，容器已经创建好，随时可以调用" class="headerlink" title="13. 广播事件，告诉上下文，容器已经创建好，随时可以调用"></a>13. 广播事件，告诉上下文，容器已经创建好，随时可以调用</h3><div class="hljs"><pre><code class="hljs java">finishRefresh();</code></pre></div>

<p>方法是最后一步，广播事件，ApplicationContext 初始化完成。</p>
<h2 id="Ioc容器的加载过程简单概括："><a href="#Ioc容器的加载过程简单概括：" class="headerlink" title="Ioc容器的加载过程简单概括："></a>Ioc容器的加载过程简单概括：</h2><ol>
<li>刷新预处理</li>
<li>将配置信息解析，注册到BeanFactory</li>
<li>设置bean的类加载器</li>
<li>如果有第三方想再bean加载注册完成后，初始化前做点什么(例如修改属性的值，修改bean的scope为单例或者多例。)，提供了相应的模板方法，后面还调用了这个方法的实现，并且把这些个实现类注册到对应的容器中</li>
<li>初始化当前的事件广播器</li>
<li>初始化所有的bean。（懒加载不执行这一步）</li>
<li>广播applicationcontext初始化完成。</li>
</ol>
<h2 id="BeanFactory和FactoryBean"><a href="#BeanFactory和FactoryBean" class="headerlink" title="BeanFactory和FactoryBean"></a>BeanFactory和FactoryBean</h2><ul>
<li>BeanFactory：以Factory结尾，是spring中比较原始的Factory，如XMLBeanFactory就是一种典型的BeanFactory，表示它是一个工厂类，又称IoC容器或对象工厂，所有的Bean都是由BeanFactory（IoC容器）来进行管理；</li>
<li>FactoryBean：以Bean结尾，表示它是一个Bean，不同于普通Bean的是：FactoryBean能生产或修饰对象生成的工厂Bean，它的实现与设计模式中的工厂模式和修饰器模式类似。</li>
</ul>
<h2 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h2><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。<br><strong>区别：</strong><br>依赖关系：</p>
<ul>
<li><p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p>
</li>
<li><p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p>
<ul>
<li>继承MessageSource，因此支持国际化（i18n）。</li>
<li>统一的资源文件访问方式。</li>
<li>提供在监听器中注册bean的事件。</li>
<li>同时加载多个配置文件。</li>
<li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li>
</ul>
</li>
</ul>
<p>加载方式：</p>
<ul>
<li>BeanFactory采用的是<strong>延迟加载</strong>的形式来注入Bean</li>
<li>ApplicationContext在容器启动时一次性创建所有的Bean。这样在容器启动时，就可以发现Spring中存在的配置错误，但是不足之处在于占用内存空间，从而导致程序启动较慢。</li>
</ul>
<p>创建方式：</p>
<ul>
<li>BeanFactory通常以<strong>编程</strong>的方式被创建</li>
<li>ApplicationContext还能以<strong>声明</strong>的方式创建，如使用ContextLoader。</li>
</ul>
<h2 id="ApplicationContext通常的实现是什么？"><a href="#ApplicationContext通常的实现是什么？" class="headerlink" title="ApplicationContext通常的实现是什么？"></a>ApplicationContext通常的实现是什么？</h2><ul>
<li>FileSystemXmlApplicationContext：通过程序在初始化的时候，导入Bean配置文件，然后得到Bean实例。</li>
<li>ClassPathXmlApplicationContext：从类路径下的xml文件中加载bean的配置文件；</li>
<li>XmlWebApplicationContext：在B/S系统中,通常在web.xml初始化bean的配置文件，然后由WebAppliCationContextUtil得到ApplicationContext</li>
</ul>
<h2 id="什么是依赖注入（DI）"><a href="#什么是依赖注入（DI）" class="headerlink" title="什么是依赖注入（DI）"></a>什么是依赖注入（DI）</h2><p>依赖注入（Dependency Injection，DI），是组件之间依赖关系由容器在运行期决定，即由容器动态地将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了<strong>提升组件重用的频率</strong>，并为系统搭建一个<strong>灵活</strong>、<strong>可扩展</strong>的平台。通过依赖注入机制，只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。<br><strong>依赖注入是实现控制反转的方法和手段。</strong></p>
<h2 id="依赖注入的常见实现方式"><a href="#依赖注入的常见实现方式" class="headerlink" title="依赖注入的常见实现方式"></a>依赖注入的常见实现方式</h2><ul>
<li><p>setter注入</p>
</li>
<li><p>构造方法注入</p>
</li>
<li><p>注解注入</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;
    <span class="hljs-comment">// 使用注解自动注入</span>
    <span class="hljs-meta">@Autowired</span>()
    <span class="hljs-keyword">private</span> UserService userService;
    <span class="hljs-comment">// do something</span>
&#125;
<span class="hljs-comment">// 创建依赖对象</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;
   <span class="hljs-comment">// do something </span>
&#125;</code></pre></div>

</li>
</ul>
<h1 id="Spring-Beans"><a href="#Spring-Beans" class="headerlink" title="Spring Beans"></a>Spring Beans</h1><h2 id="Bean的5种作用域"><a href="#Bean的5种作用域" class="headerlink" title="Bean的5种作用域"></a>Bean的5种作用域</h2><ul>
<li>singleton：bean在每个Spring ioc 容器中只有一个实例。</li>
<li>prototype：一个bean的定义可以有多个实例。</li>
<li>request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring<br>ApplicationContext情形下有效。</li>
<li>session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
<li>global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
</ul>
<p>对于有状态的bean使用prototype，对于无状态的bean则使用singleton。</p>
<blockquote>
<p>有状态就是有数据存储功能，有状态对象就是有实例变量的对象，可以保存数据，是非线程安全的，所以要使用prototype保证安全；</p>
<p>无状态就是一次操作，不能保存数据，无状态对象就是没有实例变量的对象，线程安全，因此使用singleton性能更好。</p>
</blockquote>
<h3 id="Spring配置bean实例化有哪些方式？"><a href="#Spring配置bean实例化有哪些方式？" class="headerlink" title="Spring配置bean实例化有哪些方式？"></a>Spring配置bean实例化有哪些方式？</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-number">1</span>）使用类构造器实例化(默认无参数)
&lt;bean id="bean1" class="cn.itcast.spring.b_instance.Bean1"&gt;&lt;/bean&gt;
<span class="hljs-number">2</span>）使用静态工厂方法实例化(简单工厂模式)
<span class="hljs-comment">//下面这段配置的含义：调用Bean2Factory的getBean2方法得到bean2</span>
&lt;bean id=<span class="hljs-string">"bean2"</span> 
<span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"cn.itcast.spring.b_instance.Bean2Factory"</span> factory-method=<span class="hljs-string">"getBean2"</span>&gt;
&lt;/bean&gt;
<span class="hljs-number">3</span>）使用实例工厂方法实例化(工厂方法模式)
<span class="hljs-comment">//先创建工厂实例bean3Facory，再通过工厂实例创建目标bean实例</span>
&lt;bean id=<span class="hljs-string">"bean3Factory"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"cn.itcast.spring.b_instance.Bean3Factory"</span>&gt;
&lt;/bean&gt;
&lt;bean id=<span class="hljs-string">"bean3"</span> factory-bean=<span class="hljs-string">"bean3Factory"</span> factory-method=<span class="hljs-string">"getBean3"</span>&gt;
&lt;/bean&gt;</code></pre></div>
<h3 id="Spring配置bean实例化有哪些方式"><a href="#Spring配置bean实例化有哪些方式" class="headerlink" title="Spring配置bean实例化有哪些方式"></a>Spring配置bean实例化有哪些方式</h3><p>1）使用类构造器实例化(默认无参数)</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bean1"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.itcast.spring.b_instance.Bean1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>2）使用静态工厂方法实例化(简单工厂模式)<br>下面这段配置的含义：调用Bean2Factory的getBean2方法得到bean2</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bean2"</span> </span>
<span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">"cn.itcast.spring.b_instance.Bean2Factory"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"getBean2"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>3）使用实例工厂方法实例化(工厂方法模式)<br>先创建工厂实例bean3Facory，再通过工厂实例创建目标bean实例</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bean3Factory"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.itcast.spring.b_instance.Bean3Factory"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bean3"</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"bean3Factory"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"getBean3"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>
<h2 id="Spring如何解决线程并发问题"><a href="#Spring如何解决线程并发问题" class="headerlink" title="Spring如何解决线程并发问题"></a>Spring如何解决线程并发问题</h2><p>在Spring中，绝大部分Bean都可以声明为singleton作用域（不是线程安全的），因为Spring对一些Bean中非线程安全状态采用<strong>ThreadLocal</strong>进行处理，解决线程安全问题。<br>ThreadLocal会为每个线程提供一个独立的变量副本，从而隔离多个线程对数据的访问冲突，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>
<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><ol>
<li>实例化：Spring对Bean进行实例化；</li>
<li>属性赋值：Spring将值和Bean的引用注入到Bean对应的属性中；</li>
<li>初始化：<ul>
<li>如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，此处传递的就是Spring配置文件中Bean的id值；</li>
<li>如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory(setBeanFactory(BeanFactory)传递的是Spring工厂自身（可以用这个方式来获取其它Bean，只需在Spring配置文件中配置一个普通的Bean就可以）；</li>
<li>如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文（同样这个方式也可以实现步骤4的内容，但比4更好，因为ApplicationContext是BeanFactory的子接口，有更多的实现方法）；</li>
<li>如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术；</li>
<li>如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。</li>
<li>如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法；</li>
</ul>
</li>
<li>销毁：当容器关闭时，调用Bean的销毁方法（A：使用配置文件指定的destroy-method属性；B：实现org.springframwork.bean.factory.DisposeableBean接口）</li>
</ol>
<p>注意：Spring 容器可以管理 singleton 作用域下 bean 的生命周期，在此作用域下，Spring 能够精确地知道bean何时被创建，何时初始化完成，以及何时被销毁。而<strong>对于 prototype 作用域的bean，Spring只负责创建</strong>，当容器创建了 bean 的实例后，bean 的实例就交给了客户端的代码管理，Spring容器将不再跟踪其生命周期，并且不会管理那些被配置成prototype作用域的bean的生命周期。  </p>
<h2 id="Bean生命周期方法"><a href="#Bean生命周期方法" class="headerlink" title="Bean生命周期方法"></a>Bean生命周期方法</h2><p>bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。相应的注解是@PostConstruct和@PreDestroy。</p>
<h2 id="Bean注入属性有几种方式？"><a href="#Bean注入属性有几种方式？" class="headerlink" title="Bean注入属性有几种方式？"></a>Bean注入属性有几种方式？</h2><p>接口注入、构造器注入、set注入。</p>
<h2 id="Component-和-Bean-有什么区别？"><a href="#Component-和-Bean-有什么区别？" class="headerlink" title="@Component 和 @Bean 有什么区别？"></a>@Component 和 @Bean 有什么区别？</h2><p>它们的作用对象不同：@Component 作用于类，而 @Bean 注解作用于方法。</p>
<p>@Component 通常是通过类路径扫描来自动侦测和装配对象到 Spring 容器中，比如 @ComponentScan 注解就是定义扫描路径中的类装配到 Spring 的 Bean 容器中；@Bean 注解是告诉 Spring 这是某个类的实例，当我需要用它时把它给我，@Bean 注解比 @Component 注解自定义性更强，很多地方我们只能通过 @Bean 注解来注册 Bean，比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean 来实现。</p>
<h2 id="使用-Autowired注解自动装配的过程是怎样的？"><a href="#使用-Autowired注解自动装配的过程是怎样的？" class="headerlink" title="使用@Autowired注解自动装配的过程是怎样的？"></a>使用@Autowired注解自动装配的过程是怎样的？</h2><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config /&gt;。</p>
<p>在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p>
<ul>
<li>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</li>
<li>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</li>
<li>如果上述查找的结果为空，那么会抛出异常。解决方法是使用required=false。</li>
</ul>
<h1 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h1><p>@Required 注解有什么作用<br>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。示例：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-meta">@Required</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;
        <span class="hljs-keyword">this</span>.name=name;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> string <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> name;
    &#125;
&#125;</code></pre></div>

<h2 id="Autowired和-Resource之间的区别"><a href="#Autowired和-Resource之间的区别" class="headerlink" title="@Autowired和@Resource之间的区别"></a>@Autowired和@Resource之间的区别</h2><p>@Autowired可用于：构造函数、成员变量、Setter方法<br>@Autowired和@Resource之间的区别</p>
<ul>
<li>@Autowired默认是按照<strong>类型</strong>装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</li>
<li>@Resource默认是按照<strong>名称</strong>来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</li>
</ul>
<h2 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h2><p>用来标识 http 请求地址与 Controller 类的方法之间的映射，可以注释到类上，也可以注释到方法上。</p>
<h1 id="Spring数据访问"><a href="#Spring数据访问" class="headerlink" title="Spring数据访问"></a>Spring数据访问</h1><h2 id="Spring-DAO有什么用"><a href="#Spring-DAO有什么用" class="headerlink" title="Spring DAO有什么用"></a>Spring DAO有什么用</h2><p>Spring DAO（数据访问对象）使得JDB、Hibernate或JDO这样的数据访问技术更容易以一种统一的方式工作，使得用户容易在持久层技术之间切换，而无需考虑捕获每种技术不同的异常。</p>
<h2 id="JdbcTemplate是什么"><a href="#JdbcTemplate是什么" class="headerlink" title="JdbcTemplate是什么"></a>JdbcTemplate是什么</h2><p>JdbcTemplate类提供了很多便利的方法解决诸如把数据库数据编程基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p>
<h2 id="Spring的事务管理"><a href="#Spring的事务管理" class="headerlink" title="Spring的事务管理"></a>Spring的事务管理</h2><p>事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。</p>
<p>Spring有自己的事务管理机制，一般是使用TransactionManager进行管理，可以通过Spring的注入来完成此功能，Spring提供了几个有关事务处理的类：</p>
<ul>
<li>TransactionDefinition：事务属性定义；</li>
<li>TransactionStatus：代表了当前事务，可以提交、回滚；</li>
<li>PlatformTransactionManager：Spring提供用于管理事务的基础接口，其下有一个实现的抽象类AbstractPlatformTransactionManager，我们使用的事务管理类如：DataSourceTransactionManager等都是这个类的子类。</li>
</ul>
<p>一般事务定义步骤：</p>
<div class="hljs"><pre><code class="hljs java">TransactionDefinition td = newTransactionDefinition();
TransactionStatus ts = transactionManager.getTransaction(td);
<span class="hljs-keyword">try</span>&#123; 
    <span class="hljs-comment">//do sth</span>
    transactionManager.commit(ts);
&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;
    transactionManager.rollback(ts);
&#125;</code></pre></div>

<h2 id="Spring支持的事务管理类型及其实现方式"><a href="#Spring支持的事务管理类型及其实现方式" class="headerlink" title="Spring支持的事务管理类型及其实现方式"></a>Spring支持的事务管理类型及其实现方式</h2><p>Spring支持两种类型的事务管理：</p>
<ul>
<li>编程式事务管理：通过编程的方式管理事务，灵活但难以维护；</li>
<li><strong>声明式事务管理</strong>：将业务代码和事务管理分离，只需用注解或xml配置文件来管理事务，非侵入性。</li>
</ul>
<p>声明式事务管理建立在AOP上，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或加入一个事务，执行完目标方法之后根据执行的情况进行提交或回滚。</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><ul>
<li>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，可以读到未提交的内容；</li>
<li>READ-COMMITTED(读取已提交)： 通过“快照读”的机制，保证只能读到已经提交的内容；</li>
<li>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，因为事务开启后，不允许进行“修改，删除”操作；</li>
<li>SERIALIZABLE(可串行化)：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，但是效率太差，性能开销也大，几乎不使用。</li>
</ul>
<h2 id="事务的传播属性"><a href="#事务的传播属性" class="headerlink" title="事务的传播属性"></a>事务的传播属性</h2><p>　<strong>PROPAGATION_REQUIRED</strong> – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。<br>　<strong>PROPAGATION_SUPPORTS</strong> – 支持当前事务，如果当前没有事务，就以非事务方式执行。<br>　<strong>PROPAGATION_MANDATORY</strong> – 支持当前事务，如果当前没有事务，就抛出异常。<br>　<strong>PROPAGATION_REQUIRES_NEW</strong> – 新建事务，如果当前存在事务，把当前事务挂起。<br>　<strong>PROPAGATION_NOT_SUPPORTED</strong> – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>　<strong>PROPAGATION_NEVER</strong> – 以非事务方式执行，如果当前存在事务，则抛出异常。<br>　<strong>PROPAGATION_NESTED</strong>–如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED</p>
<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><p>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，用于<strong>将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块</strong>，这个模块被命名为“<strong>切面</strong>”（Aspect），以减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于<strong>权限认证</strong>、日志、事务处理等。AOP底层原理就是动态代理的实现。</p>
<h2 id="AOP的名词解释"><a href="#AOP的名词解释" class="headerlink" title="AOP的名词解释"></a>AOP的名词解释</h2><ul>
<li><strong>通知（Advice）</strong>：在切面的某个特定的连接点（Joinpoint）上执行的动作。通知有各种类型，其中包扩“around”，“before”和“after”等通知。<br>通知的类型将在后面部分进行讨论。许多AOP框架，包括Spring，都是以拦截器做通知模型， 并维护一个以连接点为中心的拦截器链。</li>
<li><strong>连接点（JoinPoint）</strong>：Spring<strong>允许</strong>你使用通知的地方，一般是方法前后；</li>
<li><strong>切入点（Pointcut）</strong>：连接点是可以使用通知的地方，而切入点是你<strong>想要</strong>使用通知的地方；</li>
<li><strong>切面（Aspect）</strong>：<strong>通知</strong>和<strong>切入点</strong>的结合，通知说明了<strong>干什么和什么时候干</strong>（时间是通过方法名中的before、after、around等确定的），切入点说明了<strong>在哪干</strong>（指定使用通知的方法）；</li>
<li><strong>目标（target）</strong>：被通知的对象，也就是真正的业务逻辑，被通知的对象可以在毫不知情的情况下，被织入切面，而自己专注于业务本身的逻辑；</li>
<li><strong>织入（weaving）</strong>：把切面应用到目标对象来创建新的代理对象的过程；</li>
</ul>
<h2 id="Spring-AOP和AspectJ-AOP有什么区别"><a href="#Spring-AOP和AspectJ-AOP有什么区别" class="headerlink" title="Spring AOP和AspectJ AOP有什么区别"></a>Spring AOP和AspectJ AOP有什么区别</h2><p><strong>AOP实现的关键在于代理模式</strong>，AOP代理主要分为静态代理和动态代理，静态代理的代表是AspectJ，动态代理则有Spring AOP和CGLIB。<br>区别：</p>
<ul>
<li>AspectJ是静态代理的增强，AOP框架会在<strong>编译阶段</strong>生成AOP代理类，因此也称为编译时增强，它会在编译阶段将Aspect（切面）织入到Java字节码中，运行的时候就是增强后的AOP对象。</li>
<li>Spring AOP使用的动态代理，AOP框架不会去修改字节码，而是每次<strong>运行时</strong>在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</li>
</ul>
<p>静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说<strong>AspectJ的静态代理方式具有更好的性能</strong>，但是<strong>AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理</strong>。</p>
<h2 id="静态代理、JDK动态代理、CGLIB动态代理"><a href="#静态代理、JDK动态代理、CGLIB动态代理" class="headerlink" title="静态代理、JDK动态代理、CGLIB动态代理"></a>静态代理、JDK动态代理、CGLIB动态代理</h2><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>建一个接口，接口中定义相应（代理对象和目标对象都要实现）的方法。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Subject</span></span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;
&#125;</code></pre></div>

<p>目标类（实现上述接口）</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span></span>&#123;
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tset</span><span class="hljs-params">()</span></span>&#123;
	System.out.printin(<span class="hljs-string">"target method"</span>);
	&#125;
&#125;</code></pre></div>

<p>代理类（实现上述接口）</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span></span>&#123;
	<span class="hljs-keyword">private</span> RealSubject realSubject;
	
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Proxy</span><span class="hljs-params">(RealSubject realSubject)</span></span>&#123;
	<span class="hljs-keyword">this</span>.realSubject = realSubject;
	&#125;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;
        System.out.printin(<span class="hljs-string">"Before"</span>);
        <span class="hljs-keyword">try</span>&#123;
        	realSubject.test();
        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;
            System.out.println(<span class="hljs-string">"ex:"</span>+e.getmessage());
            <span class="hljs-keyword">throw</span> e;
        &#125;<span class="hljs-keyword">finally</span>&#123;
        	System.out.println(<span class="hljs-string">"After"</span>);
        &#125;
    &#125;
&#125;</code></pre></div>

<p>客户端调用</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;
        <span class="hljs-comment">//通过接口</span>
        Subject subject = <span class="hljs-keyword">new</span> Proxy(<span class="hljs-keyword">new</span> RealSubject());
        subject.test();
    &#125;
&#125;</code></pre></div>

<p>静态代理缺点：不灵活，<strong>重复代码多</strong>。静态代理的代表是AspectJ，AspectJ是静态代理的增强，AOP框架会在<strong>编译阶段</strong>生成AOP代理类，因此也称为<strong>编译时增强</strong>，它会在编译阶段将Aspect（切面）织入到Java字节码中，运行的时候就是增强后的AOP对象。</p>
<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理只提供<strong>接口</strong>的代理，不支持类的代理，核心<code>InvocationHandler</code>接口和<code>Proxy</code>类，InvocationHandler 通过<code>invoke()</code>方法<strong>反射</strong>来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，<strong>Proxy利用 InvocationHandler动态创建一个符合某一接口的实例, 生成目标类的代理对象。</strong></p>
<ul>
<li><p>类：java.lang.reflect.Proxy（通过该类动态生成代理类）</p>
</li>
<li><p>代理类实现接口：InvocationHandler</p>
</li>
<li><p>JDK动态代理只能基于接口动态代理。</p>
</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdkProxySubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span></span>&#123;
    <span class="hljs-comment">//引入要代理的真实对象</span>
    <span class="hljs-keyword">private</span> RealSubject realSubject;

    <span class="hljs-comment">//用构造器注入目标方法，给我们要代理的真实对象赋初值</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JdkProxySubject</span><span class="hljs-params">(RealSubject realSubject)</span></span>&#123;
    	<span class="hljs-keyword">this</span>.realSubJect=realSubject;
    &#125;
    <span class="hljs-comment">//实现接口的方法</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy,Method method,Object[] args)</span><span class="hljs-keyword">throws</span> Throwable</span>&#123;
        System.out.println(<span class="hljs-string">"before"</span>);
        Object result = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span>&#123;
        <span class="hljs-comment">//调用目标方法</span>
        <span class="hljs-comment">//利用反射构造目标对象</span>
        <span class="hljs-comment">//当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span>
        result=method.invoke(realSubject,args);

        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;
            System.out.println(<span class="hljs-string">"ex:"</span>+e.getMessage());
            <span class="hljs-keyword">throw</span> e; 
        &#125;<span class="hljs-keyword">finally</span>&#123;
        	System.out.println(<span class="hljs-string">"after"</span>);
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;</code></pre></div>

<p>客户端调用（使用Proxy）</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span></span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;
    <span class="hljs-comment">//使用Proxy构造对象</span>
    <span class="hljs-comment">//参数</span>
    <span class="hljs-comment">//java泛型需要转换一下</span>
    <span class="hljs-comment">/* 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数</span>
<span class="hljs-comment">    * 第一个参数 getClassLoader() ，我们这里使用Client这个类的ClassLoader对象来加载我们的代理对象</span>
<span class="hljs-comment">    * 第二个参数表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了</span>
<span class="hljs-comment">    * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上</span>
<span class="hljs-comment">    */</span>     
    Subject subject = (Subject) java.lang.reflect.Proxy.newProxyInstance(Client.class.getClassLoader(),new Class[]&#123;Subject.class&#125;,new JdkProxySubject(new RralSubject()));
    <span class="hljs-comment">//调用方法</span>
    subject.test;
    &#125;
&#125;</code></pre></div>

<h4 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h4><p>过程：调用Proxy.newProxyInstance生成代理类的实现类；</p>
<p>InvocationHandler接口：</p>
<p>每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个hadler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的invoke()方法来进行调用:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function">Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable</span>&#123;&#125;</code></pre></div>

<ul>
<li>proxy:　　指代我们所代理的那个真实对象</li>
<li>method:　指代的是我们所要调用真实对象的某个方法的Method对象</li>
<li>args:　　   指代的是调用真实对象某个方法时接受的参数</li>
</ul>
<p>Proxy类：</p>
<p>Proxy这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，我们经常使用的是newProxyInstance()这个方法，这个方法的作用是得到一个动态的代理对象，其接收三个参数：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">newProxyInstance</span><span class="hljs-params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException</span>&#123;&#125;</code></pre></div>

<ul>
<li>loader：一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载；</li>
<li>interfaces：一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口，这样我就能调用这组接口中的方法；</li>
<li>h：一个InvocationHandler对象，表示当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上。</li>
</ul>
<h3 id="CGLIB代理"><a href="#CGLIB代理" class="headerlink" title="CGLIB代理"></a>CGLIB代理</h3><p><strong>如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。</strong>CGLIB（Code Generation Library）是一个代码生成的类库，可以在运行时动态地生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过<strong>继承</strong>的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p>
<p>代理类：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span></span>&#123;<span class="hljs-comment">//主要的方法拦截类，它是Callback接口的子接口，需要用户实现</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object obj,Method method,Object[] args,MethodProxy proxy )</span><span class="hljs-keyword">throws</span> Throwable</span>&#123;
        System.out.println(<span class="hljs-string">"before cgplib"</span>);
        Object result = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span>&#123;
            <span class="hljs-comment">//利用反射创建代理对象 </span>
            result = proxy.invokeSuper(obj,args);
        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;
            System.out.println(<span class="hljs-string">"ex:"</span>+e.getMessage());
            <span class="hljs-keyword">throw</span> e;
        &#125;<span class="hljs-keyword">finally</span>&#123;
        	System.out.println(<span class="hljs-string">"after cglib"</span>);
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;</code></pre></div>

<p>调用类：</p>
<div class="hljs"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;
        <span class="hljs-comment">// 主要的增强类</span>
        Enhancer enhancer=<span class="hljs-keyword">new</span> Enhancer();
        <span class="hljs-comment">//  目标类 , 设置父类，被增强的类</span>
        enhancer.setSuperclass(RealSubject<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        <span class="hljs-comment">// 回调对象</span>
        enhancer.setCallback(<span class="hljs-keyword">new</span> CglibMethodInterceptor());
        <span class="hljs-comment">//生成代理类对象，用cglibProxy来增强RealSubject</span>
        Subject subject=enhancer.create();
        subject.test();
    &#125;
&#125;</code></pre></div>

<h4 id="原理解析-1"><a href="#原理解析-1" class="headerlink" title="原理解析"></a>原理解析</h4><p>Cglib是一个优秀的动态代理框架，它的底层使用ASM在内存中动态的生成被代理类的子类，使用CGLIB即使代理类没有实现任何接口也可以实现动态代理功能。CGLIB具有简单易用，它的<strong>运行速度要远远快于JDK的Proxy动态代理</strong>：<br>CGLIB的核心类：</p>
<ul>
<li>net.sf.cglib.proxy.Enhancer – 主要的增强类</li>
<li>net.sf.cglib.proxy.MethodInterceptor – 主要的方法拦截类，它是Callback接口的子接口，需要用户实现</li>
<li>net.sf.cglib.proxy.MethodProxy – JDK的java.lang.reflect.Method类的代理类，可以方便的实现对源对象方法的调用,如使用：</li>
</ul>
<div class="hljs"><pre><code class="hljs java">Object o = methodProxy.invokeSuper(proxy, args);<span class="hljs-comment">//虽然第一个参数是被代理对象，也不会出现死循环的问题。</span></code></pre></div>



<h2 id="Spring通知类型"><a href="#Spring通知类型" class="headerlink" title="Spring通知类型"></a>Spring通知类型</h2><p>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中，代理封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean，当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。<br>Spring切面有5种类型的通知：</p>
<ul>
<li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li>
<li>后置通知（After）：在目标方法完成之后调用通知，不关心方法的输出结果；</li>
<li>返回通知（After-returning）：在目标方法成功执行之后调用通知；</li>
<li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li>
<li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li>
</ul>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/SSM%E6%A1%86%E6%9E%B6/">SSM框架</a>
                    
                      <a class="hover-with-bg" href="/categories/SSM%E6%A1%86%E6%9E%B6/Spring/">Spring</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Spring/">Spring</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/07/10/MyBatis%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MyBatis核心知识点</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/07/07/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/">
                        <span class="hidden-mobile">MySQL数据库</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <script defer src="https://utteranc.es/client.js"
          repo="gavin-yyj/commit-utterance"
          issue-term="pathname"
  
          theme="github-light"
          crossorigin="anonymous"
  >
  </script>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Spring核心知识点&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
