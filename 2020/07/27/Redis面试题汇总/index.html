<!DOCTYPE html>
<html lang="zh-CH">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="光说不做假把式">
  <meta name="author" content="杨玉杰">
  <meta name="keywords" content="">
  <title>Redis面试题汇总 - 杨玉杰|个人博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/agate.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>杨玉杰|个人博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友情链接
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bgi.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-07-27 14:20">
      July 27, 2020 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      12k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      126
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>Redis是一个使用C语言编写的，开源的高性能<strong>非关系型</strong>的<strong>键值对</strong>数据库。</p>
<p>Redis可以存储键和五种不同类型的值之间的映射，<strong>键的类型只能为字符串</strong>，值支持五种数据类型：String，List，Set，Hash，ZSet。</p>
<p>与传统数据库不同的是Redis的数据是存储在<strong>内存</strong>中，所以读写速度非常快，因此Redis被广泛应用在<strong>缓存</strong>方向，每秒可以处理超过10万次读写操作，是已知性能最快的key-value 数据库，另外，Redis也经常用来做<strong>分布式锁</strong>，除此之外，Redis支持<strong>事务</strong>，<strong>持久化</strong>，<strong>LUA脚本</strong>，<strong>LRU驱动事件</strong>，多种<strong>集群</strong>方案。</p>
<h2 id="Redis有哪些优缺点"><a href="#Redis有哪些优缺点" class="headerlink" title="Redis有哪些优缺点"></a>Redis有哪些优缺点</h2><p>优点：</p>
<ul>
<li>读写性能优异，Redis能读的速度是110000次/s，写的速度是81000次/s</li>
<li>支持数据持久化，支持<code>AOF</code>和<code>RDB</code>两种持久化方式。</li>
<li>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行；</li>
<li>数据结构丰富，除了支持String类型的value外，还支持hash，set，zset，list等数据结构；</li>
<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据库容量受到物理内存的限制，<strong>不能做海量数据的高性能读写</strong>，因此Redis适合的场景主要局限于较小数据量的高性能操作和运算上；</li>
<li>Redis<strong>不具备自动容错和恢复功能</strong>，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或手动切换前端的IP才能恢复；</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引起数据不一致的问题，降低了系统的可用性；</li>
<li>Redis<strong>在线扩容比较复杂</strong>，当集群容量达到上限时在线扩容会变得很复杂，为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li>
</ul>
<h2 id="为什么要用缓存？"><a href="#为什么要用缓存？" class="headerlink" title="为什么要用缓存？"></a>为什么要用缓存？</h2><p>主要从“高性能”和“高并发”这两点来看待这个问题。</p>
<h3 id="高性能："><a href="#高性能：" class="headerlink" title="高性能："></a>高性能：</h3><p><img src="https://img-blog.csdnimg.cn/2020072609180374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<h3 id="高并发："><a href="#高并发：" class="headerlink" title="高并发："></a>高并发：</h3><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的。<br><img src="https://img-blog.csdnimg.cn/20200726091913177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<h2 id="为什么要用Redis而不用map-guava做缓存"><a href="#为什么要用Redis而不用map-guava做缓存" class="headerlink" title="为什么要用Redis而不用map/guava做缓存"></a>为什么要用Redis而不用map/guava做缓存</h2><p>缓存分为<strong>本地缓存</strong>和<strong>分布式缓存</strong>，以Java为例，使用自带的map或者guava实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着JVM的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，<strong>缓存不具有一致性</strong>。</p>
<p>使用Redis或Memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，<strong>缓存具有一致性</strong>，缺点是需要保持Redis或Memcached服务的高可用，整个程序架构上较为复杂。</p>
<h2 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h2><ul>
<li><strong>完全基于内存</strong>，绝大部分请求都是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，查找和操作的时间复杂度都为O(1)；</li>
<li><strong>数据结构</strong>简单，对数据操作也简单，Redis的数据结构是专门进行设计的；</li>
<li><strong>采用单线程，避免了不必要的上下文切换和竞争条件</strong>，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，因为没有可能出现死锁而导致的性能消耗；</li>
<li>使用<strong>多路I/O复用模型</strong>，非阻塞IO；</li>
<li>使用<strong>底层模型</strong>不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="Redis有哪些数据类型"><a href="#Redis有哪些数据类型" class="headerlink" title="Redis有哪些数据类型"></a>Redis有哪些数据类型</h2><p><img src="https://img-blog.csdnimg.cn/2020072609412168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<h2 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a>Redis的应用场景</h2><h2 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h2><p><strong>计数器</strong><br>可以对String进行自增自减运算，从而实现计数器功能，Redis这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。<br><strong>缓存</strong><br>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。<br><strong>会话缓存</strong><br>可以使用Redis来统一存储多台应用服务器的会话信息，当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。<br><strong>查找表</strong><br>例如DNS记录就很适合使用Redis进行存储，查找表和缓存类似，也是利用了Redis快速的查找特性，但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。<br><strong>消息队列（发布/订阅功能）</strong><br>List是一个双向链表，可以通过<code>lpush</code>和<code>rpop</code>写入和读取消息，不过最好使用Kafka，RabbitMQ等消息中间件。<br><strong>分布式锁实现</strong><br>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步，可以使用Redis自带的<code>SETNX</code>命令实现分布式锁，除此之外，还可以使用官方提供的<code>RedLock</code>分布式锁实现。<br><strong>其他</strong><br>Set可以实现交集，并集操作，从而实现共同好友等功能，ZSet可以实现有序性操作，从而实现排行榜等功能。</p>
<h2 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h2><p>Redis相比其他缓存，有一个非常大的优势，就是支持多种数据类型。</p>
<ul>
<li>String–适合最简单的k-v存储，类似于Memcached的存储结构，短信验证码，配置信息等，就用这种类型来存储；</li>
<li>hash–一般key为ID或者唯一标识，value对应的就是详情了，如商品详情，个人信息详情，新闻详情等；</li>
<li>list–有序，比较适合存储一些有序且数据相对固定的数据，如：省市区表，字典表等，因为list是有序的，适合根据写入的时间来排序，如：消息队列等；</li>
<li>set–可以简单理解为ID-list模式，如微博中一个人有哪些好友，可以对两个set提供交集，并集，差集操作，例如：查找两个人共同的好友等；</li>
<li>Sorted Set–是set的增强版本，增加了一个<code>score</code>参数，自动会根据score的值进行排序，比较适合类似于top10等不根据插入的时间来排序的数据。</li>
</ul>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="什么是Redis持久化"><a href="#什么是Redis持久化" class="headerlink" title="什么是Redis持久化"></a>什么是Redis持久化</h2><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机导致内存数据丢失。</p>
<h2 id="Redis持久化机制是什么？各自的优缺点？"><a href="#Redis持久化机制是什么？各自的优缺点？" class="headerlink" title="Redis持久化机制是什么？各自的优缺点？"></a>Redis持久化机制是什么？各自的优缺点？</h2><p>Redis提供了两种持久化机制RDB（默认）和AOF机制。</p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB：默认的持久化方式，按照一定的时间将内存的数据以<code>快照</code>的形式保存到磁盘中，对应产生的数据文件为<code>dump.rdb</code>，有两个Redis命令可以用于生成RDB文件，一个是<code>SAVE</code>，另一个是<code>BGSAVE</code>，（SAVE会阻塞Redis服务器进程，直到RDB文件创建完毕，BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程继续处理请求命令）。<br><img src="https://img-blog.csdnimg.cn/20200726100538969.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>优点：</strong></p>
<ul>
<li>只有一个文件dump.rdb，方便备份；</li>
<li>容灾性好，一个文件可以保存到安全的磁盘；</li>
<li>性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化，使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了Redis的高性能；</li>
<li>相对于数据集大时，比AOF的启动效率更高；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>数据安全性低，RDB是间隔一段时间进行持久化，如果持久化之间Redis发生故障，会发生数据丢失，所以这种方式更适合数据要求不高的情况；</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF持久化（Append Only File）是将Redis执行的每次写命令<strong>记录到单独的日志文件</strong>中，当重启Redis会重新将持久化的日志中文件恢复数据。</p>
<p><strong>当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。</strong><br><img src="https://img-blog.csdnimg.cn/20200726101403651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>优点：</p>
<ul>
<li><strong>数据安全</strong>，AOF持久化可以配置<code>appendfsync</code>属性，有always，每进行一次命令操作就记录到AOF文件中一次；</li>
<li>通过append模式写文件，即使中途服务器宕机，可以通过<code>redis-check-aof</code>工具解决数据一致性问题；</li>
<li>AOF机制的rewrite模式（文件过大时会对命令进行合并重写），可以删除其中的某些命令。</li>
</ul>
<p>缺点：</p>
<ul>
<li>AOF文件比RDB文件大，且恢复速度慢</li>
<li>数据集大的时候，AOF启动效率低</li>
</ul>
<h2 id="如何选择合适的持久化方式"><a href="#如何选择合适的持久化方式" class="headerlink" title="如何选择合适的持久化方式"></a>如何选择合适的持久化方式</h2><ul>
<li>一般来说，如果是想达到足以媲美PostgreSQL的数据安全性，你应该<strong>同时使用两种持久化功能</strong>，在这种情况下，当Redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集更完整；</li>
<li>如果你非常关心你的数据，但仍可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化；</li>
<li>有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照非常便于进行数据库备份，并且RDB恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免AOF程序的bug；</li>
<li>如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式；</li>
</ul>
<h2 id="Redis持久化数据和缓存怎么做扩容"><a href="#Redis持久化数据和缓存怎么做扩容" class="headerlink" title="Redis持久化数据和缓存怎么做扩容"></a>Redis持久化数据和缓存怎么做扩容</h2><ul>
<li>如果Redis被当做缓存使用，使用<strong>一致性哈希</strong>实现动态扩容缩容；</li>
<li>如果Redis被当做一个持久化存储使用，必须使用固定的<code>keys-to-nodes</code>映射关系，节点的数量一旦确定不能变化，如果Redis节点需要动态变化，必须使用可以在运行时进行数据再平衡的一套系统，而当前只有<strong>Redis集群</strong>可以做到这样。</li>
</ul>
<h1 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h1><h2 id="Redis-key的过期时间和永久有效分别怎么设置"><a href="#Redis-key的过期时间和永久有效分别怎么设置" class="headerlink" title="Redis key的过期时间和永久有效分别怎么设置"></a>Redis key的过期时间和永久有效分别怎么设置</h2><p><code>EXPIRE</code>和<code>PERSIST</code>命令。</p>
<h2 id="Redis的过期键的删除策略"><a href="#Redis的过期键的删除策略" class="headerlink" title="Redis的过期键的删除策略"></a>Redis的过期键的删除策略</h2><p>Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间，Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。<br>过期策略通常有三种：</p>
<ul>
<li><strong>定时过期</strong>：每个设置过期时间的key都需要创建一个定时器，到<strong>过期时间就会立即清除</strong>，该策略可以立即清除过期的数据，对内存很友好，但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</li>
<li><strong>惰性过期</strong>：只有当访问一个key时，才会判断该key是否已过期，过期就清除，该策略可以最大化的节省CPU资源，却对内存非常不友好，极端情况下可能会出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li>
<li><strong>定期过期</strong>：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key，该策略是前两者的一个折中方案，通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优 的平衡效果。<br>（expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向进键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间，键空间是指该Redis集群中保存的所有键。）</li>
</ul>
<p><strong>Redis同时使用了惰性过期和定期过期两种过期策略。</strong></p>
<h1 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h1><h2 id="MySQL里有2000w数据，Redis中只有20w的数据，如何保证Redis中的数据都是热点数据"><a href="#MySQL里有2000w数据，Redis中只有20w的数据，如何保证Redis中的数据都是热点数据" class="headerlink" title="MySQL里有2000w数据，Redis中只有20w的数据，如何保证Redis中的数据都是热点数据"></a>MySQL里有2000w数据，Redis中只有20w的数据，如何保证Redis中的数据都是热点数据</h2><p>Redis内存数据集大小上升到一定大小的时候，就会施行<strong>数据淘汰策略</strong>。</p>
<h2 id="Redis的内存淘汰策略有哪些"><a href="#Redis的内存淘汰策略有哪些" class="headerlink" title="Redis的内存淘汰策略有哪些"></a>Redis的内存淘汰策略有哪些</h2><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p>
<h3 id="全局的键空间选择性移除"><a href="#全局的键空间选择性移除" class="headerlink" title="全局的键空间选择性移除"></a>全局的键空间选择性移除</h3><ul>
<li><strong>noeviction</strong>：当内存不足以容纳新写入数据时，<strong>新写入操作会报错</strong>；</li>
<li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，<strong>移除最近最少使用的key</strong>。</li>
<li><strong>allkeys-random</strong>：当内存不足以容纳新写入数据时，在键空间中，<strong>随机移除某个key</strong>。</li>
</ul>
<h3 id="设置过期时间的键空间选择性移除"><a href="#设置过期时间的键空间选择性移除" class="headerlink" title="设置过期时间的键空间选择性移除"></a>设置过期时间的键空间选择性移除</h3><ul>
<li><strong>volatile-lru</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，<strong>移除最近最少使用的key</strong>；</li>
<li><strong>volatile-random</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，<strong>随机移除某个key</strong>；</li>
<li><strong>volatile-ttl</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，<strong>有更早过期时间的key优先移除</strong>。</li>
</ul>
<h2 id="Redis主要消耗什么物理资源"><a href="#Redis主要消耗什么物理资源" class="headerlink" title="Redis主要消耗什么物理资源"></a>Redis主要消耗什么物理资源</h2><p>内存</p>
<h2 id="Redis的内存用完了会发生什么"><a href="#Redis的内存用完了会发生什么" class="headerlink" title="Redis的内存用完了会发生什么"></a>Redis的内存用完了会发生什么</h2><p>如果达到设置的上限，Redis的<strong>写命令会返回错误信息</strong>（读命令还可以正常返回），或者你可以配置内存淘汰机制，当Redis达到内存上限时会<strong>冲刷掉旧的内容</strong>。</p>
<h2 id="Redis如何做内存优化"><a href="#Redis如何做内存优化" class="headerlink" title="Redis如何做内存优化"></a>Redis如何做内存优化</h2><p>可以好好利用Hash，list，sorted set，set等集合类型数据，因为通常情况下很多小的key-value可以用更紧凑的方式存放到一起，尽可能使用散列表（hash），散列表使用的内存非常小，所以你应该尽可能地将你的数据模型抽象到一个散列表中，比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面。</p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：</p>
<ul>
<li>文件事件：服务器与客户端（或其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li>
<li>时间事件：Redis服务器中的一些操作需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li>
</ul>
<h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>Redis基于<strong>Reactor</strong>模式开发了网络事件处理器，这个处理器被称为<strong>文件事件处理器</strong>，它的组成结构为4部分：<strong>多个套接字</strong>，<strong>IO多路复用程序</strong>，<strong>文件事件分派器</strong>，<strong>事件处理器</strong>。<code>因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型</code>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7368936-fe23b577eef07aa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" srcset="/img/loading.gif" alt="img"></p>
<ul>
<li>文件事件处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答（accept），读取（read），写入（write），关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p>虽然<strong>文件事件处理器以单线程方式运行</strong>，但通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了Redis内部单线程设计的简单性。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化，按顺序执行，事务在执行过程中，不会被其他客户端发送来的命令请求所打断。<br>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<h2 id="Redis事务的概念"><a href="#Redis事务的概念" class="headerlink" title="Redis事务的概念"></a>Redis事务的概念</h2><p>Redis事务的本质是通过<strong>MULTI</strong>，<strong>EXEC</strong>，<strong>WATCH</strong>等一组命令的集合，事务支持一次执行多个命令，一个事务中所有命令都会被序列化，在事务执行过程中，会按照顺序序列化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。<br>总结说：Redis事务就是<strong>一次性</strong>、<strong>顺序性</strong>、<strong>排他性</strong>地执行一个队列中的一系列命令。</p>
<h2 id="Redis事务的三个阶段"><a href="#Redis事务的三个阶段" class="headerlink" title="Redis事务的三个阶段"></a>Redis事务的三个阶段</h2><ul>
<li>事务开始MULTI</li>
<li>命令入队</li>
<li>事务执行EXEC</li>
</ul>
<p>事务执行过程中，如果服务端收到有EXEC,DISCARD,WATCH,MULTI之外的请求，将会把请求放入队列中排队。</p>
<h2 id="Redis事务相关命令"><a href="#Redis事务相关命令" class="headerlink" title="Redis事务相关命令"></a>Redis事务相关命令</h2><p>Redis事务功能是通过<strong>MULTI</strong>,<strong>EXEC</strong>,<strong>DISCARD</strong>和<strong>WATCH</strong>四个原语实现的，Redis会将一个事务中所有命令序列化，然后按顺序执行。</p>
<ol>
<li>Redis不支持回滚，“<strong>Redis在事务失败时不进行回滚，而是继续执行余下的命令</strong>”，所以Redis的内部可以保持简单且快速；</li>
<li>如果在一个事务中的命令出现错误，那么所有的命令都不会执行；</li>
<li>如果在一个事务中出现运行错误，那么正确的命令会被执行。</li>
</ol>
<p>四个原语：</p>
<ul>
<li>WATCH命令是一个乐观锁，可以为Redis事务提供check-and-set（CAS）行为，可以<strong>监控一个或多个键，一旦其中有一个键被修改，之后的事务就都不会执行，监控一直持续到EXEC命令</strong>；</li>
<li><strong>MULTI命令用于开启一个事务</strong>，它总是返回OK，MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个<strong>队列</strong>中，当EXEC命令被调用时，所有队列中的命令才会被执行。</li>
<li><strong>EXEC：执行所有事务块内的命令</strong>，返回事务块内所有命令的返回值，按命令执行的先后顺序排列，当操作被打断时，返回空值nil。</li>
<li>通过调用<strong>DISCARD</strong>，客户端可以清空事务队列，并放弃执行事务，并且客户端会从事务状态中退出。</li>
<li>UNWATCH命令可以取消WATCH对所有key的监控。</li>
</ul>
<h2 id="事务管理（ACID）概述"><a href="#事务管理（ACID）概述" class="headerlink" title="事务管理（ACID）概述"></a>事务管理（ACID）概述</h2><p><strong>原子性（Atomicity）</strong><br>原子性是指事务是一个<strong>不可分割的工作单位</strong>，事务中操作要么都发生，要么都不发生。<br><strong>一致性（Consistency）</strong><br>事务前后数据的完整性必须保持一致。<br><strong>隔离性（Isolation）</strong><br>多个事务并发执行时，一个事务的执行不应影响其他其他事务的执行。<br><strong>持久性（Durability）</strong><br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</p>
<p>Redis的事务总是具有ACID中的<strong>一致性</strong>和<strong>隔离性</strong>，其他特性是不支持的，当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有持久性。</p>
<h2 id="Redis事务支持隔离性吗"><a href="#Redis事务支持隔离性吗" class="headerlink" title="Redis事务支持隔离性吗"></a>Redis事务支持隔离性吗</h2><p>Redis是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止，因此<strong>Redis的事务总是带有隔离性的</strong>。</p>
<h2 id="Redis事务保证原子性吗？支持回滚吗？"><a href="#Redis事务保证原子性吗？支持回滚吗？" class="headerlink" title="Redis事务保证原子性吗？支持回滚吗？"></a>Redis事务保证原子性吗？支持回滚吗？</h2><p>Redis中，单条命令是原子性执行的，但<strong>事务不保证原子性，且没有回滚</strong>，事务中任意命令执行失败，其余的命令仍会被执行。</p>
<h2 id="Redis事务其他实现"><a href="#Redis事务其他实现" class="headerlink" title="Redis事务其他实现"></a>Redis事务其他实现</h2><ul>
<li>基于Lua脚本，Redis可以保证脚本内的命令一次性，按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完。</li>
<li>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成，但这样会需要额外写代码实现，比较繁琐。</li>
</ul>
<h1 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h1><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p><img src="https://img-blog.csdnimg.cn/20200726170717531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>哨兵的介绍</strong><br><strong>sentinel</strong>，中文名是哨兵，哨兵是Redis集群机构中非常重要的一个组件，主要有以下功能：</p>
<ul>
<li><strong>集群监控</strong>：负责监控Redis中master和slave进程是否正常工作；</li>
<li><strong>消息通知</strong>：如果某个Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员；</li>
<li><strong>故障转移</strong>：如果master node挂掉了，会自动转移到slave node上；</li>
<li><strong>配置中心</strong>：如果故障转移发生了，通知client客户端新的master地址。</li>
</ul>
<p><strong>哨兵用于实现Redis集群的高可用</strong>，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p>
<ul>
<li>故障转移时，判断一个master node是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式<strong>选举</strong>的问题；</li>
<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的。</li>
</ul>
<p><strong>哨兵的核心知识</strong></p>
<ul>
<li>哨兵至少需要3个实例，来保证自己的健壮性；</li>
<li>哨兵+Redis主从的部署架构，是不保证数据零丢失的，只能保证Redis集群的高可用性；</li>
<li>对于哨兵+Redis主从这种复杂的部署架构，尽量在测试环境和生产环境都进行充足的测试和演练。</li>
</ul>
<h2 id="官方Redis-Cluster方案（服务端路由查询）"><a href="#官方Redis-Cluster方案（服务端路由查询）" class="headerlink" title="官方Redis Cluster方案（服务端路由查询）"></a>官方Redis Cluster方案（服务端路由查询）</h2><p><img src="https://img-blog.csdnimg.cn/20200726180328364.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<h3 id="Redis集群模式的工作原理能说一下吗？在集群模式下，Redis的key是如何寻址的？分布式寻址都有哪些算法？了解一致性Hash算法吗？"><a href="#Redis集群模式的工作原理能说一下吗？在集群模式下，Redis的key是如何寻址的？分布式寻址都有哪些算法？了解一致性Hash算法吗？" class="headerlink" title="Redis集群模式的工作原理能说一下吗？在集群模式下，Redis的key是如何寻址的？分布式寻址都有哪些算法？了解一致性Hash算法吗？"></a>Redis集群模式的工作原理能说一下吗？在集群模式下，Redis的key是如何寻址的？分布式寻址都有哪些算法？了解一致性Hash算法吗？</h3><p><strong>简介</strong><br>Redis Cluster是一种服务端Sharding（分片）技术，3.0版本开始正式提供，Redis Cluster并没有使用一致性hash，而是采用slot（槽）的概念，一共分为16384个槽，将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行。</p>
<p><strong>方案说明</strong></p>
<ol>
<li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽区间的数据，默认分配了16384个槽位；</li>
<li>每份数据分片会存储在多个互为主从的多节点上；</li>
<li>数据写入先写主节点，再同步到从节点；</li>
<li>同一分片多个节点间的数据不保持一致性；</li>
<li>读取数据时，当客户端操作的key没有分配在该节点上时，Redis会返回转向指令，指向正确的节点；</li>
<li>扩容时需要把旧节点的数据迁移一部分到新节点。</li>
</ol>
<p>在Redis cluster架构下，每个Redis要开放两个端口号，比如一个是6379，另一个就是加1w的端口号，如：16379,16379端口号就是用来进行节点间通信的，也就是cluster bus的东西，cluster bus的通信，用来进行故障检测、配置更新、故障转移授权，cluster bus用了另外一种二进制的协议，<code>gossip</code>协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p>
<p><strong>节点间的内部通信机制</strong><br>集群元数据的维护有两种方式：集中式、gossip协议，Redis cluster节点间采用gossip协议进行通信。</p>
<p><strong>分布式寻址算法</strong></p>
<ul>
<li>hash算法（大量缓存重建）</li>
<li>一致性hash算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li>
<li>Redis cluster的hash slot算法</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>无中心架构，支持动态扩容，对业务透明；</li>
<li>具备Sentinel的监控和自动Failover（故障转移）能力；</li>
<li>客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可；</li>
<li>高性能，客户端直连Redis服务，免去了Proxy代理的损耗。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>运维也很复杂，数据迁移需要人工干预；</li>
<li>只能使用0号数据库；</li>
<li>不支持批量操作；</li>
<li>分布式逻辑和存储模块耦合等</li>
</ul>
<h2 id="基于客户端分配"><a href="#基于客户端分配" class="headerlink" title="基于客户端分配"></a>基于客户端分配</h2><p><img src="https://img-blog.csdnimg.cn/2020072618255133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>简介</strong><br>Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法，其主要思想是<strong>采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上</strong>，Java Redis客户端驱动Jedis，支持Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool。</p>
<p><strong>优点</strong><br>非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强。</p>
<p><strong>缺点</strong></p>
<ul>
<li>由于Sharding处理放到客户端，规模进一步扩大时给运维带来挑战；</li>
<li>客户端Shardin<strong>g不支持动态增删节点</strong>，服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整，连接不能共享，当应用规模增大时，资源浪费制约优化。</li>
</ul>
<h2 id="基于代理服务器分片"><a href="#基于代理服务器分片" class="headerlink" title="基于代理服务器分片"></a>基于代理服务器分片</h2><p><img src="https://img-blog.csdnimg.cn/20200726183552539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>简介</strong><br>客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发到正确的节点，最后将结果回复给客户端。</p>
<p><strong>特征</strong></p>
<ul>
<li>透明接入，业务程序不用关心后端Redis实例，切换成本低；</li>
<li>Proxy的逻辑和存储的逻辑是隔离的；</li>
<li>代理层多了一次转发，性能有所损耗；</li>
</ul>
<h2 id="Redis主从架构"><a href="#Redis主从架构" class="headerlink" title="Redis主从架构"></a>Redis主从架构</h2><p>单机的Redis，能够承载的QPS大概就在上万到几万不等，对于缓存来说，一般都是用来支撑<strong>读高并发</strong>的，因此架构做成主从架构，一主多从，<strong>主负责写</strong>，并且将数据复制到其他的slave节点，<strong>从节点负责读</strong>，所有的读请求全部走从节点，这样也可以很轻松实现水平扩容，支撑读高并发。<br><img src="https://img-blog.csdnimg.cn/20200726184208107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</p>
<p><strong>Redis replication的核心机制</strong></p>
<ul>
<li>Redis采用异步方式复制数据到slave节点，不过从Redis2.8开始，slave node会周期性地确认自己每次复制的数据量；</li>
<li>一个master node是可以配置多个slave node的；</li>
<li>slave node也可以连接其他的slave node；</li>
<li>slave node做复制的时候，不会阻塞master node的正常工作，也不会阻塞对自己的查询操作，它会用旧的数据集来提供服务，但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li>
<li>slave node主要用来进行横向扩容，做读写分离，扩容的slave node可以提高读的吞吐量。</li>
</ul>
<p>注意：<strong>如果采用了主从架构，那么建议必须开启master node的持久化</strong>，不建议用slave node作为master node的数据热备，因为那样的话，如果你关闭了master的持久化，可能在master宕机重启的时候数据是空的，然后可能一经过复制，salve node的数据也丢了。</p>
<p>另外，master的各种备份方案也需要做，万一本地的所有文件丢失了，从备份中挑选一份RDB去恢复master，这样才能确保启动的时候是有数据的，即使采用了后续讲解的高可用机制，slave node可以自动接管master node，但也可能sentinel还没检测到master failure，master node就自动重启了，还是可能导致上面所有的slave node数据被清空。</p>
<p><strong>Redis主从复制的核心原理</strong><br>当启动一个slave node的时候，它会发送一个<code>PSYNC</code>命令给master node。</p>
<p>如果这是slave node初次连接到master node，那么会触发一次<code>full resynchronization</code>全量复制，此时master会启动一个后台线程，开始生成一份RDB快照文件；</p>
<p>同时还会将从客户端client新收到的所有写命令缓存在内存中，RDB文件生成完毕后，master会将这个RDB发送给slave，<strong>slave会先写入本地磁盘，然后再从本地磁盘加载到内存中</strong>；</p>
<p>接着master会将内存中缓存的写命令发送到slave，slave也会同步这些数据；</p>
<p>slave node如果跟master node有网络故障，断开了连接，会自动重连，连接之后master node仅会复制给slave部分缺少的数据。<br><img src="https://img-blog.csdnimg.cn/20200727083524293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>过程原理</strong></p>
<ol>
<li>当从库和主库建立master-slave关系后，从库会向主库发送SYNC命令；</li>
<li>主库接收到SYNC命令后会开始在后台保存快照（RDB持久化过程），并将期间接收到的写命令缓存起来；</li>
<li>当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis；</li>
<li>从Redis接收到后，会载入快照文件并且执行收到的缓存的命令；</li>
<li>之后，主Redis每当接收到写命令时都会将命令发送给从Redis，从而保证数据的一致性</li>
</ol>
<p><strong>缺点</strong><br>所有的slave节点数据的复制和同步都由master节点来处理，会造成master节点压力太大，可以使用主从从结构来解决。</p>
<h2 id="Redis集群的主从复制模型是怎么样的"><a href="#Redis集群的主从复制模型是怎么样的" class="headerlink" title="Redis集群的主从复制模型是怎么样的"></a>Redis集群的主从复制模型是怎么样的</h2><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品。</p>
<h2 id="生产环境中的Redis是怎么部署的"><a href="#生产环境中的Redis是怎么部署的" class="headerlink" title="生产环境中的Redis是怎么部署的"></a>生产环境中的Redis是怎么部署的</h2><p>Redis cluster，10台机器，5台机器部署了Redis主实例，另外5台机器部署了Redis的从实例，每个主实例挂了一个从实例，5个节点对外提供读写服务，每个节点的读写高峰QPS可以达到每秒5万，5台机器最多是25万读写请求/s。</p>
<p>机器是什么配置？<br>32G内存+8核CPU+1T磁盘，但是分配给Redis进程的是10G，一般线上生产环境，Redis的内存尽量不要超过10G，不然可能会有问题。</p>
<p>5台机器对外提供读写，一共有50G内存。</p>
<p>因为每个主实例都挂了一个从实例，任何一个主实例宕机，都会自动故障迁移，Redis从实例会自动变成主实例继续提供读写服务。</p>
<p>你往内存里写的是什么数据？每条数据的大小是多少？<br>商品数据，每条数据是10kb，100条数据是1mb，10万条数据就是1G，常驻内存的是200万条商品数据，占用内存是20G，仅仅不到总内存的50%，目前高峰期每秒就是3500左右的请求量。</p>
<h2 id="说说Redis哈希槽的概念"><a href="#说说Redis哈希槽的概念" class="headerlink" title="说说Redis哈希槽的概念"></a>说说Redis哈希槽的概念</h2><p>Redis集群中没有使用一致性hash，而是引入了哈希槽的概念，Redis集群有16384个哈希槽，<strong>每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</strong></p>
<h2 id="Redis集群会有写操作丢失吗？为什么？"><a href="#Redis集群会有写操作丢失吗？为什么？" class="headerlink" title="Redis集群会有写操作丢失吗？为什么？"></a>Redis集群会有写操作丢失吗？为什么？</h2><p><strong>Redis并不能保证数据的强一致性</strong>，这意味着在实际中集群在特定的条件下可能会丢失写操作。</p>
<h2 id="Redis集群之间是如何复制的"><a href="#Redis集群之间是如何复制的" class="headerlink" title="Redis集群之间是如何复制的"></a>Redis集群之间是如何复制的</h2><p>异步复制</p>
<h2 id="Redis集群最大节点个数是多少"><a href="#Redis集群最大节点个数是多少" class="headerlink" title="Redis集群最大节点个数是多少"></a>Redis集群最大节点个数是多少</h2><p>16384</p>
<h2 id="Redis集群如何选择数据库？"><a href="#Redis集群如何选择数据库？" class="headerlink" title="Redis集群如何选择数据库？"></a>Redis集群如何选择数据库？</h2><p>Redis集群目前无法做数据库选择，默认在0数据库。</p>
<h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><h2 id="Redis是单线程的，如何提高多核CPU的利用率"><a href="#Redis是单线程的，如何提高多核CPU的利用率" class="headerlink" title="Redis是单线程的，如何提高多核CPU的利用率"></a>Redis是单线程的，如何提高多核CPU的利用率</h2><p>可以在同一个服务器<strong>部署多个Redis的实例</strong>，并把他们当做不同的服务器来使用，在某些时候，无论如何一个服务器是不够的，所以如果想使用多个CPU，可以考虑一下<strong>分区</strong>（sharding）。</p>
<h2 id="为什么要做Redis分区"><a href="#为什么要做Redis分区" class="headerlink" title="为什么要做Redis分区"></a>为什么要做Redis分区</h2><p><strong>分区可以让Redis管理更大的内存</strong>，Redis将可以使用所有机器的内存，如果没有分区，最多只能使用一台机器的内存，分区使Redis的计算能力通过简单地增加计算机得到成倍提升，Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</p>
<h2 id="你知道有哪些Redis分区实现方案"><a href="#你知道有哪些Redis分区实现方案" class="headerlink" title="你知道有哪些Redis分区实现方案"></a>你知道有哪些Redis分区实现方案</h2><ul>
<li><strong>客户端分区</strong>：就是<strong>在客户端已经决定数据会被存储到哪个Redis节点或者从哪个Redis节点读取</strong>，大多数客户端已经实现了客户端分区；</li>
<li><strong>代理分区</strong>：意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据，代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端，Redis和Memcached的一种代理实现就是Twemproxy；</li>
<li><strong>查询路由</strong>（Query routing）：客户端随机请求任意一个Redis实例，然后由Redis将请求转发给正确的Redis节点，Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个Redis节点转发到另一个Redis节点，而是在客户端的帮助下直接重定向到正确的Redis节点。</li>
</ul>
<h2 id="Redis分区有什么缺点"><a href="#Redis分区有什么缺点" class="headerlink" title="Redis分区有什么缺点"></a>Redis分区有什么缺点</h2><ul>
<li>涉及多个key的操作通常不会被支持，例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例；</li>
<li>同时操作多个key，则不能使用Redis事务；</li>
<li>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集；</li>
<li>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB/AOF文件；</li>
<li>分区时动态扩容或缩容可能非常复杂，Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。</li>
</ul>
<h1 id="分布式问题"><a href="#分布式问题" class="headerlink" title="分布式问题"></a>分布式问题</h1><h2 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h2><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系，Redis中可以使用<code>SETNX</code>【SET if NOT EXISTS】命令实现分布式锁。</p>
<p>当且仅当key不存在，将key的值设为value，若给定的key已经存在，则SETNX不做任何动作。</p>
<p>使用SETNX完成同步锁的流程及事项如下：</p>
<ul>
<li>使用SETNX命令获取锁，若返回0（key已经存在，锁已存在）则获取失败，反之获取成功。</li>
<li>为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个合理的过期时间。</li>
</ul>
<ul>
<li>释放锁，使用DEL命令将锁数据删除。</li>
</ul>
<h2 id="如何解决Redis的并发竞争Key问题"><a href="#如何解决Redis的并发竞争Key问题" class="headerlink" title="如何解决Redis的并发竞争Key问题"></a>如何解决Redis的并发竞争Key问题</h2><p>所谓Redis的并发竞争key的问题也就是多个系统同时对一个key进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p>
<p>推荐一种方案：分布式锁（Zookeeper和Redis都可以实现分布式锁）</p>
<h2 id="分布式Redis是前期做还是后期规模上来了再做好？为什么？"><a href="#分布式Redis是前期做还是后期规模上来了再做好？为什么？" class="headerlink" title="分布式Redis是前期做还是后期规模上来了再做好？为什么？"></a>分布式Redis是前期做还是后期规模上来了再做好？为什么？</h2><p>既然Redis是如此的轻量，为防止以后的扩容，最好的办法就是一开始就启动较多实例，即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p>
<p>一开始就多设置几个Redis实例，例如32或64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看这点牺牲是值得的。</p>
<p>当你的数据不断增长，需要更多的Redis服务器时，你需要做的仅仅是将Redis实例从一台服务器迁移到另外一台服务器而已，一旦你添加了另外一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。</p>
<h2 id="什么是RedLock"><a href="#什么是RedLock" class="headerlink" title="什么是RedLock"></a>什么是RedLock</h2><p>Redis官方提出的一种权威的基于Redis实现分布式锁的方式名叫Redlock，此种方式比原先的单节点的方式更安全，它可以保证以下特性：</p>
<ul>
<li>安全特性：互斥访问，即永远只有一个client能拿到锁；</li>
<li>避免死锁：最终client都可以拿到锁，不会出现死锁的情况，即使原本锁住某资源的client崩溃了或者出现了网络分区；</li>
<li>容错性：只要大部分Redis节点存活就可以正常提供服务。</li>
</ul>
<h1 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h1><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指缓存同一时间大面积的失效，所以后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p><strong>解决方案</strong></p>
<ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生；</li>
<li>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队；</li>
<li>给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存。</li>
</ol>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存在某个时间点过期的时候，恰好在这个时间点对这个 key 有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮。</p>
<p><strong>解决方案</strong></p>
<ol>
<li>设置热点数据永不过期；</li>
<li>加互斥锁</li>
</ol>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p><strong>解决方案</strong></p>
<ol>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30s，这样可以防止攻击用户反复用同一个id暴力攻击；</li>
<li>采用<strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</li>
</ol>
<h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统，这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。</p>
<p><strong>解决方案</strong></p>
<ol>
<li>直接写个缓存刷新页面，上线时手动操作一下；</li>
<li>数据量不大时，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存。</li>
</ol>
<h2 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h2><p>当访问量剧增，服务出现问题（如：响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务，系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p><strong>缓存降级的最终目的是保证核心服务可用</strong>，即使是有损的，而且有些服务是无法降级的（比如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以弃卒保帅，从而梳理出哪些必须誓死保护，哪些可降级；</p>
<p>服务降级的目的是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题，因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是<strong>Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</strong></p>
<h2 id="热点数据和冷数据"><a href="#热点数据和冷数据" class="headerlink" title="热点数据和冷数据"></a>热点数据和冷数据</h2><p>热点数据，缓存才有价值。</p>
<p>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大，频繁修改的数据，看情况考虑使用缓存。</p>
<p>对于热点数据，比如我们的某IM产品，生日祝福模块等，缓存以后可能读取数十万次。</p>
<h2 id="缓存热点key"><a href="#缓存热点key" class="headerlink" title="缓存热点key"></a>缓存热点key</h2><p>缓存中的一个key（比如一个促销商品），在某个时间点过期的时候，恰好在这个时间点对这个key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<p><strong>解决方案</strong><br>对缓存查询加锁，如果key不存在就加锁，然后从DB中查询数据并加入缓存，然后解锁，如果其他进程发现有锁就等待，然后等解锁后返回数据或者进入DB查询。</p>
<h1 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h1><h2 id="Redis支持的Java客户端都有哪些？官方推荐用哪个？"><a href="#Redis支持的Java客户端都有哪些？官方推荐用哪个？" class="headerlink" title="Redis支持的Java客户端都有哪些？官方推荐用哪个？"></a>Redis支持的Java客户端都有哪些？官方推荐用哪个？</h2><p>Redisson、Jedis，官方推荐使用Redisson。</p>
<h2 id="Redis和Redisson有什么关系？"><a href="#Redis和Redisson有什么关系？" class="headerlink" title="Redis和Redisson有什么关系？"></a>Redis和Redisson有什么关系？</h2><p>Redisson是一个高级的分布式协调Redis客户端，能够帮助用户在分布式环境中轻松实现一些Java的对象。</p>
<h2 id="Jedis和Redisson对比有什么优缺点？"><a href="#Jedis和Redisson对比有什么优缺点？" class="headerlink" title="Jedis和Redisson对比有什么优缺点？"></a>Jedis和Redisson对比有什么优缺点？</h2><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序，事务，管道，分区等Redis特性，Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="Redis与Memcached的区别"><a href="#Redis与Memcached的区别" class="headerlink" title="Redis与Memcached的区别"></a>Redis与Memcached的区别</h2><ul>
<li>Memcached所有的值均是简单的字符串，Redis作为其替代者，支持更为丰富的数据类型；</li>
<li>Redis的速度比Memcached快很多；</li>
<li>Redis可以持久化其数据</li>
</ul>
<h2 id="如何保证缓存与数据库双写时的数据一致性？"><a href="#如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性？"></a>如何保证缓存与数据库双写时的数据一致性？</h2><p>将读请求和写请求串行化，串到一个内存队列中，这样就能保证一定不会出现不一致的情况，串行化之后会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求；</p>
<p>还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是先更新数据库，然后将旧缓存失效，读取数据的时候，如果缓存不存在，则读取数据库再写缓存。</p>
<h2 id="Redis常见性能问题和解决方案？"><a href="#Redis常见性能问题和解决方案？" class="headerlink" title="Redis常见性能问题和解决方案？"></a>Redis常见性能问题和解决方案？</h2><ol>
<li>Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化；</li>
<li>如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次；</li>
<li>为了主从复制的速度和连接的稳定性，Slave和Master最好是在同一局域网内；</li>
<li>尽量避免在压力较大的主库上增加从库；</li>
<li>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占用大量的CPU和内存资源，导致服务过载，会出现短暂服务暂停现象；</li>
<li>为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。</li>
</ol>
<h2 id="Redis官方为什么不提供Windows版本"><a href="#Redis官方为什么不提供Windows版本" class="headerlink" title="Redis官方为什么不提供Windows版本"></a>Redis官方为什么不提供Windows版本</h2><p>因为目前Linux版本已经相当稳定，而且用户量很大，无须开发windows版本，反而会带来兼容性问题。</p>
<h2 id="一个字符串类型的值能存储最大容量是多少"><a href="#一个字符串类型的值能存储最大容量是多少" class="headerlink" title="一个字符串类型的值能存储最大容量是多少"></a>一个字符串类型的值能存储最大容量是多少</h2><p>512M</p>
<h2 id="Redis如何做大量数据插入？"><a href="#Redis如何做大量数据插入？" class="headerlink" title="Redis如何做大量数据插入？"></a>Redis如何做大量数据插入？</h2><p>Redis2.6开始redis-cli支持一种新的被称为之<code>pipe mode</code>的新模式用于执行大量数据插入工作。</p>
<h2 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</h2><p>使用<code>keys</code>指令可以扫出指定模式的key列表。<br>对方接着追问：如果这个Redis正在给线上的业务提供服务，那使用keys指令会有什么问题？<br>这个时候你要回答Redis的一个关键特性：<strong>Redis是单线程的，keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复</strong>，这个时候可以使用<code>scan</code>指令，<strong>scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，需要在客户端做一次去重操作</strong>，整体花费的时间比直接用keys指令长。</p>
<h2 id="使用Redis做过异步队列吗？是如何实现的"><a href="#使用Redis做过异步队列吗？是如何实现的" class="headerlink" title="使用Redis做过异步队列吗？是如何实现的"></a>使用Redis做过异步队列吗？是如何实现的</h2><p>使用<strong>list</strong>类型保存数据消息，rpush生产消息，lpop消费消息，当lpop没有消息时，可以sleep一段时间，然后再检查有没有消息，如果不想sleep的话，可以使用blpop，在没有消息的时候，会一直阻塞，直到消息的到来，<strong>Redis可以通过发布/订阅模式来实现一个生产者多个消费者</strong>。</p>
<h2 id="Redis如何实现延时队列"><a href="#Redis如何实现延时队列" class="headerlink" title="Redis如何实现延时队列"></a>Redis如何实现延时队列</h2><p>使用Sorted Set，使用时间戳做score，消息内容作为key，调用zadd来生产消息，消费者使用zrangbyscore获取n秒之前的数据做轮询处理。</p>
<h2 id="Redis回收进程如何工作"><a href="#Redis回收进程如何工作" class="headerlink" title="Redis回收进程如何工作"></a>Redis回收进程如何工作</h2><ol>
<li>一个客户端运行了新的命令，添加了新的数据；</li>
<li>Redis检查内存使用情况，如果大于maxmemory的限制，则根据设定好的策略进行回收；</li>
<li>一个新的命令被执行，等等；</li>
<li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收到边界以下。</li>
</ol>
<p>如果一个命令的结果导致大量内存被使用，不用多久内存限制就会被这个内存使用量超越。</p>
<h2 id="Redis回收使用的是什么算法"><a href="#Redis回收使用的是什么算法" class="headerlink" title="Redis回收使用的是什么算法"></a>Redis回收使用的是什么算法</h2><p>LRU算法。 </p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
                    
                      <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/">Redis</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Redis/">Redis</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/07/27/Netty%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Netty面试题汇总</span>
                        <span class="visible-mobile">前の記事</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/07/19/Spring-Cloud-%E5%BC%80%E7%AF%87/">
                        <span class="hidden-mobile">Spring Cloud 开篇</span>
                        <span class="visible-mobile">次の記事</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <script defer src="https://utteranc.es/client.js"
          repo="gavin-yyj/commit-utterance"
          issue-term="pathname"
  
          theme="github-light"
          crossorigin="anonymous"
  >
  </script>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;ディレクトリ</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">検索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">キーワード</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Redis面试题汇总&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
