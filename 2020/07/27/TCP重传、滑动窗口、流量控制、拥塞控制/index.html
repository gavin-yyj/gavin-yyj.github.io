<!DOCTYPE html>
<html lang="zh-CH">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="光说不做假把式">
  <meta name="author" content="杨玉杰">
  <meta name="keywords" content="">
  <title>TCP重传、滑动窗口、流量控制、拥塞控制 - 杨玉杰|个人博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/agate.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>杨玉杰|个人博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友情链接
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bgi.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-07-27 22:15">
      July 27, 2020 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      56
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>相信大家都知道 TCP 是一个可靠传输的协议，那它是如何保证可靠的呢？</p>
<p>为了实现可靠性传输，需要考虑很多事情，例如数据的破坏、丢包、重复以及分片顺序混乱等问题。如不能解决这些问题，也就无从谈起可靠传输。</p>
<p>TCP 是通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输的。</p>
<p>今天，将重点介绍 TCP 的<strong>重传机制</strong>、<strong>滑动窗口</strong>、<strong>流量控制</strong>、<strong>拥塞控制</strong>。<br><img src="https://img-blog.csdnimg.cn/20200727151426832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<h1 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h1><p>TCP实现可靠传输的方式之一是通过序列号和确认应答。</p>
<p>在TCP中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。<br><img src="https://img-blog.csdnimg.cn/20200727151811427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>如果数据在传输过程中丢失了？TCP针对数据包丢失的情况，会用重传机制来解决。</p>
<p>常见的重传机制有：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
<li>SACK</li>
<li>D-SACK</li>
</ul>
<h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的ACK确认应答报文，就会重发该数据。</p>
<p>TCP会在以下两种情况下发生超时重传：</p>
<ul>
<li>数据包丢失</li>
<li>确认应答丢失</li>
</ul>
<p><strong>超时时间应该设置为多少？</strong><br><img src="https://img-blog.csdnimg.cn/20200727152310356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>RTT就是数据从网络一端传送到另一端所需要的的时间，也就是包的往返时间。</p>
<p>超时重传时间是以<strong>RTO</strong>（Retransmission Timeout）表示，其值应该略大于报文往返RTT的值。</p>
<p>如果超时重发的数据再次超时，又需要重传的时候，TCP的策略是<strong>超时间隔加倍</strong>。</p>
<p>超时触发重传存在的问题是，超时周期可能相对较长，可以利用【快速重传】机制来解决超时重发的时间等待。</p>
<h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>TCP还有另外一种快速重传机制，<strong>它不以时间为驱动，而是以数据驱动重传</strong>。</p>
<p>工作流程：<br><img src="https://img-blog.csdnimg.cn/20200727153101527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在上图，发送方发出了1、2、3、4、5份数据：</p>
<ul>
<li>第一份seq1线送到了，于是ack返回2；</li>
<li>seq2因为某些原因没收到，seq3到达了，ack还是返回2；</li>
<li>后面的seq4和seq5都到了，但是ack还是返回2，因为seq2还是没有收到；</li>
<li>发送端收到了三个ack = 2的确认，知道了seq2还没有收到，就会在定时器过期之前，重传丢失的seq2；</li>
<li>最后，接收端收到了seq2，此时因为seq3，seq4，seq5都收到了，于是ack返回6。</li>
</ul>
<p>快速重传的工作方式是当收到三个相同的ack报文时，会在定时器过期之前，重传丢失的报文段。</p>
<p>快速重传机制只解决了超时时间的问题，但是重传的时候不知道该重传哪些TCP报文，于是就有了SACK方法。</p>
<h2 id="SACK方法"><a href="#SACK方法" class="headerlink" title="SACK方法"></a>SACK方法</h2><p>SACK（Selective Acknowledgement，选择性确认），这种方式需要在TCP头部【选项】字段里加一个SACK的东西，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没有收到，知道了这些信息，就可以只重传丢失的数据。</p>
<p>如下图，发送方收到了三次同样的ack确认报文，于是就会触发快速重发机制，通过SACK信息发现只有200~299这段数据丢失，则重发时就只选择这个TCP段进行重发。<br><img src="https://img-blog.csdnimg.cn/20200727154904354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>如果要支持SACK，必须双方都要支持。</p>
<h2 id="Duplicate-SACK"><a href="#Duplicate-SACK" class="headerlink" title="Duplicate SACK"></a>Duplicate SACK</h2><p>Duplicate SACK又称D-SACK，其主要使用了SACK来告诉发送方有哪些数据被重复接收了。</p>
<p>作用一：解决ack丢包问题<br><img src="https://img-blog.csdnimg.cn/20200727155659840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<ul>
<li>接收方发给发送方的两个ack确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000~3499）；</li>
<li>于是接收方发现数据是重复的，于是回了一个SACK = 3000~3500，告诉发送方3000-3500的数据早就被接收了，因为ack都到了4000，已经意味着4000之前的所有数据都已收到，所以这个SACK就代表着D-SACK；</li>
<li>这样发送方就知道数据并没有丢，是接收方的ack确认报文丢失了。</li>
</ul>
<p>作用二：解决网络延时问题</p>
<p><img src="https://img-blog.csdnimg.cn/20200727160216844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<ul>
<li>数据包（1000~1499）被网络延迟了，导致发送方没有收到ack1500的确认报文；</li>
<li>而后面报文到达的三个相同的ack确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了接收方。</li>
<li>所以<strong>接收方回了一个SACK=1000~1500，因为ack已经到了3000，所以这个SACK是D-SACK，表示收到了重复的包。</strong></li>
<li>这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的ack包丢了，而是因为网络延迟了。</li>
</ul>
<p>可见，D-SACK有这么几个好处：</p>
<ol>
<li>可以让发送方知道，是发出去的包丢了，还是接收方回应的ack包丢了；</li>
<li>可以知道是不是发送方的数据包被网络延迟了；</li>
<li>可以知道网络中是不是把发送方的数据包给复制了。</li>
</ol>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>TCP是每次发送一个数据都要进行一次确认应答，当上一个数据包收到应答了，再发送下一个。<br><img src="https://img-blog.csdnimg.cn/20200727161415343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>为了解决通信效率低的问题，TCP引入了窗口这个概念，即使在往返时间较长的情况下，它也不会降低网络通信的效率。</p>
<p>有了这个窗口，就可以指定窗口大小，窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值。</strong></p>
<p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据，如果按期收到确认应答，此时数据就可以从缓存区清除。</p>
<p>假设窗口大小为3个TCP段，那么发送方就可以连续发送3个TCP段，并且中途若有ack丢失，可以通过下一个确认应答进行确认。如下图：<br><img src="https://img-blog.csdnimg.cn/20200727162157108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>图中的ack600确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了ack700确认应答，就意味着700之前的所有数据接收方都收到了，这个模式就叫<strong>累计确认</strong>或者<strong>累计应答</strong>。</p>
<blockquote>
<p>Q：窗口大小由哪一方决定？</p>
</blockquote>
<p>TCP头里有一个字段叫<code>Window</code>，也就是窗口大小。<br><strong>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据，于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</strong></p>
<p>所以，通常窗口的大小是由接收方来决定的。</p>
<p>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p>
<blockquote>
<p>发送方的滑动窗口？</p>
</blockquote>
<p>我们先来看看发送方的窗口，下图就是发送方缓存的数据，根据处理的情况分为四个部分，其中深蓝色方框是发送窗口，紫色方框是可用窗口：<br><img src="https://img-blog.csdnimg.cn/20200727190855213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<ul>
<li>#1 是已发送并收到ack确认的数据：1~31字节</li>
<li>#2 是已发送但未收到ack确认的数据：32~45字节</li>
<li>#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节</li>
<li>#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后</li>
</ul>
<p>在下图，当发送方把数据全部都一下发送出去后，可用窗口的大小就为0了，表明可用窗口耗尽，在没收到ack确认之前是无法继续发送数据了。<br><img src="https://img-blog.csdnimg.cn/20200727191439674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在下图，当收到之前发送的数据32~36字节的ack确认应答后，如果发送窗口的大小没有变化，则滑动窗口往右移动5个字节，因为有5个字节的数据被应答确认，接下来52-56字节又变成可用窗口，那么后续也就可以发送52-56这5个字节的数据了。<br><img src="https://img-blog.csdnimg.cn/20200727191747768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<blockquote>
<p>程序是如何表示发送方的四个部分的呢？</p>
</blockquote>
<p>TCP滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节，其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。<br><img src="https://img-blog.csdnimg.cn/20200727192019282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<ul>
<li>SND.WND：表示发送窗口的大小（大小是由接收方指定的）；</li>
<li>SDN.UNA：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是#2的第一个字节。</li>
<li>SND.NXT：也是一个绝对指针，它指向的是未发送但总大小在接受方处理范围内的第一个自己的序列号，也就是#3的第一个字节；</li>
<li>指向#4的第一个字节是个相对指针，需要SND.UNA指针加上SND.WND大小的偏移量，就可以指向#4的第一个字节了。</li>
</ul>
<p>可用窗口大小 = SND.WND - (SND.NXT - SND.UNA)</p>
<blockquote>
<p>接收方的滑动窗口</p>
</blockquote>
<p>接收窗口相对简单一些，根据处理的情况划分为三个部分：</p>
<ul>
<li>#1 + #2 是已成功接收并确认的数据（等待应用进程读取）；</li>
<li>#3 是未收到数据但可以接收的数据；</li>
<li>#4 未收到数据并不可以接收的数据；</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2020072719424445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>其中三个接收部分，使用两个指针进行划分：</p>
<ul>
<li>RCV.WND：表示接收窗口的大小，它会通告给发送方；</li>
<li>RCV.NXT：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是#3的第一个字节；</li>
<li>指向#4的第一个字节是相对指针，它需要RCV.NXT指针加上RCV.WND大小的偏移量，就可以指向#4的第一个字节了。</li>
</ul>
<blockquote>
<p>接收窗口和发送窗口的大小是相等的吗？</p>
</blockquote>
<p>并不完全相等，接收窗口的大小是约等于发送窗口的大小的。<br>因为滑动窗口并不是一成不变的，比如：当接收方的应用程序读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来，那么新的接收窗口大小，是通过TCP保温的windows字段来告诉发送方，那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。</p>
<h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。</p>
<p>如果一直无脑地发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量无端的浪费。</p>
<p>为了解决这种现象发生，TCP提供了一种机制可以让发送方根据接收方的实际接收能力控制发送的数据量，这就是所谓的流量控制。</p>
<p>举个例子，假设以下场景：</p>
<ul>
<li>客户端是接收方，服务端是发送方；</li>
<li>假设接收窗口和发送窗口相同，都为200；</li>
<li>假设两个设备在整个传输过程中都保持相同的窗口大小，不受外界影响。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200727202125810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>根据上图的流量控制，说明下每个过程：</p>
<ol>
<li>客户端向服务端发送请求数据报文；</li>
<li>服务端收到请求报文后，发送确认报文和80字节的数据，于是可用窗口Usable减少为120字节，同时SND.NXT指针也向右偏移80字节后，指向321，这意味着下次发送数据的时候，序列号为321；</li>
<li>客户端收到80字节数据后，于是接收窗口往右移动80字节，RCV.NXT也就执行321，这意味着客户端期望的下一个报文的序列号是321，接着发送确认报文给服务端。</li>
<li>服务端再次发送了120字节数据，于是可用窗口耗尽为0，服务端无法再继续发送数据；</li>
<li>客户端收到120字节的数据后，于是接收窗口往右移动120字节，RCV.NXT也就指向441，接着发送确认报文给服务端；</li>
<li>服务端收到对80字节数据的确认报文后，SND.UNA指针往右偏移后指向321，于是可用窗口Usable增加到80；</li>
<li>服务端收到120字节数据的确认报文后，SND.UNA指针往右偏移后指向441，于是可用窗口Usable增加到200；</li>
<li>服务端可以继续发送了，于是发送了160字节的数据后，SND.NXT指向601，于是可用窗口Usable减少到40；</li>
<li>客户端收到160字节后，接收窗口往右移动了160字节，RCV.NXT也就是指向了601，接着发送确认报文给服务端；</li>
<li>服务端收到160字节数据的确认报文后，发送窗口往右移动了160字节，于是SND.UNAZ指针偏移了160后指向601，可用窗口Usable也就增大至200。 </li>
</ol>
<h2 id="操作系统缓冲区和滑动窗口的关系"><a href="#操作系统缓冲区和滑动窗口的关系" class="headerlink" title="操作系统缓冲区和滑动窗口的关系"></a>操作系统缓冲区和滑动窗口的关系</h2><p>前面的流量控制例子，我们假定了发送窗口和接收窗口是不变的，但是实际上，发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会被<strong>操作系统调整</strong>。</p>
<p>当应用进程没办法及时读取缓冲区的内容时，也会对我们的缓冲区造成影响。</p>
<p>如果发生了先减少缓存，再收缩窗口，就会出现丢包的现象，为了防止这种情况发生，TCP规定不允许同时减少缓存又收缩窗口，而是采用先收缩窗口，过段时间再减少缓存，这样可以避免丢包情况。</p>
<h2 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h2><p>TCP通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。</p>
<p>如果窗口大小为0时，就会阻止发送方给接收方传递数据，直到窗口变为非0为止，这就是窗口关闭。</p>
<blockquote>
<p>窗口关闭潜在的危险</p>
</blockquote>
<p>接收方向发送方通告窗口大小时，是通过ack报文来通告的，那么当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非0的ack报文，如果这个通告窗口的ack报文在网络中丢失了，就会导致发送方一直等待接收方的非0窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程就会造成死锁。</p>
<blockquote>
<p>TCP是如何解决窗口关闭时潜在的死锁现象的？</p>
</blockquote>
<p>为了解决这个问题，TCP为每个连接设有一个持续计时器，只要TCP连接一方收到对方的零窗口通知，就启动<strong>持续计时器</strong>。</p>
<p>如果持续计时器超时，就会发送窗口探测报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p>
<ul>
<li>如果接收窗口仍然为0，那么收到这个报文的一方就会重新启动持续计时器；</li>
<li>如果接收窗口不是0，那么死锁的局面就可以被打破了。</li>
</ul>
<p>窗口探测的次数一般为3次，每次大约30~60秒，如果3次过后接收窗口还是0的话，有的TCP实现就会发RST报文来中断连接。</p>
<h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><blockquote>
<p>为什么要有拥塞控制？</p>
</blockquote>
<p>前面的流量控制是避免发送方的数据填满接收方的缓存，但是并不知道网络中发生了什么。</p>
<p>一般来说，计算机网络都处于一个共享的环境，因此也有可能会因为其他主机之间的通信使得网络拥塞；</p>
<p>在网络出现拥堵时，如果继续发送大量数据包，可能会发导致数据包延时，丢失等，这次TCP就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包。</p>
<p>所以，TCP不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发生拥塞时，TCP会自我牺牲，降低发送的数据量。</p>
<p>于是就有了拥塞控制，其目的就是<strong>避免发送方的数据填满整个网络</strong>。</p>
<p>为了在发送方调节所要发送数据的量，定义了一个叫做<strong>拥塞窗口</strong>的概念。</p>
<blockquote>
<p>什么是拥塞窗口？和发送窗口有什么关系？</p>
</blockquote>
<p>拥塞窗口（cwnd）是发送方维护的一个状态变量，它会根据网络的拥塞程度动态变化。</p>
<p>前面提到过发送窗口swnd和接收窗口rwnd是约等于关系，那么由于引入拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd,rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p>
<p>拥塞窗口变化规则：</p>
<ul>
<li>只要网络中没有出现拥塞，cwnd就会增大；</li>
<li>如果网络中出现了拥塞，cwnd就会减少；</li>
</ul>
<blockquote>
<p>如何知道当前网络是否出现了拥塞？</p>
</blockquote>
<p>其实只要发送方没有在规定时间内接收到ack应答报文，也就发生了超时重传，就会认为网络出现了拥塞。</p>
<blockquote>
<p>拥塞控制有哪些控制算法？</p>
</blockquote>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>
<h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><p>TCP在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点点提高发送数据包的数量，也就是当发送方每收到一个ack，就拥塞窗口cwnd的大小就会加1；<br>这里假定拥塞窗口 cwnd 和发送窗口 swnd 相等，下面举个栗子：</p>
<ul>
<li>连接建立完成后，一开始初始化 cwnd = 1，表示可以传一个 MSS 大小的数据。</li>
<li>当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个</li>
<li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个</li>
<li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4个，所以这一次能够发送 8 个。<br><img src="https://img-blog.csdnimg.cn/20200727213058407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>可以看出，慢启动算法发包的个数是指数增长。</li>
</ul>
<blockquote>
<p>慢启动涨到什么时候是个头呢？</p>
</blockquote>
<p>有一个叫慢启动门限  <strong>ssthresh</strong> （slow start threshold）状态变量。</p>
<ul>
<li>当 cwnd &lt; ssthresh 时，使用慢启动算法。</li>
<li>当 cwnd &gt;= ssthresh 时，就会使用「拥塞避免算法」。</li>
</ul>
<h2 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h2><p>一般来说 ssthresh 的大小是 65535 字节。</p>
<p>那么进入拥塞避免算法后，它的规则是：每当收到一个 ACK 时，cwnd 增加 1/cwnd。</p>
<p>接上前面的慢启动的栗子，现假定 ssthresh 为 8：</p>
<p>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 MSS 大小的数据，变成了线性增长。<br><img src="https://img-blog.csdnimg.cn/20200727213259148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。</p>
<p>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p>
<p>当触发了重传机制，也就进入了「拥塞发生算法」。</p>
<h2 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h2><p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p>
<ul>
<li>超时重传</li>
<li><strong>快速重传</strong></li>
</ul>
<p>这两种使用的拥塞发送算法是不同的，主要分析快重传算法。</p>
<p>当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</p>
<p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：</p>
<ul>
<li>cwnd = cwnd/2 ，也就是设置为原来的一半;</li>
<li>ssthresh = cwnd;</li>
<li>进入快速恢复算法</li>
</ul>
<h2 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h2><p>进入快速恢复算法如下：</p>
<ul>
<li>拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）</li>
<li>重传丢失的数据包</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1</li>
<li>如果收到新数据的 ACK 后，设置 cwnd 为 ssthresh，接着就进入了拥塞避免算法</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200727213717914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/07/27/Spring-Cloud%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/">
                        <span class="hidden-mobile">Spring Cloud面试题汇总</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <script defer src="https://utteranc.es/client.js"
          repo="gavin-yyj/commit-utterance"
          issue-term="pathname"
  
          theme="github-light"
          crossorigin="anonymous"
  >
  </script>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "TCP重传、滑动窗口、流量控制、拥塞控制&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
