<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>shiro系列-2.核心</title>
    <link href="/2020/06/23/shiro%E7%B3%BB%E5%88%97-2-%E6%A0%B8%E5%BF%83/"/>
    <url>/2020/06/23/shiro%E7%B3%BB%E5%88%97-2-%E6%A0%B8%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1、认证"><a href="#1、认证" class="headerlink" title="1、认证"></a>1、认证</h1><p>认证（Authentication）：身份验证的过程–也就是证明一个用户的真实身份。为了证明用户的身份，需要提供系统可以理解和相信的身份信息【principals】和证据【credentials】。</p><ul><li>Principals（身份）是Subject的“标识属性”，可以是任何与Subject相关的标识，通常用用户名或者邮件地址来作为标识。</li><li>Credentials（证明）：通常是只有Subject直到的机密内容，用来证明他们真正拥有所需的身份，一般有密码，指纹，X.509证书等。</li></ul><p>最常见的身份/证明是用户名和密码，用户名是所需的身份说明，密码是证明身份的证据，如果一个提交的密码和系统要求的一致，程序才认为该用户身份正确。</p><h2 id="验证Subjects"><a href="#验证Subjects" class="headerlink" title="验证Subjects"></a>验证Subjects</h2><p>Subject验证的过程可以分为下面三步：</p><ol><li>收集Subject提交的身份和证明；</li><li>向Authentication提交身份和证明；</li><li>如果提交的内容正确，允许访问，否则重新尝试验证或阻止访问；</li></ol><h3 id="第一步：收集用户身份和证明"><a href="#第一步：收集用户身份和证明" class="headerlink" title="第一步：收集用户身份和证明"></a>第一步：收集用户身份和证明</h3><div class="hljs"><pre><code class="hljs java">UssernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(username,password);</code></pre></div><p>Shiro并不关心我们从哪里获得username和password，我们可以根据自己的需求来构造和引用AuthenticationToken实例。</p><h3 id="第二步：提交身份和证明"><a href="#第二步：提交身份和证明" class="headerlink" title="第二步：提交身份和证明"></a>第二步：提交身份和证明</h3><p>当身份和证明被收集并实例化为一个AuthenticationToken（认证令牌）后，我们需要向Shiro提交令牌以执行真正的验证尝试：</p><div class="hljs"><pre><code class="hljs java">Subject currentUser = SecurityUtils.getSubject();currentUser.login(token);</code></pre></div><p>在获取当前执行的Subject后，我们执行一个单独的login命令，将之前创建的AuthenticationToken实例传给它。<br>调用login方法就是为了对用户的身份进行校验。</p><h3 id="第三步：处理成功或失败"><a href="#第三步：处理成功或失败" class="headerlink" title="第三步：处理成功或失败"></a>第三步：处理成功或失败</h3><p>当login方法没有返回信息时说明验证通过，程序可以继续运行，此时执行前面代码里的currentUser.isAuthenticated()将返回true。<br>如果校验失败，则Shiro将会捕捉异常，程序员根据异常信息就可以判断为何校验失败。<br>如果原有的异常不能满足我们的需求，可以自定义AuthenticationExceptions来表示特定的失败场景。</p><h2 id="Remembered-vs-Authenticated"><a href="#Remembered-vs-Authenticated" class="headerlink" title="Remembered vs. Authenticated"></a>Remembered vs. Authenticated</h2><p>Shiro支持在登录过程中执行“remember me”，记住，一个已记住的Subject（remembered Subject）和一个正常通过认证的Subject（authenticated Subject）在Shiro中是完全不同的。<br>已记住（Remembered）和已验证（Authenticated）是互斥的，已记住是说它的身份被先前的认证过程记住，并存在与先前的session中，已验证的Subject是成功验证后存在于当前session中。</p><h2 id="Logging-Out-退出登录"><a href="#Logging-Out-退出登录" class="headerlink" title="Logging Out 退出登录"></a>Logging Out 退出登录</h2><p>与验证相对的是释放所有已知的身份信息，当Subject与程序不再交互了，可以调用Subject.logout（）来丢掉所有的身份信息。</p><div class="hljs"><pre><code class="hljs java">currentUser.logout();<span class="hljs-comment">//清除验证信息，使session失效</span></code></pre></div><p>当调用logout，任何现存的session将变得不可用并且所有的身份信息将消失。<br>注意：因为在web程序中记住身份信息往往使用cookies，而cookies只能在Response提交时才能被删除，所以强烈要求在为最终用户调用subject.logout()之后立即将用户引到到一个新页面，确保任何与安全相关的cookies如期删除。</p><h2 id="认证序列"><a href="#认证序列" class="headerlink" title="认证序列"></a>认证序列</h2><p>现在我们看看当一个验证发生时，Shiro内部发生了什么？<br><strong>第1步</strong>：程序代码调用Subject.login方法，向AuthenticationToken（认证令牌）实例的构造函数传递用户的身份和证明；<br><strong>第2步</strong>：Subject实例，通常是一个<strong>DelegatingSubject</strong>（或其子类）通过调用<code>SecurityManager.login(token)</code>将这个令牌转交给程序的SecurityManager。<br><strong>第3步</strong>：SecurityManager，基本的“安全伞”组件，得到令牌并通过调用 authenticator.authenticate(token)简单地将其转交给它内部的 Authenticator 实例，大部分情况下是一个 <strong>ModularRealmAuthenticator</strong> 实例，用来支持在验证过程中协调一个或多个Realm实例。<br><strong>第4步</strong>：如果程序配置了多个Realm，ModularRealmAuthenticator实例将使用其配置的AuthenticationStrategy开始一个或多个Realm身份验证的尝试。在Realm被验证调用的整个过程中，AuthenticationStrategy被调用用来回应每个Realm的结果。<br>注意：如果只有一个Realm被配置，则不需要AuthenticationStrategy。<br><strong>第5步</strong>：每一个配置的Realm都被检验看其是否支持提交的AuthenticationToken，如果支持，则该Realm的<code>getAuthenticationInfo</code>方法随着提交的令牌被调用，getAuthenticationInfo方法为特定的Realm提供一次有效的独立的验证尝试。</p><h3 id="Authenticator"><a href="#Authenticator" class="headerlink" title="Authenticator"></a>Authenticator</h3><p>如果希望用自定义的Authenticator实现配置SecurityManager，可以在shiro.ini中做这件事：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span>...<span class="hljs-attr">authenticator</span> = com.foo.bar.CustomAuthenticator<span class="hljs-attr">securityManager.authenticator</span> = <span class="hljs-variable">$authenticator</span></code></pre></div><p>不过一般在实际操作中，我们还是使用ModularRealmAuthenticator实例。</p><h3 id="AuthenticationStrategy"><a href="#AuthenticationStrategy" class="headerlink" title="AuthenticationStrategy"></a>AuthenticationStrategy</h3><p>当一个程序中定义了两个或多个realm时，ModularRealmAuthenticator使用一个内部的AuthenticationStrategy组件来决定一个验证是否成功。<br>AuthenticationStrategy 还有责任从每一个成功的 Realm 中收集结果并将它们“绑定”到一个单独的 AuthenticationInfo，这个AuthenticationInfo 实例是被 Authenticator 实例返回的，并且 shiro 用它来展现一个 Subject 的最终身份（也就是 Principals ）。</p><p>如果程序中使用大于一个Realm从多个数据源中获取账户数据，程序可看到的是AuthenticationStrategy最终负责Subject身份最终“合并（merged）”的视图。<br>Shiro有3个具体的AuthenticationStrategy实现：<br><img src="https://img-blog.csdnimg.cn/20200622224909382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>ModularRealmAuthenticator 默认使用 AtLeastOneSuccessfulStrategy 实现，这也是最常用的策略，然而你也可以配置你希望的不同的策略。<br>shiro.ini</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span><span class="hljs-attr">authcStrategy</span> = org.apache.shiro.authc.pam.FirstSuccessfulStrategy<span class="hljs-attr">securityManager.authenticator.authenticationStrategy</span> = <span class="hljs-variable">$authcStrategy</span></code></pre></div><p>自定义的 AuthenticationStrategy</p><p>如果你希望创建你自己的 AuthenticationStrategy 实现，你可以使用 <code>org.apache.shiro.authc.pam.AbstractAuthenticationStrategy</code>作为起始点。AbstractAuthenticationStrategy 类自动实现 ‘绑定（bundling）’/聚集（aggregation）行为将来自于每个Realm 的结果收集到一个 AuthenticationInfo 实例中。</p><h2 id="Realm-验证的顺序"><a href="#Realm-验证的顺序" class="headerlink" title="Realm 验证的顺序"></a>Realm 验证的顺序</h2><p>Realm 交互的 ModularRealmAuthenticator 按迭代（iteration）顺序执行。</p><p>ModularRealmAuthenticator 可以访问为 SecurityManager 配置的 Realm 实例，当尝试一次验证时，它将在集合中遍历，支持对提交的 AuthenticationToken 处理的每个 Realm 都将执行 Realm 的 getAuthenticationInfo 方法。</p><p>我们也可以通过shiro.ini配置文件来按照我们自己期望的顺序来配置Realm，Realm将按照他们在INI文件中定义的顺序执行。</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">blahRealm</span> = com.company.blah.Realm...<span class="hljs-attr">fooRealm</span> = com.company.foo.Realm...<span class="hljs-attr">barRealm</span> = com.company.another.Realm</code></pre></div><p>效果等价于：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">securityManager.realms</span> = <span class="hljs-variable">$blahRealm</span>, <span class="hljs-variable">$fooRealm</span>, <span class="hljs-variable">$barRealm</span></code></pre></div><p>如果你希望明确定义 realm 执行的顺序，不管他们如何被定义，你可以设置 SecurityManager 的 realms 属性，例如，使用上面定义的 realm，但你希望 blahRealm 最后执行而不是第一个：</p><div class="hljs"><pre><code class="hljs java">blahRealm = com.company.blah.Realm...fooRealm = com.company.foo.Realm...barRealm = com.company.another.RealmsecurityManager.realms = $fooRealm, $barRealm, $blahRealm</code></pre></div><p>当你明确的配置 securityManager.realms 属性时，只有被引用的 realm 将为 SecurityManager 配置，也就是说你可能在 INI 中定义了5个 realm，但实际上只使用了3个，如果在 realm 属性中只引用了3个，这和隐含的 realm 顺序不同，在那种情况下，所有有效的 realm 都会用到。</p><h1 id="2、授权"><a href="#2、授权" class="headerlink" title="2、授权"></a>2、授权</h1><p>授权（Authorization）：亦为访问控制，是管理资源访问的过程，换言之，也就是控制在一个程序中“谁”有权利访问“什么”。</p><h2 id="授权要素"><a href="#授权要素" class="headerlink" title="授权要素"></a>授权要素</h2><p>授权有三个核心元素，即：权限（permissions）、角色（roles）和用户（users）</p><h3 id="权限（permissions）"><a href="#权限（permissions）" class="headerlink" title="权限（permissions）"></a>权限（permissions）</h3><p>权限是一组关于行为的基本指令，以明确标识在一个程序中可以做什么，一个很好的权限指令定义必须描述资源以及当一个Subject与这些资源交互时什么动作可以执行。</p><p>下面是一些权限指令的例子：</p><ul><li>打开一个文件；</li><li>查看“/user/list”页面；</li><li>打印文档；</li><li>删除“JSmith”用户</li></ul><p>权限只描述行为（和资源相关的动作），并不关心“谁”有能力执行这个动作。</p><p>定义“谁”（用户）被允许做“什么”（权限）需要用一些方法将权限赋予用户，这通常取决于程序的数据模型而且经常在程序中发生改变。</p><p>上面提到的权限示例都是针对资源（门、文件、客户等）指定的动作（打开、读、删除等），在一些场景中，我们也会指定非常细粒度的“实例级别”行为–例如：“删除”（delete）名为“Jsmith”（实例标识）的“用户”（资源类型）。</p><h3 id="角色（roles）"><a href="#角色（roles）" class="headerlink" title="角色（roles）"></a>角色（roles）</h3><p>角色是一个实体名，代表一组行为或职责，这些行为在程序中转化为你可以或不能做的事情。角色通常赋给用户账户，关联后，用户既可以“做”属于不同角色的事情。</p><p>有两种有效的角色指定方式：</p><ul><li>权限隐含于角色中；<br>隐含的角色可能会增加软件的维护成本和管理问题，比如增加或删除一个角色，重新定义角色的行为等，代码改动太大。</li><li>明确为角色指定权限；<br>明确为角色指定权限本质上是一组权限指令的名称集，程序（以及 Shiro）准确知道一个特定的角色是什么意思，因为它确切知道某行为是否可以执行，而不用去猜测特定的角色可以或不可以做什么。</li></ul><h3 id="用户（users）"><a href="#用户（users）" class="headerlink" title="用户（users）"></a>用户（users）</h3><p>一个用户本质上是程序中的“谁”，前面提到的Subject实际上是shiro的“用户”。<br>用户（Subjects）通过与角色或权限关联确定是否被允许执行程序内特定的动作，程序数据模型确切定义了 Subject 是否允许做什么事情。</p><p>例如，在你的数据模型中，你定义了一个普通的用户类并且直接为其设置了权限，或者你只是直接给角色设置了权限，然后将用户与该角色关联，通过这种关联，用户就“有”了角色所具备的权限，或者你也可以通过“组”的概念完成这件事，这取决于你程序的设计。</p><p>数据模型定义了如何进行授权，Shiro 依赖一个 Realm 实现将你的数据模型关联转换成 Shiro 可以理解的内容，我们将稍后讨论 Realms。</p><p>最终，是 Realm 与你的数据源（RDBMS,LDAP等）做交流，Realm 用来告知Shiro 是否角色或权限是否存在，你可以完全控制你的授权模型如何创建和定义。</p><h2 id="授权对象"><a href="#授权对象" class="headerlink" title="授权对象"></a>授权对象</h2><p>在 Shiro 中执行授权可以有三种途径：</p><ul><li>程序代码–你可以在你的 JAVA 代码中执行用类似于 if 和 else 的结构来执行权限检查。</li><li>JDK 注解–你可以在你的 JAVA 方法上附加权限注解</li><li>JSP/GSP 标签–你可以基于角色和权限控制 JSP 或 GSP 页面输出内容。</li></ul><h3 id="在程序中检查授权"><a href="#在程序中检查授权" class="headerlink" title="在程序中检查授权"></a>在程序中检查授权</h3><h4 id="基于角色的授权"><a href="#基于角色的授权" class="headerlink" title="基于角色的授权"></a>基于角色的授权</h4><p>如果你想简单地检查一下当前Subject是否拥有一个角色，你可以在一个实例上调用 hasRole* 方法。</p><p>例如，查看一个 Subject 是否有特定（单独）的角色，你可以调用subject.hasRole(roleName))方法，做出相应的反馈。</p><div class="hljs"><pre><code class="hljs java">Subject currentUser = SecurityUtils.getSubject();<span class="hljs-keyword">if</span> (currentUser.hasRole(<span class="hljs-string">"administrator"</span>)) &#123;    <span class="hljs-comment">//显示 admin 按钮</span>&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//不显示按钮?  灰色吗？</span>&#125;</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200622232145591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>另外可以检测 Subjet 是否是指定的某个角色，你可以在的代码执行之前简单判断他们是否是所要求的角色，如果 Subject 不是所要求的角色， AuthorizationException 异常将被抛出，如果是所要求的角色，判断将安静地执行并按期望顺序执行下面的逻辑。</p><div class="hljs"><pre><code class="hljs java">Subject currentUser = SecurityUtils.getSubject();<span class="hljs-comment">//保证当前用户是一个银行出纳员</span><span class="hljs-comment">//因此允许开立帐户：</span>currentUser.checkRole(<span class="hljs-string">"bankTeller"</span>);openBankAccount();</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200622232306827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="基于权限的授权"><a href="#基于权限的授权" class="headerlink" title="基于权限的授权"></a>基于权限的授权</h4><p>通过基于权限的授权执行访问控制是更好的方法。基于权限的授权，因为其与程序功能（以及程序核心资源上的行为）紧密联系，基于权限授权的源代码在程序功能改变时才需要改变，而与安全策略无关。这意味着与同样基于角色的授权相比，对代码的影响更少。</p><p><strong>基于对象的权限检查</strong>：</p><div class="hljs"><pre><code class="hljs java">Permission printPermission = <span class="hljs-keyword">new</span> PrinterPermission(<span class="hljs-string">"laserjet4400n"</span>, <span class="hljs-string">"print"</span>);Subject currentUser = SecurityUtils.getSubject();<span class="hljs-keyword">if</span> (currentUser.isPermitted(printPermission)) &#123;    <span class="hljs-comment">//显示 打印 按钮</span>&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//不显示按钮?  灰色吗？</span>&#125;</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200622232542546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>基于字符串的权限检查</strong>：<br>选择用普通的字符串来代表权限：</p><div class="hljs"><pre><code class="hljs java">Subject currentUser = SecurityUtils.getSubject();<span class="hljs-keyword">if</span> (currentUser.isPermitted(<span class="hljs-string">"printer:print:laserjet4400n"</span>)) &#123;    <span class="hljs-comment">//显示 打印 按钮</span>&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//不显示按钮?  灰色吗？</span>&#125;</code></pre></div><p>基于字符串的权限有利的一面在于你不需要实现一个接口而且简单的字符串也非常易读，而不利的一面在于不保证类型安全，而且当你需要定义超出字符串表现能力之外的更复杂的行为时，你仍旧需要利用权限接口实现你自己的权限对象。实际上，大部分 Shiro 的终端用户因为其简单而选择基于字符串的方式，但最终你的程序需求决定了哪一种方法会更好。<br><img src="https://img-blog.csdnimg.cn/20200622232837821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="权限判断"><a href="#权限判断" class="headerlink" title="权限判断"></a>权限判断</h4><p>另一种检查 Subject 是否被允许做某件事的方法是，在逻辑执行之前简单判断他们是否具备所需的权限，如果不允许，AuthorizationException异常被抛出，如果是允许的，判断将安静地执行并按期望顺序执行下面的逻辑。</p><p>例如：</p><div class="hljs"><pre><code class="hljs java">Subject currentUser = SecurityUtils.getSubject();<span class="hljs-comment">//担保允许当前用户</span><span class="hljs-comment">//开一个银行帐户：</span>Permission p = <span class="hljs-keyword">new</span> AccountPermission(<span class="hljs-string">"open"</span>);currentUser.checkPermission(p);openBankAccount();</code></pre></div><p>或者，同样的判断，可以用字符串形式：</p><div class="hljs"><pre><code class="hljs java">Subject currentUser = SecurityUtils.getSubject();<span class="hljs-comment">//担保允许当前用户</span><span class="hljs-comment">//开一个银行帐户：</span>currentUser.checkPermission(<span class="hljs-string">"account:open"</span>);openBankAccount();</code></pre></div><p>与 isPermitted* 方法相比较，这种方法的优势是代码更为清晰，如果当前Subject 不符合条件，你不必创建你自己的 AuthorizationExceptions 异常（如果你不想那么做）。<br><img src="https://img-blog.csdnimg.cn/20200622233049193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="基于注解的授权"><a href="#基于注解的授权" class="headerlink" title="基于注解的授权"></a>基于注解的授权</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在你使用 JAVA 的注解之前，你需要在程序中启动 AOP 支持，因为有许多AOP 框架，所以很不幸，在这里并没有标准的在程序中启用 AOP 的方法。</p><h4 id="RequiresAuthentication-注解"><a href="#RequiresAuthentication-注解" class="headerlink" title="RequiresAuthentication 注解"></a>RequiresAuthentication 注解</h4><p>RequiresAuthentication 注解表示在访问或调用被注解的类/实例/方法时，要求 Subject 在当前的 session中已经被验证。</p><p>举例：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequiresAuthentication</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateAccount</span><span class="hljs-params">(Account userAccount)</span> </span>&#123;    <span class="hljs-comment">//这个方法只会被调用在</span>    <span class="hljs-comment">//Subject 保证被认证的情况下</span>    ...&#125;</code></pre></div><p>这基本上与下面的基于对象的逻辑效果相同：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateAccount</span><span class="hljs-params">(Account userAccount)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!SecurityUtils.getSubject().isAuthenticated()) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthorizationException(...);    &#125;    <span class="hljs-comment">//这里 Subject 保证被认证的情况下</span>    ...&#125;</code></pre></div><h4 id="RequiresGuest-注解"><a href="#RequiresGuest-注解" class="headerlink" title="RequiresGuest 注解"></a>RequiresGuest 注解</h4><p>RequiresGuest 注解表示要求当前Subject是一个“guest(访客)”，也就是，在访问或调用被注解的类/实例/方法时，他们没有被认证或者在被前一个Session 记住。</p><p>例如：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequiresGuest</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signUp</span><span class="hljs-params">(User newUser)</span> </span>&#123;    <span class="hljs-comment">//这个方法只会被调用在</span>    <span class="hljs-comment">//Subject 未知/匿名的情况下</span>    ...&#125;</code></pre></div><p>这基本上与下面的基于对象的逻辑效果相同：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signUp</span><span class="hljs-params">(User newUser)</span> </span>&#123;    Subject currentUser = SecurityUtils.getSubject();    PrincipalCollection principals = currentUser.getPrincipals();    <span class="hljs-keyword">if</span> (principals != <span class="hljs-keyword">null</span> &amp;&amp; !principals.isEmpty()) &#123;        <span class="hljs-comment">//已知的身份 - 不是 guest（访客）:</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthorizationException(...);    &#125;    <span class="hljs-comment">//在这里 Subject 确保是一个 'guest（访客）'</span>    ...&#125;</code></pre></div><h4 id="RequiresPermissions-注解"><a href="#RequiresPermissions-注解" class="headerlink" title="RequiresPermissions 注解"></a>RequiresPermissions 注解</h4><p>RequiresPermissions 注解表示要求当前Subject在执行被注解的方法时具备一个或多个对应的权限。</p><p>例如：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequiresPermissions</span>(<span class="hljs-string">"account:create"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createAccount</span><span class="hljs-params">(Account account)</span> </span>&#123;    <span class="hljs-comment">//这个方法只会被调用在</span>    <span class="hljs-comment">//Subject 允许创建一个 account 的情况下</span>    ...&#125;</code></pre></div><p>这基本上与下面的基于对象的逻辑效果相同</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createAccount</span><span class="hljs-params">(Account account)</span> </span>&#123;    Subject currentUser = SecurityUtils.getSubject();    <span class="hljs-keyword">if</span> (!subject.isPermitted(<span class="hljs-string">"account:create"</span>)) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthorizationException(...);    &#125;    <span class="hljs-comment">//在这里 Subject 确保是允许</span>    ...&#125;</code></pre></div><h4 id="RequiresRoles-注解"><a href="#RequiresRoles-注解" class="headerlink" title="RequiresRoles 注解"></a>RequiresRoles 注解</h4><p>RequiresRoles 注解表示要求当前Subject在执行被注解的方法时具备所有的角色，否则将抛出 AuthorizationException 异常。</p><p>例如：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequiresRoles</span>(<span class="hljs-string">"administrator"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteUser</span><span class="hljs-params">(User user)</span> </span>&#123;    <span class="hljs-comment">//这个方法只会被 administrator 调用 </span>    ...&#125;</code></pre></div><p>这基本上与下面的基于对象的逻辑效果相同</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteUser</span><span class="hljs-params">(User user)</span> </span>&#123;    Subject currentUser = SecurityUtils.getSubject();    <span class="hljs-keyword">if</span> (!subject.hasRole(<span class="hljs-string">"administrator"</span>)) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthorizationException(...);    &#125;    <span class="hljs-comment">//Subject 确保是一个 'administrator'</span>...&#125;</code></pre></div><h4 id="RequiresUser-注解"><a href="#RequiresUser-注解" class="headerlink" title="RequiresUser 注解"></a>RequiresUser 注解</h4><p>RequiresUser 注解表示要求在访问或调用被注解的类/实例/方法时，当前 Subject 是一个程序用户，“程序用户”是一个已知身份的 Subject，或者在当前 Session 中被验证过或者在以前的 Session 中被记住过。</p><p>例如：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequiresUser</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateAccount</span><span class="hljs-params">(Account account)</span> </span>&#123;    <span class="hljs-comment">//这个方法只会被 'user' 调用 </span>    <span class="hljs-comment">//i.e. Subject 是一个已知的身份with a known identity</span>    ...&#125;</code></pre></div><p>这基本上与下面的基于对象的逻辑效果相同</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateAccount</span><span class="hljs-params">(Account account)</span> </span>&#123;    Subject currentUser = SecurityUtils.getSubject();    PrincipalCollection principals = currentUser.getPrincipals();    <span class="hljs-keyword">if</span> (principals == <span class="hljs-keyword">null</span> || principals.isEmpty()) &#123;        <span class="hljs-comment">//无身份 - 他们是匿名的，不被允许</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthorizationException(...);    &#125;    <span class="hljs-comment">//Subject 确保是一个已知的身份</span>    ...&#125;</code></pre></div><h3 id="授权序列"><a href="#授权序列" class="headerlink" title="授权序列"></a>授权序列</h3><p>当一个授权命令调用时 Shiro 内部发生了什么事情？<br><strong>第1步</strong>：程序或框架代码调用一个 Subject 的hasRole<em>、checkRole</em>、 isPermitted<em>或者 checkPermission</em>方法，传递所需的权限或角色。</p><p><strong>第2步</strong>：Subject实例，通常是一个 DelegatingSubject（或子类），通过调用securityManager 与各 hasRole<em>、checkRole*、 isPermitted</em> 或 checkPermission* 基本一致的方法将权限或角色传递给程序的 SecurityManager(实现了 org.apache.shiro.authz.Authorizer 接口)</p><p><strong>第3步</strong>：SecurityManager 作为一个基本的“保护伞”组件,接替/代表其内部 org.apache.shiro.authz.Authorizer 实例通过调用 authorizer 的各自的 hasRole<em>, checkRole</em> , isPermitted* ,或 checkPermission* 方法。 authorizer 默认情况下是一个实例 ModularRealmAuthorizer 支持协调一个或多个实例 Realm 在任何授权操作实例。</p><p><strong>第4步</strong>:，检查每一个被配置的 Realm 是否实现相同的 Authorizer接口，如果是，Realm 自己的各 hasRole<em>、checkRole*、 isPermitted</em> 或 checkPermission* 方法被调用。</p><h4 id="ModularRealmAuthorizer"><a href="#ModularRealmAuthorizer" class="headerlink" title="ModularRealmAuthorizer"></a>ModularRealmAuthorizer</h4><p>前面提到过，Shiro SecurityManager 默认使用 ModularRealmAuthorizer 实例，ModularRealmAuthorizer 实例同等支持用一个 Realm 的程序和用多个 Realm 的程序。</p><p>对于任何授权操作，ModularRealmAuthorizer 将在其内部的 Realm 集中迭代（iterator），按迭代（iteration）顺序同每一个 Realm 交互，与每一个 Realm 交互的方法如下：</p><p>1.如果Realm实现了 Authorizer 接口，调用它各自的授权方法（hasRole<em>、 checkRole</em>、isPermitted<em>或 checkPermission</em>）。</p><p>1.1.如果 Realm 函数的结果是一个 exception，该 exception 衍生自一个 Subject 调用者的 AuthorizationException，就切断授权过程，剩余的授权 Realm 将不在执行。</p><p>1.2.如果 Realm 的方法是一个 hasRole* 或 isPermitted*，并且返回真，则真值立即被返回而且剩余的 Realm 被短路，这种做法作为一种性能增强，在一个 Realm 判断允许后，隐含认为这个 Subject 被允许。它支持最安全的安全策略：默认情况下所有都被禁止，明确指定允许的事情。</p><p>2.如果 Realm 没有实现 Authorizer 接口，将被忽略。</p><h4 id="授权顺序"><a href="#授权顺序" class="headerlink" title="授权顺序"></a>授权顺序</h4><p>需要指出非常重要的一点，就如同验证（authentication）一样，ModularRealmAuthorizer 按迭代（iteration）顺序与 Realm 交互。</p><p>ModularRealmAuthorizer 拥有 SecurityManager 配置的 Realm 实例的入口，当执行一个授权操作时，它将在整个集合中进行迭代（iteration），对于每一个实现 Authorizer 接口的 Realm，调用Realm 各自的 Authorizer 方法（如 hasRole、 checkRole、 isPermitted或 checkPermission）。</p><h4 id="配置全局的-PermissionResolver"><a href="#配置全局的-PermissionResolver" class="headerlink" title="配置全局的 PermissionResolver"></a>配置全局的 PermissionResolver</h4><p>当执行一个基于字符串的权限检查时，大部分 Shiro 默认的 Realm 将会在执行权限隐含逻辑之前首先把这个字符串转换成一个常用的权限实例。</p><p>这是因为权限被认为是基于隐含逻辑而不是相等检查（查看Permission章节了解更多隐含与相等的对比）。隐含逻辑用代码表示要比通过字符串对比好，因此，大部分 Realm需要转换一个提交的权限字符串为对应的权限实例。</p><p>为了这个转换目的，Shiro 支持 PermissionResolver，大部分 Shiro Realm 使用 PermissionResolver 来支持它们对Authorizer 接口中基于字符串权限方法的实现：当这些方法在Realm上被调用时，将使用PermissionResolver 将字符串转换为权限实例，并执行检查。</p><p>所有的 Shiro Realm 默认使用内部的 WildcardPermissionResolver，它使用 Shiro 的WildcardPermission字符串格式。</p><p>如果你想创建你自己的 PermissionResolver 实现，比如说你想创建你自己的权限字符串语法，希望所有配置的Realm实例都支持这个语法，你可以把自己的 PermissionResolver 设置成全局，供所有 realm 使用。</p><p>如，在shiro.ini中：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">globalPermissionResolver</span> = com.foo.bar.authz.MyPermissionResolver...<span class="hljs-attr">securityManager.authorizer.permissionResolver</span> = <span class="hljs-variable">$globalPermissionResolver</span>...</code></pre></div><h4 id="PermissionResolverAware"><a href="#PermissionResolverAware" class="headerlink" title="PermissionResolverAware"></a>PermissionResolverAware</h4><p>如果你想配置一个全局的 PermissionResolver，每一个会读取这个PermissionResolver 配置的 Realm 必须实现PermissionResolverAware 接口，这确保被配置 PermissionResolver 的实例可以传递给支持这种配置的每一个 Realm。</p><p>如果你不想使用一个全局的 PermissionResolver 或者你不想被PermissionResolverAware 接口麻烦，你可以明确地为单个的 Realm 配置 PermissionResolver 接口（可看作是JavaBean的setPermissionResolver 方法）：</p><div class="hljs"><pre><code class="hljs java">permissionResolver = com.foo.bar.authz.MyPermissionResolverrealm = com.foo.bar.realm.MyCustomRealmrealm.permissionResolver = $permissionResolver...</code></pre></div><h4 id="配置全局的RolePermissionResolver"><a href="#配置全局的RolePermissionResolver" class="headerlink" title="配置全局的RolePermissionResolver"></a>配置全局的RolePermissionResolver</h4><p>与 PermissionResolver 类似，RolePermissionResolver 有能力表示执行权限检查的 Realm 所需的权限实例。</p><p>最主要的不同在于接收的字符串是一个角色名，而不是一个权限字符串。</p><p>RolePermissionResolver 被 Realm 在需要时用来转换一个角色名到一组明确的权限实例。</p><p>这是非常有用的，它支持那些遗留的或者不灵活的没有权限概念的数据源。</p><p>例如，许多 LDAP 目录存储角色名称（或组名）但不支持角色名和权限的联合，因为它没有权限的概念。一个使用 shiro 的程序可以使用存储于 LDAP 的角色名，但需要实现一个 RolePermissionResolver 来转换 LDAP 名到一组确切的权限中以执行明确的访问控制，权限的联合将被存储于其它的数据存储中，比如说本地数据库。</p><p>因为这种将角色名转换为权限的概念是特定的，Shiro 默认的 Realm 没有使用它们。</p><p>然而，如果你想创建你自己的 RolePermissionResolver 并且希望用它配置多个 Realm 实现，你可以将你的 RolePermissionResolver设置成全局。<br>shiro.ini</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">globalRolePermissionResolver</span> = com.foo.bar.authz.MyPermissionResolver...<span class="hljs-attr">securityManager.authorizer.rolePermissionResolver</span> = <span class="hljs-variable">$globalRolePermissionResolver</span>...</code></pre></div><h4 id="RolePermissionResolverAware"><a href="#RolePermissionResolverAware" class="headerlink" title="RolePermissionResolverAware"></a>RolePermissionResolverAware</h4><p>如果你想配置一个全局的 RolePermissionResolver, 每个 Realm 接收必须实现了 RolePermisionResolverAware 接口的配置了的 RolePermissionResolver 。这保证了配置全局 RolePermissionResolver 实例可以传递到各个支持这样配置的 Realm 。</p><p>如果你不想使用全局的 RolePermissionResolver 或者你不想麻烦实现 RolePermissionResolverAware 接口，你可以单独为一个 Realm 配置 RolePermissionResolver（可以看作 JavaBean 的 setRolePermissionResolver 方法）。</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">rolePermissionResolver</span> = com.foo.bar.authz.MyRolePermissionResolver<span class="hljs-attr">realm</span> = com.foo.bar.realm.MyCustomRealm<span class="hljs-attr">realm.rolePermissionResolver</span> = <span class="hljs-variable">$rolePermissionResolver</span></code></pre></div><h5 id="定制Authorizer"><a href="#定制Authorizer" class="headerlink" title="定制Authorizer"></a>定制Authorizer</h5><p>如果你的程序使用多于一个 Realm 来执行授权而 ModularRealmAuthorizer 默认的简单迭代（iteration）、短路授权的行为不能满足你的需求，你可以创建自己的 Authorizer 并配置给相应的 SecurityManager。</p><p>例如，在shiro.ini中：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span>...<span class="hljs-attr">authorizer</span> = com.foo.bar.authz.CustomAuthorizer<span class="hljs-attr">securityManager.authorizer</span> = <span class="hljs-variable">$authorizer</span></code></pre></div><h1 id="3、Realms"><a href="#3、Realms" class="headerlink" title="3、Realms"></a>3、Realms</h1><p>Realm 是可以访问程序特定的安全数据如用户、角色、权限等的一个组件。Realm 会将这些程序特定的安全数据转换成一种 Shiro 可以理解的形式。</p><p>Realm通常和数据源是一对一的对应关系，如关系数据库，LDAP 目录，文件系统，或其他类似资源。因此，Realm 接口的实现使用数据源特定的API 来展示授权数据（角色，权限等），如JDBC，文件IO，Hibernate 或JPA，或其他数据访问API。</p><p>Realm实质上就是一个特定安全的DAO</p><p>因为这些数据源大多数通常存储身份验证数据（如密码的凭证）以及授权数据（如角色或权限），每个Shiro Realm能够执行身份验证和授权操作。</p><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>如果使用 Shiro 的 ini 配置文件，你可以在[main]区域内像配置其它对象一样定义和引用Realms，但是 Realm 在 secrityManager上的配置有两种方式：明确方式和隐含方式。</p><h3 id="显式配置"><a href="#显式配置" class="headerlink" title="显式配置"></a>显式配置</h3><p>在定义一个或多个Realm后，再将它们在securityManager上进行统一配置。<br><img src="https://img-blog.csdnimg.cn/20200623002743915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="隐式配置（不推荐）"><a href="#隐式配置（不推荐）" class="headerlink" title="隐式配置（不推荐）"></a>隐式配置（不推荐）</h3><p>这种方法可能引发意想不到的行为，如果你改变 realm 定义的顺序的话。建议你避免使用此方法，并使用显式分配，它拥有确定的行为。该功能很可能在未来的 Shiro 版本中被废弃或移除。</p><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>了解在一个授权尝试中当 Authenticator 与 Realm 交互时到底发生了什么是很重要的。</p><h3 id="Supporting-AuthenticationTokens"><a href="#Supporting-AuthenticationTokens" class="headerlink" title="Supporting AuthenticationTokens"></a>Supporting AuthenticationTokens</h3><p>正如在认证流程中提到的，在一个 Realm 执行一个验证尝试之前，它的supports)方法被调用。只有在返回值为 true 的时候它的getAuthenticationInfo(token) 方法才会执行。</p><p>通常情况下，一个 realm 将检查提交的令牌类型（接口或类）确定自己是否可以处理它，例如，一个处理生物特性数据的Realm 可能一点也不理解 UsernamePasswordTokens，在这种情况下它将从支持函数中返回 false。</p><h3 id="Handling-supported-AuthenticationTokens"><a href="#Handling-supported-AuthenticationTokens" class="headerlink" title="Handling supported AuthenticationTokens"></a>Handling supported AuthenticationTokens</h3><p>如果一个Realm支持提交的验证令牌，验证将调用 Realm 的getAuthenticationInfo(token)) 方法，这是Realm 使用后台数据进行验证的一次有效尝试，顺序执行以下动作：</p><p>1.检查主要 principal (身份)令牌（用户身份信息）；</p><p>2.基于主要 principal (信息)，在数据源中查找对应的用户数据；</p><p>3.确定令牌支持的 credentials (凭证数据)和存储的数据相符；</p><p>4.如果凭证相符，返回一个AuthenticationInfo实例，里面封装了 Shiro 可以理解的用户数据。</p><p>5.如果证据不符，抛出 AuthenticationException异常。</p><p>这是所有Realm getAuthenticationInfo 实现的最高级别工作流，Realm 在这个过程中可以自由做自己想做的事情，比如记录日志，修改数据，以及其他，只要对于存储的数据和验证尝试来讲是合理的就行。</p><p>仅有一件事情是必须的，如果 credentials （凭证）和给定的 principal （主要信息）匹配，需要返回一个非空的 AuthenticationInfo 实例，用来表示来自数据源的 Subject 账户信息。</p><p>直接实现 Realm 接口也许需要时间并容易出错，大部分用户选择继承 AuthorizingRealm 虚拟类，这个类实现了常用的认证和授权工作流，这会节省你的时间而且不易出错。</p><h3 id="凭证匹配"><a href="#凭证匹配" class="headerlink" title="凭证匹配"></a>凭证匹配</h3><p>在上述 realm 认证工作流中，一个 Realm 必须较验 Subject 提交的凭证（如密码）是否与存储在数据中的凭证相匹配，如果匹配，验证成功，系统保留已认证的终端用户身份。</p><p>检查提交的凭证是否与后台存储数据相匹配是每一个 Realm 的责任而不是 Authenticator 的责任，每一个 Realm 都具备与凭证形式及存储密切相关的技能，可以执行详细的凭证比对，而 Authenticator 只是一个普通的工作流组件。</p><p>凭证匹配的过程在所有程序中基本上是一样的，通常只是对比数据方式不同。要确保这个过程在必要时是可插拔和可定制的，AuthenticatingRealm 以及它的子类支持用 CredentialsMatcher 来执行一个凭证对比。</p><p>在找到用户数据之后，它和提交的 AuthenticationToken 一起传递给一个 CredentialsMatcher ，后者用来检查提交的数据和存储的数据是否相匹配。</p><p>Shiro某些 CredentialsMatcher 实现可以使你开箱即用，比如 SimpleCredentialsMatcher 和 HashedCredentialsMatcher 实现，但如果你想配置一个自定义的实现来完成特定的对比逻辑，你可以这样做：</p><div class="hljs"><pre><code class="hljs java">Realm myRealm = <span class="hljs-keyword">new</span> com.company.shiro.realm.MyRealm();CredentialsMatcher customMatcher = <span class="hljs-keyword">new</span> com.company.shiro.realm.CustomCredentialsMatcher();myRealm.setCredentialsMatcher(customMatcher);</code></pre></div><p>或者，使用 Shiro 的 INI配置文件</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span>...<span class="hljs-attr">customMatcher</span> = com.company.shiro.realm.CustomCredentialsMatcher<span class="hljs-attr">myRealm</span> = com.company.shiro.realm.MyRealm<span class="hljs-attr">myRealm.credentialsMatcher</span> = <span class="hljs-variable">$customMatcher</span>...</code></pre></div><h1 id="4、Session-Management"><a href="#4、Session-Management" class="headerlink" title="4、Session Management"></a>4、Session Management</h1><p>Apache Shiro 提供安全框架界独一无二的东西：一个完整的企业级Session 解决方案，从最简单的命令行及智能手机应用到最大的集群企业Web 应用程序。</p><h2 id="使用Sessions"><a href="#使用Sessions" class="headerlink" title="使用Sessions"></a>使用Sessions</h2><p>几乎与所有其他在Shiro 中的东西一样，你通过与当前执行的Subject 交互来获取Session：</p><div class="hljs"><pre><code class="hljs java">Subject currentUser = SecurityUtils.getSubject();Session session = currentUser.getSession();session.setAttribute( <span class="hljs-string">"someKey"</span>, someValue);</code></pre></div><p>subject.getSession() 方法是调用 currentUser.getSubject(true)的快捷方式。</p><p>对于那些熟悉 HttpServletRequest API 的，Subject.getSession(boolean create) 方法与 HttpServletRequest.getSession(boolean create) 方法有着异曲同工之效。</p><ul><li>如果该Subject 已经拥有一个Session，则boolean 参数被忽略且Session 被立即返回。</li><li>如果该Subject 还没有一个Session 且create 参数为true，则创建一个新的会话并返回该会话。</li><li>如果该Subject 还没有一个Session 且create 参数为false，则不会创建新的会话且返回null。</li></ul><p>getSession 要求能够在任何应用程序工作，甚至是非 Web 应用程序。</p><p>当开发框架代码来确保一个 Session 没有被创建是没有必要的时候，subject.getSession(false) 可以起到很好的作用。 当你获取了一个 Subject 的 Session 后，你可以用它来做许多事情，像设置或取得 attribute，设置其超时时间，以及 更多。</p><h2 id="SessionManager"><a href="#SessionManager" class="headerlink" title="SessionManager"></a>SessionManager</h2><p>SessionManager，名如其意，在应用程序中为所有的 subject 管理Session —— 创建，删除，inactivity(失效)及验证，等等。如同其他在Shiro 中的核心结构组件一样，SessionManager 也是一个由 SecurityManager 维护的顶级组件。<br>默认的 SecurityManger 实现是默认使用开箱即用的DefaultSessionManager。</p><p>像其他被 SecurityManager 管理的组件一样，SessionManager 可以通过 JavaBean 风格的 getter/setter 方法在所有Shiro 默认 SecurityManager 实现（getSessionManager()/setSessionManager()）上获取或设置值。或者例如，如果在使用 shiro.ini 配置：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span>...<span class="hljs-attr">sessionManager</span> = com.foo.my.SessionManagerImplementation<span class="hljs-attr">securityManager.sessionManager</span> = <span class="hljs-variable">$sessionManager</span></code></pre></div><p>但从头开始创建一个 SessionManager 是一个复杂的任务且是大多数人不想亲自做的事情。Shiro 的开箱即用的SessionManager 实现是高度可定制的和可配置的，并满足大多数的需要。本文档的其余部分假定你将使用 Shiro 的默认 SessionManager 实现，当覆盖配置选项时。但请注意，你基本上可以创建或插入任何你想要的东西。</p><h3 id="Session超时"><a href="#Session超时" class="headerlink" title="Session超时"></a>Session超时</h3><p>Shiro 的 SessionManager 实现默认是 30 分钟会话超时。也就是说，如果任何 Session 创建后闲置（未被使用，它的lastAccessedTime)未被更新）的时间超过了 30 分钟，那么该 Session 就被认为是过期的，且不允许再被使用。</p><p>你可以设置 SessionManager 默认实现的 globalSessionTimeout 属性来为所有的会话定义默认的超时时间。例如，如果你想超时时间是一个小时而不是 30 分钟：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span>...<span class="hljs-comment"># 3,600,000 milliseconds = 1 hour</span><span class="hljs-attr">securityManager.sessionManager.globalSessionTimeout</span> = <span class="hljs-number">3600000</span></code></pre></div><h3 id="Session监听器"><a href="#Session监听器" class="headerlink" title="Session监听器"></a>Session监听器</h3><p>Shiro 支持 SessionListener 概念来允许你对发生的重要会话作出反应。你可以实现 SessionListener 接口（或扩展易用的SessionListenerAdapter ）并与相应的会话操作作出反应。 由于默认的 SessionManager sessionListeners 属性是一个集合，你可以对 SessionManager 配置一个或多个 listener 实 现，就像其他在 shiro.ini 中的集合一样：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span>...<span class="hljs-attr">aSessionListener</span> = com.foo.my.SessionListener<span class="hljs-attr">anotherSessionListener</span> = com.foo.my.OtherSessionListener<span class="hljs-attr">securityManager.sessionManager.sessionListeners</span> = <span class="hljs-variable">$aSessionListener</span>, <span class="hljs-variable">$anotherSessionListener</span>, etc.</code></pre></div><p>当任何会话发生事件时，SessionListeners 都会被通知——不仅仅是对一个特定的会话</p><h3 id="Session存储"><a href="#Session存储" class="headerlink" title="Session存储"></a>Session存储</h3><p>每当一个会话被创建或更新时，它的数据需要持久化到一个存储位置以便它能够被稍后的应用程序访问。同样地，当一个会话失效且不再被使用时，它需要从存储中删除以便会话数据存储空间不会被耗尽。SessionManager 实现委托这些 Create/Read/Update/Delete(CRUD) 操作为内部组件，同时，SessionDAO，反映了数据访问对象（DAO）设计模式。</p><p>SessionDAO 的权力是你能够实现该接口来与你想要的任何数据存储进行通信。这意味着你的会话数据可以驻留在内存中，文件系统，关系数据库或NoSQL 的数据存储，或其他任何你需要的位置。你得控制持久性行为。</p><p>你可以将任何 SessionDAO 实现作为一个属性配置在默认的SessionManager 实例上。例如，在shiro.ini 中：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span>...<span class="hljs-attr">sessionDAO</span> = com.foo.my.SessionDAO<span class="hljs-attr">securityManager.sessionManager.sessionDAO</span> = <span class="hljs-variable">$sessionDAO</span></code></pre></div><p>注意：上述的 securityManager.sessionManager.sessionDAO = $sessionDAO 作业仅在使用一个本地的 Shiro 会话管理器时才 工作。Web 应用程序默认不会使用本地的会话管理器，而是保持不支持SessionDAO 的 Servlet Container 的默认会话 管理器。如果你想基于 Web 应用程序启用 SessionDAO 来自定义会话存储或会话群集，你将不得不首先配置一个本 地的Web 会话管理器。例如：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span>...<span class="hljs-attr">sessionManager</span> = org.apache.shiro.web.session.mgt.DefaultWebSessionManager<span class="hljs-attr">securityManager.sessionManager</span> = <span class="hljs-variable">$sessionManager</span><span class="hljs-comment"># Configure a SessionDAO and then set it:</span><span class="hljs-attr">securityManager.sessionManager.sessionDAO</span> = <span class="hljs-variable">$sessionDAO</span></code></pre></div><p>Shiro 的默认配置本地 SessionManagers 使用仅内存 Session 存储。这是不适合大多数应用程序的。大多数生产应用程序想要配置提供的 EHCache（见下文）支持或提供自己的SessionDAO 实现。</p><h4 id="EHCache-SessionDAO"><a href="#EHCache-SessionDAO" class="headerlink" title="EHCache SessionDAO"></a>EHCache SessionDAO</h4><p>EHCache 默认是没有启用的，但如果你不打算实现你自己的 SessionDAO，那么强烈地建议你为 Shiro 的 SessionManagerment 启用 EHCache 支持。EHCache SessionDAO 将会在内存中保存会话，并支持溢出到磁盘，若内存成为制约。这对生产程序确保你在运行时不会随机地“丢失”会话是非常好的。</p><p>如果你急需独立的容器会话集群，EHCache 会是一个不错的选择。你可以显式地在 EHCache 之后插入TerraCotta，并拥有一个独立于容器集群的会话缓存。不必再担心 Tomcat，JBoss，Jetty，WebSphere 或WebLogic 特定的会话集群！</p><p>为会话启用 EHCache 是非常容易的。首先，确保在你的 classpath 中有shiro-ehcache-.jar 文件;</p><p>当在 classpath 中后，这第一个 shiro.ini 实例向你演示怎样为所有Shiro 的缓存需要（不只是会话支持）使用 EHCache：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span><span class="hljs-attr">sessionDAO</span> = org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO<span class="hljs-attr">securityManager.sessionManager.sessionDAO</span> = <span class="hljs-variable">$sessionDAO</span><span class="hljs-attr">cacheManager</span> = org.apache.shiro.cache.ehcache.EhCacheManager<span class="hljs-attr">securityManager.cacheManager</span> = <span class="hljs-variable">$cacheManager</span></code></pre></div><p>最后一行，securityManager.cacheManager = $cacheManager，为所有 Shiro 的需要配置了一个 CacheManager。该CacheManager 实例会自动地直接传送到 SessionDAO（通过 EnterpriseCacheSessionDAO 实现 CacheManagerAware 接口的性质）。</p><p>然后，当 SessionManager 要求 EnterpriseCacheSessionDAO 去持久化一个 Session 时，它使用一个 EHCache 支持的 Cache 实现去存储Session 数据。</p><p>注意：Web 应用程序默认使用基于容器的 SessionManager，它不支持 SessionDAO。如果你想在 Web 应用程序中使用基于 EHCache 的会话存储，配置一个 如上所述的 Web SessionManager。</p><h4 id="EHCache-Session-Cache-Configuration"><a href="#EHCache-Session-Cache-Configuration" class="headerlink" title="EHCache Session Cache Configuration"></a>EHCache Session Cache Configuration</h4><p>默认地，EhCacheManager 使用一个 Shiro 特定的 ehcache.xml 文件来建立 Session 缓存区以及确保 Sessions 正常存取的必要设置。</p><p>然而，如果你想改变缓存设置，或想配置你自己的 ehcache.xml 或EHCache net.sf.ehcache.CacheManager 实例，你需要配置缓存区来确保Sessions 被正确地处理。</p><p>如果你查看默认的 ehcache.xml 文件，你会看到接下来的 shiro-activeSessionCache 缓存配置：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"shiro-activeSessionCache"</span></span><span class="hljs-tag">       <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">"10000"</span></span><span class="hljs-tag">       <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">"true"</span></span><span class="hljs-tag">       <span class="hljs-attr">eternal</span>=<span class="hljs-string">"true"</span></span><span class="hljs-tag">       <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">"0"</span></span><span class="hljs-tag">       <span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">"0"</span></span><span class="hljs-tag">       <span class="hljs-attr">diskPersistent</span>=<span class="hljs-string">"true"</span></span><span class="hljs-tag">       <span class="hljs-attr">diskExpiryThreadIntervalSeconds</span>=<span class="hljs-string">"600"</span>/&gt;</span></code></pre></div><p>如果你希望使用你自己的 ehcache.xml 文件，那么请确保你已经为 Shiro 所需的定义了一个类似的缓存项。<br>很有可能 你会改变 maxElementsInMemory 的属性值来吻合你的需要。然而，至少下面两个存在于你自己配置中的属性是非常重要的：</p><ul><li>overflowToDisk=”true” - 这确保当你溢出进程内存时，会话不丢失且能够被序列化到磁盘上。</li><li>eternal=”true” - 确保缓存项（ Session 实例）永不过期或被缓存自动清除。这是很有必要的，因为 Shiro 基于计划过程完成自己的验证。如果我们关掉这项，缓存将会在 Shiro 不知道的情况下清扫这些 Sessions，这可能引起麻烦</li></ul><h4 id="EHCache-Session-Cache-Name"><a href="#EHCache-Session-Cache-Name" class="headerlink" title="EHCache Session Cache Name"></a>EHCache Session Cache Name</h4><p>默认地，EnterpriseCacheSessionDAO 向 CacheManager 寻求一个名为”shiro-activeSessionCache”的 Cache。该缓存的 name/region 将在 ehcache.xml 中配置，如上所述。</p><p>如果你想使用一个不同的名字而不是默认的，你可以在EnterpriseCacheSessionDAO 上配置名字，例如：</p><div class="hljs"><pre><code class="hljs java">[main]...sessionDAO = org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAOsessionDAO.activeSessionsCacheName = myname...</code></pre></div><p>只要确保在 ehcahe.xml 中有一项与名字匹配且你已经配置好了如上所述的 overflowToDisk=”true” 和 eternal=”true”。</p><h2 id="会话集群"><a href="#会话集群" class="headerlink" title="会话集群"></a>会话集群</h2><p>Apache Shiro 会话能力一个非常令人兴奋的事情是,你可以原生的集群 Subject 会话,不需要再担心你的容器环境。也就是说,如果您使用 Shiro 的原生会话并配置一个会话集群,可以部署到 Jetty 和 Tomcat 开发环境,JBoss 或 Geronimo 的生产环境,或任何其他环境，不用担心容器/特定于环境的集群安装或配置。 Shiro 会话集群配置一次，无论您的部署环境如何，都能正常运行</p><p>因为 Shiro 的基于 pojo 的 n 层体系结构,使会话集群的集群机制非常简单,使会话持久性的水平。 也就是说,如果您配置集群 SessionDAO ,DAO 可以与集群交互机制, Shiro 的 SessionManager 不需要知道集群的问题。</p><h2 id="Sessions和Subject状态"><a href="#Sessions和Subject状态" class="headerlink" title="Sessions和Subject状态"></a>Sessions和Subject状态</h2><h3 id="有状态"><a href="#有状态" class="headerlink" title="有状态"></a>有状态</h3><p>默认地，Shiro 的SecurityManager 实现使用一个Subject 的Session 作为一种策略来为接下来的引用存储Subject 的身份 ID（PrincipalCollection）和验证状态（subject.isAuthenticated()）。这通常发生在一个Subject 登录后或当一个 Subject 的身份 ID 通过Remember 服务被发现后。</p><p>这个默认的方法有几个好处:</p><ul><li>任何服务于请求，调用或消息的应用程序可以用请求/调用/消息的有效载荷关联会话ID，且这是Shiro 用入站<br>请求关联用户所有所必须的。例如，如果使用Subject.Builder，这是需要获取相关的Subject 所需的一切：</li></ul><div class="hljs"><pre><code class="hljs java">Serializable sessionId = <span class="hljs-comment">//get from the inbound request or remotemethod invocation payload Subject </span>requestSubject = <span class="hljs-keyword">new</span> Subject.Builder().sessionId(sessionId).buildSubject();</code></pre></div><p>这给大多数Web 应用程序及任何编写远程处理或消息框架的人带来了令人难以置信的方便（这事实上是Shiro 的Web 支持在自己的框架代码内关联Subject 和ServletRequest）。</p><ul><li>任何”RememberMe”身份基于一个能够在第一次访问就能持久化到会话的初始请求。这确保了Subject 被记住的身份可以跨请求保存而不需要反序列化及将它解释到每个请求。例如，在一个 Web 应用程序中，没有必要去读取每一个请求的加密RememberMe Cookie，如果该身份在会话中是已知的。这可是一个很好的性能提升。</li></ul><h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>虽然上述的默认策略对于大多数应用程序而言是很好的（通常是可取的），但这对于尝试尽可能无状态的应用程序来说是不合适的。许多无状态的架构规定在请求中不能存在持久状态，这种情况下的 Sessions 不会被允许（一个会话其本质代表了持久状态）。</p><p>但这一要求带来一个便利的代价—— Subject 状态不能跨请求保留。这意味着有这一要求的应用程序必须确保 Subject 状态可以在每一个请求中以其他的方式代表。</p><p>这几乎总是通过验证每个由应用程序处理的请求/调用/消息来完成的。例如，大多数无状态 Web 应用程序通常支持这一点通过执行 HTTP 基本验证，允许浏览器验证每一个代表最终用户的请求。</p><h3 id="一个混合的方法"><a href="#一个混合的方法" class="headerlink" title="一个混合的方法"></a>一个混合的方法</h3><p>如果你想使用混合的方法呢？如果某些对象应该有会话而某些没有？这种混合法方法能够给许多应用程序带来好处。例如：</p><ul><li>也许 human Subject（如 Web 浏览器用户）由于上面提供的好处能够使用Session。</li><li>也许non-human Subject（如 API 客户端或第三方应用程序）不应该创建session 由于它们与软件的交互可能会间歇或不稳定。</li><li>也许所有某种确定类型的 Subject 或从某一确定位置访问系统的应该将状态保持在会话中，但所有其他的不应该。如果你需要这个混合方法，你可以实现一个 SessionStorageEvaluator。</li></ul><h4 id="SessionStorageEvaluator"><a href="#SessionStorageEvaluator" class="headerlink" title="SessionStorageEvaluator"></a>SessionStorageEvaluator</h4><p>在你想究竟控制哪个 Subject 能够在它们的 Session 中保存它们的状态的情况下，你可以实现<code>org.apache.shiro.mgt.SessionStorageEvaluator</code> 接口，并告诉Shiro 哪个 Subject 支持会话存储。</p><p>该接口只有一个方法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SessionStorageEvaluator</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSessionStorageEnabled</span><span class="hljs-params">(Subject subject)</span></span>;&#125;</code></pre></div><p>关于更详细的API 说明，请参见 SessionStorageEvaluator 的JavaDoc。 你可以实现这一接口，并检查 Subject，为了你可能做出这一决定的任何信息</p><h4 id="Subject-Inspection"><a href="#Subject-Inspection" class="headerlink" title="Subject Inspection"></a>Subject Inspection</h4><p>但实现 isSessionStorageEnabled(subject)接口方法时，你可以一直查看 Subject 并访问任何你需要用来作出决定的东西。</p><p>当然所有期望的 Subject 方法都是可用的（gePrincipals()等），但特定环境的 Subject 实例也是有价值的。</p><p>例如，在 Web 应用程序中，如果该决定必须基于当前 ServletRequest 中的数据，你可以获取该 request 或该 response，因为运行时的Subjce 实例实际上就是一个 WebSubject 实例：</p><div class="hljs"><pre><code class="hljs java">...<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSessionStorageEnabled</span><span class="hljs-params">(Subject subject)</span> </span>&#123;    <span class="hljs-keyword">boolean</span> enabled = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">if</span> (WebUtils.isWeb(Subject)) &#123;        HttpServletRequest request = WebUtils.getHttpRequest(subject);        <span class="hljs-comment">//set 'enabled' based on the current request.</span>    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//not a web request - maybe a RMI or daemon invocation?</span>        <span class="hljs-comment">//set 'enabled' another way...</span>    &#125;    <span class="hljs-keyword">return</span> enabled;&#125;</code></pre></div><p>N.B.框架开发人员应该考虑到这种类型的访问，并确保任何请求/调用/消息上下文对象可用是同过特定环境下的 Subject 实现的。联系 Shiro 用户邮件列表，如果你想帮助设置它，为了你的框架/环境。</p><h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><p>在你实现了 SessionStorageEvaluator 接口后，你可以在 shiro.ini 中配置它：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span>...<span class="hljs-attr">sessionStorageEvaluator</span> = com.mycompany.shiro.subject.mgt.MySessionStorageEvaluator<span class="hljs-attr">securityManager.subjectDAO.sessionStorageEvaluator</span> = <span class="hljs-variable">$sessionStorageEvaluator</span>...</code></pre></div><h4 id="Web-Applications"><a href="#Web-Applications" class="headerlink" title="Web Applications"></a>Web Applications</h4><p>通常 Web 应用程序希望在每一个请求的基础上容易地启用或禁用会话的创建，不管是哪个 Subject 正在执行请求。这经常在支持 REST 及Messaging/RMI 构架上使用来产生很好的效果。例如，也许正常的终端用户（使用浏览器的人）被允许创建和使用会话，但远程的 API 客户端使用REST 或 SOAP，不该拥有会话（因为它们在每一个请求上验证， 常见于 REST/SOAP 体系结构）。</p><p>为了支持这种 hybrid/per-request （混合/每次请求）的能力，noSessionCreation 过滤器被添加到 Shiro 的默认“池”g过滤器中，为 Web 应用程序启用的。该过滤器将会阻止在请求期间创建新的会话来保证无状态的体验。在shiro.ini 的[urls]项中，你通常定义该过滤器在所有其它过滤器之前来确保会话永远不会被使用。</p><p>举例：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[urls]</span>.../rest/** = noSessionCreation, authcBasic, ...</code></pre></div><p>这个过滤器允许现有会话的任何会话操作，但不允许在过滤的请求创建新的会话。也就是说，在请求或没有会话存在的Subject 调用下面四个方法中的任何一个时，将会自动地触发一个 DisabledSessionException 异常：</p><ul><li>httpServletRequest.getSession()</li><li>httpServletRequest.getSession(true)</li><li>subject.getSession()</li><li>subject.getSession(true)</li></ul><p>如果一个 Subject 在访问 noSessionCreation-protected-URL（无会话创建保护的 URL） 之前已经有一个会话，则上述的四种调用仍然会如预期工作。</p><p>最后，在所有情况下，下面的调用将始终被允许：</p><ul><li>httpServletRequest.getSession(false)</li><li>subject.getSession(false)</li></ul>]]></content>
    
    
    <categories>
      
      <category>安全框架</category>
      
      <category>Shiro</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shiro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谷粒商城-Day05</title>
    <link href="/2020/06/22/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-Day05/"/>
    <url>/2020/06/22/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-Day05/</url>
    
    <content type="html"><![CDATA[<h1 id="1-测试fastdfs"><a href="#1-测试fastdfs" class="headerlink" title="1.测试fastdfs"></a>1.测试fastdfs</h1><p>在测试前要确保所有服务都已正常开启：</p><blockquote><p>开启tomcat：root@yyj-virtual-machine:/opt/apache-tomcat-8.5.24/bin#<br>./startup.sh </p><p>开启zookeeper： root@yyj-virtual-machine:/opt/zookeeper-3.4.11/bin#<br>./zkServer.sh start<br>root@yyj-virtual-machine:/opt/zookeeper-3.4.11/bin# ./zkServer.sh<br>status</p><p>开启nginx： root@yyj-virtual-machine:/usr/local/nginx/sbin# ./nginx</p><p>启动tracker和storage sudo service fdfs_trackerd start sudo service<br>fdfs_trackerd status</p></blockquote><ol><li>在opt目录下新建一个图片文件，我这里是timg.jpg<br><img src="https://img-blog.csdnimg.cn/20200617122635775.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></li><li>执行<code>root@yyj-virtual-machine:/opt# /usr/bin/fdfs_test /etc/fdfs/client.conf upload /opt/timg.jpg</code><br>出现下面的语句说明操作成功：<br><img src="https://img-blog.csdnimg.cn/20200617122814386.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></li><li>进入<code>/opt/fastdfs/data/00/00/</code>路径下(这里是文件上传后保存的路径)，执行<code>ls</code>:<br><img src="https://img-blog.csdnimg.cn/20200617123044426.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>说明文件确实上传成功了。</li><li>因为fastdfs本身不是http服务器，所以无法处理http协议的web请求，因此上面两个url直接在浏览器上访问是没办法看到效果的。</li></ol><h2 id="安装fdfs整合nginx的插件"><a href="#安装fdfs整合nginx的插件" class="headerlink" title="安装fdfs整合nginx的插件"></a>安装fdfs整合nginx的插件</h2><ol><li>解压插件：<code>root@yyj-virtual-machine:/opt# tar -zxvf fastdfs-nginx-module_v1.16.tar.gz</code></li><li>进入解压文件的src目录下，有两个配置文件：<br><img src="https://img-blog.csdnimg.cn/20200617124318126.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>第一个config是它自身的配置文件，第二个是需要拷贝到/etc/fdfs下的配置文件。</li><li>先修改自身的配置文件：<code>vi config</code><br><img src="https://img-blog.csdnimg.cn/20200617124742523.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>将这里的两处地方改一下，去掉local即可。</li><li>将第二个配置文件拷贝到/etc/fdfs/目录下：<code>root@yyj-virtual-machine:/opt/fastdfs-nginx-module/src# cp mod_fastdfs.conf /etc/fdfs/</code><br>然后修改/etc/fdfs/路径下的该配置文件：<br><code>root@yyj-virtual-machine:/etc/fdfs# vi mod_fastdfs.conf</code><br>有四处地方需要修改：</li></ol><div class="hljs"><pre><code class="hljs vi">#软件安装目录base_path&#x3D;&#x2F;opt&#x2F;fastdfs#Web的url是否包含group的路径名url_have_group_name &#x3D; true#Tracker_server地址tracker_server&#x3D;192.168.37.132:22122#上传文件地址store_path0&#x3D;&#x2F;opt&#x2F;fastdfs&#x2F;fdfs_storage</code></pre></div><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><ol><li><p>解压nginx安装包<br><code>root@yyj-virtual-machine:/opt# tar -zxvf nginx-1.12.2.tar.gz</code></p></li><li><p>创建临时的目录/var/temp/nginx/client<br><code>root@yyj-virtual-machine:/usr/local/nginx/sbin# mkdir -p /var/temp/nginx/client</code></p></li><li><p>进入解压文件夹下，然后将下面命令粘贴运行，用于做web服务器，提供http请求</p></li></ol><div class="hljs"><pre><code class="hljs haml">./configure \-<span class="ruby">-prefix=<span class="hljs-regexp">/usr/local</span><span class="hljs-regexp">/nginx \</span></span><span class="ruby">--pid-path=<span class="hljs-regexp">/var/run</span><span class="hljs-regexp">/nginx/nginx</span>.pid \</span><span class="ruby">--lock-path=<span class="hljs-regexp">/var/lock</span><span class="hljs-regexp">/nginx.lock \</span></span><span class="ruby">--error-log-path=<span class="hljs-regexp">/var/log</span><span class="hljs-regexp">/nginx/error</span>.log \</span><span class="ruby">--http-log-path=<span class="hljs-regexp">/var/log</span><span class="hljs-regexp">/nginx/access</span>.log \</span><span class="ruby">--with-http_gzip_static_module \</span><span class="ruby">--http-client-body-temp-path=<span class="hljs-regexp">/var/temp</span><span class="hljs-regexp">/nginx/client</span> \</span><span class="ruby">--http-proxy-temp-path=<span class="hljs-regexp">/var/temp</span><span class="hljs-regexp">/nginx/proxy</span> \</span><span class="ruby">--http-fastcgi-temp-path=<span class="hljs-regexp">/var/temp</span><span class="hljs-regexp">/nginx/fastcgi</span> \</span><span class="ruby">--http-uwsgi-temp-path=<span class="hljs-regexp">/var/temp</span><span class="hljs-regexp">/nginx/uwsgi</span> \</span><span class="ruby">--http-scgi-temp-path=<span class="hljs-regexp">/var/temp</span><span class="hljs-regexp">/nginx/scgi</span> \</span><span class="ruby">--add-<span class="hljs-class"><span class="hljs-keyword">module</span>=/<span class="hljs-title">opt</span>/<span class="hljs-title">fastdfs</span>-<span class="hljs-title">nginx</span>-<span class="hljs-title">module</span>/<span class="hljs-title">src</span></span></span></code></pre></div><p><strong>这里有个坑。</strong>（–pid-path=/var/run/nginx/nginx.pid \）因为IP没有设置为静态IP，所以后面IP可能会变。<br>可以参考下面几篇文章进行解决：1、<a href="https://blog.csdn.net/qq_36937342/article/details/80876385?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/qq_36937342/article/details/80876385?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a><br><a href="https://blog.csdn.net/qq_42975842/article/details/81705244?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">2、https://blog.csdn.net/qq_42975842/article/details/81705244?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a><br>4. 执行make，make install指令<br><code>root@yyj-virtual-machine:/opt/nginx-1.12.2# make</code><br><code>root@yyj-virtual-machine:/opt/nginx-1.12.2# make install</code><br>5. 修改nginx.conf<br><code>vi /usr/local/nginx/conf/nginx.conf</code><br><img src="https://img-blog.csdnimg.cn/20200617132520590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>6. 启动nginx</p><div class="hljs"><pre><code class="hljs java">root@yyj-virtual-machine:/usr/local/nginx/sbin# ./nginx./nginx: error <span class="hljs-keyword">while</span> loading shared libraries: libfdfsclient.so: cannot open shared object file: No such file or directory</code></pre></div><p>如果有上面的报错，解决办法：</p><div class="hljs"><pre><code class="hljs java">root@yyj-virtual-machine:/usr/lib64# cp libfdfsclient.so  /usr/lib</code></pre></div><p>再次启动nginx</p><div class="hljs"><pre><code class="hljs java">root@yyj-virtual-machine:/usr/local/nginx/sbin# ./nginxngx_http_fastdfs_set pid=<span class="hljs-number">55777</span></code></pre></div><p>一切正常，此时浏览器访问之前上传图片的http：<br><img src="https://img-blog.csdnimg.cn/20200617154756420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="nginx集群"><a href="#nginx集群" class="headerlink" title="nginx集群"></a>nginx集群</h1><p>一个tracker可以有很多storage，如果要有多个tracker，可以用nginx实现负载均衡。</p><h1 id="nginx整合SpringBoot"><a href="#nginx整合SpringBoot" class="headerlink" title="nginx整合SpringBoot"></a>nginx整合SpringBoot</h1><h2 id="1-通过git下载fdfs的客户端"><a href="#1-通过git下载fdfs的客户端" class="headerlink" title="1.通过git下载fdfs的客户端"></a>1.通过git下载fdfs的客户端</h2><p><a href="https://github.com/happyfish100/fastdfs-client-java" target="_blank" rel="noopener">https://github.com/happyfish100/fastdfs-client-java</a></p><h2 id="2-将fdfs的客户端打包到本地maven仓库中"><a href="#2-将fdfs的客户端打包到本地maven仓库中" class="headerlink" title="2.将fdfs的客户端打包到本地maven仓库中"></a>2.将fdfs的客户端打包到本地maven仓库中</h2><p><img src="https://img-blog.csdnimg.cn/20200617155930255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>导入maven工程<br><img src="https://img-blog.csdnimg.cn/20200617160332499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>然后在gmall-manage-web模块下的pom文件中引入fastdfs的依赖。</p><div class="hljs"><pre><code class="hljs pom">&lt;dependency&gt;     &lt;groupId&gt;org.csource&lt;&#x2F;groupId&gt;     &lt;artifactId&gt;fastdfs-client-java&lt;&#x2F;artifactId&gt;     &lt;version&gt;1.29-SNAPSHOT&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;</code></pre></div><p>实现spu图片的上传工具类PmsUploadUtil.java</p><p>spu保存涉及到的数据结构<br>Pms_product_info<br>Pms_product_image<br>Pms_product_sale_attr<br>Pms_procuct_sale_attr_value<br>Pms_base_sale_attr</p><p>sku管理功能<br>Pms_Sku_info<br>Pms_sku_image(从已经添加的spu的图片库中选择，当前sku涉及的图片)<br>Pms_Sku_attr_value<br>Pms_Sku_sale_attr_value_<br>当前sku所关联的平台属性中间表</p><p>平台属性和销售属性的区别：<br>平台属性属于所有商品，由电商网站维护管理<br>销售属性属于商家，由商家来维护管理</p><p> 添加sku<br>1 平台属性列表(平台属性+平台属性值双层集合)<br><a href="http://127.0.0.1:8081/attrInfoList?catalog3Id=61" target="_blank" rel="noopener">http://127.0.0.1:8081/attrInfoList?catalog3Id=61</a></p><p>2 销售属性列表<br><a href="http://127.0.0.1:8081/spuSaleAttrList?spuId=24" target="_blank" rel="noopener">http://127.0.0.1:8081/spuSaleAttrList?spuId=24</a></p><p>3 spu的图片列表<br><a href="http://127.0.0.1:8081/spuImageList?spuId=24" target="_blank" rel="noopener">http://127.0.0.1:8081/spuImageList?spuId=24</a></p><p>4 保存spu信息<br><a href="http://127.0.0.1:8081/saveSkuInfo" target="_blank" rel="noopener">http://127.0.0.1:8081/saveSkuInfo</a></p><p>5 保存skuInfo<br>新建controller、service、mapper，增删改查。。。</p><h1 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1><p>今天的主要内容还是前面配置环境，后面涉及到代码部分的建议直接看代码来理解是如何将数据传给前端的。<br>代码仓库：<a href="https://github.com/gavin-yyj/gmall" target="_blank" rel="noopener">https://github.com/gavin-yyj/gmall</a></p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer-最小的k个数</title>
    <link href="/2020/06/22/%E5%89%91%E6%8C%87Offer-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
    <url>/2020/06/22/%E5%89%91%E6%8C%87Offer-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.gavin.demo;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">import</span> java.util.PriorityQueue;<span class="hljs-keyword">import</span> java.util.Queue;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: gavin</span><span class="hljs-comment"> * <span class="hljs-doctag">@GitHub</span>: https://github.com/gavin-yyj</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: Created in 21:48 2020/6/21</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 剑指Offer系列</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 面试题40：最小的K个数</span><span class="hljs-comment">     * 题目描述：输入整数数组 arr ，找出其中最小的 k 个数。</span><span class="hljs-comment">     * 例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</span><span class="hljs-comment">     */</span>    <span class="hljs-comment">/**方法一：快速排序*/</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getLeastNumbers(<span class="hljs-keyword">int</span>[]arr,<span class="hljs-keyword">int</span> k)&#123;        <span class="hljs-comment">//特排</span>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span> || arr.length == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr.length &lt;= k)&#123;            <span class="hljs-keyword">return</span> arr;        &#125;        <span class="hljs-comment">//原地不断划分数组</span>        partitionArray(arr,<span class="hljs-number">0</span>,arr.length-<span class="hljs-number">1</span>,k);        <span class="hljs-comment">//数组的前k个数就是最小的k个数，将其输出即为答案</span>        <span class="hljs-keyword">return</span> Arrays.copyOf(arr,k);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">partitionArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-comment">//做一次partition操作,得到当前分界点所在的下标</span>        <span class="hljs-keyword">int</span> m = partition(arr,lo,hi);        <span class="hljs-keyword">if</span>(m == k)&#123;            <span class="hljs-comment">//正好找到最小的k个数</span>            <span class="hljs-keyword">return</span>;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k &lt; m)&#123;            <span class="hljs-comment">//最小的k个数一定在前m个数中</span>            partitionArray(arr,lo,m-<span class="hljs-number">1</span>,k);        &#125;<span class="hljs-keyword">else</span> &#123;            partitionArray(arr,m+<span class="hljs-number">1</span>,hi,k);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = lo;        <span class="hljs-keyword">int</span> j = hi + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> v = arr[lo];        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;            <span class="hljs-keyword">while</span>(arr[--j] &gt; v)&#123;                <span class="hljs-keyword">if</span>(j == lo)&#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-keyword">while</span>(arr[++i] &lt; v)&#123;                <span class="hljs-keyword">if</span>(i == hi)&#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span>(i &gt;= j)&#123;                <span class="hljs-keyword">break</span>;            &#125;            swap(arr,i,j);        &#125;        swap(arr,lo,j);        <span class="hljs-keyword">return</span> j;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    &#125;    <span class="hljs-comment">/**方法二：大根堆(前 K 小) / 小根堆（前 K 大)*/</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getLeastNumbers2(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> k)&#123;        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        &#125;        <span class="hljs-comment">//使用一个最大堆（大顶堆）</span>        <span class="hljs-comment">//Java的PriorityQueue默认是小顶堆，添加comparator参数使其变成最大堆</span>        Queue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(k,(o1,o2)-&gt;Integer.compare(o2,o1));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a:arr)&#123;            <span class="hljs-comment">//当前数字小于堆顶元素才会入堆</span>            <span class="hljs-keyword">if</span>(maxHeap.isEmpty() || maxHeap.size() &lt; k || maxHeap.peek() &gt; a)&#123;                maxHeap.offer(a);            &#125;            <span class="hljs-comment">//如果当前堆的大小大于k，则删除堆顶最大元素</span>            <span class="hljs-keyword">if</span>(maxHeap.size() &gt; k)&#123;                maxHeap.poll();            &#125;        &#125;        <span class="hljs-comment">//将堆中的元素存入数组</span>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[maxHeap.size()];        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> e:maxHeap)&#123;            res[j++] = e;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;;        <span class="hljs-keyword">int</span>[] leastNumbers = getLeastNumbers(arr, <span class="hljs-number">4</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; leastNumbers.length; i++) &#123;            System.out.print(arr[i]);        &#125;    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;;        <span class="hljs-keyword">int</span>[] leastNumbers = getLeastNumbers2(arr, <span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; leastNumbers.length; i++) &#123;            System.out.print(leastNumbers[i]);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谷粒商城-Day04</title>
    <link href="/2020/06/21/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-Day04/"/>
    <url>/2020/06/21/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-Day04/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构的复习"><a href="#数据结构的复习" class="headerlink" title="数据结构的复习"></a>数据结构的复习</h1><ol><li>spu和sku的概念<br>spu：标准的商品单元（standard product unit），XX系列<br>sku：存库存储单元，单位为件，台，部，盒（stock keep unit）</li><li>spu和sku之间的关系<br>从范围上来说spu包含sku，spu表和sku表是一对多的关系</li><li>什么是平台属性，有哪些相关的表<br>平台属性和平台属性值是由平台指定的，主要用于商品的检索，每个三级分类下的属性值都不同。<br>每个商品对应的每种属性都有对应的属性值。<br><img src="https://img-blog.csdnimg.cn/20200617105330997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>由两张表组成：pms_base_attr_info(平台属性表) pms_base_attr_value(平台属性值表)</li><li>平台属性和商品分类、商品之间的关系<br>平台属性在某个商品分类下，一个属性下包含多个商品。</li></ol><h1 id="商品spu功能介绍"><a href="#商品spu功能介绍" class="headerlink" title="商品spu功能介绍"></a>商品spu功能介绍</h1><p>商品分类与商品属性和商品的spu是一对多的关系，商品分类下包含多个商品属性，也会包含多个商品的spu；<br>商品的spu + 商品的销售属性 = 商品的sku<br>xxx系列 + 红色,64G,… = xxx具体产品</p><p>数据结构：<br><img src="https://img-blog.csdnimg.cn/20200621002813608.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="分布式文件存储（fastdfs）"><a href="#分布式文件存储（fastdfs）" class="headerlink" title="分布式文件存储（fastdfs）"></a>分布式文件存储（fastdfs）</h1><p><img src="https://img-blog.csdnimg.cn/20200617113922681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="配置虚拟机环境"><a href="#配置虚拟机环境" class="headerlink" title="配置虚拟机环境"></a>配置虚拟机环境</h2><div class="hljs"><pre><code class="hljs markdown">sudo apt-get install libpcre3 libpcre3-dev -ysudo apt-get install openssl libssl-dev -ysudo apt-get install unzip -ysudo apt-get install libpcre3 libpcre3-dev -ysudo apt-get install zlib1g zlib1g-dev -ysudo apt-get install gcc -y</code></pre></div><p>如果出现下面类似错误：<br><img src="https://img-blog.csdnimg.cn/20200617114350592.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>参考这篇文章：<a href="https://blog.csdn.net/zally_1994/article/details/84566171" target="_blank" rel="noopener">https://blog.csdn.net/zally_1994/article/details/84566171</a></p><h2 id="fastdfs软件"><a href="#fastdfs软件" class="headerlink" title="fastdfs软件"></a>fastdfs软件</h2><p>配置tracker<br>配置storage<br>(依赖于：Gcc、libevent、perl)<br>A新建目录mkdir /opt/fastdfs<br>B解压FastDFS_v5.05.tar.gz到/usr/local<br>C进入解压目录cd  FastDFS<br>D./make.sh<br>E./make.sh install<br>F进入conf配置目录将文件都拷贝到/etc/fdfs下cp  *  /etc/fdfs/（安装时自动生成）<br>G进入/etc/fdfs/，配置tracker.conf<br>vim /etc/fdfs/tracker.conf ，设置软件数据和日志目录<br><img src="https://img-blog.csdnimg.cn/20200621003247679.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>H storage的配置(storage不需要安装，因为安装tracker时已经同时安装)<br>vim /etc/fdfs/storage.conf<br>软件目录<br><img src="https://img-blog.csdnimg.cn/20200621003258992.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Storage存储文件的目录（新建mkdir /opt/fastdfs/fdfs_storage）<br><img src="https://img-blog.csdnimg.cn/20200621003322506.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Storage的trackerip<br><img src="https://img-blog.csdnimg.cn/20200621003333328.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>3 配置tracker和storage的启动服务<br>进入/etc/init.d启动脚本目录，默认fastdfs已经生成<br><img src="https://img-blog.csdnimg.cn/20200621003346475.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Vi fdfs_trackerd脚本文件<br><img src="https://img-blog.csdnimg.cn/20200621003356841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200621003404283.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>mkdir /usr/local/fdfs（因为启动脚本还在安装目录下，所以我们新建/usr/local/fdfs目录，并且将启动脚本cp到该目录）<br>进入安装目录/opt/FastDFs<br>cp restart.sh  /usr/local/fdfs/<br>cp stop.sh  /usr/local/fdfs/</p><p>配置storage启动服务(restart和stop脚本已经拷贝到/usr/local/fdfs下，所以storage只需要配置/etc/init.d/fdfs_storage脚本就可以了)<br><img src="https://img-blog.csdnimg.cn/20200621003428691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200621003433491.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>将启动脚本加入linux服务<br>sudo service fdfs_trackerd start<br>如若报错，使用：/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf start<br>sudo service fdfs_storaged start<br>如若报错，使用：/usr/bin/fdfs_storaged /etc/fdfs/storage.conf start<br>参考：<a href="https://blog.csdn.net/Lan_cer/article/details/86744333" target="_blank" rel="noopener">https://blog.csdn.net/Lan_cer/article/details/86744333</a></p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>shiro系列-1.总览</title>
    <link href="/2020/06/21/shiro%E7%B3%BB%E5%88%97-1-%E6%80%BB%E8%A7%88/"/>
    <url>/2020/06/21/shiro%E7%B3%BB%E5%88%97-1-%E6%80%BB%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><h2 id="什么是shiro？"><a href="#什么是shiro？" class="headerlink" title="什么是shiro？"></a>什么是shiro？</h2><p>Apache Shiro是一个功能强大、灵活的，开源的安全框架。它可以干净利落地处理<strong>身份验证</strong>、<strong>授权</strong>、<strong>企业会话管理</strong>和<strong>加密</strong>。<br>shiro能做什么？</p><ul><li>验证身份</li><li>用户访问权限控制，比如：<ul><li>判断用户是否分配了一定的安全角色；</li><li>判断用户是否被授予完成某个操作的权限；</li></ul></li><li>在非 web 或 EJB 容器的环境下可以任意使用Session API</li><li>可以响应认证、访问控制、或者Session生命周期中发生的事件</li><li>可以将一个或以上的用户安全数据源数据整合成一个复合的用户“view”（视图）</li><li>支持单点登录（SSO）功能</li><li>支持提供“Remember Me”服务，获取用户关联信息而无需登录</li><li>…<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><img src="https://img-blog.csdnimg.cn/20200619155347749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Authentication（认证）, Authorization（授权）, Session Management（会话管理）, Cryptography（加密）被 Shiro 框架的开发团队称之为应用安全的四大基石。</li><li><strong>Authentication（认证）</strong>：用户身份识别，通常被称为用户“登录”；</li><li><strong>Authorization（授权）</strong>：访问控制，比如某个用户是否具有每个操作的使用权限；</li><li><strong>Session Management（会话管理）</strong>：特定于用户的会话管理，甚至在非web或EJB应用程序；</li><li><strong>Cryptography（加密）</strong>：在对数据源使用加密算法加密的同时，保证易于使用；<br>还提供以下支持：</li><li>web支持：shiro提供的web支持api，可以很轻松的保护web应用程序的安全；</li><li>缓存：缓存是Apache shiro保证安全操作快速、高效的重要手段；</li><li>并发：支持多线程应用程序的并发特性；</li><li>测试：支持单元测试和集成测试，确保代码和预想的一样安全；</li><li>Run As：这个功能允许用户采用其他用户的身份（在许可的前提下），有时在管理方案中很有用；</li><li>Remember Me：跨session记录用户的身份，只有在强制需要时用户才需要登录；</li></ul><h1 id="2-教程"><a href="#2-教程" class="headerlink" title="2 教程"></a>2 教程</h1><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><ul><li>Java1.5及以上</li><li>Maven2.2.1及以上<h2 id="创建shiro-tutorial工程"><a href="#创建shiro-tutorial工程" class="headerlink" title="创建shiro-tutorial工程"></a>创建shiro-tutorial工程</h2>建议先去github上创建一个项目，然后在该项目下创建shiro-tutorial模块。<h3 id="引入pom-xml依赖"><a href="#引入pom-xml依赖" class="headerlink" title="引入pom.xml依赖"></a>引入pom.xml依赖</h3></li></ul><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.gavin.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-tutorial<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.6<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.6<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>$&#123;project.build.sourceEncoding&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-comment">&lt;!-- This plugin is only to test run our little application.  It is not</span><span class="hljs-comment">                 needed in most Shiro-enabled applications: --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.mojo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>exec-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>                        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">classpathScope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">classpathScope</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>Tutorial<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- Shiro uses SLF4J for logging.  We'll use the 'simple' binding</span><span class="hljs-comment">             in this example app.  See http://www.slf4j.org for more info. --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><h3 id="创建Tutorial-java文件"><a href="#创建Tutorial-java文件" class="headerlink" title="创建Tutorial.java文件"></a>创建Tutorial.java文件</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tutorial</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> Logger log = LoggerFactory.getLogger(Tutorial<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        log.info(<span class="hljs-string">"我的第一个shiro应用"</span>);        System.exit(<span class="hljs-number">0</span>);    &#125;&#125;</code></pre></div><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p>在项目根目录下执行<code>mvn compile exec:java</code>，出现下面的打印输出就说明程序运行成功。<br><img src="https://img-blog.csdnimg.cn/20200619195549311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="使用shiro"><a href="#使用shiro" class="headerlink" title="使用shiro"></a>使用shiro</h2><p>在使用shiro之前要理解一件事情就是：shiro几乎所有事情都和一个中心组件SecurityManager有关（这里的SecurityManager跟java.lang.SecurityManager是两码事）。后面会详细说明shiro的设计，这里只是让读者有个概念，每个程序都必定会存在一个SecurityManager。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>通过配置文件的方式来实现对SecurityManager的配置，Shiro默认提供了一个基本的INI配置文件的方案，当然也可以使用XML,YAML,JSON,Groovy Builder markup等多种形式来配置。</p><h4 id="shiro-ini"><a href="#shiro-ini" class="headerlink" title="shiro.ini"></a>shiro.ini</h4><p>在pom.xml同目录中创建一个src/main/resources子目录，在该子目录下创建一个shiro.ini文件，内容如下：</p><div class="hljs"><pre><code class="hljs text"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;# Tutorial INI configuration## Usernames&#x2F;passwords are based on the classic Mel Brooks&#39; film &quot;Spaceballs&quot; :)# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;# -----------------------------------------------------------------------------# Users and their (optional) assigned roles# username &#x3D; password, role1, role2, ..., roleN# -----------------------------------------------------------------------------[users]root &#x3D; secret, adminguest &#x3D; guest, guestpresidentskroob &#x3D; 12345, presidentdarkhelmet &#x3D; ludicrousspeed, darklord, schwartzlonestarr &#x3D; vespa, goodguy, schwartz# -----------------------------------------------------------------------------# Roles with assigned permissions# roleName &#x3D; perm1, perm2, ..., permN# -----------------------------------------------------------------------------[roles]admin &#x3D; *schwartz &#x3D; lightsaber:*goodguy &#x3D; winnebago:drive:eagle5</code></pre></div><p>可以看到，在该配置文件中仅仅配置了几个静态的账户，后面会使用更复杂的用户数据，比如：数据库、LDAP【轻型目录访问协议】和活动目录等。</p><h3 id="引用配置"><a href="#引用配置" class="headerlink" title="引用配置"></a>引用配置</h3><p>接下来创建SecurityManager实例，用来引用INI文件，这里只需在main函数中进行处理即可。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tutorial</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> Logger log = LoggerFactory.getLogger(Tutorial<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        log.info(<span class="hljs-string">"我的第一个shiro应用"</span>);        <span class="hljs-comment">/** 1.从指定路径加载配置文件 */</span>        IniSecurityManagerFactory factory = <span class="hljs-keyword">new</span> IniSecurityManagerFactory(<span class="hljs-string">"classpath:shiro.ini"</span>);        <span class="hljs-comment">/** 2. 分析INI文件，并根据配置文件返回一个SecurityManager实例 */</span>        SecurityManager securityManager = factory.getInstance();        <span class="hljs-comment">/** 3. 将 SecurityManager 设置成了static (memory) singleton，可以通过 JVM 访问 */</span>        SecurityUtils.setSecurityManager(securityManager);        System.exit(<span class="hljs-number">0</span>);    &#125;&#125;</code></pre></div><p>这就是我们要做的–仅仅使用三行代码就把Shiro加进了我们的程序，就是这么简单。</p><p>执行mvn compile exec:java 可以看到程序成功的运行（由于 Shiro 默认在 debug 或更底层才记录日志，所以你不会看到任何 Shiro 的日志输出–只要运行时没有错误提示，你就可以知道已经成功了）。</p><p>上面所加入的代码做了下面的事情：</p><p>使用 Shiro 的 IniSecurityManagerFactory 加载了我们的shiro.ini 文件，该文件存在于 classpath 根目录里。这个执行动作反映出 shiro 支持 Factory Method Design Pattern（工厂模式）。classpath：资源的指示前缀，告诉 shiro 从哪里加载 ini 文件（其它前缀，如 url:和 file: 也被支持）。<br>2.factory.getInstance() 方法被调用，该方法分析 INI 文件并根据配置文件返回一个 SecurityManager 实例。</p><p>3.在这个简单示例中，我们将 SecurityManager 设置成了static (memory) singleton，可以通过 JVM 访问，注意如果你在一个 JVM 中加载多个使用 shiro 的程序时不要这样做，在这个简单示例中，这是可以的，但在其它成熟的应用环境中，通常会将 SecurityManager 放在程序指定的存储中（如在 web 中的 ServletContext 或者 Spring、Guice、 JBoss DI 容器实例）中。</p><h3 id="执行安全操作"><a href="#执行安全操作" class="headerlink" title="执行安全操作"></a>执行安全操作</h3><p>准备好SecurityManager后，可以开始进行我们真正关心的事情了–执行安全操作。<br>其实也就是两个问题：“谁是当前的用户？”，“当前用户是否允许做某件事？”，Shiro的API给当前用户定义了一个新的名词，即“<strong>Subject</strong>”。<br>在几乎所有的环境中，都可以通过如下语句得到当前用户的信息：</p><div class="hljs"><pre><code class="hljs java">Subject currentUser = SecurityUtils.getSubject();</code></pre></div><p>Subject是一个安全术语，意思是“当前运行用户的指定安全视图”，不仅仅局限于一个人，也可以是第三方进程、时钟守护任务、守护进程账户或者其他，可以简单理解为“当前和软件进行交互的事件”。</p><p>在一个独立的程序中调用 getSubject() 会在程序指定位置返回一个基于用户数据的 Subject，在服务器环境（如 web 程序）中，它将获取一个和当前线程或请求相关的基于用户数据的 Subject。</p><p>在取得了Subject后，我们可以利用它做点什么呢？</p><p>如果你想在应用程序的会话期内给用户提供一些信息，那么我们可以获得他们的session。</p><div class="hljs"><pre><code class="hljs java">Session session = currentUser.getSession();session.setAttribute( <span class="hljs-string">"someKey"</span>, <span class="hljs-string">"aValue"</span> );</code></pre></div><p>Session是shiro指定的一个实例，提供几乎所有的HttpSession功能，但是同时它又不需要HTTP环境，这句话的意思是在非web程序中，我们也能使用上面这段代码，不必考虑发布环境！从此任何需要 session 的程序不再需要强制使用 HttpSession 或者 EJB Stateful Session,并且，终端可以共享 session 数据。</p><p>现在我们获取了一个Subject和它们的Session，可以来搞事情了，比如：检测其是否被允许做某些事情？检查其角色和权限？等等。</p><p>我们只能对已知用户进行检查，上面的Subject实例代表当前用户，但是当前用户是谁？如果是匿名用户，那我们就让他们至少登录一次。下面的代码就是完成这个任务：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ( !currentUser.isAuthenticated() ) &#123;    <span class="hljs-comment">//收集用户的主要信息和凭据，来自GUI中的特定的方式</span>    <span class="hljs-comment">//如包含用户名/密码的HTML表格，X509证书，OpenID，等。</span>    <span class="hljs-comment">//我们将使用用户名/密码的例子因为它是最常见的。</span>    UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(<span class="hljs-string">"lonestarr"</span>, <span class="hljs-string">"vespa"</span>);    <span class="hljs-comment">//支持'remember me' (无需配置，自带的!):</span>    token.setRememberMe(<span class="hljs-keyword">true</span>);    currentUser.login(token);&#125;</code></pre></div><p>如果登录失败呢？那我么就可以捕获所有异常，然后按照自己的方式进行处理：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;    currentUser.login( token );    <span class="hljs-comment">//无异常，说明就是我们想要的!</span>&#125; <span class="hljs-keyword">catch</span> ( UnknownAccountException uae ) &#123;    <span class="hljs-comment">//username 不存在，给个错误提示?</span>&#125; <span class="hljs-keyword">catch</span> ( IncorrectCredentialsException ice ) &#123;    <span class="hljs-comment">//password 不匹配，再输入?</span>&#125; <span class="hljs-keyword">catch</span> ( LockedAccountException lae ) &#123;    <span class="hljs-comment">//账号锁住了，不能登入。给个提示?</span>&#125;     ... 更多类型异常 ...&#125; <span class="hljs-keyword">catch</span> ( AuthenticationException ae ) &#123;    <span class="hljs-comment">//未考虑到的问题 - 错误?</span>&#125;</code></pre></div><p>最简单的方式是将异常信息通过人类可以理解的语言返回给用户，不建议直接输出异常原始信息。</p><p>除此之外，我们还可以做些什么呢？<br>显示当前“用户”的信息</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//打印主要信息 (本例子是 username):</span>log.info( <span class="hljs-string">"User ["</span> + currentUser.getPrincipal() + <span class="hljs-string">"] logged in successfully."</span> );</code></pre></div><p>也可以判断它们是否拥有某个角色；</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ( currentUser.hasRole( <span class="hljs-string">"schwartz"</span> ) ) &#123;    log.info(<span class="hljs-string">"May the Schwartz be with you!"</span> );&#125; <span class="hljs-keyword">else</span> &#123;    log.info( <span class="hljs-string">"Hello, mere mortal."</span> );&#125;</code></pre></div><p>还可以判断它们是否拥有某个特定动作或入口的权限；</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ( currentUser.isPermitted( <span class="hljs-string">"lightsaber:weild"</span> ) ) &#123;    log.info(<span class="hljs-string">"You may use a lightsaber ring.  Use it wisely."</span>);&#125; <span class="hljs-keyword">else</span> &#123;    log.info(<span class="hljs-string">"Sorry, lightsaber rings are for schwartz masters only."</span>);&#125;</code></pre></div><p>同样，我们还可以执行非常强大的instance-level（实例级别）的权限检测，检测用户是否具备访问某个类型特定实例的权限：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ( currentUser.isPermitted( <span class="hljs-string">"winnebago:drive:eagle5"</span> ) ) &#123;    log.info(<span class="hljs-string">"You are permitted to 'drive' the 'winnebago' with license plate (id) 'eagle5'.  "</span> +                <span class="hljs-string">"Here are the keys - have fun!"</span>);&#125; <span class="hljs-keyword">else</span> &#123;    log.info(<span class="hljs-string">"Sorry, you aren't allowed to drive the 'eagle5' winnebago!"</span>);&#125;</code></pre></div><p>最后，当用记不再使用系统，可以退出登录：</p><div class="hljs"><pre><code class="hljs java">currentUser.logout(); <span class="hljs-comment">//清除识别信息，设置 session 失效.</span></code></pre></div><h3 id="最终的class"><a href="#最终的class" class="headerlink" title="最终的class"></a>最终的class</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.shiro.SecurityUtils;<span class="hljs-keyword">import</span> org.apache.shiro.authc.*;<span class="hljs-keyword">import</span> org.apache.shiro.config.IniSecurityManagerFactory;<span class="hljs-keyword">import</span> org.apache.shiro.mgt.SecurityManager;<span class="hljs-keyword">import</span> org.apache.shiro.session.Session;<span class="hljs-keyword">import</span> org.apache.shiro.subject.Subject;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: gavin</span><span class="hljs-comment"> * <span class="hljs-doctag">@GitHub</span>: https://github.com/gavin-yyj</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: Created in 19:48 2020/6/19</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tutorial</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> Logger log = LoggerFactory.getLogger(Tutorial<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        log.info(<span class="hljs-string">"我的第一个shiro应用"</span>);        <span class="hljs-comment">//1.从指定路径加载配置文件</span>        IniSecurityManagerFactory factory = <span class="hljs-keyword">new</span> IniSecurityManagerFactory(<span class="hljs-string">"classpath:shiro.ini"</span>);        <span class="hljs-comment">// 2. 分析INI文件，并根据配置文件返回一个SecurityManager实例</span>        SecurityManager securityManager = factory.getInstance();        <span class="hljs-comment">// 3. 将 SecurityManager 设置成了static (memory) singleton，可以通过 JVM 访问</span>        SecurityUtils.setSecurityManager(securityManager);        <span class="hljs-comment">//获取当前执行的用户</span>        Subject currentUser = SecurityUtils.getSubject();        <span class="hljs-comment">//做点跟Session相关的事</span>        Session session = currentUser.getSession();        session.setAttribute(<span class="hljs-string">"someKey"</span>,<span class="hljs-string">"aValue"</span>);        String value = (String) session.getAttribute(<span class="hljs-string">"someKey"</span>);        <span class="hljs-keyword">if</span>(value.equals(<span class="hljs-string">"aValue"</span>))&#123;            log.info(<span class="hljs-string">"检索出正确的值："</span>+ value);        &#125;        <span class="hljs-comment">//登录当前用户检验角色和权限</span>        <span class="hljs-keyword">if</span>(!currentUser.isAuthenticated())&#123;            <span class="hljs-comment">//将用户名和密码包装成token</span>            UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(<span class="hljs-string">"lonestarr"</span>, <span class="hljs-string">"vespa"</span>);            token.setRememberMe(<span class="hljs-keyword">true</span>);            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//尝试登录</span>                currentUser.login(token);            &#125;<span class="hljs-keyword">catch</span> (UnknownAccountException uae)&#123;                log.info(<span class="hljs-string">"用户名不正确"</span>);            &#125;<span class="hljs-keyword">catch</span> (IncorrectCredentialsException ice)&#123;                log.info(<span class="hljs-string">"密码不正确"</span>);            &#125;<span class="hljs-keyword">catch</span> (LockedAccountException lae)&#123;                log.info(<span class="hljs-string">"账号被锁定"</span>);            &#125;            <span class="hljs-comment">// ...其他已知异常</span>            <span class="hljs-keyword">catch</span> (AuthenticationException e)&#123;                log.info(<span class="hljs-string">"其他未知错误，请联系管理员"</span>);            &#125;        &#125;        <span class="hljs-comment">//说出他们是谁：</span>        <span class="hljs-comment">//打印主要识别信息</span>        log.info(<span class="hljs-string">"User["</span>+currentUser.getPrincipal()+<span class="hljs-string">"] logged in successfully."</span>);        <span class="hljs-comment">//测试角色：</span>        <span class="hljs-keyword">if</span>(currentUser.hasRole(<span class="hljs-string">"schwartz"</span>))&#123;            log.info(<span class="hljs-string">"你好！schwartz"</span>);        &#125;<span class="hljs-keyword">else</span>&#123;            log.info(<span class="hljs-string">"你好！普通人"</span>);        &#125;        <span class="hljs-comment">//测试一个权限（非（instance-level)实例级别）</span>        <span class="hljs-keyword">if</span>(currentUser.isPermitted(<span class="hljs-string">"lightsaber:weild"</span>))&#123;            log.info(<span class="hljs-string">"你可以使用这个光剑戒指，试试吧"</span>);        &#125;<span class="hljs-keyword">else</span>&#123;            log.info(<span class="hljs-string">"对不起，光剑戒指仅适用于schwartz大师"</span>);        &#125;        <span class="hljs-comment">//一个非常强大的实例级别的权限：</span>        <span class="hljs-keyword">if</span>(currentUser.isPermitted(<span class="hljs-string">"winnebago:drive:eagle5"</span>))&#123;            log.info(<span class="hljs-string">"您可以使用车牌号为eagle5的winnebago，这是钥匙，玩得开心！"</span>);        &#125;<span class="hljs-keyword">else</span>&#123;            log.info(<span class="hljs-string">"对不起，您money不够，玩不起"</span>);        &#125;        <span class="hljs-comment">//完成，退出</span>        currentUser.logout();        System.exit(<span class="hljs-number">0</span>);    &#125;&#125;</code></pre></div><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200619214928565.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这节我们通过一个示例介绍了如何在基础程序中加入Shiro，并理解Shiro的设计理念，Subject 和 SecurityManager。<br>接下来我们将更加深入的理解Shiro的架构及其配置机制。</p><h1 id="3-架构"><a href="#3-架构" class="headerlink" title="3 架构"></a>3 架构</h1><p>Apache Shiro 设计理念是使程序的安全变得简单直观而易于实现，Shiro的核心设计参照大多数用户对安全的思考模式–如何对某人（或某事）在与程序交互的环境中的进行安全控制。<br>比如：我们设计一个按钮，如果我的应用程序的交互对象是已经登录认证过的用户，那么我们展示的这个按钮可以用来查看他们的账户信息；如果该用户没有登录，那么这个按钮将作为一个注册按钮。</p><h2 id="高级概述"><a href="#高级概述" class="headerlink" title="高级概述"></a>高级概述</h2><p>Shio架构包含三个重要的理念：Subject、SecurityManager和Realm，下图展示了这些组件是如何相互作用的，我们将在下面依次对其进行描述：<br><img src="https://img-blog.csdnimg.cn/20200619220838962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li><strong>Subject</strong>：Subject本质上是当时运行用户特定的View（视图），而单词“User”经常暗指一个人，Subject可以是一个人，也可以是第三方服务、守护进程账户、时钟守护任务或者其他和当前软件交互的任何事件。<strong>Subject实例都和一个SecurityManager绑定</strong>，当你和一个Subject进行交互，这些交互动作被转换成SecurityManager下Subject特定的交互动作，比如前面提到的按钮操作。</li><li><strong>SecurityManager</strong>：SecurityManager是Shiro架构的核心，配合内部安全组件共同组成安全伞。然而，一旦一个程序配置好了SecurityManager和它的内部对象，程序开发人员几乎花费所有的时间在Subject API上，但是我们要清楚，任何Subject的安全操作中SecurityManager才是幕后真正的举重者。</li><li><strong>Realms</strong>：Realms是Shiro和你的程序安全数据之间的“桥”或者“连接”，当真正需要和安全性相关的数据（例如用户账户）进行交互以执行身份验证（登录）和授权（访问控制）时，Shiro会从一个或多个程序配置的Realm中查找这些东西。<br>Realm本质上是一个特定的安全DAO，它封装与数据源连接的细节，得到Shiro所需的相关数据，在配置Shiro的时候，必须指定至少一个Realm来实现认证（Authentication）和/或授权（Authorization）。SecurityManager可以配置多个复杂的Realm，但是至少保证有一个。<br>Shiro提供开箱即用的Realms来连接安全数据源（或叫地址）如：LDAP、JDBC、文件配置如INI和属性文件等，如果已有的Realm不能满足你的需求，你也可以开发自己的Realm实现，和其他内部组件一样，Shiro SecurityManager管理如何使用Realms获取Subject实例所代表的安全和身份信息。</li></ul><h2 id="详细架构"><a href="#详细架构" class="headerlink" title="详细架构"></a>详细架构</h2><p><img src="https://img-blog.csdnimg.cn/20200619225243989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li><p><strong>Subject</strong>：正在与软件交互的一个特定的实体“view”（用户、第三方服务、时钟守护任务等）</p></li><li><p><strong>SecurityManager</strong>：shiro的核心，用来协调它管理的组件使之平稳地一起工作，同时它也管理着Shiro中每一个程序用户的视图，所以它知道每个用户如何执行安全操作。</p></li><li><p><strong>Authenticator</strong>：Authenticator是负责执行用户的身份验证（登录）并对其作出反应的组件。 当用户尝试登录时，该逻辑由身份验证器执行。 身份验证器知道如何与一个或多个存储相关用户/帐户信息的领域进行协调。 从这些领域获得的数据用于验证用户的身份，以确保用户确实是他们所说的真实身份。</p></li><li><p><strong>Authentication Strategy</strong>：如果配置了多个Realm，AuthenticationStrategy将会协调Realm，以确定在一个身份验证成功或失败的条件。（比如：如果在一个方面验证成功了，但是其他方面有验证失败了，那么这次尝试是否成功，由Authentication Strategy说了算）</p></li><li><p><strong>Authorizer</strong>：Authorizer是负责程序中用户访问控制的组件，它是最终判断一个用户是否允许做某件事的途径，像Authenticator一样，Authorizer也知道如何通过协调多种后台数据源来访问角色和权限信息，Authorizer利用这些信息来准确判断一个用户是否可以执行给定的动作。</p></li><li><p><strong>SessionManager</strong>：SessionManager知道如何创建并管理用户Session生命周期，从而在所有环境中为用户提供一个强有力的Session体验。Shiro 将使用现有的session（如Servlet Container），但如果环境中没有，比如在一个独立的程序或非 web 环境中，它将使用它自己建立的 session 提供相同的作用，sessionDAO 用来使用任何数据源使 session 持久化。</p></li><li><p><strong>SessionDAO</strong>：SessionDAO用于将session持久化到数据库，实现对其增删改查。</p></li><li><p><strong>CacheManager</strong>：CacheManager为Shiro的其他组件提供创建缓存实例和管理缓存生命周期的功能，利用缓存来提高访问效率，目前主流开源或企业级缓存框架都可以集成到Shiro中。</p></li><li><p><strong>Cryptography</strong>：Shiro的crypto包包含了易用且易懂的加密方式，Hashes(即digests)和不同的编码实现。</p></li><li><p><strong>Realms</strong>：Realm 是 shiro 和你的应用程序安全数据之间的“桥”或“连接”，当实际要与安全相关的数据进行交互如用户执行身份认证（登录）和授权验证（访问控制）时，shiro 从程序配置的一个或多个Realm 中查找这些数据，你需要配置多少个 Realm 便可配置多少个 Realm（通常一个数据源一个），shiro 将会在认证和授权中协调它们。</p><h2 id="SecurityManager"><a href="#SecurityManager" class="headerlink" title="SecurityManager"></a>SecurityManager</h2><p>因为 Shiro API 鼓励以 Subject 为中心的开发方式，大部分开发人员将很少会和 SecurityManager 直接交互（尽管框架开发人员也许发现它非常有用），尽管如此，知道 SecurityManager 如何工作，特别是当在一个程序中进行配置的时候，是非常重要的。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>程序中SecurityManager执行操作并且管理所有程序用户的状态，在Shiro基础的SecurityManager实现中，包含以下内容：</p></li><li><p>认证（Authentication）</p></li><li><p>授权（Authorization）</p></li><li><p>会话管理（Session Management）</p></li><li><p>缓存管理（Cache Management）</p></li><li><p>Realm协调（Realm coordination）</p></li><li><p>事件传导（Event propagation ）</p></li><li><p>“RememberMe” 服务（”Remember Me” Services）</p></li><li><p>建立Subject(Subject creation)</p></li><li><p>退出登录（Logout）</p></li><li><p>…</p></li></ul><p>   以上这些功能都放在一个单独的组件中进行管理，为了实现配置的简单、灵活、机动性，Shiro的实现在设计上都是高度模块化的，SecurityManager类及其实现类主要充当轻量级的“容器”组件功能，几乎将所有的行为委托给嵌套/包装的组件，这里可以参考上面的架构图。</p><p>   当组件执行逻辑的时候，SecurityManager知道如何以及何时去协调组件做出正确的动作。<br>   SecurityManager 和 JavaBean 兼容，这允许你（或者配置途径）通过标准的JavaBean 访问/设置方法（get/set）很容易地定制插件，这意味着 Shiro 模块可以根据用户行为转化成简易的配置。</p><h1 id="4-配置"><a href="#4-配置" class="headerlink" title="4 配置"></a>4 配置</h1><p>Shiro 的 SecurityManager 的实现和其所依赖的组件都是 JavaBean，所以可以用多种形式对 Shiro 进行配置，比如XML（Spring, JBoss, Guice, 等等），YAML, JSON, Groovy Builder markup等，INI 只是 Shiro 一种最基本的配置方式，使得其可以在任何环境中进行配置。</p><h2 id="在程序中配置"><a href="#在程序中配置" class="headerlink" title="在程序中配置"></a>在程序中配置</h2><p>伪代码如下：</p><div class="hljs"><pre><code class="hljs java">Realm realm = <span class="hljs-comment">//实例化或获得一个Realm的实例。我们将稍后讨论Realm。</span>SecurityManager securityManager = <span class="hljs-keyword">new</span> DefaultSecurityManager(realm);<span class="hljs-comment">//使SecurityManager实例通过静态存储器对整个应用程序可见：</span>SecurityUtils.setSecurityManager(securityManager);</code></pre></div><p>如同我们在架构（Architecture ）中讨论过的，Shiro SecurityMangger 本质上是一个由一套安全组件组成的对象模块视图（graph），因为与 JavaBean兼容，所以可以对所有这些组件调用的 getter 和 setter 方法来配置SecurityManager 和它的内部对象视图。</p><p>例如，你想用一个自定义的 SessionDAO 来定制 Session Management从而配置一个 SecurityManager 实例，你就可以使用 SessionManager 的 setSessionDAO 方法直接 set 这个 SessionDAO。</p><div class="hljs"><pre><code class="hljs java">DefaultSecurityManager securityManager = <span class="hljs-keyword">new</span> DefaultSecurityManager(realm);SessionDAO sessionDAO = <span class="hljs-keyword">new</span> CustomSessionDAO();((DefaultSessionManager)securityManager.getSessionManager()).setSessionDAO(sessionDAO);</code></pre></div><p>使用这些函数，你可以配置 SecurityManager 视图（graph）中的任何一部分。</p><p>虽然在程序中配置很简单，但它并不是我们现实中配置的完美解决方案。在几种情况下这种方法可能并不适合你的程序：</p><ul><li><p>它需要你确切知道并实例化一个直接实现（direct implementation），然而更好的做法是你并不需要知道这些实现也不需要知道从哪里找到它们。</p></li><li><p>因为JAVA类型安全的特性，你必须对通过 get* 获取的对象进行强制类型转换，这么多强制转换非常的丑陋、累赘并且会和你的类紧耦合。</p></li><li><p>SecurityUtils.setSecurityManager 方法会将 SecurityManager实例化为虚拟机的单独静态实例，在大多数程序中没有问题，但如果有多个使用 Shiro 的程序在同一个 JVM 中运行时，各程序有自己独立的实例会更好些，而不是共同引用一块静态内存。 </p></li><li><p>改变配置就需要重新编译你的程序。</p></li></ul><p>然而，尽管有这些不足，在程序中定制的这种方法在限制内存（memory-constrained ）的环境中还是很有价值的，像智能电话程序。如果你的程序不是运行在一个限制内存的环境中，你会发现基于文本的配置会更易读易用。</p><h2 id="INI-配置"><a href="#INI-配置" class="headerlink" title="INI 配置"></a>INI 配置</h2><p>大多数程序已经改为使用基于文本的配置，不需要依靠代码就可进行修改；<br>为了确保具有共性的基于文本配置的途径适用于任何环境而且减少对第三方的依赖，Shiro 支持使用 INI 创建 SecurityManager 对象视图（graph）以及它支持的组件，INI 易读易配置，很容易创建并且对大多数程序都很适合。</p><h3 id="通过INI资源创建-SecurityManager"><a href="#通过INI资源创建-SecurityManager" class="headerlink" title="通过INI资源创建 SecurityManager"></a>通过INI资源创建 SecurityManager</h3><p>这里举两个通过INI配置创建SecurityManager的例子。</p><h4 id="从INI资源创建SecurityManager"><a href="#从INI资源创建SecurityManager" class="headerlink" title="从INI资源创建SecurityManager"></a>从INI资源创建SecurityManager</h4><div class="hljs"><pre><code class="hljs java">Factory&lt;SecurityManager&gt; factory = <span class="hljs-keyword">new</span> IniSecurityManagerFactory(<span class="hljs-string">"classpath:shiro.ini"</span>);SecurityManager securityManager = factory.getInstance();SecurityUtils.setSecurityManager(securityManager);</code></pre></div><h4 id="通过INI实例创建SecurityManager"><a href="#通过INI实例创建SecurityManager" class="headerlink" title="通过INI实例创建SecurityManager"></a>通过INI实例创建SecurityManager</h4><p>INI 配置可以通过<code>org.apache.shiro.config.Ini</code>类用程序方式创建，这个 INI 类类似于 JDK 的<code>java.util.Properties</code>类，但支持通过section 名分割。如：</p><div class="hljs"><pre><code class="hljs java">Ini ini = <span class="hljs-keyword">new</span> Ini();<span class="hljs-comment">//populate the Ini instance as necessary</span>...Factory&lt;SecurityManager&gt; factory = <span class="hljs-keyword">new</span> IniSecurityManagerFactory(ini);SecurityManager securityManager = factory.getInstance();SecurityUtils.setSecurityManager(securityManager);</code></pre></div><p>接下来解决如何定义一个Shiro INI配置文件的问题</p><h3 id="INI-Sections"><a href="#INI-Sections" class="headerlink" title="INI Sections"></a>INI Sections</h3><p>INI　基于文本配置，在独立命名的区域内通过成对的键名/键值组成。键名在每个区域内必须唯一，但是在整个配置文件中并不要求唯一，每个区域（session）可以看作是一个独立的Properties定义。<br>注释行可以用“#”或“;”标识，下面是一个关于shiro的示例。</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-comment"># =======================</span><span class="hljs-comment"># Shiro INI configuration</span><span class="hljs-comment"># =======================</span><span class="hljs-section">[main]</span><span class="hljs-comment"># Objects and their properties are defined here, </span><span class="hljs-comment"># Such as the securityManager, Realms and anything</span><span class="hljs-comment"># else needed to build the SecurityManager</span><span class="hljs-section">[users]</span><span class="hljs-comment"># The 'users' section is for simple deployments</span><span class="hljs-comment"># when you only need a small number of statically-defined </span><span class="hljs-comment"># set of User accounts.</span><span class="hljs-section">[roles]</span><span class="hljs-comment"># The 'roles' section is for simple deployments</span><span class="hljs-comment"># when you only need a small number of statically-defined</span><span class="hljs-comment"># roles.</span><span class="hljs-section">[urls]</span><span class="hljs-comment"># The 'urls' section is used for url-based security</span><span class="hljs-comment"># in web applications.  We'll discuss this section in the</span><span class="hljs-comment"># Web documentation</span></code></pre></div><h4 id="main"><a href="#main" class="headerlink" title="[main]"></a>[main]</h4><p>[main]区域是配置程序 SecurityManager 实例及其支撑组件的地方，如 Realm。</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span><span class="hljs-attr">sha256Matcher</span> = org.apache.shiro.authc.credential.Sha256CredentialsMatcher<span class="hljs-comment"># 定义一个对象</span><span class="hljs-attr">myRealm</span> = com.company.security.shiro.DatabaseRealm<span class="hljs-comment"># 设置对象属性</span><span class="hljs-attr">myRealm.connectionTimeout</span> = <span class="hljs-number">30000</span><span class="hljs-attr">myRealm.username</span> = jsmith<span class="hljs-attr">myRealm.password</span> = secret<span class="hljs-comment"># 引用值</span><span class="hljs-attr">myRealm.credentialsMatcher</span> = <span class="hljs-variable">$sha256Matcher</span><span class="hljs-comment"># 嵌套属性</span><span class="hljs-attr">securityManager.sessionManager.globalSessionTimeout</span> = <span class="hljs-number">1800000</span></code></pre></div><p><strong>1、定义一个对象</strong><br>这一行实例化了一个类型为 <code>com.company.shiro.realm.MyRealm</code>的对象实例并且使对象使用 myRealm 作为名称以便于将来引用和配置。</p><p>如果对象实例化时实现了 <code>org.apache.shiro.util.Nameable</code>接口，Nameable.setName方法将被以该名（在此例中为myRealm）命名的对象调用。</p><p><strong>2、设置对象属性</strong><br>上面代码等价于</p><div class="hljs"><pre><code class="hljs ini">myRealm.setConnectionTimeout(30000);myRealm.setUsername("jsmith");myRealm.setPassword("secret");</code></pre></div><p>这是因为Shiro默认使用Apache通用的BeanUtils来完成这项复杂的工作，BeanUtils知道如何将这些字符串值转换为适合的原始值类型并调用合适的JavaBeans的setter方法。</p><p><strong>3、引用值</strong><br>如果你想设置的值并不是一个原始值，而是另一个对象怎么办呢？你可以使用一个 $ 符来引用一个之前定义的实例。</p><p><strong>4、嵌套属性</strong><br>通过在等号左侧使用点符号，你可以得到你希望设置对象视图最终的对象/属性；<br><code>securityManager.sessionManager.globalSessionTimeout = 1800000</code>等价于<code>securityManager.getSessionManager().setGlobalSessionTimeout(1800000);</code></p><p><strong>5、字节数组值</strong><br>因为原始的字节数组不能直接在文本中定义，我们必须使用字节数组的文本编码。可以使用64位编码（默认）或者16位编码，使用16位编码必须在字符串前面加上0x前缀；<br><code>securityManager.rememberMeManager.cipherKey = 0x3707344A4093822299F31D008</code></p><p><strong>6、集合属性</strong><br>列表（Lists）、集合（Sets）、图（Maps）可以像其它属性一样设置–直接设置或者像嵌套属性一样，对于列表和集合，只需指定一个逗号分割的值集或者对象引用集。</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">sessionListener1</span> = com.company.my.SessionListenerImplementation...<span class="hljs-attr">sessionListener2</span> = com.company.my.other.SessionListenerImplementation...<span class="hljs-attr">securityManager.sessionManager.sessionListeners</span> = <span class="hljs-variable">$sessionListener1</span>, <span class="hljs-variable">$sessionListener2</span></code></pre></div><p>对于图（Maps），你可以指定以逗号分割的键-值对列表，每个键-值之间用冒号分割：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">object1</span> = com.company.some.Class<span class="hljs-attr">object2</span> = com.company.another.Class...<span class="hljs-attr">anObject</span> = some.class.with.a.Map.property<span class="hljs-attr">anObject.mapProperty</span> = key1:<span class="hljs-variable">$object1</span>, key2:<span class="hljs-variable">$object2</span></code></pre></div><p>在上面的例子中，$object1 引用的对象将存于键 key1 之下，也就是map.get(“key1”) 将返回 object1。你也可以使用其它对象作为键值：</p><div class="hljs"><pre><code class="hljs text">anObject.map &#x3D; $objectKey1:$objectValue1, $objectKey2:$objectValue2</code></pre></div><p><strong>注意事项</strong></p><p>1、顺序问题<br>每一个对象实例以及每一个指定的值都将按照其在 [main] 区域中产生的顺序的执行，这些行最终转换为 JavaBeans 的 getter/setter 方法调用，这些方法按同样的顺序调用。<br>2、覆盖实例<br>每个对象都可以被后定义的新实例覆盖：</p><div class="hljs"><pre><code class="hljs text">myRealm &#x3D; com.company.security.MyRealm...myRealm &#x3D; com.company.security.DatabaseRealm</code></pre></div><p>这样的结果是 myRealm 是<code>com.company.security.DatabaseRealm</code> 实例而前面的实例不会被使用（会作为垃圾回收）。<br>3、默认Default SecurityManager<br>securityManager实例是特殊的–它已经为你实例化过了并且准备好了，所以你并不需要知道指定的实例化SecurityManager的实现类。</p><p>当然，如果你确实想指定你自己的实现类，你可以像上面的覆盖实例那样定义你自己的实现：</p><div class="hljs"><pre><code class="hljs text">securityManager &#x3D; com.company.security.shiro.MyCustomSecurityManager</code></pre></div><p>当然，很少需要这样–Shiro 的 SecurityManager 实现可以按需求进行定制，你可能要问一下自己（或者用户群）你是否真的需要这样做。</p><h4 id="users"><a href="#users" class="headerlink" title="[users]"></a>[users]</h4><p>[users]区域允许你定义一组静态的用户帐号，这对于那些只有少数用户帐号并且用户帐号不需要在运行时动态创建的环境来说非常有用。下面是一个例子：</p><div class="hljs"><pre><code class="hljs text">[users]admin &#x3D; secretlonestarr &#x3D; vespa, goodguy, schwartzdarkhelmet &#x3D; ludicrousspeed, badguy, schwartz</code></pre></div><p>定义非空的[users]或[roles]区域将自动创建<code>org.apache.shiro.realm.text.IniRealm</code>     实例,在[main]区域下生成一个可用的 iniRealm ，你可以像上面配置其它对象那样配置它。</p><p><strong>格式：</strong></p><div class="hljs"><pre><code class="hljs text">username &#x3D; password, roleName1, roleName2, ..., roleNameN</code></pre></div><ul><li>等号左边的值是用户名；</li><li>等号右侧第一个值是用户密码，密码是必须的；</li><li>密码之后用逗号分割的值是赋予用户的角色名，角色名是可选的。</li></ul><p><strong>密码加密</strong><br>如果你不希望[users]区域下的密码以明文显示，你可以用你喜欢的哈希算法（MD5, Sha1, Sha256, 等）来加密它们，将加密后的字符串作为密码值，默认的情况下密码用16位编码算法，但也可以用64位编码算法替代（如下）</p><p>指定哈希文本密码值后，您必须告诉Shiro这些密码已加密。 为此，您可以在[main]部分中配置隐式创建的iniRealm，以使用与您指定的哈希算法相对应的适当CredentialsMatcher实现：</p><div class="hljs"><pre><code class="hljs text">[main]...sha256Matcher &#x3D; org.apache.shiro.authc.credential.Sha256CredentialsMatcher...iniRealm.credentialsMatcher &#x3D; $sha256Matcher...[users]# user1 &#x3D; sha256-hashed-hex-encoded password, role1, role2, ...user1 &#x3D; 2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b, role1, role2, ...</code></pre></div><p>如果用64位编码方式进行编码，需要指定：</p><div class="hljs"><pre><code class="hljs text">[main]...# true &#x3D; hex, false &#x3D; base64:sha256Matcher.storedCredentialsHexEncoded &#x3D; false</code></pre></div><h4 id="roles"><a href="#roles" class="headerlink" title="[roles]"></a>[roles]</h4><p>[roles]区域允许你将权限和在[users]定义的角色对应起来，同样的，这对于那些只有少数用户帐号并且用户帐号不需要在运行时动态创建的环境来说非常有用。</p><div class="hljs"><pre><code class="hljs text">[roles]# &#39;admin&#39; role has all permissions, indicated by the wildcard &#39;*&#39;admin &#x3D; *# The &#39;schwartz&#39; role can do anything (*) with any lightsaber:schwartz &#x3D; lightsaber:*# The &#39;goodguy&#39; role is allowed to &#39;drive&#39; (action) the winnebago (type) with# license plate &#39;eagle5&#39; (instance specific id)goodguy &#x3D; winnebago:drive:eagle5</code></pre></div><p><strong>格式</strong><br>[roles]区域下的每一行必须用下面的格式定义角色-权限的键/值对应关系。<br><code>rolename = permissionDefinition1, permissionDefinition2, ..., permissionDefinitionN</code></p><p>注意如果一个特定的权限定义需要用到逗号分隔（如：printer:5thFloor:print,info），你需要将该定义用双引号括起来从而避免出错：”printer:5thFloor:print,info”。</p><p>如果你有不需要权限的角色，不需要将它们列入[roles]区域，仅仅在 [users]区域定义角色名就可以创建它们。</p><h4 id="urls"><a href="#urls" class="headerlink" title="[urls]"></a>[urls]</h4><p>Web章节讨论</p>]]></content>
    
    
    <categories>
      
      <category>安全框架</category>
      
      <category>Shiro</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shiro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shiro系列-shiro入门示例</title>
    <link href="/2020/06/19/shiro%E7%B3%BB%E5%88%97-shiro%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B/"/>
    <url>/2020/06/19/shiro%E7%B3%BB%E5%88%97-shiro%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>基本上，在所有的开发的系统中，都必须做认证(authentication)和授权(authorization)，以保证系统的安全性。<br>简单来说：认证解决“你是谁”的问题，授权解决“你能做什么”的问题。<br>在Java生态中，目前两大安全框架是Spring Security和Apache Shiro，可以用来完成认证和授权的功能。</p><blockquote><p>关于Shiro：<br>Apache Shiro 是一个功能强大且易于使用的 Java 安全框架，它可以提供身份验证、授权、加密和会话管理的功能。<br>通过 Shiro 易于理解的 API ，你可以快速、轻松地保护任何应用程序 —— 从最小的移动端应用程序到大型的的 Web 和企业级应用程序。</p></blockquote><h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h1><h2 id="2-1-引入依赖"><a href="#2-1-引入依赖" class="headerlink" title="2.1 引入依赖"></a>2.1 引入依赖</h2><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--实现对Spring MVC的自动化配置--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-comment">&lt;!--实现对shiro的自动化配置--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h2 id="2-2-ShiroConfig"><a href="#2-2-ShiroConfig" class="headerlink" title="2.2 ShiroConfig"></a>2.2 ShiroConfig</h2><p>创建com.gavin.shiro.config.ShiroConfig配置类，用来实现Shiro的自定义配置，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShiroConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Realm <span class="hljs-title">realm</span><span class="hljs-params">()</span></span>&#123;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DefaultWebSecurityManager <span class="hljs-title">securityManager</span><span class="hljs-params">()</span></span>&#123;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ShiroFilterFactoryBean <span class="hljs-title">shiroFilterFactoryBean</span><span class="hljs-params">()</span></span>&#123;    &#125;&#125;</code></pre></div><p>下面重点分析三个Bean的配置。</p><h3 id="2-2-1-Realm"><a href="#2-2-1-Realm" class="headerlink" title="2.2.1 Realm"></a>2.2.1 Realm</h3><p>Realm是可以访问程序特定的安全数据如用户、角色、权限等的一个组件，Realm可以将这些程序特定的安全数据转换成一种Shiro可以理解的形式。简单说：Realm的职责就是进行<strong>身份认证</strong>和<strong>授权</strong>。</p><p>Realm整体的类图如下：<br><img src="https://img-blog.csdnimg.cn/20200618154954140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Realm接口，主要定义了认证的方法，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Realm</span> </span>&#123;    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(AuthenticationToken var1)</span></span>;    <span class="hljs-function">AuthenticationInfo <span class="hljs-title">getAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken var1)</span> <span class="hljs-keyword">throws</span> AuthenticationException</span>;&#125;</code></pre></div><p>AuthorizingRealm抽象类，额外定义了授权方法，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection var1)</span></span>;</code></pre></div><p>同时它又实现了Authorizer接口，提供判断经过认证过的Subject是否具有指定的角色、权限方法。</p><p>从Realm类图结构可以看出，Shiro提供了多种AuthorizingRealm的实现类，提供从不同的数据源获取数据，不过在一般的项目中，我们会自定义实现Authorizing Realm来从自己定义的表结构中读取用户、角色、权限等数据。虽然Shiro提供了JdbcRealm可以访问数据库，但是它的表结构是固定的，所以我们才选择自定义实现AuthorizingRealm。</p><p>在本示例中，在<code>com.gavin.shiro.config.ShiroConfig#realm</code>方法中，我们创建了SimpleAccountRealm对象，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Realm <span class="hljs-title">realm</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//创建SimpleAccountRealm对象</span>    SimpleAccountRealm realm = <span class="hljs-keyword">new</span> SimpleAccountRealm();    <span class="hljs-comment">//添加两个用户，参数分别是username、password、roles</span>    realm.addAccount(<span class="hljs-string">"admin"</span>,<span class="hljs-string">"admin"</span>,<span class="hljs-string">"ADMIN"</span>);    realm.addAccount(<span class="hljs-string">"normal"</span>,<span class="hljs-string">"normal"</span>,<span class="hljs-string">"NORMAL"</span>);    <span class="hljs-keyword">return</span> realm;&#125;</code></pre></div><p>在该方法中，我们添加了两个用户，分别对应ADMIN和NORMAL角色。</p><h3 id="2-2-2-SecurityManager"><a href="#2-2-2-SecurityManager" class="headerlink" title="2.2.2 SecurityManager"></a>2.2.2 SecurityManager</h3><p>SecurityManager是Shiro架构的核心，配合内部安全组件共同组成安全伞。<br>在本示例中，在<code>com.gavin.shiro.config.ShiroConfig#securityManager</code>方法中，我们创建了DefaultWebSecurityManager对象，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span> <span class="hljs-function"><span class="hljs-keyword">public</span> DefaultWebSecurityManager <span class="hljs-title">securityManager</span><span class="hljs-params">()</span></span>&#123;     <span class="hljs-comment">//创建DefaultWebSecurityManager对象</span>     DefaultWebSecurityManager securityManager = <span class="hljs-keyword">new</span> DefaultWebSecurityManager();     <span class="hljs-comment">//设置其使用的Realm</span>     securityManager.setRealm(<span class="hljs-keyword">this</span>.realm());     <span class="hljs-keyword">return</span> securityManager; &#125;</code></pre></div><h3 id="2-2-3-ShiroFilter"><a href="#2-2-3-ShiroFilter" class="headerlink" title="2.2.3 ShiroFilter"></a>2.2.3 ShiroFilter</h3><p>通过AbstractShiroFilter过滤器，实现对请求的拦截，从而实现Shiro的功能，AbstractShiroFilter整体的类图如下：<br><img src="https://img-blog.csdnimg.cn/20200618164026190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在本示例中，在<code>com.gavin.shiro.config.ShiroConfig#shiroFilterFactoryBean</code>方法中，我们创建了ShiroFilterFactoryBean对象，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> ShiroFilterFactoryBean <span class="hljs-title">shiroFilterFactoryBean</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-comment">//&lt;1&gt;创建ShiroFilterFactoryBean对象，用于创建ShiroFilter过滤器</span>      ShiroFilterFactoryBean filterFactoryBean = <span class="hljs-keyword">new</span> ShiroFilterFactoryBean();      <span class="hljs-comment">//&lt;2&gt;设置其SecurityManager属性</span>      filterFactoryBean.setSecurityManager(<span class="hljs-keyword">this</span>.securityManager());      <span class="hljs-comment">//&lt;3&gt;设置URL</span>      <span class="hljs-comment">//登录URL</span>      filterFactoryBean.setLoginUrl(<span class="hljs-string">"/login"</span>);      <span class="hljs-comment">//登录成功URL</span>      filterFactoryBean.setSuccessUrl(<span class="hljs-string">"/login_success"</span>);      <span class="hljs-comment">//无权限URL，在请求校验权限不通过时，会重定向到该URL上</span>      filterFactoryBean.setUnauthorizedUrl(<span class="hljs-string">"/unauthorized"</span>);      <span class="hljs-comment">//&lt;4&gt;设置URL的权限配置</span>      filterFactoryBean.setFilterChainDefinitionMap(<span class="hljs-keyword">this</span>.filterChainDefinitionMap());      <span class="hljs-keyword">return</span> filterFactoryBean;  &#125;</code></pre></div><p>在介绍<code>filterChainDefinitionMap</code>方法的具体URL的权限配置之前，我们先来了解一下Shiro内置的过滤器，在<code>DefaultFilter</code>枚举类中，枚举了这些过滤器，以及其配置名：<br><img src="https://img-blog.csdnimg.cn/20200618175353156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>比较常用的过滤器有：</p><ul><li><p>anon：AnonymousFilter，允许匿名访问，无需登录；</p></li><li><p>authc：FormAuthenticationFilter，需要经过认证的用户才可以访问，如果是匿名用户，则根据URL不同，会有不同的处理：<br> 1、如果拦截的URL是GET loginUrl登录页面，则进行该请求，跳转到登录页面；<br> 2、如果拦截的URL是POST loginUrl登录请求，则基于请求表单的username、password进行认证，认证通过后，默认重定向到GET loginSuccessUrl地址；<br> 3、如果拦截的URL是其他URL时，则记录该URL到Session中，在用户登录成功后，重定向到该URL上。</p></li><li><p>logout：LogoutFilter，拦截的URL，执行退出登录，退出完成后，重定向到GET loginUrl登录页面。</p></li><li><p>roles：RolesAuthorizationFilter，拥有指定角色的用户可访问；</p></li><li><p>perms：PermissionsAuthorizationFilter，拥有指定权限的用户可以访问。</p><p>下面，让我们回过头来看看<code>#filterChainDefinitionMap()</code>方法的具体URL的权限配置，代码如下：</p></li></ul><div class="hljs"><pre><code class="hljs java">  <span class="hljs-comment">/** URL的权限配置*/</span><span class="hljs-function"><span class="hljs-keyword">private</span> Map&lt;String, String&gt; <span class="hljs-title">filterChainDefinitionMap</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//使用有序的LinkedHashMap，用来实现顺序匹配</span>    LinkedHashMap&lt;String,String&gt; filterMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();    <span class="hljs-comment">//允许匿名访问</span>    filterMap.put(<span class="hljs-string">"/test/echo"</span>,<span class="hljs-string">"anon"</span>);    <span class="hljs-comment">//需要ADMIN角色才能访问</span>    filterMap.put(<span class="hljs-string">"/test/admin"</span>,<span class="hljs-string">"roles[ADMIN]"</span>);    <span class="hljs-comment">//需要NORMAL角色才能访问</span>    filterMap.put(<span class="hljs-string">"/test/normal"</span>,<span class="hljs-string">"roles[NORMAL]"</span>);    <span class="hljs-comment">//注销登录</span>    filterMap.put(<span class="hljs-string">"/logout"</span>,<span class="hljs-string">"logout"</span>);    <span class="hljs-comment">//默认剩余的URL，都要经过认证后才能访问</span>    filterMap.put(<span class="hljs-string">"/**"</span>,<span class="hljs-string">"authc"</span>);    <span class="hljs-keyword">return</span> filterMap;&#125;</code></pre></div><p>这里补充一点，请求在ShiroFilter拦截之后，会根据该请求的情况，匹配到配置中内置的所有Shio Filter，逐个进行处理，也就是说Shiro Filter内部有一个由内置的Shiro Filter组成的过滤器链。</p><h2 id="2-3-SecurityController"><a href="#2-3-SecurityController" class="headerlink" title="2.3 SecurityController"></a>2.3 SecurityController</h2><p> 创建一个SecurityController类，用来提供登录，登录成功等接口，代码如下：</p><div class="hljs"><pre><code class="hljs java">com.gavin.shiro.controller.SecurityController<span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityController</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/login"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">loginPage</span><span class="hljs-params">()</span></span>&#123;    &#125;    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/login"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;    &#125;    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/login_success"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">loginSuccess</span><span class="hljs-params">()</span></span>&#123;    &#125;    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/unauthorized"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">unauthorized</span><span class="hljs-params">()</span></span>&#123;    &#125;&#125;</code></pre></div><h3 id="2-3-1-登录页面"><a href="#2-3-1-登录页面" class="headerlink" title="2.3.1 登录页面"></a>2.3.1 登录页面</h3><p>GET /login地址，来到登录页面，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/login"</span>)  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">loginPage</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"login.html"</span>;  &#125;</code></pre></div><p>login.html静态页面代码如下：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>登录页面<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>        用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>        密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"登录"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>POST提交登录请求到/login地址。</p><h3 id="2-3-2-登录请求"><a href="#2-3-2-登录请求" class="headerlink" title="2.3.2 登录请求"></a>2.3.2 登录请求</h3><p>对于登录请求，会被我们配置的<code>FormAuthenticationFilter</code>过滤器进行拦截，进行用户的身份认证，过程如下：</p><ul><li><p>FormAuthenticationFilter解析请求的<code>username</code>、<code>password</code>参数，创建UsernamePasswordToken对象；</p></li><li><p>然后，调用SecurityManager的<code>login(Subject subject, AuthenticationToken authenticationToken)</code>方法，执行登录操作，进行“身份验证”（认证）；</p></li><li><p>在这内部其实是调用Realm的<code>个体Authentication Info（AuthenticationToken token）</code>方法进行认证，此时根据认证是否成功，会有不同的处理方式：<br>1、如果认证通过，则FormAuthenticationFilter会将请求重定向到Get loginSuccess地址上；<br>2、如果认证失败，则会将认证失败的原因设置到请求的attributes中，后续该请求会继续请求到POST login地址上，这样，在POST loginUrl地址上，我们可以从attributes中获取到失败的原因提示给用户。</p><p>所以，POST loginUrl的目的实际上是为了处理认证失败的情况，其实现的代码如下：</p></li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ResponseBody</span>   <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/login"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;       <span class="hljs-comment">// &lt;1&gt; 判断是否已经登录</span>       Subject subject = SecurityUtils.getSubject();       <span class="hljs-keyword">if</span>(subject.getPrincipal() != <span class="hljs-keyword">null</span>)&#123;           <span class="hljs-keyword">return</span> <span class="hljs-string">"你已经登录，无需重复登录"</span>+subject.getPrincipal();       &#125;       <span class="hljs-comment">// &lt;2&gt; 获得登录失败的原因</span>       String shiroLoginFailure = (String) request.getAttribute(FormAuthenticationFilter.DEFAULT_ERROR_KEY_ATTRIBUTE_NAME);       <span class="hljs-comment">// 翻译成人类看得懂的提示</span>       String msg = <span class="hljs-string">""</span>;       <span class="hljs-keyword">if</span>(UnknownAccountException<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>().<span class="hljs-title">equals</span>(<span class="hljs-title">shiroLoginFailure</span>))</span>&#123;           msg = <span class="hljs-string">"账号不存在"</span>;       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(IncorrectCredentialsException<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>().<span class="hljs-title">equals</span>(<span class="hljs-title">shiroLoginFailure</span>))</span>&#123;           msg = <span class="hljs-string">"密码不正确"</span>;       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(LockedAccountException<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>().<span class="hljs-title">equals</span>(<span class="hljs-title">shiroLoginFailure</span>))</span>&#123;           msg = <span class="hljs-string">"账号被锁定"</span>;       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ExpiredCredentialsException<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>().<span class="hljs-title">equals</span>(<span class="hljs-title">shiroLoginFailure</span>))</span>&#123;           msg = <span class="hljs-string">"账号已过期"</span>;       &#125;<span class="hljs-keyword">else</span>&#123;           msg = <span class="hljs-string">"未知错误，请联系管理员"</span>;           logger.error(<span class="hljs-string">"[login][未知错误：&#123;&#125;]"</span>,shiroLoginFailure);       &#125;       <span class="hljs-keyword">return</span> <span class="hljs-string">"登录失败，原因："</span> + msg;   &#125;</code></pre></div><h3 id="2-3-3-登录成功"><a href="#2-3-3-登录成功" class="headerlink" title="2.3.3 登录成功"></a>2.3.3 登录成功</h3><p>GET login_success地址，登录成功后响应，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ResponseBody</span>   <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/login_success"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">loginSuccess</span><span class="hljs-params">()</span></span>&#123;       <span class="hljs-keyword">return</span> <span class="hljs-string">"恭喜你，登录成功！！"</span>;   &#125;</code></pre></div><p>如果是AJAX请求，我们可以返回json数据；<br>如果是非AJAX请求，我们可以重定向到登录成功的页面，比如管理后台的home页面。</p><h3 id="2-3-4-未授权"><a href="#2-3-4-未授权" class="headerlink" title="2.3.4 未授权"></a>2.3.4 未授权</h3><p>GET unauthorized地址，未授权响应，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ResponseBody</span>   <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/unauthorized"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">unauthorized</span><span class="hljs-params">()</span></span>&#123;       <span class="hljs-keyword">return</span> <span class="hljs-string">"对不起，您没有权限进行操作"</span>;   &#125;</code></pre></div><p>如果是AJAX请求，我们可以返回json数据；<br>如果是非AJAX请求，我们可以重定向到登录页面。</p><h2 id="2-4-TestController"><a href="#2-4-TestController" class="headerlink" title="2.4 TestController"></a>2.4 TestController</h2><p>测试API接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/test"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/demo"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">demo</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"示例返回"</span>;    &#125;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/home"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">home</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"首页"</span>;    &#125;        <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/admin"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"我是管理员"</span>;    &#125;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/normal"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">normal</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"我是普通用户"</span>;    &#125;&#125;</code></pre></div><ul><li>对于 /test/demo 接口，直接访问，无需登陆。</li><li>对于 /test/home 接口，无法直接访问，需要进行登陆。</li><li>对于 /test/admin 接口，需要登陆「admin/admin」用户，因为需要 ADMIN 角色。</li><li>对于 /test/normal 接口，需要登陆「user/user」用户，因为需要 USER 角色。</li></ul><h1 id="3-Shiro注解"><a href="#3-Shiro注解" class="headerlink" title="3.Shiro注解"></a>3.Shiro注解</h1><p>在Shiro中，提供了如下5个注解，可以直接添加在SpringMVC的URL对应的方法上，实现权限配置：</p><h2 id="3-1-RequiresGuest"><a href="#3-1-RequiresGuest" class="headerlink" title="3.1 @RequiresGuest"></a>3.1 @RequiresGuest</h2><p>等同于<code>anon</code></p><h2 id="3-2-RequiresAuthentication"><a href="#3-2-RequiresAuthentication" class="headerlink" title="3.2 @RequiresAuthentication"></a>3.2 @RequiresAuthentication</h2><p>等同于<code>authc</code></p><h2 id="3-3-RequiresUser"><a href="#3-3-RequiresUser" class="headerlink" title="3.3 @RequiresUser"></a>3.3 @RequiresUser</h2><p>等同于<code>user</code>，要求必须登录</p><h2 id="3-4-RequiresRoles"><a href="#3-4-RequiresRoles" class="headerlink" title="3.4 @RequiresRoles"></a>3.4 @RequiresRoles</h2><p>和roles等价，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RequiresRoles &#123;    String[] value();<span class="hljs-comment">//当有多个角色时，AND表示要拥有全部角色，OR表示拥有任意角色即可</span>    <span class="hljs-function">Logical <span class="hljs-title">logical</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> Logical.AND</span>; &#125;</code></pre></div><p>示例代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 属于 NORMAL 角色</span><span class="hljs-meta">@RequiresRoles</span>(<span class="hljs-string">"NORMAL"</span>)<span class="hljs-comment">// 要同时拥有 ADMIN 和 NORMAL 角色</span><span class="hljs-meta">@RequiresRoles</span>(&#123;<span class="hljs-string">"ADMIN"</span>, <span class="hljs-string">"NORMAL"</span>&#125;)<span class="hljs-comment">// 拥有 ADMIN 或 NORMAL 任一角色即可（OR）</span><span class="hljs-meta">@RequiresRoles</span>(value = &#123;<span class="hljs-string">"ADMIN"</span>, <span class="hljs-string">"NORMAL"</span>&#125;, logical = Logical.OR)</code></pre></div><p>如果验证角色不通过，就会抛出AuthorizationException异常，此时我们可以基于Spring MVC提供的@RestControllerAdvice+@ExceptionHandler注解，实现全局异常的处理。<br>不了解可以看看《芋道 Spring Boot SpringMVC 入门》的「5. 全局异常处理」小节。</p><h2 id="3-5-RequiresPermissions"><a href="#3-5-RequiresPermissions" class="headerlink" title="3.5 @RequiresPermissions"></a>3.5 @RequiresPermissions</h2><p>等价于perms，示例代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 拥有 user:add 权限</span><span class="hljs-meta">@RequiresPermissions</span>(<span class="hljs-string">"user:add"</span>)<span class="hljs-comment">// 要同时拥有 user:add 和 user:update 权限</span><span class="hljs-meta">@RequiresPermissions</span>(&#123;<span class="hljs-string">"user:add"</span>, <span class="hljs-string">"user:update"</span>&#125;)<span class="hljs-comment">// 拥有 user:add 和 user:update 任一权限即可</span><span class="hljs-meta">@RequiresPermissions</span>(value = &#123;<span class="hljs-string">"user:add"</span>, <span class="hljs-string">"user:update"</span>&#125;, logical = Logical.OR)</code></pre></div><p>同样如果验证权限不通过，则会抛出AuthorizationException异常。</p><h2 id="3-6-使用示例"><a href="#3-6-使用示例" class="headerlink" title="3.6 使用示例"></a>3.6 使用示例</h2><p>新建DemoController类，提供示例API接口，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/demo"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoController</span> </span>&#123;    <span class="hljs-meta">@RequiresGuest</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/echo"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">demo</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"示例返回"</span>;    &#125;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/home"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">home</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"首页"</span>;    &#125;    <span class="hljs-meta">@RequiresRoles</span>(<span class="hljs-string">"ADMIN"</span>)    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/admin"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"我是管理员"</span>;    &#125;    <span class="hljs-meta">@RequiresRoles</span>(<span class="hljs-string">"NORMAL"</span>)    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/normal"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">normal</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"我是普通用户"</span>;    &#125;&#125;</code></pre></div><p>参考文献：<br><a href="https://mp.weixin.qq.com/s/NmwqOM5rSDlmvs-Bi4P2Ag" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/NmwqOM5rSDlmvs-Bi4P2Ag</a><br>github源码地址：<a href="https://github.com/gavin-yyj/shiro/tree/master/worker/shiro%E7%B3%BB%E5%88%97/shiro-test" target="_blank" rel="noopener">点这里</a></p>]]></content>
    
    
    <categories>
      
      <category>安全框架</category>
      
      <category>Shiro</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shiro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认证、授权、鉴权和权限控制的理解</title>
    <link href="/2020/06/18/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E3%80%81%E9%89%B4%E6%9D%83%E5%92%8C%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2020/06/18/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E3%80%81%E9%89%B4%E6%9D%83%E5%92%8C%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-认证"><a href="#1-认证" class="headerlink" title="1. 认证"></a>1. 认证</h1><p>认证（identification）：是指根据声明者所持有的识别信息，来确认声明者的身份。<br>最常用的认证方式是通过用户名和密码，除此之外还有：身份证、二维码扫码、手机短信、邮箱登录、指纹等等认证方式。<br>为了确认用户的身份，防止伪造，在安全要求高的场合，经常会使用组合认证（或者叫多因素认证），也就是同时使用多个认证方式对用户的身份进行校验。</p><h1 id="2-授权"><a href="#2-授权" class="headerlink" title="2. 授权"></a>2. 授权</h1><p>授权（authorization）：一般是指获取用户的委派权限。<br>在信息安全领域，授权是指资源所有者委派执行者，赋予执行者指定范围的资源操作权限，以便执行者代理执行对资源的相关操作，有四个概念需要弄清楚：</p><ul><li>资源所有者：一般是资源的拥有者，拥有资源的全部权限；</li><li>资源执行者：被委派去执行资源的相关操作；</li><li>权限操作：可以对资源进行的某种操作，比如：增删改查等；</li><li>资源：有价值的信息或数据等，受到安全保护。</li></ul><p>另外，资源所有者和执行者可以是自然人，也就是普通用户，但是不限于自然人，在信息安全领域，资源所有者和执行者，很多时候是应用程序或者机器，比如：用户在浏览器上登录一个网站，那么这个浏览器就成为了一个执行者，它在用户登录后获得了用户的授权，代表着用户执行各种指令，进行购物，下单，转账等操作。<br><img src="https://img-blog.csdnimg.cn/20200618141042245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>同时，资源所有者和资源执行者可以是分开的不同实体，也可以是同一个，如果是不同实体，那么资源执行者是以资源所有者的代理形式而存在。</p><p>授权方式非常多，常见的有：银行卡、门禁卡、公证书，这些哦都是现实生活中授权的方式，其实现方式主要是通过一个共信的媒介完成，这个媒介不可被篡改，不可随意伪造，很多时候需要被保护，防止被窃取。</p><p>在互联网应用开发领域，授权所用到的授信媒介主要包括以下几种：</p><ul><li>通过web服务器的session机制，一个访问会话保持着用户的授权信息；</li><li>通过web浏览器的cookie机制，一个网站的cookie保持着用户的授权信息；</li><li>颁发授权令牌（token），一个合法有效的令牌中保持着用户的授权信息。</li></ul><p>前面两者常见于web开发， 需要有浏览器的支持。</p><h1 id="3-鉴权"><a href="#3-鉴权" class="headerlink" title="3. 鉴权"></a>3. 鉴权</h1><p>鉴权（authentication）：是指对于一个声明者所声明的身份权利的真实性进行鉴别确认的过程。</p><p>授权和鉴权是两个上下游相匹配的关系，先授权，后鉴权，鉴权是一个承上启下的环节，上游它接受授权的输出，校验其真实性后，然后获取权限（permission），这个将会为下一步的权限控制做好准备。<br><img src="https://img-blog.csdnimg.cn/20200618142323802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="4-权限控制"><a href="#4-权限控制" class="headerlink" title="4. 权限控制"></a>4. 权限控制</h1><p>权限控制（access/permission control）：是指对可执行的各种操作组合配置为权限列表，然后根据执行者的权限，若其操作在权限范围内，则允许执行，否则禁止。</p><p>权限控制其实可以分为两部分来理解：权限是抽象的逻辑概念，而控制是具体的实现方式。<br>权限（permission）一般预先定义和配置好，以便控制具体实现，一般情况下，通过基于角色的方式来定义权限，由角色来封装可执行的操作。<br>权限将执行者和可具体执行的操作分离了。</p><p>对于控制，就是根据执行者的权限，对其所执行的操作进行判断，并决定允许或禁止当前操作的执行，在互联网web后端服务，通常用来控制接口访问，允许或拒绝访问请求。</p><h1 id="5-认证、授权、鉴权和权限控制的关系"><a href="#5-认证、授权、鉴权和权限控制的关系" class="headerlink" title="5. 认证、授权、鉴权和权限控制的关系"></a>5. 认证、授权、鉴权和权限控制的关系</h1><p>认证、授权、鉴权和权限控制这四个环节是一个前后依次发生、上下游的关系。<br>比如网站登录的时候，用户在使用用户名和密码登录的时候，认证和授权两个环节先完成，而鉴权和权限控制则发生在后面的访问请求中，比如在选购物品或支付时。</p><p>从过程上讲，授权和权限控制是可以分开的两个阶段，获得了授权并不一定就能够成功执行所获得权限允许的操作，比如授权曹氏，虽然权限已颁发，但是若超时了就会失效，这个判断是由权限控制来决定，权限控制是比较灵活的阶段，除了根据客户端发过来的授权信息，还可以根据其他条件来判断是否可以执行相应的操作，比如登录的IP地址是否安全、是否长时间未登录、是否在执行大风险的操作、若有风险的话，可以进行追加鉴权操作，确定该操作确实由用户所委派。</p><h1 id="6-认证和鉴权的关系"><a href="#6-认证和鉴权的关系" class="headerlink" title="6. 认证和鉴权的关系"></a>6. 认证和鉴权的关系</h1><p>认证和鉴权其实不是一个概念，虽然两者都有对身份的确认过程，但是两者主要的区别在于：</p><ul><li>认证是确认声明者的本身身份，其作为授权的上游衔接而存在；</li><li>鉴权是对声明者所声明的真实性进确认的过程，其作为授权的下游衔接而存在；</li></ul><h1 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a>7. 小结</h1><p><img src="https://img-blog.csdnimg.cn/20200618145932956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>参考文献：<a href="http://www.hyhblog.cn/2018/04/25/user_login_auth_terms/#3" target="_blank" rel="noopener">http://www.hyhblog.cn/2018/04/25/user_login_auth_terms/#3</a></p>]]></content>
    
    
    <categories>
      
      <category>安全框架</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深入分析Java Web技术内幕-6.Servlet工作原理解析</title>
    <link href="/2020/06/17/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-6-Servlet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <url>/2020/06/17/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-6-Servlet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>带着如下问题学习本文内容：<br>1、以Tomcat为例，说说Servlet容器是如何工作的；<br>2、一个Web工程是如何在Servlet容器中启动的；<br>3、Servlet容器是如何解析你的web.xml中定义的Servlet；<br>4、用户的请求是如何被分配给指定的Servlet的；<br>5、Servlet容器是如何管理Servlet生命周期的；<br>6、Servlet的API类层次结构，以及如何分析Servlet中的一些难点问题；</p></blockquote><h1 id="1-Servlet容器"><a href="#1-Servlet容器" class="headerlink" title="1 Servlet容器"></a>1 Servlet容器</h1><p>Servlet容器作为一个独立发展的标准化产品，其存在的意义是为了适应工厂化生产，通过标准化接口来相互协作，实现Servlet和Servlet容器之间的解耦。<br>tomcat容器模型如下图所示：<br><img src="https://img-blog.csdnimg.cn/2020061719534915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>由上图可知，Tomcat的容器分为4个等级，真正管理Servlet容器的是Context容器，一个Context对应一个Web工程。</p><h2 id="1-1-Servlet容器的启动过程"><a href="#1-1-Servlet容器的启动过程" class="headerlink" title="1.1 Servlet容器的启动过程"></a>1.1 Servlet容器的启动过程</h2><p>当添加一个应用时将会创建一个StandardContext容器，并且给这个容器设置一些必要的参数，如：url和path分别代表这个应用在tomcat的访问路径和这个应用的实际物理路径，另外一个非常重要的配置是ContextConfig，这个类将会负责整个web应用配置的解析工作，最后将这个context容器加到父容器Host中。</p><p>tomcat主要类的启动时序图如下所示：<br><img src="https://img-blog.csdnimg.cn/20200617200907246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>由上图可知：tomcat的通过start()方法启动tomcat，而tomcat的启动逻辑是基于观察者模式设计的，所有的容器都会继承lifecycle接口，由他管理容器的整个生命周期，所有容器的修改和状态的改变都会由他去通知已经注册的观察者。</p><p>当context容器初始化状态为init时，添加在context容器的listener将会被触发，而ContextConfig继承了LifecycleListener接口，因此它也就被加入到StandardContext容器中，负责整个web应用的配置文件解析工作。</p><p>ContextConfig的init方法主要完成以下工作：</p><ul><li>创建用于解析xml配置文件的contextDigester对象</li><li>读取默认context.xml配置文件，解析</li><li>读取默认host配置文件，解析</li><li>读取默认context配置文件，解析</li><li>设置context的docBase</li></ul><p>ContextConfig的init方法完成后，context容器会执行startInternal方法，主要完成以下任务：</p><div class="hljs"><pre><code class="hljs markdown">1、创建读取资源文件的对象  2、创建ClassLoader对象  3、设置应用的工作目录  4、启动相关的辅助类如：logger realm resources等  5、修改启动状态，通知感兴趣的观察者（web应用的配置）  6、子容器的初始化  7、获取ServletContext并设置必要的参数  8、初始化"load on startup"的servlet</code></pre></div><h2 id="1-2-Web应用的初始化工作"><a href="#1-2-Web应用的初始化工作" class="headerlink" title="1.2 Web应用的初始化工作"></a>1.2 Web应用的初始化工作</h2><p>Web应用的初始化工作是在ContextConfig的configureStart方法中实现的，主要是为了解析web.xml文件。</p><p>在web.xml文件中的各个配置项将会被解析成相应的属性，保存在WebXml对象中。</p><p>接下来会将WebXml对象中的属性设置到Context容器中，这里包括创建Servlet对象、filter、listener等。</p><p>提问：为什么要将servlet包装成StandardWrapper？<br>因为StandardWrapper是tomcat容器中的一部分，具有容器的特征，而servlet是一个独立的web开发标准，不应该强耦合到tomcat中。</p><p>除了将servlet包装成StandardWrapper并作为子容器添加到context中，其他的所有web.xml属性都被解析到context中，所以说context容器才是真正运行servlet的容器，一个web应用对应一个context容器，容器的配置属性由应用的web.xml指定。</p><h1 id="2-创建Servlet实例"><a href="#2-创建Servlet实例" class="headerlink" title="2 创建Servlet实例"></a>2 创建Servlet实例</h1><h2 id="2-1-创建Servlet对象"><a href="#2-1-创建Servlet对象" class="headerlink" title="2.1 创建Servlet对象"></a>2.1 创建Servlet对象</h2><p>如果Servlet的load-on-startup配置项大于0，那么在Context容器启动时就会被实例化。</p><p>创建Servlet实例的方法是从Wrapper.loadServlet开始的，loadServlet方法要完成的就是获取servletClass，然后把它交给InstanceManager去创建一个基于servletClass.class的对象，如果这个Servlet配置了jsp-file，那么这个servletClass就是在conf/web.xml中定义的org.apache.jasper.servlet.JspServlet了。<br>创建Servlet对象的相关类结构图如下所示：<br><img src="https://img-blog.csdnimg.cn/20200617211923652.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="2-2-初始化Servlet"><a href="#2-2-初始化Servlet" class="headerlink" title="2.2 初始化Servlet"></a>2.2 初始化Servlet</h2><p>初始化Servlet在StandardWrapper的initServlet方法中，通过调用Servlet的init方法，同时把包装了StandardWrapper对象的StandardWrapperFacade作为ServletConfig传给Servlet。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initServlet</span><span class="hljs-params">(Servlet servlet)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;       <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.instanceInitialized || <span class="hljs-keyword">this</span>.singleThreadModel) &#123;           <span class="hljs-keyword">try</span> &#123;               <span class="hljs-keyword">if</span> (Globals.IS_SECURITY_ENABLED) &#123;                   <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;                   <span class="hljs-keyword">try</span> &#123;                       Object[] args = <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-keyword">this</span>.facade&#125;;                       SecurityUtil.doAsPrivilege(<span class="hljs-string">"init"</span>, servlet, classType, args);                       success = <span class="hljs-keyword">true</span>;                   &#125; <span class="hljs-keyword">finally</span> &#123;                       <span class="hljs-keyword">if</span> (!success) &#123;                           SecurityUtil.remove(servlet);                       &#125;                   &#125;               &#125; <span class="hljs-keyword">else</span> &#123;                   servlet.init(<span class="hljs-keyword">this</span>.facade);               &#125;               <span class="hljs-keyword">this</span>.instanceInitialized = <span class="hljs-keyword">true</span>;           &#125; <span class="hljs-keyword">catch</span> (UnavailableException var10) &#123;               <span class="hljs-keyword">this</span>.unavailable(var10);               <span class="hljs-keyword">throw</span> var10;           &#125;           <span class="hljs-comment">//省略catch</span>       &#125;   &#125;</code></pre></div><h1 id="3-Servlet体系结构"><a href="#3-Servlet体系结构" class="headerlink" title="3 Servlet体系结构"></a>3 Servlet体系结构</h1><p>Servlet顶层类关联图如下：<br><img src="https://img-blog.csdnimg.cn/20200617214705759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>与Servlet主动关联的是ServletConfig、ServletRequest和ServletResponse。这三个类都是通过容器传递给Servlet的，其中ServletConfig在Servlet初始化时就传递给Servlet了，ServletConfig中的方法主要是为了获取这个Servlet的一些配置属性，而这些属性可能在Servlet运行时被用到；<br>ServletContext可以认为是一个全局的存储信息的空间，所有用户共享一个ServletContext，tomcat启动就存在，tomcat关闭才释放；<br>ServletRequest和ServletResponse是实现数据交互的具体对象，可以理解为运输工具用来传递交互结果；</p><p>ServletConfig和ServletContext在Tomcat容器中的类关系图：<br><img src="https://img-blog.csdnimg.cn/20200617215807174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>可以看出，StandardWrapper和StandardWrapperFacade都实现了ServletConfig接口，而StandardWrapperFacade是StandardWrapper门面类，所以传给Servlet的是StandardWrapperFacade对象，这个类能够保证从StandardWrapper中拿到ServletConfig所规定的数据，而又不把ServletConfig不关心的数据暴露给Servlet。</p><p>同样，ServletContext和ServletConfig也有类似的结构，在Servlet中能拿到的ServletContext的实际对象也是ApplicationContextFacade对象，ApplicationContextFacade同样保证ServletContext只能从容器中拿到它该拿的数据，这是典型的<strong>门面设计模式</strong>。</p><p>我们在创建自己的Servlet类时通常使用的是HttpServletRequest和HttpServletResponse，它们继承了ServletRequest和ServletResponse。<strong>从Context容器中传过来的ServletRequest和ServletResponse可以直接被转化为HttpServletRequest和HttpServletResponse。</strong><br><img src="https://img-blog.csdnimg.cn/20200617222622729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>通过分析Tomcat的Request和Response类结构图可以得知：Tomcat一接收到请求首先会创建org.apache.coyote.Request和org.apache.coyote.Response，用来将请求快速分配给后续线程去处理，然后用户线程去处理这个请求时又创建org.apache.catalina.connector.Request和org.apache.catalina.connector.Response对象，直到传给Servlet，但是实际上传给Servlet的是Request和Response的门面类RequestFacade和ResponseFacade，所以我个人认为这也就解释了为何Context容器传过来的ServletRequest、ServletResponse可以被转化为HttpServletRequest和HttpServletResponse了。</p><h1 id="4-Servlet如何工作"><a href="#4-Servlet如何工作" class="headerlink" title="4 Servlet如何工作"></a>4 Servlet如何工作</h1><p>当用户从浏览器向服务器发起一个请求通常会包含以下信息：<a href="http://hostname:port/contextpath/servletpath,其中：hostname和port用来与服务器建立TCP连接，后面的URL用来选择在服务器中哪个子容器来服务用户的请求。">http://hostname:port/contextpath/servletpath,其中：hostname和port用来与服务器建立TCP连接，后面的URL用来选择在服务器中哪个子容器来服务用户的请求。</a><br>Tomcat是如何实现根据URL来到达正确的Servlet容器中的呢？<br>在Tomcat7中通过一个专门的映射类来完成，这个映射类就是org.apache.tomcat.util.http.mapper，这个类保存了Tomcat的Container容器中的所有子容器的信息，org.apache.catalina.contnector.Reqeuest类在进入Container容器之前，Mapper将会根据这次请求的hostname和contextpath将host和context容器设置到Request的mappingData属性中，所以当Request进入Container容器之前，对于它要访问哪个子容器就已经确定了。<br><img src="https://img-blog.csdnimg.cn/20200617224934814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>之所以Mapper中会有容器的完整关系，还是多亏了MapperListener类，其核心方法如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>&#123;        <span class="hljs-keyword">this</span>.setState(LifecycleState.STARTING);        Engine engine = <span class="hljs-keyword">this</span>.service.getContainer();        <span class="hljs-keyword">if</span> (engine != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">this</span>.findDefaultHost();            <span class="hljs-keyword">this</span>.addListeners(engine);            Container[] conHosts = engine.findChildren();            Container[] arr$ = conHosts;            <span class="hljs-keyword">int</span> len$ = conHosts.length;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i$ = <span class="hljs-number">0</span>; i$ &lt; len$; ++i$) &#123;                Container conHost = arr$[i$];                Host host = (Host)conHost;                <span class="hljs-keyword">if</span> (!LifecycleState.NEW.equals(host.getState())) &#123;                    <span class="hljs-keyword">this</span>.registerHost(host);                &#125;            &#125;        &#125;    &#125;</code></pre></div><p>这段代码的作用就是将MapperListener类作为一个监听者加到整个Container容器的每个子容器中，这样只要任何一个容器发生变化，MapperListener都将会被通知到，在for循环中就是将host及下面的子容器注册到mapper中。</p><p>请求到达最终的Wrapper容器后，接下来就是要执行Fiter链以及通知你在web.xml中定义的listener，然后执行Servlet的service方法。</p><p>当servlet从容器中移除时，也就意味着servlet的生命周期结束了，这次servlet的destroy方法将被调用。</p><h1 id="5-Servlet中的Listener"><a href="#5-Servlet中的Listener" class="headerlink" title="5 Servlet中的Listener"></a>5 Servlet中的Listener</h1><p>Listener是基于观察者模式设计的，能够方便地从另一个纵向维度控制程序和数据。<br>详见：<a href="https://yq.aliyun.com/articles/636239?type=2" target="_blank" rel="noopener">https://yq.aliyun.com/articles/636239?type=2</a></p><h1 id="6-Filter如何工作"><a href="#6-Filter如何工作" class="headerlink" title="6 Filter如何工作"></a>6 Filter如何工作</h1><h2 id="6-1-Fiter简介"><a href="#6-1-Fiter简介" class="headerlink" title="6.1 Fiter简介"></a>6.1 Fiter简介</h2><p>Fiter虽然不是一个Servlet，不能产生response，但是它能够在一个request到达servlet之前预处理request，也可以在response离开servlet时处理response；<br>主要用途是：比如过滤一些敏感内容、编码过滤、URL权限控制等等。</p><h2 id="6-2-工作原理"><a href="#6-2-工作原理" class="headerlink" title="6.2 工作原理"></a>6.2 工作原理</h2><p><img src="https://img-blog.csdnimg.cn/20200617231721779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="6-3-生命周期"><a href="#6-3-生命周期" class="headerlink" title="6.3 生命周期"></a>6.3 生命周期</h2><p>Filter接口中有三个重要的方法：</p><div class="hljs"><pre><code class="hljs markdown">init()方法：初始化参数，在创建Filter时自动调用。当我们需要设置初始化参数的时候，可以写到该方法中。doFilter()方法：拦截到要执行的请求时，doFilter就会执行。这里面写我们对请求和响应的预处理。destroy()方法：在销毁Filter时自动调用，当web容器调用这个方法之后，容器还会再调用一次doFilter方法。</code></pre></div><p>Filter的创建和销毁由web服务器来控制。</p><ul><li>服务器启动的时候，web服务器创建Filter的实例对象，并调用其init方法，完成对象的初始化功能，filter对象只会创建一次，init方法也只会执行一次；</li><li>拦截到请求时，执行doFilter方法，可以多次执行；</li><li>服务器关闭时，web服务器销毁Filter的实例对象。</li></ul><p>Filter类的核心还是FilterChain对象，这个对象保存了到最终Servlet对象等待所有Filter对象，这些对象都保存再ApplicationFilterChain对象的filters数组中，再FilterChain链上每执行一个Filter对象，数组的当前计数都会加1，直到计数等于数组的长度。当FilterChain上所有的Filter对象执行完成后，就会执行最终的servlet，所以在ApplicationFilterChain对象中会持有Servlet对象的引用。</p><h1 id="7-Servlet中的url-pattern"><a href="#7-Servlet中的url-pattern" class="headerlink" title="7 Servlet中的url-pattern"></a>7 Servlet中的url-pattern</h1><p>在web.xml中<srevlet-mapping>和<filter-mapping>中都有<url-pattern>配置项，其作用是匹配一次请求是否会执行这个Servlet或者Filter。<br>Filter的url-pattern匹配是在创建ApplicationFilterChain对象时进行的，它会把所有定义的Filter的url-pattern与当前的URL匹配，如果匹配成功就将这个Filter保存到ApplicationFilterChain的filters数组中，然后在FilterChain中依次调用。</p>]]></content>
    
    
    <categories>
      
      <category>Web技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谷粒商城-Day03</title>
    <link href="/2020/06/14/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-Day03/"/>
    <url>/2020/06/14/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-Day03/</url>
    
    <content type="html"><![CDATA[<h1 id="1-pms商品管理系统的介绍"><a href="#1-pms商品管理系统的介绍" class="headerlink" title="1.pms商品管理系统的介绍"></a>1.pms商品管理系统的介绍</h1><p>首先明确两个概念：SKU和SPU</p><ul><li>SKU：Stock Keeping Unit(库存量单元),即库存进出计量的单位， 可以是以件、盒、托盘等为单位。</li><li>SPU(Standard Product Unit)：标准化产品单元。是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。</li></ul><h1 id="2-pms商品的数据结构的划分"><a href="#2-pms商品的数据结构的划分" class="headerlink" title="2. pms商品的数据结构的划分"></a>2. pms商品的数据结构的划分</h1><p>1 sku的结构  pms_sku_<br>2 spu的结构  pms_spu_<br>3类目的结构 pms_catalog_<br>4属性的结构 pms_attr_</p><h1 id="3-manage系统前后端分离"><a href="#3-manage系统前后端分离" class="headerlink" title="3. manage系统前后端分离"></a>3. manage系统前后端分离</h1><p>前后端分离<br>JVM  Spring Maven IDEA<br>Nodejs  vue  npm  vscode<br>安装nodejs，npm<br>这里我用的是postman进行演示操作，所以没用到前端框架；</p><h1 id="4-商城的商品录入功能（manage）"><a href="#4-商城的商品录入功能（manage）" class="headerlink" title="4. 商城的商品录入功能（manage）"></a>4. 商城的商品录入功能（manage）</h1><p>1 三级分类的查询<br>2 商品的平台属性列表的增删改查<br>3 商品spu的添加<br>    spu列表查询<br>    spu的销售属性、属性值、Fastdfs图片上传<br>4 商品sku的添加<br>    sku信息、sku关联的销售属性、sku关联的平台属性、sku图片</p><p>1 sku的结构  pms_sku_<br>2 spu的结构  pms_spu_</p><p>3类目的结构 pms_catalog_<br>三级分类，一级二级三级</p><p>4属性的结构 pms_attr_<br>平台属性的外键是三级分类id，在使用平台属性功能之前必须选择三级分类</p><h1 id="5-商品分类的查询"><a href="#5-商品分类的查询" class="headerlink" title="5 商品分类的查询"></a>5 商品分类的查询</h1><ol><li>新建两个模块：gmall-manage-web和gmall-manage-service</li><li>配置gmall-manage-web</li><li>根据前端提供的接口写一个getCatalog1()方法来返回前端想要的数据</li><li>数据通过gmall-manage-service来提供，利用通用mapper来返回数据。</li></ol><h1 id="6-前后端的跨域问题"><a href="#6-前后端的跨域问题" class="headerlink" title="6. 前后端的跨域问题"></a>6. 前后端的跨域问题</h1><p>因为前后端端口号不一样，所以会导致跨域 问题，因此在springMvc控制层下加入@CrossOrigini注解。<br><img src="https://img-blog.csdnimg.cn/20200614161851706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="7-商品平台属性的管理功能-增删改查"><a href="#7-商品平台属性的管理功能-增删改查" class="headerlink" title="7. 商品平台属性的管理功能(增删改查)"></a>7. 商品平台属性的管理功能(增删改查)</h1><p>1 根据三级分类id，catalog3Id查询平台属性列表<br>A新建一个AttrController，方法attrInfoList<br>B新建PmsBaseAttrInfo和PmsBaseAttrValue的映射类<br>C新建service、mapper</p><p>代码：<a href="https://github.com/gavin-yyj/gmall" target="_blank" rel="noopener">https://github.com/gavin-yyj/gmall</a></p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>谷粒商城-Day02</title>
    <link href="/2020/06/14/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-Day02/"/>
    <url>/2020/06/14/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-Day02/</url>
    
    <content type="html"><![CDATA[<h1 id="1-gmall-parent父依赖的创建"><a href="#1-gmall-parent父依赖的创建" class="headerlink" title="1.gmall-parent父依赖的创建"></a>1.gmall-parent父依赖的创建</h1><p>1.1 用maven创建一个gmall-parent的工程<br>1.2 新建其他项目模块（子项目）的时候，继承自gmall-parent<br>1.3 gmall-parent中父依赖使用SpringBoot1.5.21，并打包成pom文件</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.21.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.gavin.gmall<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gmall-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span></code></pre></div><p>1.4 在gmall-parent中定义好项目的技术框架版本<br>    <strong>注意：这里只是确定版本号，实际模块中需要用到哪些依赖要自己添加，只是版本号由gmall-parent来指定。</strong></p><h1 id="2-抽取api工程（负责管理项目中所有的接口和bean）"><a href="#2-抽取api工程（负责管理项目中所有的接口和bean）" class="headerlink" title="2. 抽取api工程（负责管理项目中所有的接口和bean）"></a>2. 抽取api工程（负责管理项目中所有的接口和bean）</h1><ol><li><p>首先用maven创建一个gmall-api的工程；</p></li><li><p>将XXXService接口和所有的bean类都放到api中；</p></li><li><p>修改有依赖Service接口和bean类的引入全部修改引入路径。</p><h1 id="3-抽取util工程"><a href="#3-抽取util工程" class="headerlink" title="3. 抽取util工程"></a>3. 抽取util工程</h1></li><li><p>项目中的通用框架，是所有应用工程需要引入的包<br>例如：springboot，common-langs，common-beanutils</p></li><li><p>基于soa的架构理念，项目分为web前端controller（webUtil）<br>例如：Jsp，thymeleaft，cookie工具类<br>需要加入commonUtil</p></li><li><p>基于soa的架构理念，项目分为web后端service（serviceUtil）<br>例如：Mybatis，MySQL，Redis<br>同样需要加入commonUtil</p></li></ol><h1 id="4-soa面向服务（以dobbo为基础）"><a href="#4-soa面向服务（以dobbo为基础）" class="headerlink" title="4. soa面向服务（以dobbo为基础）"></a>4. soa面向服务（以dobbo为基础）</h1><p>特点：<br>1.dubbo的soa的工作原理和springcloud类似；<br>2.dubbo和springcloud的区别在于dubbo由自己的dubbo协议通信，springcloud是由http协议（rest风格）进行通信；<br>3.dubbo有一个注册中心的客户端在实时同步注册中心的服务信息；<br>4.dubbo有一个javaweb的监控中心，负责监控服务的注册信息，甚至可以配置负载均衡。</p><h1 id="5-引入Dubbo"><a href="#5-引入Dubbo" class="headerlink" title="5.引入Dubbo"></a>5.引入Dubbo</h1><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><h3 id="安装虚拟机"><a href="#安装虚拟机" class="headerlink" title="安装虚拟机"></a>安装虚拟机</h3><p><a href="https://blog.csdn.net/qq_31939617/article/details/100114546" target="_blank" rel="noopener">https://blog.csdn.net/qq_31939617/article/details/100114546</a></p><h3 id="安装xshell"><a href="#安装xshell" class="headerlink" title="安装xshell"></a>安装xshell</h3><p>配置ssh：<a href="https://www.cnblogs.com/cookiewu/p/9664062.html" target="_blank" rel="noopener">https://www.cnblogs.com/cookiewu/p/9664062.html</a><br>成功的标志：<br><img src="https://img-blog.csdnimg.cn/20200612191359842.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><a href="https://www.cnblogs.com/Hijack-you/p/10501136.html" target="_blank" rel="noopener">安装和使用XShell</a></p><h3 id="配置JDK"><a href="#配置JDK" class="headerlink" title="配置JDK"></a>配置JDK</h3><p><a href="https://www.cnblogs.com/liunanjava/p/4296540.html" target="_blank" rel="noopener">https://www.cnblogs.com/liunanjava/p/4296540.html</a></p><div class="hljs"><pre><code class="hljs markdown">用XShell将windows下的JDK包传输到ubuntu指定的路径下，来到xshell的命令行，前提是虚拟机与xshell通信正常，来到ubuntu需要存放的安装包的路径下，在root权限下输入<span class="hljs-code">`rz`</span>，然后就将windows下的安装包发送就OK了。解压文件：tar -zxvf jdk-8u31-linux-x64.tar.gz进入文件目录：root@yyj-virtual-machine:/opt# cd jdk1.8.0_152/root@yyj-virtual-machine:/opt/jdk1.8.0_152# pwd/opt/jdk1.8.0_152修改配置文件：root@yyj-virtual-machine:~# source ~/.bashrcexport JAVA<span class="hljs-emphasis">_HOME=/opt/jdk1.8.0_</span>152export JRE<span class="hljs-emphasis">_HOME=$&#123;JAVA_</span>HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA<span class="hljs-emphasis">_HOME&#125;/lib:$&#123;JRE_</span>HOME&#125;/libexport PATH=.:$&#123;JAVA_HOME&#125;/bin:$PATH出现下面文字说明JDK配置成功：root@yyj-virtual-machine:~# java -versionjava version "1.8.0_152"</code></pre></div><h3 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h3><p><a href="https://www.jianshu.com/p/a3fcd1ec7a17" target="_blank" rel="noopener">https://www.jianshu.com/p/a3fcd1ec7a17</a></p><div class="hljs"><pre><code class="hljs MarkDown">root@yyj-virtual-machine:~# cd /optroot@yyj-virtual-machine:/opt# cd apache-tomcat-8.5.24root@yyj-virtual-machine:/opt/apache-tomcat-8.5.24# cd binroot@yyj-virtual-machine:/opt/apache-tomcat-8.5.24/bin# ./startup.sh Using CATALINA_BASE:   /opt/apache-tomcat-8.5.24Using CATALINA_HOME:   /opt/apache-tomcat-8.5.24Using CATALINA_TMPDIR: /opt/apache-tomcat-8.5.24/tempUsing JRE<span class="hljs-emphasis">_HOME:        /opt/jdk1.8.0_</span>152/jreUsing CLASSPATH:       /opt/apache-tomcat-8.5.24/bin/bootstrap.jar:/opt/apache-tomcat-8.5.24/bin/tomcat-juli.jarTomcat started.</code></pre></div><h3 id="安装dubbo-admin-war"><a href="#安装dubbo-admin-war" class="headerlink" title="安装dubbo-admin.war"></a>安装dubbo-admin.war</h3><div class="hljs"><pre><code class="hljs markdown">1 将dubbo监控中心和tomct上传至linux服务器2 用unzip命令解压dubbo-admin.war监控中心Unzip file文件名 -d 解压路径3 配置tomcat的server.xml配置文件先要进入tomcat的配置文件，然后打开服务器配置文件cd /opt/apache-tomcat-8.5.24/confsudo vi server.xml再修改里面的内容，增加Context标签<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Context</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/dubbo"</span> <span class="hljs-attr">docBase</span>=<span class="hljs-string">"/opt/dubbo"</span> <span class="hljs-attr">debug</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">privileged</span>=<span class="hljs-string">"true"</span> /&gt;</span></span>4 启动tomcat，打开监控中心</code></pre></div><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p><a href="https://www.cnblogs.com/tangzz/p/11950126.html" target="_blank" rel="noopener">https://www.cnblogs.com/tangzz/p/11950126.html</a></p><h3 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h3><p>我是用docker装的，如果网上的主流方法不行，可以用docker来装</p><h3 id="安装Zookeeper"><a href="#安装Zookeeper" class="headerlink" title="安装Zookeeper"></a>安装Zookeeper</h3><p><a href="https://blog.csdn.net/qq_41822647/article/details/84647037" target="_blank" rel="noopener">https://blog.csdn.net/qq_41822647/article/details/84647037</a></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-number">1</span> 解压zookeeperTar -zxvf <span class="hljs-number">2</span> 修改zookeeper的配置文件Conf/zoo.cfg建立一个/opt/zookeeper-<span class="hljs-number">3.4</span><span class="hljs-number">.11</span>/data数据目录需要修改dataDir的内容，改为上面 你创建的数据目录<span class="hljs-number">3</span> 启动zookeeper./zkServer.sh start ./zkServer.sh status</code></pre></div><p>此时在浏览器输入你的虚拟机ip：端口号/dubbo，出现下面界面说明配置成功：</p><h1 id="总结"><a href="#总结" class="headerlink" title=" 总结"></a><img src="https://img-blog.csdnimg.cn/20200614100436794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"> 总结</h1><p>项目源码：<a href="https://github.com/gavin-yyj/gmall" target="_blank" rel="noopener">https://github.com/gavin-yyj/gmall</a><br>运行<code>GmallManageServiceApplication</code>，刷新浏览器，会显示你的services服务：<br><img src="https://img-blog.csdnimg.cn/20200614103558281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>同时命令行中会打印心跳：<br><img src="https://img-blog.csdnimg.cn/20200614103657715.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>第二天的主要工作是配置环境，另外就是将我们这个项目的代码按照分布式架构进行设计。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深入分析Java Web技术内幕-5.JVM内存管理</title>
    <link href="/2020/06/12/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-5-JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2020/06/12/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-5-JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-物理内存与虚拟内存"><a href="#1-物理内存与虚拟内存" class="headerlink" title="1 物理内存与虚拟内存"></a>1 物理内存与虚拟内存</h1><ol><li>物理内存就是RAM（随机存储器），还有一个存储单元叫做寄存器，连接处理器和RAM或者寄存器的是地址总线，这个地址总线的宽度影响了物理地址的索引范围，同时也决定了处理器最大可以寻址的地址空间。</li><li>除了硬件程序或者驱动程序需要直接访问存储器外，大部分情况下都是通过操作系统提供的接口来访问内存，在java中甚至不需要写和内存相关的代码。</li><li>我们要运行程序，都要向操作系统先申请内存地址，每个进程拥有一段独立的地址空间，操作系统也会保证每个进程只能访问自己的内存空间。</li><li>虚拟内存的出现使得多个进程在同时运行时可以共享物理内存，虚拟地址不但可以让进程共享物理内存，提高内存利用率，而且还能扩展内存的地址空间。如：一个进程在不活动的情况下，操作系统将这个物理内存中的数据移到一个磁盘文件中，而真正高效的物理内存留给正在活动的程序使用。</li></ol><h1 id="2-内核空间与用户空间"><a href="#2-内核空间与用户空间" class="headerlink" title="2 内核空间与用户空间"></a>2 内核空间与用户空间</h1><p>内核空间主要是操作系统运行时所使用的用于进程调度，虚拟内存的使用或者硬件资源等的程序逻辑。<br>为了保证系统的稳定性和安全性，所以分为两个空间，如访问硬件资源只能由操作系统来完成，用户程序不允许直接访问硬件资源。<br>如果用户需要访问硬件资源，如网络连接等，可以调用操作系统提供的接口来访问。<br>在执行系统调用的时候，需要在两个内存空间进行切换、复制，虽然保证了程序运行的稳定性和安全性，但是也牺牲了一部分效率，Linux系统提供了sendfile文件传输方式来减少复制带来的开销。</p><h1 id="3-在Java中哪些组件需要使用内存"><a href="#3-在Java中哪些组件需要使用内存" class="headerlink" title="3 在Java中哪些组件需要使用内存"></a>3 在Java中哪些组件需要使用内存</h1><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>Java堆是用于存储Java对象的内存区域，堆的大小在JVM启动时就一次向操作系统申请完成，通过-Xmx和-Xms两个选项来控制。-xmx表示堆的最大值，xms表示初始大小，一旦分配完成，堆空间就固定了。不能重新申请。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>JVM运行实际程序的实体是线程，每个线程创建时JVM都会为它创建一个堆栈。<br>如果运行的应用程序的线程数量比可用于处理它们的处理器数量多，效率通常很低，并且可能导致比较差的性能和更高的内存占用率。</p><h2 id="类和类加载器"><a href="#类和类加载器" class="headerlink" title="类和类加载器"></a>类和类加载器</h2><p>JVM是按需加载类的，JVM只会加载那些在你的应用程序中明确要使用的类到内存中，要查看JVM到底加载了哪些类，可以在启动参数上加上<code>-verbose:class</code>。<br>如果使用自定义的类加载器来加载类，可能会出现重复加载的情况，就有可能导致PermGen区内存泄漏。<br>通常一个类能够被卸载，需要满足如下条件：</p><div class="hljs"><pre><code class="hljs markdown">1：在Java堆中没加载有该类的classloader对象的引用。2：java堆上没有加载该类的classloader已加载的类的class对象引用3：java堆上没有加载该类的类加载器加载的任何类的对象由于jvm创建的三个默认类加载器都不可能满足这些条件，所以任何系统类加载器加载的类都不能在运行时被释放。</code></pre></div><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><div class="hljs"><pre><code class="hljs markdown">NIO引入了一种基于通道和缓存区来执行I/O的新方式；NIO使用java.nio.ByteBuffer.allocateDirect()方法分配内存；ByteBuffer.allocateDirect()分配的内存使用的是本机内存而不是Java堆上的内存，每次分配内存时会调用操作系统的os:malloc()函数；ByteBuffer产生的数据如果和网络或者磁盘交互都在操作系统的内核空间中发生，不需要将数据复制到Java内存中，避免了在Java堆与本机堆之间复制数据；很多NIO框架都在代码中显式地调用System.gc()来释放NIO持有的内存，但是这样做回影响应用程序的性能，还有可能导致内存泄漏。</code></pre></div><h2 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h2><p>JNI技术使得java代码可以调用本机代码（比如c语言程序）。这部分用到了native memory，也就是本地内存。</p><h1 id="4-JVM内存结构"><a href="#4-JVM内存结构" class="headerlink" title="4 JVM内存结构"></a>4 JVM内存结构</h1><h2 id="PC寄存器（程序计数器）"><a href="#PC寄存器（程序计数器）" class="headerlink" title="PC寄存器（程序计数器）"></a>PC寄存器（程序计数器）</h2><p>它用于保存当前正常执行的程序的内存地址，当有多个线程交叉执行时，被中断线程的程序当前执行到哪条的内存地址必然要保存下来，以便于它被恢复执行时再按照被中断时的指令地址继续执行下去。</p><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-number">1</span> Java的栈和线程关联在一起。<span class="hljs-number">2</span> 每个线程有一个栈。<span class="hljs-number">3</span> 每运行一个方法就创建一个新栈帧。<span class="hljs-number">4</span> 栈帧包含了内部变量（方法内部的变量，不是方法参数，方法参数用调用者传来），操作数栈，方法返回值等信息。<span class="hljs-number">5</span> 每个方法执行完成时，每个栈帧都会弹出栈帧的元素作为方法的返回值。<span class="hljs-number">6</span> java栈的栈顶就是当前的活动栈，pc寄存器会指向这个地址。<span class="hljs-number">7</span> 线程私有，不用担心数据一致性问题，也不会存在同步锁的问题</code></pre></div><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是存储对象的地方，每一个存储在堆中的对象都是这个对象类的一个副本，它会复制包括继承它的父类的所有非静态属性。<br>注意是非静态属性，静态属性编译时确定，存在类的元数据中，在方法区。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，是线程共享的内存区域。<br>方法区存储的数据比较稳定，不会被频繁回收。</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池时方法区的一部分，用于存放编译期生成的各种字面量和符号引用。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈是为JVM运行本地方法（Native）方法准备的空间，跟Java栈的作用类似。</p><h1 id="5-JVM内存分配策略"><a href="#5-JVM内存分配策略" class="headerlink" title="5 JVM内存分配策略"></a>5 JVM内存分配策略</h1><h2 id="通常的内存分配策略"><a href="#通常的内存分配策略" class="headerlink" title="通常的内存分配策略"></a>通常的内存分配策略</h2><p>在操作系统中内存分配策略分为三种，分别是：</p><ul><li>静态内存分配</li><li>栈内存分配</li><li>堆内存分配<br>静态内存分配是指在程序编译时就能确定每个数据在运行时的存储空间需求，因此在编译时就可以给它们分配固定的内存空间。<br>栈内存分配也可以称为动态存储分配，是由一个类似于堆栈的运行栈来实现的，按照先进后出的原则进行分配。<br>堆内存分配是在程序运行时才执行的，它的运行效率也是比较差的。<h2 id="Java中的内存分配详情"><a href="#Java中的内存分配详情" class="headerlink" title="Java中的内存分配详情"></a>Java中的内存分配详情</h2>Java栈的分配是和线程绑定在一起的，没创建一个线程，虚拟机就为其分配一个Java栈，一个线程的方法的调用和返回对应这个Java栈的压栈和出栈。当线程激活一个Java方法时，JVM就会在线程的Java堆栈里新压入一个帧，这个帧用来保存参数，局部变量，中间计算过程和其他数据。<br>栈中主要存放一些基本类型的数据变量（int、short、long、byte、float、double、boolean、char）和对象句柄（引用）。<br>优点：存取速度快，数据可以共享；<br>缺点：存在栈中 的数据大小与生存期必须确定，缺乏灵活性。</li></ul><p>每个Java应用都唯一对应一个JVM实例，每个实例唯一对应一个堆，应用程序在运行中所创建的所有类实例或数组都放在这个堆中，并由应用程序所有的线程共享。<br>所有对象的存储空间都是在堆中分配，但是这个对象的引用却是在堆栈中分配；<br>堆的优势是可以动态地分配内存大小；<br>缺点是存取速度慢。</p><p>从栈和堆的功能和作用来通俗的比较：堆主要用来存放对象，栈主要用来执行程序。</p><h1 id="6-JVM内存回收策略"><a href="#6-JVM内存回收策略" class="headerlink" title="6 JVM内存回收策略"></a>6 JVM内存回收策略</h1><p>通常显式的内存申请有两种：静态内存分配和动态内存分配</p><h2 id="静态内存分配和回收"><a href="#静态内存分配和回收" class="headerlink" title="静态内存分配和回收"></a>静态内存分配和回收</h2><p>在Java中静态内存分配是指在Java被编译时就已经能够确定需要的内存空间，当程序被加载时系统把内存一次性分配给它。、<br>在Java的类和方法中的局部变量包括原生数据类型和对象的引用都是静态分配内存。<br>静态内存空间是在Java栈上分配的，当着方法运行结束时，对应的栈帧也就撤销，所以分配的静态内存空间也就回收了。</p><h2 id="动态内存分配和回收"><a href="#动态内存分配和回收" class="headerlink" title="动态内存分配和回收"></a>动态内存分配和回收</h2><p>基本数据类型存储在Java栈中，方法执行结束就会消失，而对象类型存储在Java堆中，是可以被共享的，也不一定随着方法执行结束而被消失。<br>动态分配是程序只有在执行时才知道要分配的存储空间大小，而不是在编译时就能够确定的。<br>内存的回收是以对象不再引用为前提的。</p><h2 id="如何检测垃圾"><a href="#如何检测垃圾" class="headerlink" title="如何检测垃圾"></a>如何检测垃圾</h2><p>只要对象不再被其他活动对象引用，那么就可以被回收，这里的活动对象是指能够被一个根对象集合到达的对象，也就是我们通常所说的可达性分析。<br>除了可达性分析外，还有一种方法叫做引用计数法，但是不推荐使用，因为相互引用会导致无法被垃圾收集器回收，从而可能造成内存泄漏。</p><h2 id="基于分代的垃圾收集是算法"><a href="#基于分代的垃圾收集是算法" class="headerlink" title="基于分代的垃圾收集是算法"></a>基于分代的垃圾收集是算法</h2><p>把对象按照寿命长短来分组，分为年轻代和年老代，如果对象经过几次回收后仍然存活，那么再把这个对象划分到年老代。<br>JVM将整个堆划分为Young区、Old区和Perm区，分别存放不同年龄的对象。<br><img src="https://img-blog.csdnimg.cn/20200614231204862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Young区分为"><br>Young区分为Eden区和两个Survivor区，其中所有新建的对象都放在Eden区，当Eden区满后会触发<strong>minor GC</strong>将Eden区仍然存活的对象复制到其中一个Survivor区中，另外一个Survivor区中的存活对象也复制到这个Survivor中，以保证始终有一个Survivor区是空的。<br>Old区存放的是Young区的Survivor满后触发minor GC后仍然存活的对象，当Eden区满后会将对象存放到Survivor区中，如果Survivor区仍然存放不下这些对象，GC收集器会将这些对象直接放到Old区，如果在Survivor区中的对象足够老，也直接放到Old区，如果Old区也满了，将会触发<strong>Full GC</strong>，回收整个堆内存。<br>Perm区存放的主要是类的Class对象，如果一个类被频繁的加载，也可能导致Perm区满，Perm区的垃圾回收也是由Full GC触发的。<br>建议：Young区的大小为整个堆的1/4，而Young区的Survivor区一般设置为整个Young区的1/8。</p>]]></content>
    
    
    <categories>
      
      <category>Web技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入分析Java Web技术内幕-4.深入分析ClassLoader工作机制</title>
    <link href="/2020/06/12/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-4-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90ClassLoader%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/06/12/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-4-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90ClassLoader%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是ClassLoader"><a href="#1-什么是ClassLoader" class="headerlink" title="1 什么是ClassLoader"></a>1 什么是ClassLoader</h1><p>当我们编写的程序在运行的时候，需要调用其他.class文件中的方法，在Java中并不会一次性加载程序的所要用的所有的class文件，而是根据程序的需要，通过Java的类加载机制来动态加载某个.class文件到内存当中，只有class文件被加载到内存中后，才能被其他clss所引用，JVM负责加载.class字节码到内存，而<strong>ClassLoader</strong>就负责将.class字节码加载到JVM中。<br>ClassLoader除了能将Class加载到JVM中之外，还有两个作用：<br>1、审查每个类应该由谁加载；<br>2、Class字节码重新解析成JVM统一要求的对象格式；</p><p>虚拟机设计团队把类加载阶段中的“<strong>通过一个类的全限定名来获取描述此类的二进制字节流</strong>”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p><h1 id="ClassLoader常用方法"><a href="#ClassLoader常用方法" class="headerlink" title="ClassLoader常用方法"></a>ClassLoader常用方法</h1><h2 id="defineClass-byte-int-int"><a href="#defineClass-byte-int-int" class="headerlink" title="defineClass(byte[],int,int)"></a>defineClass(byte[],int,int)</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; defineClass(<span class="hljs-keyword">byte</span>[] b, <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len)        <span class="hljs-keyword">throws</span> ClassFormatError</code></pre></div><p>用来将byte字节流解析成JVM能够识别的Class对象</p><h2 id="findClass-String"><a href="#findClass-String" class="headerlink" title="findClass(String)"></a>findClass(String)</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException(name);&#125;</code></pre></div><p>defineClass通常和findClass方法一起使用，通过直接覆盖ClassLoader父类的findClass方法来实现类的加载规则，从而取得要加载类的字节码。然后调用defineClass方法生成类的Class对象。</p><h2 id="resolveClass-Class-lt-gt"><a href="#resolveClass-Class-lt-gt" class="headerlink" title="resolveClass(Class&lt;?&gt;)"></a>resolveClass(Class&lt;?&gt;)</h2><p>在类被加载到JVM中调用该方法就会被链接（Link）</p><h2 id="loadClass-String-boolean"><a href="#loadClass-String-boolean" class="headerlink" title="loadClass(String , boolean)"></a>loadClass(String , boolean)</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)       <span class="hljs-keyword">throws</span> ClassNotFoundException   &#123;       <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;           <span class="hljs-comment">// 1.检查这个类是否已经被加载了</span>           Class&lt;?&gt; c = findLoadedClass(name);           <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;               <span class="hljs-keyword">long</span> t0 = System.nanoTime();               <span class="hljs-keyword">try</span> &#123;                   <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;                   <span class="hljs-comment">//如果父加载器存在，使用父加载器加载</span>                       c = parent.loadClass(name, <span class="hljs-keyword">false</span>);                   &#125; <span class="hljs-keyword">else</span> &#123;                   <span class="hljs-comment">//使用内置加载器加载</span>                       c = findBootstrapClassOrNull(name);                   &#125;               &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;                   <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span>                   <span class="hljs-comment">// from the non-null parent class loader</span>               &#125;               <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;                   <span class="hljs-comment">// 如果仍未加载，调用findClass方法加载</span>                   <span class="hljs-keyword">long</span> t1 = System.nanoTime();                   c = findClass(name);                   <span class="hljs-comment">// this is the defining class loader; record the stats</span>                   sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                   sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                   sun.misc.PerfCounter.getFindClasses().increment();               &#125;           &#125;           <span class="hljs-comment">//根据第二个参数来决定是否链接（Link）</span>           <span class="hljs-keyword">if</span> (resolve) &#123;               resolveClass(c);           &#125;           <span class="hljs-keyword">return</span> c;       &#125;   &#125;</code></pre></div><h1 id="ClassLoader的等级加载机制"><a href="#ClassLoader的等级加载机制" class="headerlink" title="ClassLoader的等级加载机制"></a>ClassLoader的等级加载机制</h1><h2 id="BootstrapClassLoader"><a href="#BootstrapClassLoader" class="headerlink" title="BootstrapClassLoader"></a>BootstrapClassLoader</h2><p>主要加载JVM自身工作需要的类，完全由JVM自己控制，别人访问不了这个类，它仅仅是一个类的加载工具而已，既没有更高一级的父加载器，也没有子加载器。</p><h2 id="ExtClassLoader"><a href="#ExtClassLoader" class="headerlink" title="ExtClassLoader"></a>ExtClassLoader</h2><p>ExtClassLoader称为扩展类加载器，主要负责加载Java的扩展类库,默认加载<code>JAVA_HOME/jre/lib/ext/</code>目录下的所有jar包或者由<code>java.ext.dirs</code>系统属性指定的jar包.放入这个目录下的jar包对AppClassLoader加载器都是可见的(因为ExtClassLoader是AppClassLoader的父加载器,并且Java类加载器采用了委托机制)。</p><h2 id="AppClassLoader"><a href="#AppClassLoader" class="headerlink" title="AppClassLoader"></a>AppClassLoader</h2><p>AppClassLoader应用类加载器,又称为系统类加载器,负责在JVM启动时,加载来自在命令java中的<code>classpath</code>或者<code>java.class.path</code>系统属性或者<code>CLASSPATH</code>操作系统属性所指定的JAR类包和类路径。<br>我们在实现自己的类加载器的时候，不管是直接实现抽象类ClassLoad还是继承URLClassLoad类，或是其他子类，他的父加载器都是AppClassLoad，因为不管调用哪个父类构造器，创建的对象都必须最终调用<code>getSystemClassLoader()</code>作为父加载器，而<code>getSystemClassLoader()</code>方法返回的正是AppClassLoader。</p><p>JVM加载class文件到内存的两种方式：<br><strong>隐式加载</strong>：不通过在代码里调用ClassLoader来加载需要的类，而是通过JVM来自动加载需要的类到内存的方式，例如：当我们在类中继承或者引用某个类时，JVM在解析当前这个类时发现引用的类不在内存中，那么就会自动将这些类加载到内存中。<br><strong>显示加载</strong>：在代码中通过调用ClassLoader类来加载一个类的方式，例如：调用<code>this.getClass.getClassLoader().loadClass()</code>或者<code>Class.forName()</code>，或者是调用我们自己实现的ClassLoader的findClass()方法等。</p><h1 id="3-如何加载class文件"><a href="#3-如何加载class文件" class="headerlink" title="3 如何加载class文件"></a>3 如何加载class文件</h1><p>将ClassLoader加载一个class文件到JVM时需要经过的步骤如下：<br><img src="https://img-blog.csdnimg.cn/20200612110825762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>    第一个阶段是找到.class文件并把这个文件包含的字节码加载到内存中。<br>    第二个阶段又可以分为三个步骤，分别实字节码验证、Class类数据结构及相应的内存分配和最后的符号表的链接。<br>    第三个阶段是类中静态属性和初始化赋值，以及静态块的执行等。</p><h2 id="加载字节码到内存"><a href="#加载字节码到内存" class="headerlink" title="加载字节码到内存"></a>加载字节码到内存</h2><p>查看URLClassLoader部分源码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">URLClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SecureClassLoader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Closeable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> URLClassPath ucp;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AccessControlContext acc;<span class="hljs-comment">//构造方法必须要指定一个URL数据才能够创建URLClassLoader对象，也就是必须要指定这个ClassLoader默认到哪个目录下去查找class文件</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">URLClassLoader</span><span class="hljs-params">(URL[] urls)</span> </span>&#123;        <span class="hljs-keyword">super</span>();        SecurityManager security = System.getSecurityManager();        <span class="hljs-keyword">if</span> (security != <span class="hljs-keyword">null</span>) &#123;            security.checkCreateClassLoader();        &#125;        <span class="hljs-keyword">this</span>.acc = AccessController.getContext();        <span class="hljs-comment">//通过一个URLClassPath类帮助取得要加载的class文件字节流,URLClassPath也就定义了到哪去找这个class文件，如果找到了这个class文件，在读取他的byte字节流，通过调用defineClass()方法来创建类对象。</span>        ucp = <span class="hljs-keyword">new</span> URLClassPath(urls, acc);    &#125;<span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(<span class="hljs-keyword">final</span> String name)        <span class="hljs-keyword">throws</span> ClassNotFoundException    &#123;        <span class="hljs-keyword">final</span> Class&lt;?&gt; result;        <span class="hljs-keyword">try</span> &#123;            result = AccessController.doPrivileged(                <span class="hljs-keyword">new</span> PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;                    <span class="hljs-keyword">public</span> Class&lt;?&gt; run() <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;                        String path = name.replace(<span class="hljs-string">'.'</span>, <span class="hljs-string">'/'</span>).concat(<span class="hljs-string">".class"</span>);                        <span class="hljs-comment">//这里就用到了ucp来取得要加载类的字节码</span>                        Resource res = ucp.getResource(path, <span class="hljs-keyword">false</span>);                        <span class="hljs-keyword">if</span> (res != <span class="hljs-keyword">null</span>) &#123;                            <span class="hljs-keyword">try</span> &#123;                            <span class="hljs-comment">//生成Class对象</span>                                <span class="hljs-keyword">return</span> defineClass(name, res);                            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException(name, e);                            &#125;                        &#125; <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;                        &#125;                    &#125;                &#125;, acc);        &#125; <span class="hljs-keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;            <span class="hljs-keyword">throw</span> (ClassNotFoundException) pae.getException();        &#125;        <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException(name);        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre></div><p>在URLClassLoader中通过一个URLClassPath类帮助取得要加载的class文件字节流，而这个URLClassPath定义了到哪里去找这个class文件，如果找到了这个class文件，再读取它的byte字节流，通过调用defineClass()方法来创建类对象。</p><p>在创建URLClassPath对象时会根据传过来的URL数组中的路径来判断是文件还是jar包，根据路径的不同分别创建FileLoader或者JarLoader，或者使用默认的加载器。当JVM调用findClass时由这几个加载器来将class文件的字节码加载到内存中。</p><h2 id="验证与解析"><a href="#验证与解析" class="headerlink" title="验证与解析"></a>验证与解析</h2><ul><li>字节码验证，类装入器对于类的字节码要做许多检测，以确保格式正确、行为正确。</li><li>类准备，在这个阶段准备代表每个类中定义的字段、方法和实现接口所必须的数据结构。</li><li>解析，在这个阶段类装入器装入类所引用的其他所有类。可以用许多方式引用类，如超类、接口、字段、方法签名、方法中使用的本地变量。<h2 id="初始化Class对象"><a href="#初始化Class对象" class="headerlink" title="初始化Class对象"></a>初始化Class对象</h2>在类中包含的静态初始化器都会被执行，设置为默认值。<h1 id="4-常见加载类错误分析"><a href="#4-常见加载类错误分析" class="headerlink" title="4 常见加载类错误分析"></a>4 常见加载类错误分析</h1><h2 id="ClassNotFoundException"><a href="#ClassNotFoundException" class="headerlink" title="ClassNotFoundException"></a>ClassNotFoundException</h2>这个异常通常发生在显式加载类的时候。<br>显式加载通常有如下方式：</li><li>通过类Class中的forName()方法；</li><li>通过类ClassLoader中的loadclass()方法；</li><li>通过类ClassLoader中的findSystemClass()方法</li></ul><p>出现这类错误也很好理解，就是当JVM要加载指定文件的字节码到内存时，并没由找到这个类对应的字节码，也就是说这个字节码.class文件不存在。解决方法就是检测在当前的classpath目录下有没有指定的文件存在，如果不知道classpath路径，就可以通过如下命令获取：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">this</span>.getClass().getClassLoader().getResource(<span class="hljs-string">""</span>).toString()</code></pre></div><h2 id="NoClassDefFoundError"><a href="#NoClassDefFoundError" class="headerlink" title="NoClassDefFoundError"></a>NoClassDefFoundError</h2><p>这个异常在第一次使用命令执行Java类时很可能会碰到，如下面这种情况</p><div class="hljs"><pre><code class="hljs java">java -cp example.jar Example</code></pre></div><p>假如在这个jar包里面只有一个类，这个类时net.xx.Exmple ，那么原因很可能是你在命令行中没有加类的包名，正确的写法是这样的：</p><div class="hljs"><pre><code class="hljs java">java cp example.jar net.xx.Example</code></pre></div><p>在JVM的规范中描述了出现NoClassDefFoundError可能的情况就是使用new关键字、属性引用某个类、继承了某个接口或者类，以及方法的某个参数中引用了某个类，这个是出发JVM隐式加载这些类时发现这些类不存在的异常。</p><p>解决这个错误的方法就是确保这个类引用的类都在当前的classpath下面</p><h2 id="ClassCastException"><a href="#ClassCastException" class="headerlink" title="ClassCastException"></a>ClassCastException</h2><p>通常在程序中出现强制类型转换时出现这个错误。<br>JVM在做类型转换时会按照如下规则进行检查</p><ul><li>对于普通对象，对象必须时目标类的实例或目标类的子类的实例。如果目标是是接口，那么会把它当作实现了接口的一个子类。</li><li>对于数组类型，目标类必须是数组类型或java.lang.Object、java.lang.Cloneable、java.io.Serializele</li></ul><p>如果不满足上面的规则，JVM就会报这个错误。要避免这个错误有两种方式：</p><ul><li>在容器类型中现实的指明这个容器所包含的对象类型</li><li>先通过instanceof检查是不是目标类型，然后再进行强制类型转换。<h2 id="ExceptionInInitializerError"><a href="#ExceptionInInitializerError" class="headerlink" title="ExceptionInInitializerError"></a>ExceptionInInitializerError</h2>这个错误在JVM规范中是这样定义的：</li><li>如果Java虚拟机试图创建类ExceptionInInitializerError的新实例，但是因为出现Out-Of-Memory-Error而无法创建新实例，那么就抛出OutOfMemoryError对象作为代替。</li><li>如果初始化器抛出一些Excepton，而且Exception类不是Error或者它的某个子类，那么就会创建ExceptioinInInitializerError类的一个新实例，并用Exception作为参数，用这个实例代替Excepiton。<h2 id="UnsatisfiedLinkError"><a href="#UnsatisfiedLinkError" class="headerlink" title="UnsatisfiedLinkError"></a>UnsatisfiedLinkError</h2>这个异常倒不是很常见，但是出错的话，通常是在JVM启动的时候，如果一不小心将在JVM的某个lib删除了，可能就会报这个错误。</li></ul><p>参考文献：<br>1 <a href="https://blog.csdn.net/u013412772/article/details/80837735" target="_blank" rel="noopener">https://blog.csdn.net/u013412772/article/details/80837735</a></p>]]></content>
    
    
    <categories>
      
      <category>Web技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入分析Java Web技术内幕-3.深入分析Java Web中的中文编码问题</title>
    <link href="/2020/06/11/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-3-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-Web%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <url>/2020/06/11/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-3-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-Web%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-几种常见的编码格式"><a href="#1-几种常见的编码格式" class="headerlink" title="1 几种常见的编码格式"></a>1 几种常见的编码格式</h1><h2 id="为什么要编码"><a href="#为什么要编码" class="headerlink" title="为什么要编码"></a>为什么要编码</h2><p>在计算机中存储信息的最小单元是1个字节（8bit），所以能表示的字符范围是0-255个。人类要表达的字符太多，无法用1个字节完全表示。要解决这个问题需要使用新的数据结构char，从char到byte必须编码。</p><h2 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h2><p>ASCII码：共128个，用一个字节的低7位表示，0-31控制字符，32-126打印字符。</p><p>ISO-8859-1：拓展自ASCII码，覆盖大多数西欧语言字符，单字节编码，共能表示256个字节。</p><p>GB2312：双字节编码，包含6763个汉字。</p><p>GBK：拓展自GB2312，和GB2312兼容，能表示21003个汉字。</p><p>GB18030：可能单字节、双字节或四字节，应用不广泛。</p><p>UTF-16：具体定义了<code>Unicode</code>[统一码]字符在计算机中的存取方法。定长，使用两个字节表示任何字符。Java以UTF-16作为内存的字符存储格式。</p><p>UTF-8：采用变长技术，每个编码区域有不同的字码长度。中文一般占三个字节。</p><h1 id="2-Java中的编码操作"><a href="#2-Java中的编码操作" class="headerlink" title="2 Java中的编码操作"></a>2 Java中的编码操作</h1><h2 id="I-O操作："><a href="#I-O操作：" class="headerlink" title="I/O操作："></a>I/O操作：</h2><p>上一篇文章介绍I/O字符和字节转化的时候有提到两个类：<code>StreamDecoder</code>和<code>StreamEncoder</code>，InputStreamReader在I/O过程中处理读取字节到字符的转换，其委托StreamDecoder实现字节到字符的节码实现，解码过程中必须由用户指定Charset编码格式，默认使用本地环境中的默认字符集（中文环境即为GBK）。<br>OutputStreamWriter负责转换字符到字节，编码格式和默认编码规则与解码一致。<br>示例如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        String file = <span class="hljs-string">"C:/stream.txt"</span>;        String charset = <span class="hljs-string">"utf-8"</span>;        <span class="hljs-keyword">try</span> &#123;            FileOutputStream outputStream = <span class="hljs-keyword">new</span> FileOutputStream(file);            OutputStreamWriter writer = <span class="hljs-keyword">new</span> OutputStreamWriter(outputStream, charset);            <span class="hljs-keyword">try</span> &#123;                writer.write(<span class="hljs-string">"这是要保存的中文字符"</span>);            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125; <span class="hljs-keyword">finally</span> &#123;               writer.close();            &#125;            <span class="hljs-comment">//读取字节转换成字符</span>            FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(file);            InputStreamReader reader = <span class="hljs-keyword">new</span> InputStreamReader(inputStream);            StringBuffer buffer = <span class="hljs-keyword">new</span> StringBuffer();            <span class="hljs-keyword">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">64</span>];            <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">while</span>((count = reader.read(chars)) != -<span class="hljs-number">1</span>)&#123;                    buffer.append(chars,<span class="hljs-number">0</span>,count);                &#125;                System.out.println(buffer.toString());            &#125;<span class="hljs-keyword">finally</span> &#123;                reader.close();            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            System.out.println(<span class="hljs-string">"文件不存在"</span>);        &#125;    &#125;</code></pre></div><h2 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h2><div class="hljs"><pre><code class="hljs java">String s = <span class="hljs-string">"这是一段中文字符串"</span>;<span class="hljs-keyword">byte</span>[] b = s.getBytes(<span class="hljs-string">"uft-8"</span>);String n = <span class="hljs-keyword">new</span> String(b,<span class="hljs-string">"uft-8"</span>);</code></pre></div><p>另外Charset提供了encode和decode方法，代码如下：</p><div class="hljs"><pre><code class="hljs java">String string = <span class="hljs-string">"中文字符串"</span>;Charset charset = Charset.forName(<span class="hljs-string">"UTF-8"</span>);ByteBuffer byteBuffer = charset.encode(string);   CharBuffer charBuffer = charset.decode(byteBuffer);</code></pre></div><h1 id="3-在Java中如何编解码"><a href="#3-在Java中如何编解码" class="headerlink" title="3 在Java中如何编解码"></a>3 在Java中如何编解码</h1><p>String → ByteBuffer：Charset.encode()<br>ByteBuffer → String：Charset.decode().toString()<br>CharBuffer→ String ：toString()<br>ByteBuffer → byte[]：array()<br>byte[] → ByteBuffer :ByteBuffer.wrap()<br>CharBuffer  → char[]：array()<br>char[] → CharBuffer：CharBuffer.wrap()</p><h1 id="4-Java-Web中涉及的编解码"><a href="#4-Java-Web中涉及的编解码" class="headerlink" title="4 Java Web中涉及的编解码"></a>4 Java Web中涉及的编解码</h1><h2 id="URL编解码"><a href="#URL编解码" class="headerlink" title="URL编解码"></a>URL编解码</h2><p><img src="https://img-blog.csdnimg.cn/20200611205539345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br> 浏览器编码URL是将非ASCII字符按照某种编码格式编码成16进制数字后将每个16进制表示的字符前加上%。<img src="https://img-blog.csdnimg.cn/20200611210115739.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>URL的URI部分进行解码的字符集是在<code>&lt;Connector URIEncodeing=&quot;UTF-8&quot;&gt;</code>里设置的。<br>QueryString的解析过程：GET方式HTTP请求的querystring和POST方式HTTP请求的表单参数都是作为parameters保存的，都通过request.getParameter();<br>queryString的解码字符集是在哪定义的呢？<br>是在HTTP的header的contentType或者是默认的ISO-8859-1，如果要用HTTP的header中中定义的编码需要设置<code>&lt;Connector URIEncoding=&quot;UTF-8&quot;      useBodyEncodingForURI=&#39;true&#39;&gt;</code></p><h2 id="HTTP-Hander的编解码"><a href="#HTTP-Hander的编解码" class="headerlink" title="HTTP Hander的编解码"></a>HTTP Hander的编解码</h2><p>客户端发起的HTTP请求除了URL外，还可能会在Header中传递其他参数（如Cookie）。对Header中的项进行解码默认使用ISO-8859-1，且不能设置Header其他的解码格式，若设置的Header中有非ASCII字符，解码中肯定会出现乱码。若一定要传递，则调用Tomcat中的URLEncoder编码，再添加到Header中。</p><h2 id="POST表单的编解码"><a href="#POST表单的编解码" class="headerlink" title="POST表单的编解码"></a>POST表单的编解码</h2><p>POST表单的参数传递方式是通过HTTP的BODY传递到服务器的，当提交时先根据ContentType中的字符集进行解码，字符集编码可以由request.setCharacterEncoding(charset)来设置。<br>此外务必注意：对POST表单提交参数的解码是发生在getParameter时，所以在第一次调用request.getParameter方法之前就要先设置request.setCharacterEncoding(charset)方法。<br>关于上传的文件编码：也是使用ContentType定义的字符集编码，不过上传文件是以字节流的方式传输到服务器的本地临时目录，此过程尚不涉及字符编码，只有当文件内容添加到parameters时才进行编码。</p><h2 id="HTTP-BODY的编解码"><a href="#HTTP-BODY的编解码" class="headerlink" title="HTTP BODY的编解码"></a>HTTP BODY的编解码</h2><p>编解码字符集通过response.setCharacterEncoding来设置，通过Header的Content-Type返回客户端。若Header中没有Content-Type，浏览器会根据<meta http-equiv="Content-Type" content="text/html; charset=utf-8">中的charset来解码，若依然没有该属性，浏览器则使用默认编码。</p><h1 id="5-常见问题分析"><a href="#5-常见问题分析" class="headerlink" title="5 常见问题分析"></a>5 常见问题分析</h1><h2 id="中文变成了看不懂的字符"><a href="#中文变成了看不懂的字符" class="headerlink" title="中文变成了看不懂的字符"></a>中文变成了看不懂的字符</h2><p>解码和编码用的字符集不一样，就会出现乱码。</p><h2 id="一个汉字变成一个问号"><a href="#一个汉字变成一个问号" class="headerlink" title="一个汉字变成一个问号"></a>一个汉字变成一个问号</h2><p>ISO-8859-1遇到不认识的用3F表示，是问号。</p><h2 id="一个汉字变成两个问号"><a href="#一个汉字变成两个问号" class="headerlink" title="一个汉字变成两个问号"></a>一个汉字变成两个问号</h2><p>说明中文经过了多次编码</p>]]></content>
    
    
    <categories>
      
      <category>Web技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入分析Java Web技术内幕-2.深入分析Java I/O的工作机制</title>
    <link href="/2020/06/11/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-2-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-I-O%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/06/11/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-2-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-I-O%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Java的I-O类库的基本架构"><a href="#1-Java的I-O类库的基本架构" class="headerlink" title="1 Java的I/O类库的基本架构"></a>1 Java的I/O类库的基本架构</h1><p>1.基于字节操作的I/O接口：InputStream和OutputStream<br>2.基于字符操作的I/O接口：Reader和Writer<br>3.基于磁盘操作的I/O接口：File<br>4.基于网络操作的I/O接口：Socket<br>前两者是数据传输格式，后两者是数据传输方式，数据传输格式与数据传输方式是影响效率的最关键因素。</p><h2 id="基于字节的I-O操作接口"><a href="#基于字节的I-O操作接口" class="headerlink" title="基于字节的I/O操作接口"></a>基于字节的I/O操作接口</h2><p>InputStream和OutPutStream的类层次结构：<br><img src="https://img-blog.csdnimg.cn/20200611150937566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200611151227820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>有两点注意事项：<br>1.操作数据的方式是可以组合使用的，即装饰者模式：</p><div class="hljs"><pre><code class="hljs java">OutputStream out = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"fileName"</span>)));</code></pre></div><p>2.必须要指定流最终写到什么地方，比如：磁盘、网络等。</p><h2 id="基于字符的I-O操作接口"><a href="#基于字符的I-O操作接口" class="headerlink" title="基于字符的I/O操作接口"></a>基于字符的I/O操作接口</h2><p><img src="https://img-blog.csdnimg.cn/20200611152734662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200611153006907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>注意：不管是Writer还是Reader类，都只是定义了读取或写入的数据字符的方式，但是没有规定数据要写到哪，这些后面会具体讨论。</p><h2 id="字节和字符的转换接口"><a href="#字节和字符的转换接口" class="headerlink" title="字节和字符的转换接口"></a>字节和字符的转换接口</h2><p>从字节到字符的解码：<br><img src="https://img-blog.csdnimg.cn/20200611153935554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>InputStreamReader：实现从字节到字符的转化，从InputStram到Reader的过程中要指定编码字符集，而这一工作由StreamDecoder来实现。<br>写入通过OutPutStreamWriter来完成从字符到字节的编码过程。<br><img src="https://img-blog.csdnimg.cn/20200611153900739.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="2-磁盘I-O工作机制"><a href="#2-磁盘I-O工作机制" class="headerlink" title="2 磁盘I/O工作机制"></a>2 磁盘I/O工作机制</h1><h2 id="几种访问文件的方式"><a href="#几种访问文件的方式" class="headerlink" title="几种访问文件的方式"></a>几种访问文件的方式</h2><p>I/O操作需要用到操作系统提供的接口，因为磁盘设备是操作系统管理的。操作系统为了安全将<strong>内核地址空间</strong>与<strong>用户地址空间</strong>隔离开，如此以来，必然存在数据可能需要从磁盘复制到内核地址空间，再从内核地址空间向用户空间复制的问题，这将非常缓慢。操作系统为了加速I/O访问，在内核空间使用缓存机制——将从磁盘读取的文件按照一定的组织方式进行缓存，如果与用户程序访问的是同一段磁盘地址的空间数据，那么操作系统从内缓存中直接取出返回给用户程序，以减少I/O的响应时间。（操作系统引入缓存机制加速磁盘IO的访问）</p><h3 id="标准访问文件的方式"><a href="#标准访问文件的方式" class="headerlink" title="标准访问文件的方式"></a>标准访问文件的方式</h3><p>读：程序调用操作系统的read()接口，若内核空间中有相应的缓存数据，则直接从缓存中返回，若没有，则从磁盘中读取并缓存在操作系统缓存中。<br>写：程序调用write()接口将数据写入内核地址空间的缓存中，写操作完成。操作系统决定什么时候写到磁盘中。除非显式的调用了<code>sync</code>同步命令。<br><img src="https://img-blog.csdnimg.cn/20200611155103888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="直接I-O的方式"><a href="#直接I-O的方式" class="headerlink" title="直接I/O的方式"></a>直接I/O的方式</h3><p>应用程序直接访问磁盘数据，不经过内核数据缓冲区。<br>使用：数据库管理系统，系统明确地知道应该加载哪些数据、失效哪些数据、对热点数据预加载（操作系统却不知道）。<br>优点：减少一次数据从内核空间到应用空间的访问，提高访问效率<br>缺点：若访问的数据不在应用缓存中，那么数据会从磁盘直接加载，非常缓慢。<br>通常将直接I/O与异步I/O结合使用<br><img src="https://img-blog.csdnimg.cn/20200611155536131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="同步访问文件的方式"><a href="#同步访问文件的方式" class="headerlink" title="同步访问文件的方式"></a>同步访问文件的方式</h3><p>同步访问就是数据的读写都是同步的，数据成功被写入磁盘时才返回给应用程序成功的标志。而标准访问方式读是同步的，写是异步的，数据写入内核地址空间缓冲区就已经算成功。<br>特点：性能比较差，对数据安全性比较高的场景中使用，硬件都是定制的。<br><img src="https://img-blog.csdnimg.cn/20200611160449106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="异步访问文件的方式"><a href="#异步访问文件的方式" class="headerlink" title="异步访问文件的方式"></a>异步访问文件的方式</h3><p>当处理数据的线程发出请求时，线程接着去处理其他事情而不是阻塞等待，请求的数据返回后接着进行下面的操作。<br>特点：提高应用程序的效率，但不会提高访问文件的效率。<br><img src="https://img-blog.csdnimg.cn/20200611160454841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="内存映射的方式"><a href="#内存映射的方式" class="headerlink" title="内存映射的方式"></a>内存映射的方式</h3><p>内存映射的方式是指操作系统将内存中的某一块区域与磁盘中的文件关联起来，当要求访问内存中的一段数据时，转换为访问文件的某一段数据。这种方式的目的同样是减少数据从内核空间缓存到用户空间缓存的数据复制操作，因为这两个空间的数据是共享的。<br><img src="https://img-blog.csdnimg.cn/20200611160640922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="Java访问磁盘文件"><a href="#Java访问磁盘文件" class="headerlink" title="Java访问磁盘文件"></a>Java访问磁盘文件</h2><p>有两点注意：<br>1、数据在磁盘中的唯一最小描述就是文件，文件也是操作系统和磁盘驱动器交互的最小单元。<br>2、File代表一个虚拟的对象，而不是真实的文件对象，真正使用到这个文件时，才会检查这个文件存在不存在。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaWebTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readFileTest</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//创建File，也就是指定文件的路径跟名称，但是不会去检查是否存在</span>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:/file.txt"</span>);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//这里读取文件内容，如果文件不存在，会抛出异常</span>            FileReader fileReader = <span class="hljs-keyword">new</span> FileReader(file);            StringBuffer stringBuffer = <span class="hljs-keyword">new</span> StringBuffer();            <span class="hljs-keyword">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1024</span>];            <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;            <span class="hljs-comment">//这里就将读取到的文件内容存入chars缓存区中</span>            <span class="hljs-keyword">while</span> ((len = fileReader.read(chars))&gt;<span class="hljs-number">0</span>)&#123;                stringBuffer.append(chars,<span class="hljs-number">0</span>,len);            &#125;            System.out.println(<span class="hljs-string">"文件中的内容是："</span>+stringBuffer.toString());        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;            System.out.println(<span class="hljs-string">"文件不存在"</span>);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            System.out.println(<span class="hljs-string">"文件读取错误"</span>);        &#125;    &#125;&#125;</code></pre></div><h2 id="Java序列化技术"><a href="#Java序列化技术" class="headerlink" title="Java序列化技术"></a>Java序列化技术</h2><p>Java序列化是将一个对象转换成一串二进制表示的字节数组，通过保存或转移这些数据来达到持久化的目的。<br>Java的反序列化使用序列化生成的.dat文件以及一个类模板将字节数组重新构造成对象。<br>下面描述一些复杂情况：<br>1.当父类继承Serializable接口时，所有子类都可以被序列化。<br>2.子类实现了Serializable接口，父类没有时，父类中的属性不能序列化。<br>3.序列化的属性是对象，那么这个对象也必须实现Serializable接口。<br>4.反序列化时，若对象属性修改或删减，那么修改的部分丢失，不报错。<br>5.反序列化时，若serialVersionUID被修改，则反序列化失败。<br>多语言情况使用通用数据结构：<br>Java序列化在Java环境下可以很好的工作，但在多语言环境下，用Java序列化存储后，很难用其他语言还原出结果，这种情况下要尽量存储通用的数据结构，如JSON或者XML结构。</p><h1 id="3-网络I-O工作机制"><a href="#3-网络I-O工作机制" class="headerlink" title="3 网络I/O工作机制"></a>3 网络I/O工作机制</h1><p>两台主机交互时，首先要有相互沟通的意向，其次要有沟通的渠道（物理链路），再次要有一个通讯协议。</p><h2 id="TCP状态转化"><a href="#TCP状态转化" class="headerlink" title="TCP状态转化"></a>TCP状态转化</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200611165004107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>    第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。<br>    第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。<br>    第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。<br>    经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://img-blog.csdnimg.cn/2020061116520429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>    第一次挥手：A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置 1，其序号 seq = u（等于前面已传送过的数据的最后一个字节的序号加 1），这时 A 进入 FIN-WAIT-1（终止等待1）状态，等待 B 的确认。请注意：TCP 规定，FIN 报文段即使不携带数据，也将消耗掉一个序号。<br>    第二次挥手：B 收到连接释放报文段后立即发出确认，确认号是 ack = u + 1，而这个报文段自己的序号是 v（等于 B 前面已经传送过的数据的最后一个字节的序号加1），然后 B 就进入 CLOSE-WAIT（关闭等待）状态。TCP 服务端进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭（half-close）状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一段时间。A 收到来自 B 的确认后，就进入 FIN-WAIT-2(终止等待2)状态，等待 B 发出的连接释放报文段。<br>    第三次挥手：若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN = 1。假定 B 的序号为 w（在半关闭状态，B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号 ack = u + 1。这时 B 就进入 LAST-ACK(最后确认)状态，等待 A 的确认。<br>第四次挥手：A 在收到 B 的连接释放报文后，必须对此发出确认。在确认报文段中把 ACK 置 1，确认号 ack = w + 1，而自己的序号 seq = u + 1（前面发送的 FIN 报文段要消耗一个序号）。然后进入 TIME-WAIT(时间等待) 状态。请注意，现在 TCP 连接还没有释放掉。必须经过时间等待计时器设置的时间 2MSL（MSL：最长报文段寿命）后，A 才能进入到 CLOSED 状态，然后撤销传输控制块，结束这次 TCP 连接。 B一收到 A 的确认就进入 CLOSED 状态，然后撤销传输控制块。所以在释放连接时，B 结束 TCP 连接的时间要早于 A。</p><p>为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？<br>MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，它是任何报文在网络上存活的最长时间，超过这个时间报文将被丢弃。而2MSL的意思就是2倍的MSL的意思。<br>假设第四次挥手时数据丢失，那么服务器就会一直收不到客户端的回应，因此服务器会重传第三次挥手的报文段，所以客户端不能直接进入CLOSE，而是要保持TIME_WAIT。</p><h2 id="影响网络传输的因素"><a href="#影响网络传输的因素" class="headerlink" title="影响网络传输的因素"></a>影响网络传输的因素</h2><ul><li>网络带宽：一条物理链路在1s内能够传输的最大比特数。</li><li>传输距离：数据在光纤中走的距离，光的传播速度很快，但数据在光纤中不是走直线的，速度大概是光的2/3。这个时间是我们通常说的网络延时。</li><li>TCP拥塞控制：TCP通过设置一个窗口的大小来保证传输方和接收方的步调一致，窗口大小由带宽和响应时间决定。计算公式是带宽*响应时间，通过这个值可以得到理论最优的TCP缓冲区大小。Linux系统已经可以自动调整这个大小。</li></ul><h2 id="Java-Socket的工作机制"><a href="#Java-Socket的工作机制" class="headerlink" title="Java Socket的工作机制"></a>Java Socket的工作机制</h2><p>Socket描述的是计算机之间完成相互通信的一种抽象功能。<br><img src="https://img-blog.csdnimg.cn/20200611170955259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="建立通信链路"><a href="#建立通信链路" class="headerlink" title="建立通信链路"></a>建立通信链路</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">7777</span>, <span class="hljs-number">10</span>);            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;                <span class="hljs-comment">//这里底层就在进行三次握手，如果握手失败就会抛出异常</span>                Socket socket = serverSocket.accept();                InputStream inputStream = socket.getInputStream();                DataInputStream dataInputStream = <span class="hljs-keyword">new</span> DataInputStream(inputStream);                Thread.sleep(<span class="hljs-number">1000</span>);                String recvString = dataInputStream.readUTF();                System.out.println(<span class="hljs-string">"客户端接收到："</span>+ recvString);                <span class="hljs-comment">//发送</span>                DataOutputStream dataOutputStream = <span class="hljs-keyword">new</span> DataOutputStream(socket.getOutputStream());                String sendString = <span class="hljs-string">"服务端向客户端发起了一条对话 "</span>;                dataOutputStream.writeUTF(sendString);                System.out.println(sendString);                socket.close();            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;            createSocket(i);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createSocket</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//这里底层就在进行三次握手，如果握手失败就会抛出异常</span>            Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">7777</span>);            OutputStream outputStream = socket.getOutputStream();            DataOutputStream dataOutputStream = <span class="hljs-keyword">new</span> DataOutputStream(outputStream);            String sendString = <span class="hljs-string">"客户端"</span>+num+<span class="hljs-string">"向服务器发送一条消息"</span>;            dataOutputStream.writeUTF(sendString);            System.out.println(<span class="hljs-string">"发送给服务器："</span>+sendString);            <span class="hljs-comment">//接收</span>            InputStream inputStream = socket.getInputStream();            DataInputStream dataInputStream = <span class="hljs-keyword">new</span> DataInputStream(inputStream);            String recvString = dataInputStream.readUTF();            System.out.println(<span class="hljs-string">"从服务器收到"</span>+recvString);            socket.close();        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            System.out.println(<span class="hljs-string">"连接失败，地址错误或服务器拒绝连接"</span>);        &#125;    &#125;&#125;</code></pre></div><p>先运行服务端，然后运行客户端，可以看到两者之间通信建立。<br><img src="https://img-blog.csdnimg.cn/20200611181638828.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>高并发<br>比如，当成千上万个客户端同时发起连接请求，而服务端一次只能处理一个请求，这样会造成客户端排队时间过长，带来不良的访问体验。虽然可以让服务器派发不同的线程来处理Socket，但是又会导致线程一直被连接占用，如果发送的内容又不多时，就会造成线程资源的浪费，还是不能满足连接数过多的要求，因为线程可能被占用而无法释放，为其他的连接服务。当然，可以考虑使用线程池来减少线程创建和回收的成本，这是我们所说的伪异步IO，但当连接时长连接的时候仍然无法从根本上解决问题。</p><p>阻塞和死锁<br>每个Socekt都有一个InputStream和一个OutputStream。当创建Socket对象时，系统会为这两个流创建缓冲区SendQ队列和RecvQ队列。数据的读写都是通过缓冲区完成。当发送消息时，写入端数据通过OutoutStream写到sendQ中，队列满时数据被转移到recvQ中，recvQ如果满了，那么不能继续向sendQ中写入，直到RecvQ有足够空间接收sendQ的数据，因此发生阻塞。缓冲区的大小以及读写端的速度非常影响数据传输效率。因为阻塞的存在，所以同时发送数据时可能出现死锁。</p><h1 id="4-NIO"><a href="#4-NIO" class="headerlink" title="4 NIO"></a>4 NIO</h1><p> Channel和Selector它们是NIO的两个核心概念，Channel要比Socket更加具体，它代表每一个通信信道，Selector它可以轮询每个Channel的状态，还有一个Buffer类，我们可以通过Buffer来控制数据的传输。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selector</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);        Selector selector = Selector.open();<span class="hljs-comment">//调用Selector的静态工厂创建一个选择器</span>        ServerSocketChannel ssc = ServerSocketChannel.open();<span class="hljs-comment">//创建一个服务端的Channel</span>        ssc.configureBlocking(<span class="hljs-keyword">false</span>);<span class="hljs-comment">//设置为非阻塞方式</span>        ssc.socket().bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));<span class="hljs-comment">//将服务端的Channel绑定到一个Socket对象</span>        ssc.register(selector, SelectionKey.OP_ACCEPT);<span class="hljs-comment">//注册监听的事件，将Channel注册到选择器上</span>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<span class="hljs-comment">//无限循环，保持监听状态</span>            Set&lt;SelectionKey&gt; keys = selector.keys();<span class="hljs-comment">//取得所有的key集合</span>            Iterator&lt;SelectionKey&gt; iterator = keys.iterator();            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;                SelectionKey key = (SelectionKey) iterator.next();                <span class="hljs-keyword">if</span> ((key.readyOps() &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) &#123;                    ServerSocketChannel ssc2 = (ServerSocketChannel) key.channel();<span class="hljs-comment">//获取这个key所代表的通信信道对象</span>                    SocketChannel sc = ssc2.accept();<span class="hljs-comment">//服务端接受请求</span>                    sc.configureBlocking(<span class="hljs-keyword">false</span>);                    sc.register(selector, SelectionKey.OP_READ);                    iterator.remove();                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((key.readyOps() &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ) &#123;                    SocketChannel sc = (SocketChannel) key.channel();                    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                        buffer.clear();<span class="hljs-comment">//将缓冲区的索引状态重置为初始位置</span>                        <span class="hljs-keyword">int</span> a = sc.read(buffer);<span class="hljs-comment">//读取数据到buffer</span>                        <span class="hljs-keyword">if</span> (a &lt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//数据读取完毕，跳出循环</span>                            <span class="hljs-keyword">break</span>;                        &#125;                        <span class="hljs-comment">//将缓存字节数组的指针设置为数组的开始序列即数组下标0，这样就可以从buffer开头，</span>                        <span class="hljs-comment">//对该buffer进行读取了，最多只能读取之前写入的数据长度，而不是整个缓冲的容量大小，</span>                        <span class="hljs-comment">//如果没有这个方法，就是从buffer最后开始读取，读出来的都是byte=0时候的字符。</span>                        buffer.flip();                    &#125;                    iterator.remove();                &#125;            &#125;        &#125;    &#125;</code></pre></div><p>注意：这里我们是将Server端的监听连接请求的事件和处理请求的事件放在一个线程中，但是在应用中，我们通常会把它们放在两个线程中，一个线程专门负责监听客户端的连接请求，而且是以阻塞方式执行的；另外一个线程专门负责处理请求，这个专门负责处理请求的线程才会真正采用NIO的方式。<br>Selector可以监听一组Channel上的I/O状态，前提是这些Channel已经注册到Selector中，Selector可以调用select()检查已经注册的通信信道上I/O是否已经准备好，如果没有通信信道状态发生变化，那么select方法会阻塞等待或在超时后返回0，如果多个信道有数据，那么它将会把这些数据分配到对应的Buffer中。所以NIO的关键是有一个线程来处理所有连接的数据交互，而每个连接的数据交互都不是阻塞方式，因此可以同时处理大量的连接请求。</p><h2 id="Buffer的工作方式"><a href="#Buffer的工作方式" class="headerlink" title="Buffer的工作方式"></a>Buffer的工作方式</h2><p>可以把Buffer简单地理解为一组基本数据类型的元素列表，它通过几个变量来保存这个数据的当前位置状态：capacity, position, limit, mark：<br>| 索引     | 说明                                         |<br>| ——– | ——————————————– |<br>| capacity | 缓冲区数组的总长度                           |<br>| position | 下一个要操作的数据元素的位置                 |<br>| position | 下一个要操作的数据元素的位置                 |<br>| mark     | 用于记录当前position的前一个位置或者默认是-1 |<br><img src="https://img-blog.csdnimg.cn/20200611184918452.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>举例：我们通过ByteBuffer.allocate(11)方法创建了一个11个byte的数组的缓冲区，初始状态如上图，position的位置为0，capacity和limit默认都是数组长度。当我们写入5个字节时，变化如下图：<br><img src="https://img-blog.csdnimg.cn/20200611184957855.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>这时我们需要将缓冲区中的5个字节数据写入Channel的通信信道，所以我们调用ByteBuffer.flip()方法，变化如下图所示(position设回0，并将limit设成之前的position的值)：<br><img src="https://img-blog.csdnimg.cn/20200611185032258.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>这时底层操作系统就可以从缓冲区中正确读取这个5个字节数据并发送出去了。在下一次写数据之前我们再调用clear()方法，缓冲区的索引位置又回到了初始位置。</p><p>调用clear()方法：position将被设回0，limit设置成capacity，这些标记告诉我们可以从哪里开始往Buffer里写数据。如果Buffer中有一些未读的数据，调用clear()方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用compact()方法。compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。<br>调用mark()方法：它将记录当前position的上一次位置，之后可以通过调用reset()方法恢复到这个position。<br>调用rewind()方法：它可以将position设回0，所以你可以重读Buffer中的所有数据，limit保持不变，仍然表示能从Buffer中读取多少个元素。</p><h2 id="NIO的数据访问方式"><a href="#NIO的数据访问方式" class="headerlink" title="NIO的数据访问方式"></a>NIO的数据访问方式</h2><p>NIO提供了比传统的文件访问方式更好的方法，NIO有两个优化方法：一个是<code>FileChannel.transferTo</code>、<code>FileChannel.transferFrom</code>；另一个是<code>FileChannel.map</code>。<br>① FileChannel.transferXXX与传统的访问文件方式相比可以减少数据从内核到用户空间的复制，数据直接在内核空间中移动，在Linux中使用<code>sendfile</code>系统调用。<br>② FileChannel.map将文件按照一定大小块映射为内存区域，当程序访问这个内存区域时将直接操作这个文件数据，这种方式省去了数据从内核空间向用户空间复制的损耗。这种方式适合对大文件的只读性操作，如大文件的MD5校验。但是这个种方式是和操作系统底层I/O实现相关的。<br><img src="https://img-blog.csdnimg.cn/20200611185853928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="5-I-O调优"><a href="#5-I-O调优" class="headerlink" title="5 I/O调优"></a>5 I/O调优</h1><h2 id="磁盘I-O优化"><a href="#磁盘I-O优化" class="headerlink" title="磁盘I/O优化"></a>磁盘I/O优化</h2><p>① 增加缓存，减少磁盘访问次数；<br>② 优化磁盘的管理系统，设计最优的磁盘方式策略、磁盘寻址策略；<br>③ 设计合理的磁盘存储数据块，以及访问这些数据块的策略，比如我们可以给存放的数据设计索引，通过寻址索引来加快和减少磁盘的访问量，还可以采用异步和非阻塞的方式加快磁盘的访问速度；<br>④ 应用合理的<code>RAID</code>策略提升磁盘I/O【RAID：将不同的磁盘组合起来以提高I/O性能】</p><h2 id="TCP网络参数调优"><a href="#TCP网络参数调优" class="headerlink" title="TCP网络参数调优"></a>TCP网络参数调优</h2><p>要能够建立一个TCP连接，必须知道对方的IP和一个未被使用的端口号，由于32位的操作系统的端口号通常由两个字节来表示，也就是只有2^16=65535个，所以一台主机能够同时建立的连接数是有限的。在Linux中可以通过查看/proc/sys/net/ipv4/ip_local_port_range文件来知道当前这个主机可以使用的端口范围。<br><img src="https://img-blog.csdnimg.cn/20200611190730444.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>  如果可以分配的端口号偏少，遇到大量并发请求时就会成为瓶颈，由于端口有限导致大量请求等待建立链接，这样性能就压不上去。如果发现有大量的TIME_WAIT时，可以设置<code>/proc/sys/net/ipv4/tcp_fin_timeout</code>为更小的值来快速释放请求。可以使用<code>netstat -n | awk &#39;/^tcp/{++state[$NF]} END {for(key in state) print key,&quot;\t&quot;,state[key]}&#39;</code>来查看网络连接情况。<br><img src="https://img-blog.csdnimg.cn/20200611191047943.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>TCP参数调优表如下：</p><div class="hljs"><pre><code class="hljs vim"><span class="hljs-keyword">echo</span> <span class="hljs-string">"1024 65535"</span> &gt; /proc/sys/net/ipv4/ip_local_port_range设置向外连接可用端口范围 表示可以使用的端口为<span class="hljs-number">65535</span>-<span class="hljs-number">1024</span>个（<span class="hljs-number">0</span>~<span class="hljs-number">1024</span>为受保护的)　　<span class="hljs-keyword">echo</span> <span class="hljs-number">1</span> &gt; /proc/sys/net/ipv4/tcp_tw_reuse 设置time_wait连接重用 默认<span class="hljs-number">0</span>　　<span class="hljs-keyword">echo</span> <span class="hljs-number">1</span> &gt; /proc/sys/net/ipv4/tcp_tw_recycle 设置快速回收time_wait连接 默认<span class="hljs-number">0</span>　　<span class="hljs-keyword">echo</span> <span class="hljs-number">180000</span> &gt; /proc/sys/net/ipv4/tcp_max_tw_buckets 设置最大time_wait连接长度 默认<span class="hljs-number">262144</span>　　<span class="hljs-keyword">echo</span> <span class="hljs-number">1</span> &gt; /proc/sys/net/ipv4/tcp_timestamps  设置是否启用比超时重发更精确的方法来启用对RTT的计算 默认<span class="hljs-number">0</span>　　<span class="hljs-keyword">echo</span> <span class="hljs-number">1</span> &gt; /proc/sys/net/ipv4/tcp_window_scaling 设置TCP/IP会话的滑动窗口大小是否可变 默认<span class="hljs-number">1</span>　　<span class="hljs-keyword">echo</span> <span class="hljs-number">20000</span> &gt; /proc/sys/net/ipv4/tcp_max_syn_backlog 设置最大处于等待客户端没有应答的连接数 默认<span class="hljs-number">2048</span>　　<span class="hljs-keyword">echo</span> <span class="hljs-number">15</span> &gt; /proc/sys/net/ipv4/tcp_fin_timeout  设置FIN-WAIT状态等待回收时间 默认<span class="hljs-number">60</span>　　<span class="hljs-keyword">echo</span> <span class="hljs-string">"4096 87380 16777216"</span> &gt; /proc/sys/net/ipv4/tcp_rmem  设置最大TCP数据发送缓冲大小，分别为最小、默认和最大值  默认<span class="hljs-number">4096</span>    <span class="hljs-number">87380</span>   <span class="hljs-number">4194304</span>　　<span class="hljs-keyword">echo</span> <span class="hljs-string">"4096 65536 16777216"</span> &gt; /proc/sys/net/ipv4/tcp_wmem 设置最大TCP数据 接受缓冲大小，分别为最小、默认和最大值 　默认<span class="hljs-number">4096</span>    <span class="hljs-number">87380</span>   <span class="hljs-number">4194304</span>　　<span class="hljs-keyword">echo</span> <span class="hljs-number">10000</span> &gt; /proc/sys/net/core/somaxconn  设置每一个处于监听状态的端口的监听队列的长度 默认<span class="hljs-number">128</span>　　<span class="hljs-keyword">echo</span> <span class="hljs-number">10000</span> &gt; /proc/sys/net/core/netdev_max_backlog 设置最大等待cpu处理的包的数目 默认<span class="hljs-number">1000</span>　　<span class="hljs-keyword">echo</span> <span class="hljs-number">16777216</span> &gt; /proc/sys/net/core/rmem_max 设置最大的系统套接字数据接受缓冲大小 默认<span class="hljs-number">124928</span>　　<span class="hljs-keyword">echo</span> <span class="hljs-number">262144</span> &gt; /proc/sys/net/core/rmem_default  设置默认的系统套接字数据接受缓冲大小 默认<span class="hljs-number">124928</span>　　<span class="hljs-keyword">echo</span> <span class="hljs-number">16777216</span> &gt; /proc/sys/net/core/wmem_max  设置最大的系统套接字数据发送缓冲大小 默认<span class="hljs-number">124928</span>　　<span class="hljs-keyword">echo</span> <span class="hljs-number">262144</span> &gt; /proc/sys/net/core/wmem_default  设置默认的系统套接字数据发送缓冲大小 默认<span class="hljs-number">124928</span>　　<span class="hljs-keyword">echo</span> <span class="hljs-number">2000000</span> &gt; /proc/sys/fs/<span class="hljs-keyword">file</span>-<span class="hljs-built_in">max</span> 设置最大打开文件数 默认<span class="hljs-number">385583</span></code></pre></div><p>注意，以上设置都是临时性的，系统重启后就会丢失。<br>另外，Linux还提供了一些工具用于查看当前的TCP统计信息：<br>▶ cat /proc/net/netstat：查看TCP的统计信息；<br>▶ cat /proc/net/snmp：查看当前系统的连接情况；<br>▶ netstat -s：查看网络的统计信息。</p><h2 id="网络I-O优化"><a href="#网络I-O优化" class="headerlink" title="网络I/O优化"></a>网络I/O优化</h2><p>① 减少网络交互的次数。<br>        通常需要在网络交互的两端设置缓存，如Oracle的JDBC就提供了对查询结果的缓存，在客户端和服务器端都有，可以有效减少对数据库的访问。除了设置缓存还可以合并访问请求，比如在查询数据库时，我们要查询10个ID，可以每次查一个ID，也可以一次查10个ID。再比如，在访问一个页面进通常会有多个JS和CSS文件，我们可以将多个JS文件合并在一个HTTP链接中，每个文件用逗号隔开，然后发送到后端的Web服务器。</p><p>② 减少网络传输数据量的大小。<br>        通常的办法是将数据压缩后再传输，比如在HTTP请求中，通常Web服务器将请求的Web页面gzip压缩后再传输给浏览器。还有就是通过设计简单的协议，尽量通过读取有用的协议头来获取有价值的信息，比如在设计代理程序时，4层代理和7层代理都是在尽量避免读取整个通信数据来获取所需要的信息。</p><p>③ 尽量减少编码。<br>        在网络传输中数据都是以字节形式进行传输的，但是我们要发送的数据都是字符形式的，从字符到字节必须编码，但是这个编码过程是比较费时的，所以在经过网络I/O传输时，尽量直接以字节形式发送。</p><p>④ 根据应用场景设计合适的交互方式。<br>a. 同步与异步<br>        同步就是一个任务的完成需要依赖另一个任务时，只有等待被依赖的任务完成后，依赖的任务才能完成，这是一种可靠的任务序列，要成功都成功，要失败都失败。而异步不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，只要自己完成了整个任务就算完成了，所以它是不可靠的任务序列，比如打电话和发信息。同步能够保证程序的可靠性，而异步可以提升程序的性能。</p><p>b. 阻塞与非阻塞<br>        阻塞就是CPU停下来等待一个慢的操作完成后，CPU才接着完成其它的工作，非阻塞就是在这个慢的操作执行时，CPU去做其它工作，等这个慢的操作完成时，CPU在完成后续的操作。虽然非阻塞的方式可以明显提高CPU的利用率，但是也可能有不好的效果，就是系统的线程切换会比较频繁。</p><p>c. 两种方式的组合<br>        组合的方式有四种，分别是：同步阻塞、异步阻塞、同步非阻塞、异步非阻塞，这四种方式对I/O性能都有影响：<br>注意：虽然异步和非阻塞能够提升I/O的性能，但是也会带来一些额外的性能成本，比如会增加线程数量从而增加CPU的消耗，同时也会导致程序设计复杂度的上升，如果设计的不合理，反而会导致性能下降。</p><h1 id="6-设计模式"><a href="#6-设计模式" class="headerlink" title="6 设计模式"></a>6 设计模式</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器就是把一个类的接口变换成客户端所能接受的另一种接口，从而使两个接口不匹配而无法在一起工作的两个类能够在一起工作。通常被用于在一个项目需要引用一些开源框架在一起工作的情况下，这些框架的内部都有一些关于环境信息的接口，需要从外部传入，但是外部的接口不一定能够匹配，在这种情况下，就需要适配器模式来转换接口。<br><img src="https://img-blog.csdnimg.cn/20200611193423795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Target（目标接口）：客户端期待的接口；<br>Adaptee（源接口）：需要被适配的接口；<br>Adapter（适配器）：将源接口适配成目标接口，继承源接口，实现目标接口。</p><p>Java I/O中的适配器模式<br>        InputStreamReader和OutputStreamWriter类分别继承了Reader和Writer接口，但是要创建它们的对象必须在构造函数中传入一个InputStream和OutputStream的实例。InputStreamReader实现了Reader接口，并且持有了InputStream的引用，这里是通过StreamDecoder类间接持有的，因为从byte到char需要经过编码。很显然，适配器就是InputStreamReader类，源接口就是InputStream，目标接口就是Reader类。OutputStreamWriter也是类似的方式。</p><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>  装饰器模式，顾名思义，就是将某个类重新装扮一下，让它的功能变得更加强大，但是作为原来这个类的使用者，还不应该感受到装饰前和装饰后有什么不同，否则就破坏了原有类的结构，所以装饰器模式要做到对被装饰类的使用者透明，这是对装饰器模式的一个要求。<br><img src="https://img-blog.csdnimg.cn/20200611193857974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Component：抽象组件角色，定义一组抽象的接口，规定这个被装饰组件都有哪些功能；<br>ConcreteComponent：实现这个抽象组件的所有功能；<br>Decorator：装饰器角色，它持有一个Component对象实例的引用，定义一个与抽象组件一致的接口；<br>ConcreteDecorator：具体的装饰器实现者，负责实现装饰器角色定义的功能。</p><p>Java I/O中的装饰器模式<br><img src="https://img-blog.csdnimg.cn/20200611193727899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>        以FileInputStream为例，InputStream类就是以抽象组件存在的，而FileInputStream就是具体组件，它实现了抽象组件的所有功能。FilterInputStream类无疑就是装饰角色，它实现了InputStream类的所有功能，并且持有InputStream对象实例的引用。BufferedInputStream是具体的装饰器实现者，它给InputStream类附加了功能。这个装饰器类的作用就是使得InputStream读取的数据保存在内存中，从而提高读取的性能。与这个装饰器类有类似功能的是LineNumberInputStream类，它的作用就是提高按行读取数据的功能。</p><h2 id="适配器模式与装饰器模式的区别"><a href="#适配器模式与装饰器模式的区别" class="headerlink" title="适配器模式与装饰器模式的区别"></a>适配器模式与装饰器模式的区别</h2><p> 适配器模式和装饰器模式都有一个别名，就是包装模式，它们看似都是起到包装一个类或对象的作用，但是使用它们的目的很不一样。适配器模式是要将一个接口转变成另一个接口，它的目的是通过改变接口来达到重复使用的目的；而装饰器模式不是要改变被装饰对象的接口，而是恰恰要保持原有的接口，但是增强原有对象的功能，或者改变原有对象的处理方法从而提升性能。</p><p>参考文献：<br>1.<a href="https://blog.csdn.net/xilong_cheng/article/details/84199307" target="_blank" rel="noopener">https://blog.csdn.net/xilong_cheng/article/details/84199307</a><br>2.<a href="https://blog.csdn.net/Alexshi5/article/details/79481259?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-3" target="_blank" rel="noopener">https://blog.csdn.net/Alexshi5/article/details/79481259?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-3</a></p>]]></content>
    
    
    <categories>
      
      <category>Web技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文详解Nginx</title>
    <link href="/2020/06/11/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3Nginx/"/>
    <url>/2020/06/11/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3Nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>　Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理<strong>服务器</strong>；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。</p><h1 id="功能一：提供代理服务"><a href="#功能一：提供代理服务" class="headerlink" title="功能一：提供代理服务"></a>功能一：提供代理服务</h1><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式（Proxy）：为其他对象提供一种代理以控制对这个对象的访问。<br><img src="https://img-blog.csdnimg.cn/20200611125538308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Subject：抽象主题角色，是一个接口，该接口是对象和它的代理共用的接口；<br>RealSubject：真实主体角色，是实现抽象主题接口的类；<br>Proxy：代理角色，内部含有对真实对象RealSubject的引用，从而可以操作真实对象。代理对象提供与真实对象相同的接口，以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。</p><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p><img src="https://img-blog.csdnimg.cn/20200611142830801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>正向代理，”它代理的是客户端，代客户端发出请求”，是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。<br>正向代理的用途：<br>（1）访问原来无法访问的资源，如Google<br>（2） 可以做缓存，加速访问资源<br>（3）对客户端访问授权，上网进行认证<br>（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理，”它代理的是服务端，代服务端接收请求”，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。<br>　反向代理的作用：<br>（1）保证内网的安全，通常将反向代理作为公网访问地址，Web服务器是内网<br>（2）负载均衡，通过反向代理服务器来优化网站的负载</p><h1 id="功能二：实现负载均衡"><a href="#功能二：实现负载均衡" class="headerlink" title="功能二：实现负载均衡"></a>功能二：实现负载均衡</h1><p>负载均衡也是 Nginx常用的一个功能，当一台服务器的单位时间内的访问量越大时，服务器压力就越大，大到超过自身承受能力时，服务器就会崩溃。为了避免服务器崩溃，让用户有更好的体验，我们通过负载均衡的方式来分担服务器压力。我们可以建立很多很多服务器，组成一个服务器集群，当用户访问网站时，先访问一个中间服务器，在让这个中间服务器在服务器集群中选择一个压力较小的服务器，然后将该访问请求引入该服务器。如此以来，用户的每次访问，都会保证服务器集群中的每个服务器压力趋于平衡，分担了服务器压力，避免了服务器崩溃的情况。负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。<br><img src="https://img-blog.csdnimg.cn/20200611144704681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Nginx 支持的负载均衡调度算法方式如下：</p><p>①weight 轮询（默认）：接收到的请求按照顺序逐一分配到不同的后端服务器，即使在使用过程中某一台后端服务器宕机，Nginx 会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。<br>这种方式下，可以给不同的后端服务器设置一个权重值（weight），用于调整不同的服务器上请求的分配率。<br>权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。</p><p>②ip_hash：每个请求按照发起客户端的 ip 的 hash 结果进行匹配，这样的算法下一个固定 ip 地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下 Session 共享的问题。</p><p>③fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配。<br>响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少，它是结合了前两者的优点的一种调度算法。<br>但是需要注意的是 Nginx 默认不支持 fair 算法，如果要使用这种调度算法，请安装 upstream_fair 模块。</p><p>④url_hash：按照访问的 URL 的 hash 结果分配请求，每个请求的 URL 会指向后端固定的某个服务器，可以在 Nginx 作为静态服务器的情况下提高缓存效率。<br>同样要注意 Nginx 默认不支持这种调度算法，要使用的话需要安装 Nginx 的 hash 软件包。</p><h1 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h1><p>除了上面介绍的两种功能外，Nginx还可以提供HTTP服务器功能以及动静分离功能。</p><h2 id="HTTP服务器"><a href="#HTTP服务器" class="headerlink" title="HTTP服务器"></a>HTTP服务器</h2><p>Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现，首先看看Nginx做静态资源服务器。</p><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。</p><p>参考文献：<br>1.<a href="https://www.cnblogs.com/wcwnina/p/8728391.html" target="_blank" rel="noopener">https://www.cnblogs.com/wcwnina/p/8728391.html</a><br>2.<a href="https://www.cnblogs.com/wcwnina/p/9946747.html" target="_blank" rel="noopener">https://www.cnblogs.com/wcwnina/p/9946747.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入分析Java Web技术内幕-1.深入Web请求过程</title>
    <link href="/2020/06/10/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-1-%E6%B7%B1%E5%85%A5Web%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    <url>/2020/06/10/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-1-%E6%B7%B1%E5%85%A5Web%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-B-S网络架构概述"><a href="#1-B-S网络架构概述" class="headerlink" title="1 B/S网络架构概述"></a>1 B/S网络架构概述</h1><p>B/S架构优势：</p><ul><li>客户端使用统一的浏览器（Browser），不需要特殊的配置和网络连接，有效地屏蔽了不同服务提供商提供给用户使用服务的差异性；</li><li>服务器（Server）基于统一的HTTP，HTTP采用<strong>无状态的短连接</strong>的通信方式，服务开发者只需要关注提供服务的应用逻辑。</li></ul><p>B/S网络架构如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200610152139776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>主要步骤有：<br>1、用户在浏览器中输入URL；<br>2、DNS将URL解析成对应的IP地址；<br>3、根据IP地址在互联网上找到对应的服务器，服务器返回给用户需要的资源<br>在这里其中还有一些复杂的业务逻辑：<br>1、有时要通过负载均衡设备来平均分配所有用户的请求；<br>2、以及请求的数据是存储在分布式缓存里还是一个静态文件中，或是在数据库中；<br>3、当数据返回浏览器时，浏览器解析数据发现还有一些静态资源（如CSS，JS或是图片等）时又会发起另外的HTTP请求，CDN服务器来处理该请求。<br>…<br>这里有几个约定俗成的原则需要遵守：</p><ul><li>互联网上所有资源都要用一个URL来表示；</li><li>必须基于HTTP与服务器交互；</li><li>数据展示必须在浏览器中进行<h1 id="2-如何发起一个请求"><a href="#2-如何发起一个请求" class="headerlink" title="2 如何发起一个请求"></a>2 如何发起一个请求</h1>发起一个HTTP请求的过程就是建立一个Socket通信的过程。<br>接下来模拟浏览器来发送HTTP请求：<br>在Linux中可以通过<code>curl + URL</code>来简单地发起一个HTTP请求：<br><img src="https://img-blog.csdnimg.cn/20200610154208598.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>如果想要查看这次访问的HTTP头的信息，加上<code>-I</code>选项<br><img src="https://img-blog.csdnimg.cn/20200610154416519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><h1 id="3-HTTP解析"><a href="#3-HTTP解析" class="headerlink" title="3 HTTP解析"></a>3 HTTP解析</h1>B/S网络架构的核心是HTTP，而HTTP中最重要的是HTTP Header，HTTP Header控制着互联网上成千上万的用户的数据传输，而且还控制着用户浏览器的渲染行为和服务器的执行逻辑。<br><img src="https://img-blog.csdnimg.cn/20200610155057712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020061015512396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200610155138371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在浏览器上查看HTTP信息：通过<code>F12</code>键打开,然后选择<code>Network</code><h2 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h2><code>Ctrl+F5</code>刷新页面，此时在HTTP请求头中会增加两个请求项<code>Pragma:no-cache</code>和<code>Cache-Control:no-cache</code>，其作用是用于指定所有缓存机制在整个请求/响应链中必须服从的指令，告诉服务器我们要获取最新的数据而不是缓存的数据。<br><code>Expires</code>后面跟一个日期和时间，表示超过或者时间值后，缓存的内容将失效；<br><code>Last-Modified/Etag</code>:表示一个服务器上的资源的最后修改时间，后面那个Etag代表版本的意思；<h1 id="4-DNS域名解析"><a href="#4-DNS域名解析" class="headerlink" title="4 DNS域名解析"></a>4 DNS域名解析</h1><img src="https://img-blog.csdnimg.cn/20200610161609454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>1、浏览器检查缓存中有没有这个域名对应的解析过的IP地址，如果没有，执行下一步，有，则结束解析过程；<br>2、浏览器查找操作系统缓存中（<code>C:\Windows\System32\drivers\etc\hosts</code>）是否有换个域名对应的DNS解析结果，如果没有，执行下一步，有，则结束解析过程；<br>3、操作系统将这个域名发送给LDNS，也就是本地区的域名服务器（完成80%的域名解析工作）；<br>4、如果LDNS没有，则直接到Root Server域名服务器请求解析；<br>5、根域名服务器返回给本地域名服务器一个所查询域的主域名服务器（gTLD Server）地址；6、本地域名服务器（Local DNS Server）再向上一步返回的gTLD服务器发送请求；<br>7、接受请求的gTLD服务器查找并返回此域名对应的Name Server域名服务器（当时注册的域名服务器）的地址；<br>8、Name Server域名服务器会查询存储的域名和IP的映射关系表；<br>9、返回该域名对应的IP和TTL值；<br>10、把解析的结果返回给用户，用户根据TTL值存储在本地系统缓存中，域名解析过程结束。<h2 id="清除缓存的域名"><a href="#清除缓存的域名" class="headerlink" title="清除缓存的域名"></a>清除缓存的域名</h2>Windows：ipconfig /flushdns<br>Linux：sudo /etc/init.d/nscd restart</li></ul><h2 id="几种域名解析方式"><a href="#几种域名解析方式" class="headerlink" title="几种域名解析方式"></a>几种域名解析方式</h2><p>A记录：Address，指定域名对应的IP地址<br>MX记录：Mail Exchange，可以将某个域名下的邮件服务指向到自己的Mail Server<br>CNAME记录：Canonical Name，别名解析，为一个域名设置一个或多个别名<br>NS记录：为某个域名指定DNS解析服务器<br>TXT记录：为主机或域名设置说明</p><h1 id="5-CDN工作机制"><a href="#5-CDN工作机制" class="headerlink" title="5 CDN工作机制"></a>5 CDN工作机制</h1><p>CDN：内容分布网络（Content Delivery Network），构筑在现有Internet上的一种先进的流量分配网络。其目的就是将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。<br>架构图：<br><img src="https://img-blog.csdnimg.cn/20200610164758810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>如果用户要访问某个静态文件，假如这个静态文件的域名是cdn.taobao.com，那么首先也会向Local DNS服务器发起请求，然后经过迭代解析后回到这个域名的注册服务器去解析，然后通过CDN域名解析器将它重新CNAME解析到另外一个域名，被指向到CDN全局中的DNS负载均衡服务器，再由这个GTM来最终分配是哪个地方的访问用户，返回给离这个访问用户最近的CDN节点。<br>拿到DNS解析结果后，用户就直接去这个ＣDN节点访问这个静态文件了，乳沟这个节点中所情趣的文件不存在，就会再回到源站去获取这个文件，然后再返回给用户。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>Load Balance就是对工作任务进行平衡、分摊到多个操作单元上执行，共同完成工作任务。通常有三种负载均衡架构：链路负载均衡、集群负载均衡、操作系统负载均衡。</p><h3 id="链路负载均衡"><a href="#链路负载均衡" class="headerlink" title="链路负载均衡"></a>链路负载均衡</h3><p><img src="https://img-blog.csdnimg.cn/20200610170349466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>如前面提到的通过DNS解析成不同的IP，然后用户根据这个IP来访问不同的目标服务器。</p><h3 id="集群负载均衡"><a href="#集群负载均衡" class="headerlink" title="集群负载均衡"></a>集群负载均衡</h3><p>又分为硬件负责均衡和软件负载均衡，硬件负载均衡一般使用一台专门的硬件设备来转发请求，性能好，但是价格昂贵，而且不能动态扩容；<br>软件负载均衡成本非常低，缺点是一般一次访问请求要经过多次代理服务器，会增加网络延时。</p><h3 id="操作系统负载均衡"><a href="#操作系统负载均衡" class="headerlink" title="操作系统负载均衡"></a>操作系统负载均衡</h3><p>利用操作系统级别的软中断或者硬件中断来达到负载均衡。</p><p>如果想了解更多关于负载均衡的知识，请点这里。</p><h2 id="CDN动态加速"><a href="#CDN动态加速" class="headerlink" title="CDN动态加速"></a>CDN动态加速</h2><p>原理：在CDN的DNS解析中通过动态的链路探测来寻找回源最好的一条路径，然后通过DNS的调度将所有请求调度到选定的这条路径上回源，从而加速用户访问的效率。</p>]]></content>
    
    
    <categories>
      
      <category>Web技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.SpringSecurity整合OAuth2.0-Day03</title>
    <link href="/2020/06/10/4-SpringSecurity%E6%95%B4%E5%90%88OAuth2-0-Day03/"/>
    <url>/2020/06/10/4-SpringSecurity%E6%95%B4%E5%90%88OAuth2-0-Day03/</url>
    
    <content type="html"><![CDATA[<p>上一篇文章中我们介绍了获取 token 的流程，这一篇重点分析一下，携带 token 访问受限资源时，内部的工作流程。</p><h2 id="EnableResourceServer-与-EnableAuthorizationServer"><a href="#EnableResourceServer-与-EnableAuthorizationServer" class="headerlink" title="@EnableResourceServer 与 @EnableAuthorizationServer"></a>@EnableResourceServer 与 @EnableAuthorizationServer</h2><p>之前我们介绍过了 OAuth2 的两个核心概念，资源服务器与身份认证服务器。我们对两个注解进行配置的同时，到底触发了内部的什么相关配置呢？</p><p>上一篇文章重点介绍的其实是与身份认证相关的流程，即如果获取 token，而本节要分析的携带 token 访问受限资源，自然便是与 @EnableResourceServer 相关的资源服务器配置了。</p><p>我们注意到其相关配置类是 ResourceServerConfigurer，内部关联了 ResourceServerSecurityConfigurer 和 HttpSecurity。前者与资源安全配置相关，后者与 http 安全配置相关。（类名比较类似，注意区分，以 Adapter 结尾的是适配器，以 Configurer 结尾的是配置器，以 Builder 结尾的是建造器，他们分别代表不同的设计模式，对设计模式有所了解可以更加方便理解其设计思路）</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceServerConfigurerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ResourceServerConfigurer</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ResourceServerSecurityConfigurer resources &lt;<span class="hljs-number">1</span>&gt;)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;http.authorizeRequests().anyRequest().authenticated();&#125;&#125;</code></pre></div><p>&lt;1&gt; ResourceServerSecurityConfigurer 显然便是我们分析的重点了。</p><h2 id="ResourceServerSecurityConfigurer（了解）"><a href="#ResourceServerSecurityConfigurer（了解）" class="headerlink" title="ResourceServerSecurityConfigurer（了解）"></a>ResourceServerSecurityConfigurer（了解）</h2><p>其核心配置如下所示：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;AuthenticationManager oauthAuthenticationManager = oauthAuthenticationManager(http);resourcesServerFilter = <span class="hljs-keyword">new</span> OAuth2AuthenticationProcessingFilter();<span class="hljs-comment">//&lt;1&gt;</span>resourcesServerFilter.setAuthenticationEntryPoint(authenticationEntryPoint);resourcesServerFilter.setAuthenticationManager(oauthAuthenticationManager);<span class="hljs-comment">//&lt;2&gt;</span><span class="hljs-keyword">if</span> (eventPublisher != <span class="hljs-keyword">null</span>) &#123;resourcesServerFilter.setAuthenticationEventPublisher(eventPublisher);&#125;<span class="hljs-keyword">if</span> (tokenExtractor != <span class="hljs-keyword">null</span>) &#123;resourcesServerFilter.setTokenExtractor(tokenExtractor);<span class="hljs-comment">//&lt;3&gt;</span>&#125;resourcesServerFilter = postProcess(resourcesServerFilter);resourcesServerFilter.setStateless(stateless);<span class="hljs-comment">// @formatter:off</span>http.authorizeRequests().expressionHandler(expressionHandler).and().addFilterBefore(resourcesServerFilter, AbstractPreAuthenticatedProcessingFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">.<span class="hljs-title">exceptionHandling</span>()</span><span class="hljs-class">.<span class="hljs-title">accessDeniedHandler</span>(<span class="hljs-title">accessDeniedHandler</span>)//&lt;4&gt;</span><span class="hljs-class">.<span class="hljs-title">authenticationEntryPoint</span>(<span class="hljs-title">authenticationEntryPoint</span>)</span>;<span class="hljs-comment">// @formatter:on</span>&#125;</code></pre></div><p>这段是整个 oauth2 与 HttpSecurity 相关的核心配置，其中有非常多的注意点，顺带的都强调一下：</p><p>&lt;1&gt; 创建 OAuth2AuthenticationProcessingFilter，即下一节所要介绍的 OAuth2 核心过滤器。</p><p>&lt;2&gt; 为 OAuth2AuthenticationProcessingFilter 提供固定的 AuthenticationManager 即 OAuth2AuthenticationManager，它并没有将 OAuth2AuthenticationManager 添加到 spring 的容器中，不然可能会影响 spring security 的普通认证流程（非 oauth2 请求），只有被 OAuth2AuthenticationProcessingFilter 拦截到的 oauth2 相关请求才被特殊的身份认证器处理。</p><p>&lt;3&gt; 设置了 TokenExtractor 默认的实现 —-BearerTokenExtractor，这个类在下一节介绍。</p><p>&lt;4&gt; 相关的异常处理器，可以重写相关实现，达到自定义异常的目的。</p><p>还记得我们在一开始的配置中配置了资源服务器，是它触发了相关的配置。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableResourceServer</span><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceServerConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResourceServerConfigurerAdapter</span> </span>&#123;&#125;</code></pre></div><h2 id="核心过滤器-OAuth2AuthenticationProcessingFilter（掌握）"><a href="#核心过滤器-OAuth2AuthenticationProcessingFilter（掌握）" class="headerlink" title="核心过滤器 OAuth2AuthenticationProcessingFilter（掌握）"></a>核心过滤器 OAuth2AuthenticationProcessingFilter（掌握）</h2><p>回顾一下我们之前是如何携带 token 访问受限资源的：<br><code>http://localhost:8080/order/1?access_token=950a7cc9-5a8a-42c9-a693-40e817b1a4b0</code><br>唯一的身份凭证，便是这个 access_token，携带它进行访问，会进入 OAuth2AuthenticationProcessingFilter 之中，其核心代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span>&#123;<span class="hljs-keyword">final</span> HttpServletRequest request = (HttpServletRequest) req;<span class="hljs-keyword">final</span> HttpServletResponse response = (HttpServletResponse) res;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// 从请求中取出身份信息，即 access_token</span>Authentication authentication = tokenExtractor.extract(request);<span class="hljs-keyword">if</span> (authentication == <span class="hljs-keyword">null</span>) &#123;...&#125;<span class="hljs-keyword">else</span> &#123;request.setAttribute(OAuth2AuthenticationDetails.ACCESS_TOKEN_VALUE, authentication.getPrincipal());<span class="hljs-keyword">if</span> (authentication <span class="hljs-keyword">instanceof</span> AbstractAuthenticationToken) &#123;AbstractAuthenticationToken needsDetails = (AbstractAuthenticationToken) authentication;needsDetails.setDetails(authenticationDetailsSource.buildDetails(request));&#125;<span class="hljs-comment">// 认证身份</span>Authentication authResult = authenticationManager.authenticate(authentication);...eventPublisher.publishAuthenticationSuccess(authResult);<span class="hljs-comment">// 将身份信息绑定到 SecurityContextHolder 中</span>SecurityContextHolder.getContext().setAuthentication(authResult);&#125;&#125;<span class="hljs-keyword">catch</span> (OAuth2Exception failed) &#123;...<span class="hljs-keyword">return</span>;&#125;chain.doFilter(request, response);&#125;</code></pre></div><p>整个过滤器便是 oauth2 身份鉴定的关键，在源码中，对这个类有一段如下的描述</p><blockquote><p>A pre-authentication filter for OAuth2 protected resources. Extracts an OAuth2 token from the incoming request and uses it to populate the Spring Security context with an {@link OAuth2Authentication} (if used in conjunction with an {@link OAuth2AuthenticationManager}). </p><p>OAuth2 保护资源的预先认证过滤器。如果与 OAuth2AuthenticationManager 结合使用，则会从到来的请求之中提取一个 OAuth2 token，之后使用 OAuth2Authentication 来填充 Spring Security 上下文。</p></blockquote><p>其中涉及到了两个关键的类 TokenExtractor，AuthenticationManager。相信后者这个接口大家已经不陌生，但前面这个类之前还未出现在我们的视野中。</p><h2 id="OAuth2-的身份管理器-–OAuth2AuthenticationManager（掌握）"><a href="#OAuth2-的身份管理器-–OAuth2AuthenticationManager（掌握）" class="headerlink" title="OAuth2 的身份管理器 –OAuth2AuthenticationManager（掌握）"></a>OAuth2 的身份管理器 –OAuth2AuthenticationManager（掌握）</h2><p>在之前的 OAuth2 核心过滤器中出现的 AuthenticationManager 其实在我们意料之中，携带 access_token 必定得经过身份认证，但是在我们 debug 进入其中后，发现了一个出乎意料的事，AuthenticationManager 的实现类并不是我们在前面文章中聊到的常用实现类 ProviderManager，而是 OAuth2AuthenticationManager。</p><p><img src="https://img-blog.csdnimg.cn/20200610104133512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>回顾之前文章的配置，压根没有出现过这个 OAuth2AuthenticationManager，并且它脱离了我们熟悉的认证流程（之前提到的认证管理器 UML 图是一张经典的 spring security 结构类图），它直接重写了容器的顶级身份认证接口，内部维护了一个 ClientDetailService 和 ResourceServerTokenServices，这两个核心类在前一篇文章中有分析过。在 ResourceServerSecurityConfigurer 的小节中我们已经知晓了它是如何被框架自动配置的，这里要强调的是 OAuth2AuthenticationManager 是密切与 token 认证相关的，而不是与获取 token 密切相关的。</p><p>其判别身份的关键代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;...String token = (String) authentication.getPrincipal();<span class="hljs-comment">// 最终还是借助 tokenServices 根据 token 加载身份信息</span>OAuth2Authentication auth = tokenServices.loadAuthentication(token);...checkClientDetails(auth);<span class="hljs-keyword">if</span> (authentication.getDetails() <span class="hljs-keyword">instanceof</span> OAuth2AuthenticationDetails) &#123;OAuth2AuthenticationDetails details = (OAuth2AuthenticationDetails) authentication.getDetails();...&#125;auth.setDetails(authentication.getDetails());auth.setAuthenticated(<span class="hljs-keyword">true</span>);<span class="hljs-keyword">return</span> auth;&#125;</code></pre></div><p>说到 tokenServices 这个密切与 token 相关的接口，这里要强调下，避免产生误解。tokenServices 分为两类，一个是用在 AuthorizationServer 端</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthorizationServerTokenServices</span> </span>&#123;    <span class="hljs-comment">// 创建 token</span>    <span class="hljs-function">OAuth2AccessToken <span class="hljs-title">createAccessToken</span><span class="hljs-params">(OAuth2Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException</span>;    <span class="hljs-comment">// 刷新 token</span>    <span class="hljs-function">OAuth2AccessToken <span class="hljs-title">refreshAccessToken</span><span class="hljs-params">(String refreshToken, TokenRequest tokenRequest)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> AuthenticationException</span>;    <span class="hljs-comment">// 获取 token</span>    <span class="hljs-function">OAuth2AccessToken <span class="hljs-title">getAccessToken</span><span class="hljs-params">(OAuth2Authentication authentication)</span></span>;&#125;</code></pre></div><p>而在 ResourceServer 端有自己的 tokenServices 接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ResourceServerTokenServices</span> </span>&#123;<span class="hljs-comment">// 根据 accessToken 加载客户端信息</span><span class="hljs-function">OAuth2Authentication <span class="hljs-title">loadAuthentication</span><span class="hljs-params">(String accessToken)</span> <span class="hljs-keyword">throws</span> AuthenticationException, InvalidTokenException</span>;<span class="hljs-comment">// 根据 accessToken 获取完整的访问令牌详细信息。</span><span class="hljs-function">OAuth2AccessToken <span class="hljs-title">readAccessToken</span><span class="hljs-params">(String accessToken)</span></span>;&#125;</code></pre></div><p>具体内部如何加载，和 AuthorizationServer 大同小异，只是从 tokenStore 中取出相应身份的流程有点区别，不再详细看实现类了。</p><h2 id="TokenExtractor（了解）"><a href="#TokenExtractor（了解）" class="headerlink" title="TokenExtractor（了解）"></a>TokenExtractor（了解）</h2><p>这个接口只有一个实现类，而且代码非常简单</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BearerTokenExtractor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TokenExtractor</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Log logger = LogFactory.getLog(BearerTokenExtractor<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">extract</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;String tokenValue = extractToken(request);<span class="hljs-keyword">if</span> (tokenValue != <span class="hljs-keyword">null</span>) &#123;PreAuthenticatedAuthenticationToken authentication = <span class="hljs-keyword">new</span> PreAuthenticatedAuthenticationToken(tokenValue, <span class="hljs-string">""</span>);<span class="hljs-keyword">return</span> authentication;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">extractToken</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<span class="hljs-comment">// first check the header...</span>String token = extractHeaderToken(request);<span class="hljs-comment">// bearer type allows a request parameter as well</span><span class="hljs-keyword">if</span> (token == <span class="hljs-keyword">null</span>) &#123;...<span class="hljs-comment">// 从 requestParameter 中获取 token</span>&#125;<span class="hljs-keyword">return</span> token;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Extract the OAuth bearer token from a header.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">extractHeaderToken</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;Enumeration&lt;String&gt; headers = request.getHeaders(<span class="hljs-string">"Authorization"</span>);<span class="hljs-keyword">while</span> (headers.hasMoreElements()) &#123;<span class="hljs-comment">// typically there is only one (most servers enforce that)</span>...<span class="hljs-comment">// 从 Header 中获取 token</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;&#125;</code></pre></div><p>它的作用在于分离出请求中包含的 token。也启示了我们可以使用多种方式携带 token。<br>1 在 Header 中携带</p><div class="hljs"><pre><code class="hljs http"><span class="hljs-attribute">http://localhost:8080/order/1</span><span class="hljs-attribute">Header：</span>Authentication：Bearer f732723d-af7f-41bb-bd06-2636ab2be135</code></pre></div><p>2 拼接在 url 中作为 requestParam</p><div class="hljs"><pre><code class="hljs http">http://localhost:8080/order/1?access_token=f732723d-af7f-41bb-bd06-2636ab2be135</code></pre></div><p>3 在 form 表单中携带</p><div class="hljs"><pre><code class="hljs http"><span class="hljs-attribute">http://localhost:8080/order/1</span>form param：access_token=f732723d-af7f-41bb-bd06-2636ab2be135</code></pre></div><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>OAuth2 在资源服务器端的异常处理不算特别完善，但基本够用，如果想要重写异常机制，可以直接替换掉相关的 Handler，如权限相关的 AccessDeniedHandler。具体的配置应该在 @EnableResourceServer 中被覆盖，这是适配器 + 配置器的好处。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这儿，Spring Security OAuth2 的整个内部流程就算是分析结束了。本系列的文章只能算是揭示一个大概的流程，重点还是介绍相关设计 + 接口，想要了解更多的细节，需要自己去翻看源码，研究各个实现类。在分析源码过程中总结出的一点经验，与君共勉：</p><ol><li>先掌握宏观，如研究 UML 类图，搞清楚关联</li><li>分析顶级接口，设计是面向接口的，不重要的部分，具体实现类甚至都可以忽略</li><li>学会对比，如 ResourceServer 和 AuthorizationServer 是一种对称的设计，整个框架内部的类非常多，但分门别类的记忆，会加深记忆。如 ResourceServerTokenServices ，AuthorizationServerTokenServices就一定是作用相关，但所属领域不同的两个接口</li><li>熟悉设计模式，spring 中涉及了大量的设计模式，在框架的设计中也是遵循着设计模式的规范，如以 Adapter 结尾，便是运用了适配器模式；以 Factory 结尾，便是运用了工厂模式；Template 结尾，便是运用了模板方法模式；Builder 结尾，便是运用了建造者模式…</li><li>一点自己的理解：对源码的理解和灵感，这一切都建立自身的编码经验之上，自己遵循规范便能更好的理解别人同样遵守规范的代码。相对的，阅读好的源码，也能帮助我们自身提升编码规范。</li></ol>]]></content>
    
    
    <categories>
      
      <category>安全框架</category>
      
      <category>OAuth2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OAuth2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.SpringSecurity整合OAuth2.0-Day02</title>
    <link href="/2020/06/09/3-SpringSecurity%E6%95%B4%E5%90%88OAuth2.0-Day02/"/>
    <url>/2020/06/09/3-SpringSecurity%E6%95%B4%E5%90%88OAuth2.0-Day02/</url>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先开启 debug 信息：</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">logging:</span>  <span class="hljs-attr">level:</span>    <span class="hljs-attr">org.springframework:</span> <span class="hljs-string">DEBUG</span></code></pre></div><p>可以完整的看到内部的运转流程。</p><p>client 模式稍微简单一些，使用 client 模式获取 token</p><div class="hljs"><pre><code class="hljs http">http://localhost:8080/oauth/token?client_id=client_1&amp;client_secret=123456&amp;scope=select&amp;grant_type=client_credentials</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200609192018214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>查看调试窗口，由于 debug 信息太多了，我简单按照顺序列了一下关键的几个类：</p><div class="hljs"><pre><code class="hljs javascript">ClientCredentialsTokenEndpointFilterDaoAuthenticationProviderTokenEndpointTokenGranter</code></pre></div><h2 id="EnableAuthorizationServer"><a href="#EnableAuthorizationServer" class="headerlink" title="@EnableAuthorizationServer"></a>@EnableAuthorizationServer</h2><p>上一篇博客中我们尝试使用了 password 模式和 client 模式，有一个比较关键的 endpoint：/oauth/token。从这个入口开始分析，spring security oauth2 内部是如何生成 token 的？</p><p>在之前的配置中：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableAuthorizationServer</span><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationServerConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;&#125;</code></pre></div><p>出现了 AuthorizationServerConfigurerAdapter 关键类，他关联了三个重要的配置类，分别是：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthorizationServerConfigurer</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerSecurityConfigurer security &lt;<span class="hljs-number">1</span>&gt;)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients &lt;<span class="hljs-number">2</span>&gt;)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints &lt;<span class="hljs-number">3</span>&gt;)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;&#125;&#125;</code></pre></div><p>&lt;1&gt; 配置 AuthorizationServer 安全认证的相关信息，创建 ClientCredentialsTokenEndpointFilter 核心过滤器</p><p>&lt;2&gt; 配置 OAuth2 的客户端相关信息</p><p>&lt;3&gt; 配置 AuthorizationServerEndpointsConfigurer 众多相关类，包括配置身份认证器，配置认证方式，TokenStore，TokenGranter，OAuth2RequestFactory</p><p>我们逐步分析其中关键的类：</p><h2 id="客户端身份认证核心过滤器-ClientCredentialsTokenEndpointFilter（掌握）"><a href="#客户端身份认证核心过滤器-ClientCredentialsTokenEndpointFilter（掌握）" class="headerlink" title="客户端身份认证核心过滤器 ClientCredentialsTokenEndpointFilter（掌握）"></a>客户端身份认证核心过滤器 ClientCredentialsTokenEndpointFilter（掌握）</h2><p>截取关键的代码，可以分析出大概的流程<br>在请求到达 /oauth/token 之前经过了 ClientCredentialsTokenEndpointFilter 这个过滤器，关键方法如下</p><div class="hljs"><pre><code class="hljs java">org.springframework.security.oauth2.provider.client.ClientCredentialsTokenEndpointFilter#attemptAuthentication    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException, IOException, ServletException </span>&#123;...String clientId = request.getParameter(<span class="hljs-string">"client_id"</span>);String clientSecret = request.getParameter(<span class="hljs-string">"client_secret"</span>);...clientId = clientId.trim();UsernamePasswordAuthenticationToken authRequest = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(clientId,clientSecret);<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);&#125;</code></pre></div><h2 id="顶级身份管理者-AuthenticationManager（掌握）"><a href="#顶级身份管理者-AuthenticationManager（掌握）" class="headerlink" title="顶级身份管理者 AuthenticationManager（掌握）"></a>顶级身份管理者 AuthenticationManager（掌握）</h2><p>用来从请求中获取 client_id,client_secret，组装成一个 UsernamePasswordAuthenticationToken 作为身份标识，使用容器中的顶级身份管理器 AuthenticationManager 去进行身份认证（AuthenticationManager 的实现类一般是 ProviderManager。而 ProviderManager 内部维护了一个 List, 真正的身份认证是由一系列 AuthenticationProvider 去完成。而 AuthenticationProvider 的常用实现类则是 DaoAuthenticationProvider，DaoAuthenticationProvider 内部又聚合了一个 UserDetailsService 接口，</p><p><img src="https://img-blog.csdnimg.cn/20200610091710428.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>所以说UserDetailsService 才是获取用户详细信息的最终接口，而我们上一篇文章中在内存中配置用户，就是使用了 UserDetailsService 的一个实现类 InMemoryUserDetailsManager）。UML 类图可以大概理解下这些类的关系，省略了授权部分。<br><img src="https://img-blog.csdnimg.cn/20200610104349713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>可能机智的读者会发现一个问题，我前面一篇文章已经提到了 client 模式是不存在“用户”的概念的，那么这里的身份认证是在认证什么呢？debug 可以发现 UserDetailsService 的实现被适配成了 ClientDetailsUserDetailsService，这个设计是将 client 客户端的信息（client_id,client_secret）适配成用户的信息 (username,password)，这样我们的认证流程就不需要修改了。</p><p>经过 ClientCredentialsTokenEndpointFilter 之后，身份信息已经得到了 AuthenticationManager 的验证。接着便到达了TokenEndpoint。</p><h2 id="Token-处理端点-TokenEndpoint（掌握）"><a href="#Token-处理端点-TokenEndpoint（掌握）" class="headerlink" title="Token 处理端点 TokenEndpoint（掌握）"></a>Token 处理端点 TokenEndpoint（掌握）</h2><p>前面的两个 ClientCredentialsTokenEndpointFilter 和 AuthenticationManager 可以理解为一些前置校验和身份封装，而这个类一看名字就知道和我们的 token 是密切相关的。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@FrameworkEndpoint</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TokenEndpoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractEndpoint</span> </span>&#123;<span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/oauth/token"</span>, method=RequestMethod.POST)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;OAuth2AccessToken&gt; <span class="hljs-title">postAccessToken</span><span class="hljs-params">(Principal principal, @RequestParam</span></span><span class="hljs-function"><span class="hljs-params">Map&lt;String, String&gt; parameters)</span> <span class="hljs-keyword">throws</span> HttpRequestMethodNotSupportedException </span>&#123; ...String clientId = getClientId(principal);ClientDetails authenticatedClient = getClientDetailsService().loadClientByClientId(clientId);<span class="hljs-comment">//&lt;1&gt;</span>...TokenRequest tokenRequest = getOAuth2RequestFactory().createTokenRequest(parameters, authenticatedClient);<span class="hljs-comment">//&lt;2&gt;</span>...OAuth2AccessToken token = getTokenGranter().grant(tokenRequest.getGrantType(), tokenRequest);<span class="hljs-comment">//&lt;3&gt;</span>...<span class="hljs-keyword">return</span> getResponse(token);&#125;<span class="hljs-keyword">private</span> TokenGranter tokenGranter;&#125;</code></pre></div><p>&lt;1&gt; 加载客户端信息</p><p>&lt;2&gt; 结合请求信息，创建 TokenRequest</p><p>&lt;3&gt; 将 TokenRequest 传递给 TokenGranter 颁发 token</p><p>省略了一些校验代码之后，真正的 /oauth/token 端点暴露在了我们眼前，其中方法参数中的 Principal 经过之前的过滤器，已经被填充了相关的信息，而方法的内部则是依赖了一个 TokenGranter 来颁发 token。其中 OAuth2AccessToken 的实现类 DefaultOAuth2AccessToken 就是最终在控制台得到的 token 序列化之前的原始类:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultOAuth2AccessToken</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span>, <span class="hljs-title">OAuth2AccessToken</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">914967629530462926L</span>;  <span class="hljs-keyword">private</span> String value;  <span class="hljs-keyword">private</span> Date expiration;  <span class="hljs-keyword">private</span> String tokenType = BEARER_TYPE.toLowerCase();  <span class="hljs-keyword">private</span> OAuth2RefreshToken refreshToken;  <span class="hljs-keyword">private</span> Set&lt;String&gt; scope;  <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; additionalInformation = Collections.emptyMap();  <span class="hljs-comment">//getter,setter</span>&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@org</span>.codehaus.jackson.map.annotate.JsonSerialize(using = OAuth2AccessTokenJackson1Serializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">org</span>.<span class="hljs-title">codehaus</span>.<span class="hljs-title">jackson</span>.<span class="hljs-title">map</span>.<span class="hljs-title">annotate</span>.<span class="hljs-title">JsonDeserialize</span>(<span class="hljs-title">using</span> </span>= OAuth2AccessTokenJackson1Deserializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">com</span>.<span class="hljs-title">fasterxml</span>.<span class="hljs-title">jackson</span>.<span class="hljs-title">databind</span>.<span class="hljs-title">annotation</span>.<span class="hljs-title">JsonSerialize</span>(<span class="hljs-title">using</span> </span>= OAuth2AccessTokenJackson2Serializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">com</span>.<span class="hljs-title">fasterxml</span>.<span class="hljs-title">jackson</span>.<span class="hljs-title">databind</span>.<span class="hljs-title">annotation</span>.<span class="hljs-title">JsonDeserialize</span>(<span class="hljs-title">using</span> </span>= OAuth2AccessTokenJackson2Deserializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">OAuth2AccessToken</span> </span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String BEARER_TYPE = <span class="hljs-string">"Bearer"</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String OAUTH2_TYPE = <span class="hljs-string">"OAuth2"</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String ACCESS_TOKEN = <span class="hljs-string">"access_token"</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String TOKEN_TYPE = <span class="hljs-string">"token_type"</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String EXPIRES_IN = <span class="hljs-string">"expires_in"</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String REFRESH_TOKEN = <span class="hljs-string">"refresh_token"</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String SCOPE = <span class="hljs-string">"scope"</span>;...&#125;</code></pre></div><p>一个典型的样例 token 响应, 如下所示，就是上述类序列化后的结果：</p><div class="hljs"><pre><code class="hljs json">&#123; <span class="hljs-attr">"access_token"</span>:<span class="hljs-string">"950a7cc9-5a8a-42c9-a693-40e817b1a4b0"</span>, <span class="hljs-attr">"token_type"</span>:<span class="hljs-string">"bearer"</span>, <span class="hljs-attr">"refresh_token"</span>:<span class="hljs-string">"773a0fcd-6023-45f8-8848-e141296cb3cb"</span>, <span class="hljs-attr">"expires_in"</span>:<span class="hljs-number">27036</span>, <span class="hljs-attr">"scope"</span>:<span class="hljs-string">"select"</span> &#125;</code></pre></div><h2 id="TokenGranter（掌握）"><a href="#TokenGranter（掌握）" class="headerlink" title="TokenGranter（掌握）"></a>TokenGranter（掌握）</h2><p>先从 UML 类图对 TokenGranter 接口的设计有一个宏观的认识：</p><p><img src="https://img-blog.csdnimg.cn/20200610104442401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>TokenGranter 的设计思路是使用 CompositeTokenGranter 管理一个 List 列表，每一种 grantType 对应一个具体的真正授权者，在 debug 过程中可以发现 CompositeTokenGranter 内部就是在循环调用五种 TokenGranter 实现类的 grant 方法，而 granter 内部则是通过 grantType 来区分是否是各自的授权类型。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompositeTokenGranter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TokenGranter</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;TokenGranter&gt; tokenGranters;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CompositeTokenGranter</span><span class="hljs-params">(List&lt;TokenGranter&gt; tokenGranters)</span> </span>&#123;        <span class="hljs-keyword">this</span>.tokenGranters = <span class="hljs-keyword">new</span> ArrayList(tokenGranters);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> OAuth2AccessToken <span class="hljs-title">grant</span><span class="hljs-params">(String grantType, TokenRequest tokenRequest)</span> </span>&#123;        Iterator var3 = <span class="hljs-keyword">this</span>.tokenGranters.iterator();        OAuth2AccessToken grant;        <span class="hljs-keyword">do</span> &#123;            <span class="hljs-keyword">if</span> (!var3.hasNext()) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            TokenGranter granter = (TokenGranter)var3.next();            grant = granter.grant(grantType, tokenRequest);        &#125; <span class="hljs-keyword">while</span>(grant == <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">return</span> grant;    &#125;&#125;</code></pre></div><p>五种类型分别是：</p><ul><li>ResourceOwnerPasswordTokenGranter ==&gt; password 密码模式</li><li>AuthorizationCodeTokenGranter ==&gt; authorization_code 授权码模式</li><li>ClientCredentialsTokenGranter ==&gt; client_credentials 客户端模式</li><li>ImplicitTokenGranter ==&gt; implicit 简化模式</li><li>RefreshTokenGranter ==&gt;refresh_token 刷新 token 专用</li></ul><p>以客户端模式为例，思考如何产生 token 的，则需要继续研究 5 种授权者的抽象类：AbstractTokenGranter</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractTokenGranter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TokenGranter</span> </span>&#123;<span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Log logger = LogFactory.getLog(getClass());<span class="hljs-comment">// 与 token 相关的 service，重点</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AuthorizationServerTokenServices tokenServices;<span class="hljs-comment">// 与 clientDetails 相关的 service，重点</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClientDetailsService clientDetailsService;<span class="hljs-comment">// 创建 oauth2Request 的工厂，重点</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> OAuth2RequestFactory requestFactory;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String grantType;...<span class="hljs-function"><span class="hljs-keyword">public</span> OAuth2AccessToken <span class="hljs-title">grant</span><span class="hljs-params">(String grantType, TokenRequest tokenRequest)</span> </span>&#123;...String clientId = tokenRequest.getClientId();ClientDetails client = clientDetailsService.loadClientByClientId(clientId);validateGrantType(grantType, client);logger.debug(<span class="hljs-string">"Getting access token for:"</span> + clientId);<span class="hljs-keyword">return</span> getAccessToken(client, tokenRequest);&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> OAuth2AccessToken <span class="hljs-title">getAccessToken</span><span class="hljs-params">(ClientDetails client, TokenRequest tokenRequest)</span> </span>&#123;<span class="hljs-keyword">return</span> tokenServices.createAccessToken(getOAuth2Authentication(client, tokenRequest));&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> OAuth2Authentication <span class="hljs-title">getOAuth2Authentication</span><span class="hljs-params">(ClientDetails client, TokenRequest tokenRequest)</span> </span>&#123;OAuth2Request storedOAuth2Request = requestFactory.createOAuth2Request(client, tokenRequest);<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OAuth2Authentication(storedOAuth2Request, <span class="hljs-keyword">null</span>);&#125;...&#125;</code></pre></div><p>回过头去看 TokenEndpoint 中，正是调用了这里的三个重要的类变量的相关方法。由于篇幅限制，不能延展太多，不然没完没了，所以重点分析下 AuthorizationServerTokenServices 是何方神圣。</p><h2 id="AuthorizationServerTokenServices（了解）"><a href="#AuthorizationServerTokenServices（了解）" class="headerlink" title="AuthorizationServerTokenServices（了解）"></a>AuthorizationServerTokenServices（了解）</h2><p>AuthorizationServer 端的 token 操作 service，接口设计如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthorizationServerTokenServices</span> </span>&#123;<span class="hljs-comment">// 创建 token</span><span class="hljs-function">OAuth2AccessToken <span class="hljs-title">createAccessToken</span><span class="hljs-params">(OAuth2Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException</span>;<span class="hljs-comment">// 刷新 token</span><span class="hljs-function">OAuth2AccessToken <span class="hljs-title">refreshAccessToken</span><span class="hljs-params">(String refreshToken, TokenRequest tokenRequest)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException</span>;<span class="hljs-comment">// 获取 token</span><span class="hljs-function">OAuth2AccessToken <span class="hljs-title">getAccessToken</span><span class="hljs-params">(OAuth2Authentication authentication)</span></span>;&#125;</code></pre></div><p>在默认的实现类 DefaultTokenServices 中，可以看到 token 是如何产生的，并且了解了框架对 token 进行哪些信息的关联。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><span class="hljs-function"><span class="hljs-keyword">public</span> OAuth2AccessToken <span class="hljs-title">createAccessToken</span><span class="hljs-params">(OAuth2Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;OAuth2AccessToken existingAccessToken = tokenStore.getAccessToken(authentication);OAuth2RefreshToken refreshToken = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span> (existingAccessToken != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (existingAccessToken.isExpired()) &#123;<span class="hljs-keyword">if</span> (existingAccessToken.getRefreshToken() != <span class="hljs-keyword">null</span>) &#123;refreshToken = existingAccessToken.getRefreshToken();tokenStore.removeRefreshToken(refreshToken);&#125;tokenStore.removeAccessToken(existingAccessToken);&#125;<span class="hljs-keyword">else</span> &#123;tokenStore.storeAccessToken(existingAccessToken, authentication);<span class="hljs-keyword">return</span> existingAccessToken;&#125;&#125;<span class="hljs-keyword">if</span> (refreshToken == <span class="hljs-keyword">null</span>) &#123;refreshToken = createRefreshToken(authentication);&#125;<span class="hljs-comment">// But the refresh token itself might need to be re-issued if it has</span><span class="hljs-comment">// expired.</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (refreshToken <span class="hljs-keyword">instanceof</span> ExpiringOAuth2RefreshToken) &#123;ExpiringOAuth2RefreshToken expiring = (ExpiringOAuth2RefreshToken) refreshToken;<span class="hljs-keyword">if</span> (System.currentTimeMillis() &gt; expiring.getExpiration().getTime()) &#123;refreshToken = createRefreshToken(authentication);&#125;&#125;OAuth2AccessToken accessToken = createAccessToken(authentication, refreshToken);tokenStore.storeAccessToken(accessToken, authentication);<span class="hljs-comment">// In case it was modified</span>refreshToken = accessToken.getRefreshToken();<span class="hljs-keyword">if</span> (refreshToken != <span class="hljs-keyword">null</span>) &#123;tokenStore.storeRefreshToken(refreshToken, authentication);&#125;<span class="hljs-keyword">return</span> accessToken;&#125;</code></pre></div><p>简单总结一下 AuthorizationServerTokenServices 的作用，他提供了创建 token，刷新 token，获取 token 的实现。在创建 token 时，他会调用 tokenStore 对产生的 token 和相关信息存储到对应的实现类中，可以是 redis，数据库，内存，jwt。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇总结了使用客户端模式获取 Token 时，spring security oauth2 内部的运作流程，重点是在分析 AuthenticationServer 相关的类。其他模式有一定的不同，但抽象功能是固定的，只是具体的实现类会被相应地替换。阅读 spring 的源码，会发现它的设计中出现了非常多的抽象接口，这对我们理清楚内部工作流程产生了不小的困扰，我的方式是可以借助 UML 类图，先从宏观理清楚作者的设计思路，这会让我们的分析事半功倍。</p><p>下一篇文章重点分析用户携带 token 访问受限资源时，spring security oauth2 内部的工作流程。即 ResourceServer 相关的类。</p>]]></content>
    
    
    <categories>
      
      <category>安全框架</category>
      
      <category>OAuth2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OAuth2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.SpringSecurity整合OAuth2.0-Day01</title>
    <link href="/2020/06/08/2-SpringSecurity%E6%95%B4%E5%90%88OAuth2-0-Day01/"/>
    <url>/2020/06/08/2-SpringSecurity%E6%95%B4%E5%90%88OAuth2-0-Day01/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>使用 oauth2 保护你的应用，可以分为简易的分为三个步骤：</p><ul><li><p>配置资源服务器</p></li><li><p>配置认证服务器</p></li><li><p>配置 spring security</p><p>本文重点讲解接口对接中常使用的密码模式（以下简称 password 模式）和客户端模式（以下简称 client 模式）。授权码模式使用到了回调地址，是最为复杂的方式，通常网站中经常出现的微博，qq 第三方登录，都会采用这个形式。简化模式不常用。</p><h1 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h1><p>首先引入依赖：</p><div class="hljs"><pre><code class="hljs java">&lt;dependencies&gt;       &lt;!-- 注意是starter,自动配置 --&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;       &lt;/dependency&gt;       &lt;!-- 不是starter,手动配置 --&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt;           &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt;           &lt;version&gt;2.3.2.RELEASE&lt;/version&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;       &lt;/dependency&gt;       &lt;!-- 将token存储在redis中 --&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;       &lt;/dependency&gt;   &lt;/dependencies&gt;</code></pre></div><p>编写controller类，用来验证效果：</p></li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestEndpoints</span> </span>&#123;    <span class="hljs-comment">/** 商品查询接口，后续不做安全限制 **/</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/product/&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getProduct</span><span class="hljs-params">(@PathVariable String id)</span> </span>&#123;        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();        <span class="hljs-keyword">return</span> <span class="hljs-string">"product id : "</span> + id;    &#125;    <span class="hljs-comment">/** 订单查询接口，后续添加访问控制 **/</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/order/&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getOrder</span><span class="hljs-params">(@PathVariable String id)</span> </span>&#123;        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();        <span class="hljs-keyword">return</span> <span class="hljs-string">"order id : "</span> + id;    &#125;&#125;</code></pre></div><h1 id="配置资源服务器和授权服务器"><a href="#配置资源服务器和授权服务器" class="headerlink" title="配置资源服务器和授权服务器"></a>配置资源服务器和授权服务器</h1><p>资源服务器和授权服务器都是OAuth2的核心内容，这里我们在一个配置类中进行配置。<br>为了简化开发，这里将客户端信息放到内存中，实际项目开发中可以配置到数据库中。<br>token的存储一般使用redis，一来性能较好，二是本身就有自动过期的机制，符合token的特性。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OAuth2ServerConfig</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEMO_RESOURCE_ID = <span class="hljs-string">"order"</span>;    <span class="hljs-meta">@Configuration</span>    <span class="hljs-meta">@EnableResourceServer</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceServerConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResourceServerConfigurerAdapter</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ResourceServerSecurityConfigurer resources)</span> </span>&#123;            resources.resourceId(DEMO_RESOURCE_ID).stateless(<span class="hljs-keyword">true</span>);        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            http.authorizeRequests()                 <span class="hljs-comment">//配置order访问控制，必须认证过后才可以访问</span>                .antMatchers(<span class="hljs-string">"/order/**"</span>).authenticated();        &#125;    &#125;    <span class="hljs-meta">@Configuration</span>    <span class="hljs-meta">@EnableAuthorizationServer</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationServerConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;        <span class="hljs-meta">@Autowired</span>        AuthenticationManager authenticationManager;        <span class="hljs-meta">@Autowired</span>        RedisConnectionFactory redisConnectionFactory;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            String finalSecret = <span class="hljs-string">"&#123;bcrypt&#125;"</span>+<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123456"</span>);            <span class="hljs-comment">//配置两个客户端,一个用于password认证一个用于client认证</span>            clients.inMemory().withClient(<span class="hljs-string">"client_1"</span>)                    .resourceIds(DEMO_RESOURCE_ID)                    .authorizedGrantTypes(<span class="hljs-string">"client_credentials"</span>, <span class="hljs-string">"refresh_token"</span>)                    .scopes(<span class="hljs-string">"select"</span>)                    .authorities(<span class="hljs-string">"oauth2"</span>)                    .secret(finalSecret)                    .and().withClient(<span class="hljs-string">"client_2"</span>)                    .resourceIds(DEMO_RESOURCE_ID)                    .authorizedGrantTypes(<span class="hljs-string">"password"</span>, <span class="hljs-string">"refresh_token"</span>)                    .scopes(<span class="hljs-string">"select"</span>)                    .authorities(<span class="hljs-string">"oauth2"</span>)                    .secret(finalSecret);        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> </span>&#123;            endpoints                    .tokenStore(<span class="hljs-keyword">new</span> RedisTokenStore(redisConnectionFactory))                    .authenticationManager(authenticationManager)                    .allowedTokenEndpointRequestMethods(HttpMethod.GET, HttpMethod.POST);        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerSecurityConfigurer oauthServer)</span> </span>&#123;            <span class="hljs-comment">//允许表单认证</span>            oauthServer.allowFormAuthenticationForClients();        &#125;    &#125;&#125;</code></pre></div><p>认证思路：</p><ul><li>client 模式，没有用户的概念，直接与认证服务器交互，用配置中的客户端信息去申请 accessToken，客户端有自己的 client_id,client_secret ，对应于用户的 username,password，而客户端也拥有自己的 authorities，当采取 client 模式认证时，对应的权限也就是客户端自己的 authorities。</li><li>password 模式，自己本身有一套用户体系，在认证时需要带上自己的用户名和密码，以及客户端的 client_id,client_secret。此时，accessToken 所包含的权限是用户本身的权限，而不是客户端的权限。</li></ul><p>如果你的系统已经有了一套用户体系，每个用户也有了一定的权限，可以采用 password 模式；如果仅仅是接口的对接，不考虑用户，则可以使用 client 模式。</p><h1 id="配置-spring-security"><a href="#配置-spring-security" class="headerlink" title="配置 spring security"></a>配置 spring security</h1><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> UserDetailsService <span class="hljs-title">userDetailsService</span><span class="hljs-params">()</span></span>&#123;        BCryptPasswordEncoder bCryptPasswordEncoder = <span class="hljs-keyword">new</span> BCryptPasswordEncoder();        String finalPassword = <span class="hljs-string">"&#123;bcrypt&#125;"</span>+bCryptPasswordEncoder.encode(<span class="hljs-string">"123456"</span>);        InMemoryUserDetailsManager manager = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();        manager.createUser(User.withUsername(<span class="hljs-string">"user_1"</span>).password(finalPassword).authorities(<span class="hljs-string">"USER"</span>).build());        manager.createUser(User.withUsername(<span class="hljs-string">"user_2"</span>).password(finalPassword).authorities(<span class="hljs-string">"USER"</span>).build());        <span class="hljs-keyword">return</span> manager;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> PasswordEncoderFactories.createDelegatingPasswordEncoder();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 这一步的配置是必不可少的，否则SpringBoot会自动配置一个AuthenticationManager,覆盖掉内存中的用户</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationManager <span class="hljs-title">authenticationManagerBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        AuthenticationManager manager = <span class="hljs-keyword">super</span>.authenticationManagerBean();        <span class="hljs-keyword">return</span> manager;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http            .requestMatchers().anyRequest()            .and()            .authorizeRequests()            .antMatchers(<span class="hljs-string">"/oauth/**"</span>).permitAll();    &#125;&#125;</code></pre></div><p>重点就是配置了一个 UserDetailsService，和 ClientDetailsService 一样，为了方便运行，使用内存中的用户，实际项目中，一般使用的是数据库保存用户，具体的实现类可以使用 JdbcDaoImpl 或者 JdbcUserDetailsManager。</p><h1 id="获取token"><a href="#获取token" class="headerlink" title="获取token"></a>获取token</h1><p>配置完成后，启动项目，使用Postman访问密码模式：</p><div class="hljs"><pre><code class="hljs html">http://localhost:8080/oauth/token?username=user_1&amp;password=123456&amp;grant_type=password&amp;scope=select&amp;client_id=client_2&amp;client_secret=123456</code></pre></div><p>响应如下：<br><img src="https://img-blog.csdnimg.cn/20200608230325325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>接下来试试客户端模式：</p><div class="hljs"><pre><code class="hljs html">http://localhost:8080/oauth/token?grant_type=client_credentials&amp;scope=select&amp;client_id=client_1&amp;client_secret=123456</code></pre></div><p>响应如下：<br><img src="https://img-blog.csdnimg.cn/20200608230514656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在配置中我们已经配置了对order资源的保护，测试如下：<br><img src="https://img-blog.csdnimg.cn/2020060823071875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>而对于未受保护的product资源，访问效果如下：<br><img src="https://img-blog.csdnimg.cn/20200608230845622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>接下来带有accessToken参数来访问受保护的order资源：<br><img src="https://img-blog.csdnimg.cn/20200608231140408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>可以看到成功访问到了资源。<br>下面看下调试的情况：<br>密码模式下：<br><img src="https://img-blog.csdnimg.cn/20200608232347515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>客户端模式下 :<br><img src="https://img-blog.csdnimg.cn/20200608232737620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>安全框架</category>
      
      <category>OAuth2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OAuth2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谷粒商城-Day01</title>
    <link href="/2020/06/07/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-Day01/"/>
    <url>/2020/06/07/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-Day01/</url>
    
    <content type="html"><![CDATA[<h1 id="1-整体分析"><a href="#1-整体分析" class="headerlink" title="1.整体分析"></a>1.整体分析</h1><h2 id="系统构成"><a href="#系统构成" class="headerlink" title="系统构成"></a>系统构成</h2><p><img src="https://img-blog.csdnimg.cn/20200607210858589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="用到的框架技术"><a href="#用到的框架技术" class="headerlink" title="用到的框架技术"></a>用到的框架技术</h2><p><img src="https://img-blog.csdnimg.cn/20200607211031340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2.准备工作"></a>2.准备工作</h1><h2 id="1-1-准备git"><a href="#1-1-准备git" class="headerlink" title="1.1 准备git"></a>1.1 准备git</h2><p>在GitHub上新建一个仓库：<br><img src="https://img-blog.csdnimg.cn/20200607132311474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="项目地址"><br>复制仓库地址后来到IDEA页面；<br><img src="https://img-blog.csdnimg.cn/20200607132504185.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200607132636145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>记得检查JDK、MAVEN的配置是否正确：<br><img src="https://img-blog.csdnimg.cn/20200607133051908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200607133123825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>如果弹出提示框如下，问你是否要自动提交某些文件，请一律选NO,且不再提醒。否则系统会自动提交一些不必要的文件，平时养成好的习惯，否则步入社会会被人骂的。<br><img src="https://img-blog.csdnimg.cn/20200607132955394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200607143024363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="3-数据结构的概述"><a href="#3-数据结构的概述" class="headerlink" title="3.数据结构的概述"></a>3.数据结构的概述</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><img src="https://img-blog.csdnimg.cn/20200607211213891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>cms：内容管理        pms：商品管理        oms：订单管理</p><p>sms：优惠管理        ums：用户管理        wms：库存管理</p><h2 id="数据库建模工具"><a href="#数据库建模工具" class="headerlink" title="数据库建模工具"></a>数据库建模工具</h2><p>这里我使用的是<strong>PowerDesigner16.5</strong>，安装破解参考<a href="https://www.fujieace.com/software/powerdesigner.html" target="_blank" rel="noopener">这里</a>，简单学习可以参考<a href="https://www.cnblogs.com/lxbmaomao/p/9826790.html" target="_blank" rel="noopener">这篇文章</a></p><h1 id="4-通用Mapper"><a href="#4-通用Mapper" class="headerlink" title="4. 通用Mapper"></a>4. 通用Mapper</h1><h2 id="导入通用Mapper依赖"><a href="#导入通用Mapper依赖" class="headerlink" title="导入通用Mapper依赖"></a>导入通用Mapper依赖</h2><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 通用mapper --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>tk.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-comment">&lt;!--谷粒学院上面是1.2.3版本，太老了，运行会报错，用新版本--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h2 id="其他注意事项："><a href="#其他注意事项：" class="headerlink" title="其他注意事项："></a>其他注意事项：</h2><p>如果之前用的不是通用Mapper，并且已经配置过，那么记得将原先的用到Mapper的地方的导包改成<code>tk.mybatis</code>，而不能用<code>org.mybatis</code>。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="hljs-keyword">import</span> tk.mybatis.spring.annotation.MapperScan;<span class="hljs-comment">//注意</span><span class="hljs-meta">@MapperScan</span>(basePackages = <span class="hljs-string">"com.gavin.gmall.user.mapper"</span>)<span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GmallUserApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(GmallUserApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><p>另外其他用到Mapper的地方继承Mapper的时候也要选择<code>tk.mybatis</code>包下的mapper。<br><img src="https://img-blog.csdnimg.cn/20200607213213691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>源码地址：<a href="https://github.com/gavin-yyj/gmall" target="_blank" rel="noopener">https://github.com/gavin-yyj/gmall</a></p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1.理解 OAuth 2.0</title>
    <link href="/2020/06/06/1-%E7%90%86%E8%A7%A3-OAuth-2-0/"/>
    <url>/2020/06/06/1-%E7%90%86%E8%A7%A3-OAuth-2-0/</url>
    
    <content type="html"><![CDATA[<p><a href="http://en.wikipedia.org/wiki/OAuth" target="_blank" rel="noopener">OAuth</a>是一个关于授权（authorization）的<strong>开放网络标准</strong>，在全世界得到广泛应用，目前的版本是2.0版。</p><p>本文对OAuth 2.0的设计思路和运行流程，做一个简明通俗的解释，主要参考材料为<a href="http://www.rfcreader.com/#rfc6749" target="_blank" rel="noopener">RFC 6749</a>。</p><h2 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h2><p>为了理解OAuth的适用场合，让我举一个假设的例子。</p><p>有一个”云冲印”的网站，可以将用户储存在Google的照片，冲印出来。用户为了使用该服务，必须让”云冲印”读取自己储存在Google上的照片。</p><p>问题是只有得到用户的授权，Google才会同意”云冲印”读取这些照片。那么，”云冲印”怎样获得用户的授权呢？</p><p>传统方法是，用户将自己的Google用户名和密码，告诉”云冲印”，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点。</p><div class="hljs"><pre><code class="hljs lsl">（<span class="hljs-number">1</span>）<span class="hljs-string">"云冲印"</span>为了后续的服务，会保存用户的密码，这样很不安全。（<span class="hljs-number">2</span>）Google不得不部署密码登录，而我们知道，单纯的密码登录并不安全。（<span class="hljs-number">3</span>）<span class="hljs-string">"云冲印"</span>拥有了获取用户储存在Google所有资料的权力，用户没法限制<span class="hljs-string">"云冲印"</span>获得授权的范围和有效期。（<span class="hljs-number">4</span>）用户只有修改密码，才能收回赋予<span class="hljs-string">"云冲印"</span>的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效。（<span class="hljs-number">5</span>）只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。</code></pre></div><p>OAuth就是为了解决上面这些问题而诞生的。</p><h2 id="二、名词定义"><a href="#二、名词定义" class="headerlink" title="二、名词定义"></a>二、名词定义</h2><p>在详细讲解OAuth 2.0之前，需要了解几个专用名词。它们对读懂后面的讲解，尤其是几张图，至关重要。</p><div class="hljs"><pre><code class="hljs lsl">（<span class="hljs-number">1</span>）Third-party application：第三方应用程序，本文中又称<span class="hljs-string">"客户端"</span>（client），即上一节例子中的<span class="hljs-string">"云冲印"</span>。（<span class="hljs-number">2</span>）HTTP service：HTTP服务提供商，本文中简称<span class="hljs-string">"服务提供商"</span>，即上一节例子中的Google。（<span class="hljs-number">3</span>）Resource Owner：资源所有者，本文中又称<span class="hljs-string">"用户"</span>（user）。（<span class="hljs-number">4</span>）User Agent：用户代理，本文中就是指浏览器。（<span class="hljs-number">5</span>）Authorization server：认证服务器，即服务提供商专门用来处理认证的服务器。（<span class="hljs-number">6</span>）Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</code></pre></div><p>知道了上面这些名词，就不难理解，OAuth的作用就是让”客户端”安全可控地获取”用户”的授权，与”服务商提供商”进行互动。</p><h2 id="三、OAuth的思路"><a href="#三、OAuth的思路" class="headerlink" title="三、OAuth的思路"></a>三、OAuth的思路</h2><p>OAuth在”客户端”与”服务提供商”之间，设置了一个<code>授权层（authorization layer）</code>。<strong>“客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。</strong>“客户端”登录授权层所用的<code>令牌（token）</code>，与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。</p><p>“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</p><h2 id="四、运行流程"><a href="#四、运行流程" class="headerlink" title="四、运行流程"></a>四、运行流程</h2><p>OAuth 2.0的运行流程如下图，摘自RFC 6749。</p><p><img src="https://img-blog.csdnimg.cn/20200606220240314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs armasm">（A）用户打开客户端以后，客户端要求用户给予授权。（<span class="hljs-keyword">B）用户同意给予客户端授权。</span><span class="hljs-keyword"></span><span class="hljs-keyword">（C）客户端使用上一步获得的授权，向认证服务器申请令牌。</span><span class="hljs-keyword"></span><span class="hljs-keyword">（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</span><span class="hljs-keyword"></span><span class="hljs-keyword">（E）客户端使用令牌，向资源服务器申请获取资源。</span><span class="hljs-keyword"></span><span class="hljs-keyword">（F）资源服务器确认令牌无误，同意向客户端开放资源。</span></code></pre></div><p>不难看出来，上面六个步骤之中，B是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。</p><p>下面一一讲解客户端获取授权的四种模式。</p><h2 id="五、客户端的授权模式"><a href="#五、客户端的授权模式" class="headerlink" title="五、客户端的授权模式"></a>五、客户端的授权模式</h2><p>客户端必须得到用户的<code>授权（authorization grant）</code>，才能获得<code>令牌（access token）</code>。OAuth 2.0定义了四种授权方式。</p><ul><li><code>授权码模式</code>（authorization code）</li><li><code>简化模式</code>（implicit）</li><li><code>密码模式</code>（resource owner password credentials）</li><li><code>客户端模式</code>（client credentials）</li></ul><h2 id="六、授权码模式"><a href="#六、授权码模式" class="headerlink" title="六、授权码模式"></a>六、授权码模式</h2><p>授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。</p><p><img src="https://img-blog.csdnimg.cn/20200606220355162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>它的步骤如下：</p><div class="hljs"><pre><code class="hljs livecodeserver">（A）用户访问客户端，后者将前者导向认证服务器。（B）用户选择是否给予客户端授权。（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的<span class="hljs-string">"重定向URI"</span>（redirection URI），同时附上一个授权码。（D）客户端收到授权码，附上早先的<span class="hljs-string">"重定向URI"</span>，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access <span class="hljs-keyword">token</span>）和更新令牌（refresh <span class="hljs-keyword">token</span>）。</code></pre></div><p>下面是上面这些步骤所需要的参数。</p><p>A步骤中，客户端申请认证的URI，包含以下参数：</p><ul><li><code>response_type</code>：<strong>表示授权类型</strong>，必选项，此处的值固定为”<code>code</code>“</li><li><code>client_id</code>：<strong>表示客户端的ID</strong>，必选项</li><li><code>redirect_uri</code>：<strong>表示重定向URI</strong>，可选项</li><li><code>scope</code>：<strong>表示申请的权限范围</strong>，可选项</li><li><code>state</code>：<strong>表示客户端的当前状态</strong>，可以指定任意值，认证服务器会原封不动地返回这个值。</li></ul><p>下面是一个例子。</p><div class="hljs"><pre><code class="hljs html">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1Host: server.example.com</code></pre></div><p>C步骤中，服务器回应客户端的URI，包含以下参数：</p><ul><li><code>code</code>：<strong>表示授权码</strong>，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。<strong>该码与客户端ID和重定向URI，是一一对应关系</strong>。</li><li><code>state</code>：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li></ul><p>下面是一个例子。</p><div class="hljs"><pre><code class="hljs html">HTTP/1.1 302 FoundLocation: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA&amp;state=xyz</code></pre></div><p>D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：</p><ul><li><code>grant_type</code>：<strong>表示使用的授权模式</strong>，必选项，此处的值固定为”authorization_code”。</li><li><code>code</code>：<strong>表示上一步获得的授权码</strong>，必选项。</li><li><code>redirect_uri</code>：<strong>表示重定向URI</strong>，必选项，且必须与A步骤中的该参数值保持一致。</li><li><code>client_id</code>：<strong>表示客户端ID</strong>，必选项。</li></ul><p>下面是一个例子。</p><div class="hljs"><pre><code class="hljs html">POST /token HTTP/1.1Host: server.example.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</code></pre></div><p>E步骤中，认证服务器发送的HTTP回复，包含以下参数：</p><ul><li><code>access_token</code>：<strong>表示访问令牌</strong>，必选项。</li><li><code>token_type</code>：<strong>表示令牌类型</strong>，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li><li><code>expires_in</code>：<strong>表示过期时间</strong>，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li><code>refresh_token</code>：<strong>表示更新令牌</strong>，用来获取下一次的访问令牌，可选项。</li><li><code>scope</code>：<strong>表示权限范围</strong>，如果与客户端申请的范围一致，此项可省略。</li></ul><p>下面是一个例子。</p><div class="hljs"><pre><code class="hljs html">HTTP/1.1 200 OKContent-Type: application/json;charset=UTF-8Cache-Control: no-storePragma: no-cache&#123;  "access_token":"2YotnFZFEjr1zCsicMWpAA",  "token_type":"example",  "expires_in":3600,  "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",  "example_parameter":"example_value"&#125;</code></pre></div><p>从上面代码可以看到，相关参数使用<code>JSON</code>格式发送（Content-Type: application/json）。此外，HTTP头信息中明确指定不得缓存。</p><h2 id="七、简化模式"><a href="#七、简化模式" class="headerlink" title="七、简化模式"></a>七、简化模式</h2><p>简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。</p><p><img src="https://img-blog.csdnimg.cn/20200606220559505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>它的步骤如下：</p><div class="hljs"><pre><code class="hljs mathematica">（A）客户端将用户导向认证服务器。（B）用户决定是否给于客户端授权。（C）假设用户给予授权，认证服务器将用户导向客户端指定的<span class="hljs-string">"重定向URI"</span>，并在URI的<span class="hljs-keyword">Hash</span>部分包含了访问令牌。（D）浏览器向资源服务器发出请求，其中不包括上一步收到的<span class="hljs-keyword">Hash</span>值。（E）资源服务器返回一个网页，其中包含的代码可以获取<span class="hljs-keyword">Hash</span>值中的令牌。（F）浏览器执行上一步获得的脚本，提取出令牌。（G）浏览器将令牌发给客户端。</code></pre></div><p>下面是上面这些步骤所需要的参数。</p><p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p><ul><li><code>response_type</code>：<strong>表示授权类型</strong>，此处的值固定为”<code>token</code>“，必选项。</li><li><code>client_id</code>：<strong>表示客户端的ID</strong>，必选项。</li><li><code>redirect_uri</code>：<strong>表示重定向的URI</strong>，可选项。</li><li><code>scope</code>：<strong>表示权限范围</strong>，可选项。</li><li><code>state</code>：<strong>表示客户端的当前状态</strong>，可以指定任意值，认证服务器会原封不动地返回这个值。</li></ul><p>下面是一个例子。</p><div class="hljs"><pre><code class="hljs html">GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz    &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1Host: server.example.com</code></pre></div><p>C步骤中，认证服务器回应客户端的URI，包含以下参数：</p><ul><li><code>access_token</code>：<strong>表示访问令牌</strong>，必选项。</li><li><code>token_type</code>：<strong>表示令牌类型</strong>，该值大小写不敏感，必选项。</li><li><code>expires_in</code>：<strong>表示过期时间</strong>，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li><code>scope</code>：<strong>表示权限范围</strong>，如果与客户端申请的范围一致，此项可省略。</li><li><code>state</code>：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li></ul><p>下面是一个例子。</p><div class="hljs"><pre><code class="hljs html"> HTTP/1.1 302 FoundLocation: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA          &amp;state=xyz&amp;token_type=example&amp;expires_in=3600</code></pre></div><p>在上面的例子中，认证服务器用HTTP头信息的Location栏，指定浏览器重定向的网址。注意，在这个网址的Hash部分包含了令牌。</p><p>根据上面的D步骤，下一步浏览器会访问Location指定的网址，但是Hash部分不会发送。接下来的E步骤，服务提供商的资源服务器发送过来的代码，会提取出Hash中的令牌。</p><h2 id="八、密码模式"><a href="#八、密码模式" class="headerlink" title="八、密码模式"></a>八、密码模式</h2><p>密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。</p><p>在这种模式中，<strong>用户必须把自己的密码给客户端，但是客户端不得储存密码</strong>。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p><p><img src="https://img-blog.csdnimg.cn/20200606220702610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>它的步骤如下：</p><div class="hljs"><pre><code class="hljs armasm">（A）用户向客户端提供用户名和密码。（<span class="hljs-keyword">B）客户端将用户名和密码发给认证服务器，向后者请求令牌。</span><span class="hljs-keyword"></span><span class="hljs-keyword">（C）认证服务器确认无误后，向客户端提供访问令牌。</span></code></pre></div><p>B步骤中，客户端发出的HTTP请求，包含以下参数：</p><ul><li><code>grant_type</code>：<strong>表示授权类型</strong>，此处的值固定为”<code>password</code>“，必选项。</li><li><code>username</code>：<strong>表示用户名</strong>，必选项。</li><li><code>password</code>：<strong>表示用户的密码</strong>，必选项。</li><li><code>scope</code>：<strong>表示权限范围</strong>，可选项。</li></ul><p>下面是一个例子。</p><div class="hljs"><pre><code class="hljs html">POST /token HTTP/1.1Host: server.example.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=password&amp;username=johndoe&amp;password=A3ddj3w</code></pre></div><p>C步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p><div class="hljs"><pre><code class="hljs html">HTTP/1.1 200 OKContent-Type: application/json;charset=UTF-8Cache-Control: no-storePragma: no-cache&#123;  "access_token":"2YotnFZFEjr1zCsicMWpAA",  "token_type":"example",  "expires_in":3600,  "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",  "example_parameter":"example_value"&#125;</code></pre></div><p>上面代码中，各个参数的含义参见《授权码模式》一节。整个过程中，客户端不得保存用户的密码。</p><h2 id="九、客户端模式"><a href="#九、客户端模式" class="headerlink" title="九、客户端模式"></a>九、客户端模式</h2><p>客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。</p><p><img src="https://img-blog.csdnimg.cn/20200606220806373.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>它的步骤如下：</p><div class="hljs"><pre><code class="hljs dns">（<span class="hljs-keyword">A</span>）客户端向认证服务器进行身份认证，并要求一个访问令牌。（B）认证服务器确认无误后，向客户端提供访问令牌。</code></pre></div><p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p><ul><li><code>granttype</code>：<strong>表示授权类型</strong>，此处的值固定为”<code>clientcredentials</code>“，必选项。</li><li><code>scope</code>：<strong>表示权限范围</strong>，可选项。</li></ul><div class="hljs"><pre><code class="hljs html">POST /token HTTP/1.1Host: server.example.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=client_credentials</code></pre></div><p>认证服务器必须以某种方式，验证客户端身份。</p><p>B步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p><div class="hljs"><pre><code class="hljs html"> HTTP/1.1 200 OKContent-Type: application/json;charset=UTF-8Cache-Control: no-storePragma: no-cache&#123;  "access_token":"2YotnFZFEjr1zCsicMWpAA",  "token_type":"example",  "expires_in":3600,  "example_parameter":"example_value"&#125;</code></pre></div><p>上面代码中，各个参数的含义参见《授权码模式》一节。</p><h2 id="十、更新令牌"><a href="#十、更新令牌" class="headerlink" title="十、更新令牌"></a>十、更新令牌</h2><p>如果用户访问的时候，客户端的”访问令牌”已经过期，则需要使用”更新令牌”申请一个新的访问令牌。</p><p>客户端发出更新令牌的HTTP请求，包含以下参数：</p><ul><li><code>granttype</code>：表示使用的授权模式，此处的值固定为”refreshtoken”，必选项。</li><li><code>refresh_token</code>：表示早前收到的更新令牌，必选项。</li><li><code>scope</code>：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。</li></ul><p>下面是一个例子。</p><div class="hljs"><pre><code class="hljs html">POST /token HTTP/1.1Host: server.example.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>安全框架</category>
      
      <category>OAuth2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OAuth2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11. Redis--一致性Hash算法</title>
    <link href="/2020/06/06/11-Redis-%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95/"/>
    <url>/2020/06/06/11-Redis-%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Redis集群的使用"><a href="#一、Redis集群的使用" class="headerlink" title="一、Redis集群的使用"></a>一、Redis集群的使用</h1><p>我们在使用Redis的时候，为了保证Redis的高可用，提高Redis的读写性能，最简单的方式我们会做主从复制，组成Master-Master或者Master-Slave的形式，或者搭建Redis集群，进行数据的读写分离，类似于数据库的主从复制和读写分离。如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20200606181116231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>同样类似于数据库，当单表数据大于500W的时候需要对其进行分库分表，当数据量很大的时候（标准可能不一样，要看Redis服务器容量）我们同样可以对Redis进行类似的操作，就是分库分表。 </p><p>假设，我们有一个社交网站，需要使用Redis存储图片资源，存储的格式为键值对，key值为图片名称，value为该图片所在文件服务器的路径，我们需要根据文件名查找该文件所在文件服务器上的路径，数据量大概有2000W左右，按照我们约定的规则进行分库，规则就是随机分配，我们可以部署8台缓存服务器，每台服务器大概含有500W条数据，并且进行主从复制，示意图如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606181138961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>由于规则是随机的，所有我们的一条数据都有可能存储在任何一组Redis中，例如上图我们用户查找一张名称为”a.png”的图片，由于规则是随机的，我们不确定具体是在哪一个Redis服务器上的，因此我们需要进行1、2、3、4，4次查询才能够查询到（也就是遍历了所有的Redis服务器），这显然不是我们想要的结果，有了解过的小伙伴可能会想到，随机的规则不行，可以使用类似于数据库中的分库分表规则：按照Hash值、取模、按照类别、按照某一个字段值等等常见的规则就可以出来了！好，按照我们的主题，我们就使用Hash的方式。</p><h1 id="二、为Redis集群使用Hash"><a href="#二、为Redis集群使用Hash" class="headerlink" title="二、为Redis集群使用Hash"></a>二、为Redis集群使用Hash</h1><p><img src="https://img-blog.csdnimg.cn/20200606181214521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>上图中，假设我们查找的是”a.png”，由于有4台服务器（排除从库），因此公式为hash(a.png) % 4 = 2 ，可知定位到了第2号服务器，这样的话就不会遍历所有的服务器，大大提升了性能！</p><h1 id="三、使用Hash的问题"><a href="#三、使用Hash的问题" class="headerlink" title="三、使用Hash的问题"></a>三、使用Hash的问题</h1><p>上述的方式虽然提升了性能，我们不再需要对整个Redis服务器进行遍历！但是，使用上述Hash算法进行缓存时，会出现一些缺陷，主要体现在服务器数量变动的时候，所有缓存的位置都要发生改变！</p><p>试想一下，如果4台缓存服务器已经不能满足我们的缓存需求，那么我们应该怎么做呢？很简单，多增加几台缓存服务器不就行了！假设：我们增加了一台缓存服务器，那么缓存服务器的数量就由4台变成了5台。那么原本hash(a.png) % 4 = 2 的公式就变成了hash(a.png) % 5 = ？ ， 可想而知这个结果肯定不是2的，这种情况带来的结果就是当服务器数量变动时，所有缓存的位置都要发生改变！换句话说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端数据库请求数据（还记得上一篇的《缓存雪崩》吗？）！</p><p>同样的，假设4台缓存中突然有一台缓存服务器出现了故障，无法进行缓存，那么我们则需要将故障机器移除，但是如果移除了一台缓存服务器，那么缓存服务器数量从4台变为3台，也是会出现上述的问题！</p><p>所以，我们应该想办法不让这种情况发生，但是由于上述Hash算法本身的缘故，使用取模法进行缓存时，这种情况是无法避免的，为了解决这些问题，Hash一致性算法（一致性Hash算法）诞生了！</p><h1 id="四、一致性Hash算法的神秘面纱"><a href="#四、一致性Hash算法的神秘面纱" class="headerlink" title="四、一致性Hash算法的神秘面纱"></a>四、一致性Hash算法的神秘面纱</h1><p>一致性Hash算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性Hash算法是对2的32次方取模，什么意思呢？简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2的32次方-1（即哈希值是一个32位无符号整形），整个哈希环如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606181226458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2的32次方-1，也就是说0点左侧的第一个点代表2的32次方-1， 0和2的32次方-1在零点中方向重合，我们把这个由2的32次方个点组成的圆环称为Hash环。</p><p>下一步将各个服务器使用Hash进行一个哈希，具体可以选择<strong>服务器的IP或主机名</strong>作为<strong>关键字</strong>进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606181241661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！</p><p>例如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606181254463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>根据一致性Hash算法，数据A会被定位到Node A上，B被定位到Node B上，C被定位到Node C上，D被定位到Node D上。</p><h1 id="五、一致性Hash算法的容错性和可扩展性"><a href="#五、一致性Hash算法的容错性和可扩展性" class="headerlink" title="五、一致性Hash算法的容错性和可扩展性"></a>五、一致性Hash算法的容错性和可扩展性</h1><p>现假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。<strong>一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响</strong>，如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20200606181306101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>下面考虑另外一种情况，如果在系统中增加一台服务器Node X，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200606181318529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X ！一般的，在一致性Hash算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。</p><p>综上所述，一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</p><h1 id="六、Hash环的数据倾斜问题"><a href="#六、Hash环的数据倾斜问题" class="headerlink" title="六、Hash环的数据倾斜问题"></a>六、Hash环的数据倾斜问题</h1><p>一致性Hash算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器，其环分布如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606181330666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器IP或主机名的后面增加编号来实现。</p><p>例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：</p><p><img src="https://img-blog.csdnimg.cn/20200606181342261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p><h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><p>上文中，我们一步步分析了什么是一致性Hash算法，主要是考虑到分布式系统每个节点都有可能失效，并且新的节点很可能动态的增加进来的情况，如何保证当系统的节点数目发生变化的时候，我们的系统仍然能够对外提供良好的服务，这是值得考虑的！</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0. Redis--引导</title>
    <link href="/2020/06/06/0-Redis-%E5%BC%95%E5%AF%BC/"/>
    <url>/2020/06/06/0-Redis-%E5%BC%95%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Redis简介"><a href="#一、Redis简介" class="headerlink" title="一、Redis简介"></a>一、Redis简介</h1><p>Redis是一个开源的<strong>内存中</strong>的数据结构存储系统，它可以用作：<strong>数据库</strong>、<strong>缓存</strong>和<strong>消息中间件</strong>。</p><p>它支持多种类型的数据结构，如字符串（String），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）与范围查询，Bitmaps，Hyperloglogs 和地理空间（Geospatial）索引半径查询。其中常见的数据结构类型有：<strong>String</strong>、<strong>List</strong>、<strong>Set</strong>、<strong>Hash</strong>、<strong>ZSet</strong>这5种。</p><p>Redis 内置了复制（Replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（Transactions） 和不同级别的磁盘持久化（Persistence），并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（High Availability）。</p><p>Redis也提供了持久化的选项，这些选项可以让用户将自己的数据保存到磁盘上面进行存储。根据实际情况，可以每隔一定时间将数据集导出到磁盘（快照），或者追加到命令日志中（AOF只追加文件），他会在执行写命令时，将被执行的写命令复制到硬盘里面。您也可以关闭持久化功能，将Redis作为一个高效的网络的缓存数据功能使用。</p><p>Redis不使用表，他的数据库不会预定义或者强制去要求用户对Redis存储的不同数据进行关联。</p><p>数据库的工作模式按存储方式可分为：硬盘数据库和内存数据库。Redis 将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度极快。</p><h1 id="二、Redis和其他缓存数据库的区别"><a href="#二、Redis和其他缓存数据库的区别" class="headerlink" title="二、Redis和其他缓存数据库的区别"></a>二、Redis和其他缓存数据库的区别</h1><h2 id="1-1-Redis-与其他-key-value-缓存产品相比有以下三个特点："><a href="#1-1-Redis-与其他-key-value-缓存产品相比有以下三个特点：" class="headerlink" title="1.1 Redis 与其他 key - value 缓存产品相比有以下三个特点："></a>1.1 Redis 与其他 key - value 缓存产品相比有以下三个特点：</h2><p>（1）Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</p><p>（2）Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</p><p>（3）Redis支持数据的备份，即master-slave模式的数据备份。</p><h2 id="1-2-Redis和Memcached的区别"><a href="#1-2-Redis和Memcached的区别" class="headerlink" title="1.2 Redis和Memcached的区别"></a>1.2 Redis和Memcached的区别</h2><p>Redis常被拿来和高性能键值缓存服务器Memcached进行对比：这两者都可以用来存储键值对，彼此的性能也相差无几，但是Redis相对支持更多的数据类型，除了支持键值对之外，还支持list，set，zset，hash等数据结构的存储，而Memcached只能存储普通的字符串键。</p><p>Memcached用户只能通过APPEND的方式将数据添加到已有的字符串的末尾，并将这个字符串当做列表来使用。但是在删除这些元素的时候，Memcached采用的是通过黑名单的方式来隐藏列表里的元素，从而避免了对元素的读取、更新、删除等操作。相反的Redis的List和Set允许用户直接添加和删除元素。</p><h2 id="1-3-Redis和其他数据库的区别"><a href="#1-3-Redis和其他数据库的区别" class="headerlink" title="1.3 Redis和其他数据库的区别"></a>1.3 Redis和其他数据库的区别</h2><p><img src="https://img-blog.csdnimg.cn/20200606171008448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="三、Redis为什么这么快"><a href="#三、Redis为什么这么快" class="headerlink" title="三、Redis为什么这么快"></a>三、Redis为什么这么快</h1><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p><p>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p><p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p><p>4、使用多路I/O复用模型，非阻塞IO；</p><p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p><p>以上几点都比较好理解，下边我们针对多路 I/O 复用模型进行简单的探讨：</p><p>（1）多路 I/O 复用模型</p><p>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p><p><strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong>采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p><h1 id="四、为什么Redis是单线程的"><a href="#四、为什么Redis是单线程的" class="headerlink" title="四、为什么Redis是单线程的"></a>四、为什么Redis是单线程的</h1><p>我们首先要明白，上边的种种分析，都是为了营造一个Redis很快的氛围！官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。</p><p>但是，我们使用单线程的方式是无法发挥多核CPU 性能，不过我们可以通过在单机开多个Redis 实例来完善！</p><p><strong>警告</strong>：这里我们一直在强调的单线程，只是在处理我们的网络请求的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！</p><h1 id="五、扩展"><a href="#五、扩展" class="headerlink" title="五、扩展"></a>五、扩展</h1><p>以下也是你应该知道的几种模型：</p><p>1、单进程多线程模型：MySQL、Memcached、Oracle（Windows版本）；</p><p>2、多进程模型：Oracle（Linux版本）；</p><p>3、Nginx有两类进程，一类称为Master进程(相当于管理进程)，另一类称为Worker进程（实际工作进程）。启动方式有两种：</p><p>（1）单进程启动：此时系统中仅有一个进程，该进程既充当Master进程的角色，也充当Worker进程的角色。</p><p>（2）多进程启动：此时系统有且仅有一个Master进程，至少有一个Worker进程工作。</p><p>（3）Master进程主要进行一些全局性的初始化工作和管理Worker的工作；事件处理是在Worker中进行的。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10. Redis--如何优化缓存架构</title>
    <link href="/2020/06/06/10-Redis-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84/"/>
    <url>/2020/06/06/10-Redis-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="一、为什么要用缓存集群"><a href="#一、为什么要用缓存集群" class="headerlink" title="一、为什么要用缓存集群"></a>一、为什么要用缓存集群</h1><p>啥叫热 Key 和大 Value 呢?简单来说，热 Key，就是你的缓存集群中的某个 Key 瞬间被数万甚至十万的并发请求打爆。</p><p>大 Value，就是你的某个 Key 对应的 Value 可能有 GB 级的大小，导致查询 Value 的时候出现网络相关的故障问题。</p><p>先来看看下面的一幅图：</p><p><img src="https://img-blog.csdnimg.cn/20200606162958479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>简单来说，假设你手头有个系统，他本身是集群部署的，然后后面有一套缓存集群，这个集群不管你用 Redis Cluster，还是Memcached，或者是公司自研缓存集群，都可以。</p><p>那么，这套系统用缓存集群干什么呢?很简单，在缓存里放一些平时不怎么变动的数据，然后用户在查询大量的平时不怎么变动的数据的时候，不就可以直接从缓存里走了吗?</p><p>缓存集群的并发能力是很强的，而且读缓存的性能是很高的。举个例子，假设你每秒有 2 万请求，但是其中 90% 都是读请求，那么每秒 1.8 万请求都是在读一些不太变化的数据，而不是写数据。</p><p>那此时你把数据都放在数据库里，然后每秒发送 2 万请求到数据库上读写数据，你觉得合适吗?</p><p>当然不太合适了，如果你要用数据库承载每秒 2 万请求的话，那么不好意思，你很可能就得搞分库分表 + 读写分离。</p><p>比如你得分 3 个主库，承载每秒 2000 的写入请求，然后每个主库挂 3 个从库，一共 9 个从库承载每秒 1.8 万的读请求。</p><p>这样的话，你可能就需要一共是 12 台高配置的数据库服务器，这是很耗费钱的，成本非常高，而且很不合适。</p><p>所以，此时你完全就可以把平时不太变化的数据放在缓存集群里，缓存集群可以采用 2 主 2 从，<strong>主节点用来写入缓存</strong>，<strong>从节点用来读缓存。</strong></p><p>以缓存集群的性能，2 个从节点完全可以用来承载每秒 1.8 万的大量读了，然后 3 个数据库主库就是承载每秒 2000 的写请求和少量其他读请求就可以了。</p><p>大家看看下面的图，你耗费的机器瞬间变成了 4 台缓存机器 + 3 台数据库机器 = 7 台机器，是不是比之前的 12 台机器减少了很大的资源开销?</p><p>没错，缓存其实在系统架构里是非常重要的组成部分。很多时候，对于那些很少变化但是大量高并发读的数据，通过<strong>缓存集群</strong>来抗高并发读，是非常合适的。</p><p><img src="https://img-blog.csdnimg.cn/20200606163024316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>这里所有的机器数量、并发请求量都是一个示例，大家主要是体会一下这个意思就好，其目的主要是给一些不太熟悉缓存相关技术的同学一点背景性的阐述，让这些同学能够理解在系统里用缓存集群承载读请求是什么意思。</p><h1 id="二、20-万用户同时访问一个热点缓存的问题"><a href="#二、20-万用户同时访问一个热点缓存的问题" class="headerlink" title="二、20 万用户同时访问一个热点缓存的问题"></a>二、20 万用户同时访问一个热点缓存的问题</h1><p>好了，背景是已经给大家解释清楚了，那么现在就可以给大家说说今天重点要讨论的问题：热点缓存。</p><p>我们来做一个假设，你现在有 10 个缓存节点来扛大量的读请求。正常情况下，读请求应该是均匀的落在 10 个缓存节点上的，对吧!</p><p>这 10 个缓存节点，每秒承载 1 万请求是差不多的。然后我们再做一个假设，你一个节点承载 2 万请求是极限，所以一般你就限制一个节点正常承载 1 万请求就 OK 了，稍微留一点 Buffer 出来。</p><p>好，所谓的热点缓存问题是什么意思呢?很简单，就是突然因为莫名的原因，出现大量的用户访问同一条缓存数据。</p><p>举个例子，某个明星突然宣布跟某某结婚，这个时候是不是会引发可能短时间内每秒都是数十万的用户去查看这个明星跟某某结婚的那条新闻?</p><p>那么假设那条新闻就是一个缓存，然后对应就是一个缓存 Key，就存在一台缓存机器上，此时瞬时假设有 20 万请求奔向那一台机器上的一个 Key。</p><p>此时会如何?我们看看下面的图，来体会一下这种绝望的感受：</p><p><img src="https://img-blog.csdnimg.cn/20200606163209327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>这个时候很明显了，我们刚才假设的是一个缓存 Slave 节点最多每秒就是 2 万的请求，当然实际缓存单机承载 5 万~10 万读请求也是可能的，我们这里就是一个假设。</p><p>结果此时，每秒突然奔过来 20 万请求到这台机器上，会怎么样?很简单，上面图里那台被 20 万请求指向的缓存机器会过度操劳而宕机的。</p><p>那么如果缓存集群开始出现机器的宕机，此时会如何?接着，读请求发现读不到数据，会从数据库里提取原始数据，然后放入剩余的其他缓存机器里去。</p><p>但是接踵而来的每秒 20 万请求，会再次压垮其他的缓存机器。以此类推，最终导致缓存集群全盘崩溃，引发系统整体宕机。</p><p>咱们看看下面的图，再感受一下这个恐怖的现场：</p><p><img src="https://img-blog.csdnimg.cn/20200606163226832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="三、基于流式计算技术的缓存热点自动发现"><a href="#三、基于流式计算技术的缓存热点自动发现" class="headerlink" title="三、基于流式计算技术的缓存热点自动发现"></a>三、基于流式计算技术的缓存热点自动发现</h1><p>其实这里关键的一点，就是对于这种热点缓存，你的系统需要能够在热点缓存突然发生的时候，直接发现他，然后瞬间立马实现毫秒级的<strong>自动负载均衡</strong>。</p><p>那么我们就先来说说，你如何自动发现热点缓存问题?首先你要知道，一般出现缓存热点的时候，你的每秒并发肯定是很高的，可能每秒都几十万甚至上百万的请求量过来，这都是有可能的。</p><p>所以，此时完全可以基于大数据领域的流式计算技术来进行实时数据访问次数的统计，比如 Storm、Spark Streaming、Flink，这些技术都是可以的。</p><p>然后一旦在实时数据访问次数统计的过程中，比如发现一秒之内，某条数据突然访问次数超过了 1000，就直接立马把这条数据判定为是热点数据，可以将这个发现出来的热点数据写入比如 Zookeeper 中。</p><p>当然，你的系统如何判定热点数据，可以根据自己的业务还有经验值来就可以了。</p><p>大家看看下面这张图，看看整个流程是如何进行的：</p><p><img src="https://img-blog.csdnimg.cn/20200606163237932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>当然肯定有人会问，那你的流式计算系统在进行数据访问次数统计的时候，会不会也存在说单台机器被请求每秒几十万次的问题呢?</p><p>答案是否，因为流式计算技术，尤其是 Storm 这种系统，他可以做到同一条数据的请求过来，先分散在很多机器里进行本地计算，最后再汇总局部计算结果到一台机器进行全局汇总。</p><p>所以几十万请求可以先分散在比如 100 台机器上，每台机器统计了这条数据的几千次请求。</p><p>然后 100 条局部计算好的结果汇总到一台机器做全局计算即可，所以基于流式计算技术来进行统计是不会有热点问题的。</p><p><img src="https://img-blog.csdnimg.cn/2020060616325139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="四、热点缓存自动加载为-JVM-本地缓存"><a href="#四、热点缓存自动加载为-JVM-本地缓存" class="headerlink" title="四、热点缓存自动加载为 JVM 本地缓存"></a>四、热点缓存自动加载为 JVM 本地缓存</h1><p>我们自己的系统可以对 Zookeeper 指定的热点缓存对应的 Znode 进行监听，如果有变化他立马就可以感知到了。</p><p>此时系统层就可以立马把相关的缓存数据从数据库加载出来，然后直接放在自己系统内部的本地缓存里即可。</p><p>这个本地缓存，你用 Ehcache、Hashmap，其实都可以，一切都看自己的业务需求，主要说的就是将缓存集群里的集中式缓存，直接变成每个系统自己本地实现缓存即可，每个系统自己本地是无法缓存过多数据的。</p><p>因为一般这种普通系统单实例部署机器可能就一个 4 核 8G 的机器，留给本地缓存的空间是很少的，所以用来放这种热点数据的本地缓存是最合适的，刚刚好。</p><p>假设你的系统层集群部署了 100 台机器，那么好了，此时你 100 台机器瞬间在本地都会有一份热点缓存的副本。</p><p>然后接下来对热点缓存的读操作，直接系统本地缓存读出来就给返回了，不用再走缓存集群了。</p><p>这样的话，也不可能允许每秒 20 万的读请求到达缓存机器的一台机器上读一个热点缓存了，而是变成 100 台机器每台机器承载数千请求，那么那数千请求就直接从机器本地缓存返回数据了，这是没有问题的。</p><p>我们再来画一幅图，一起来看看这个过程：</p><p><img src="https://img-blog.csdnimg.cn/20200606163305719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="五、限流熔断保护"><a href="#五、限流熔断保护" class="headerlink" title="五、限流熔断保护"></a>五、限流熔断保护</h1><p>除此之外，在每个系统内部，还应该专门加一个对热点数据访问的限流熔断保护措施。</p><p>每个系统实例内部，都可以加一个熔断保护机制，假设缓存集群最多每秒承载4万读请求，那么你一共有 100 个系统实例。</p><p>你自己就该限制好，每个系统实例每秒最多请求缓存集群读操作不超过 400 次，一超过就可以熔断掉，不让请求缓存集群，直接返回一个空白信息，然后用户稍后会自行再次重新刷新页面之类的。</p><p>通过系统层自己直接加限流熔断保护措施，可以很好的保护后面的缓存集群、数据库集群之类的不要被打死，我们来看看下面的图：</p><p><img src="https://img-blog.csdnimg.cn/20200606163320488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9. Redis--Redis缓存问题</title>
    <link href="/2020/06/06/9-Redis-Redis%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/"/>
    <url>/2020/06/06/9-Redis-Redis%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><blockquote><p>咳咳，这一节内容应该早就放上博客的，一直忘记了，在写上一篇<a href="https://www.jitwxs.cn/dc21b1d2.html" target="_blank" rel="noopener">《详解布隆过滤器》</a>时，谈到缓存问题，一看博客中竟然没有写过相关的，实在是不该，特此补上。</p></blockquote><p>Redis 所存在的缓存问题也是大部分缓存所存在的问题，因此本文不单单特指于 Redis。这些问题包括<strong>缓存穿透、缓存雪崩、缓存击穿、缓存预热</strong>等等，相关文章网络上已经数不胜数了，说实话本文和它们没啥不同之处，只是为了记录，所以对于了解过的人基本就是废话了，谨慎阅读哦。</p><h2 id="二、缓存穿透"><a href="#二、缓存穿透" class="headerlink" title="二、缓存穿透"></a>二、缓存穿透</h2><p><strong>问题描述：</strong></p><p><code>缓存穿透</code>是指<strong>查询一个一定不存在的数据</strong>，这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p><p><strong>解决方案：</strong></p><p>有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用<code>布隆过滤器</code>，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被 这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</p><p>另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。</p><p><img src="https://img-blog.csdnimg.cn/20200606160601704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="三、缓存雪崩"><a href="#三、缓存雪崩" class="headerlink" title="三、缓存雪崩"></a>三、缓存雪崩</h2><p><strong>问题描述：</strong></p><p><code>缓存雪崩</code>是指在我们<strong>设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效</strong>，请求全部转发到DB，DB瞬时压力过重雪崩。</p><p>缓存正常从Redis中获取，示意图如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606164835761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>缓存失效瞬间示意图如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606164842618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>解决方案：</strong></p><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者<strong>考虑用加锁或者队列的方式保证缓存的单线程（进程）写</strong>，从而避免失效时大量的并发请求落到底层存储系统上。</p><p>还可以将缓存失效时间分散开，比如我们可以<strong>在原有的失效时间基础上增加一个随机值</strong>，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><h2 id="四、缓存击穿"><a href="#四、缓存击穿" class="headerlink" title="四、缓存击穿"></a>四、缓存击穿</h2><p><strong>问题描述：</strong></p><p>对于一些设置了过期时间的 key，如果这些 key 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个<strong>和缓存雪崩的区别在于这里针对某一 key 缓存，而缓存雪崩则是很多 key</strong>。</p><p>缓存在某个时间点过期的时候，恰好在这个时间点对这个 key 有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮。</p><p><strong>解决方案：</strong></p><p>业界比较常用的做法，是使用互斥锁(mutex)。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去 load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的 <code>SETNX</code> 或者 Memcache 的 ADD）去 set 一个 mutex key，当操作返回成功时，再进行 load db 的操作并回设缓存；否则，就重试整个 get 缓存的方法。</p><h2 id="五、缓存预热"><a href="#五、缓存预热" class="headerlink" title="五、缓存预热"></a>五、缓存预热</h2><p><strong>问题描述：</strong></p><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p><p><strong>解决方案：</strong></p><ol><li>直接写个缓存刷新页面，上线时手工操作下；</li><li>数据量不大，可以在项目启动的时候自动进行加载；</li><li>定时刷新缓存；</li></ol><h2 id="六、缓存更新"><a href="#六、缓存更新" class="headerlink" title="六、缓存更新"></a>六、缓存更新</h2><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p><p>（1）定时去清理过期的缓存；</p><p>（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</p><p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p><h2 id="七、缓存降级"><a href="#七、缓存降级" class="headerlink" title="七、缓存降级"></a>七、缓存降级</h2><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p><p><strong>降级的最终目的是保证核心服务可用</strong>，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。 </p><p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p><p>（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p><p>（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p><p>（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</p><p>（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8. Redis--Redis的实际应用</title>
    <link href="/2020/06/06/8-Redis-Redis%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
    <url>/2020/06/06/8-Redis-Redis%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>在<a href="https://www.jitwxs.cn/5108d6b6.html" target="_blank" rel="noopener">《Redis初探（7）——Jedis操纵集群》</a>中，我们已经学会了搭建 Redis 集群，以及使用策略模式，在xml文件中灵活切换单机版和集群版。</p><p>本章将演示在宜立方商城项目中使用 Redis，项目地址：<a href="https://github.com/jitwxs/e3mall" target="_blank" rel="noopener">e3mall</a>。</p><h2 id="一、功能需求"><a href="#一、功能需求" class="headerlink" title="一、功能需求"></a>一、功能需求</h2><p>商城首页访问量巨大，因为首页的大轮播图是从数据库查询获取的，<strong>每次访问都要查询一次数据库</strong>，数据库压力巨大，亟需缓存。</p><p><img src="https://img-blog.csdnimg.cn/20200606160145616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="二、功能实现"><a href="#二、功能实现" class="headerlink" title="二、功能实现"></a>二、功能实现</h2><p>实现之前首先思考 Redis 是要加在 Service 层还是 Web 层。理论上来说都可以，但是加在 Web 层的话，其他 Web 去调用 Service 还是得去查数据库，因此我们加在 Service 层。</p><p>其次思考使用什么数据类型，我们使用<strong>哈希类型</strong>，field 为类别的 id，value 为对应查询的查询内容。</p><h3 id="2-1-配置文件-cfg-properties"><a href="#2-1-配置文件-cfg-properties" class="headerlink" title="2.1 配置文件 cfg.properties"></a>2.1 配置文件 cfg.properties</h3><p>首先在配置文件中加入 Redis 相关的信息，最后一项 <code>redis.CONTENT_KEY</code> 为我们首页轮播图缓存的 key 值：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-comment">#Redis单机</span><span class="hljs-attr">redis.standalone.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.standalone.port</span>=<span class="hljs-number">6379</span><span class="hljs-comment">#Redis集群</span><span class="hljs-attr">redis.cluster.01.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.01.port</span>=<span class="hljs-number">7001</span><span class="hljs-attr">redis.cluster.02.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.02.port</span>=<span class="hljs-number">7002</span><span class="hljs-attr">redis.cluster.03.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.03.port</span>=<span class="hljs-number">7003</span><span class="hljs-attr">redis.cluster.04.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.04.port</span>=<span class="hljs-number">7004</span><span class="hljs-attr">redis.cluster.05.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.05.port</span>=<span class="hljs-number">7005</span><span class="hljs-attr">redis.cluster.06.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.06.port</span>=<span class="hljs-number">7006</span><span class="hljs-comment">#Redis key相关</span><span class="hljs-comment">#用于存放tb_content表的缓存（哈希类型）</span><span class="hljs-attr">redis.CONTENT_KEY</span>=CONTENT_KEY</code></pre></div><h3 id="2-2-Spring-中-Redis-配置"><a href="#2-2-Spring-中-Redis-配置" class="headerlink" title="2.2 Spring 中 Redis 配置"></a>2.2 Spring 中 Redis 配置</h3><p>这里的代码在上一节已经说过了，因为我们是开发环境，使用单机版即可。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context</span></span><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 注意：单机和集群同时只能放开一个 --&gt;</span>    <span class="hljs-comment">&lt;!-- 加载配置文件 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:cfg.properties"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 配置Redis单机 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jedisClientPool"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"jit.wxs.common.jedis.JedisClientPool"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"jedisPool"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"jedisPool"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jedisPool"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.JedisPool"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.standalone.host&#125;"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.standalone.port&#125;"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置Redis集群 --&gt;</span>    <span class="hljs-comment">&lt;!--&lt;bean id="jedisClientCluster" class="jit.wxs.common.jedis.JedisClientCluster"&gt;--&gt;</span>        <span class="hljs-comment">&lt;!--&lt;property name="jedisCluster" ref="jedisCluster"/&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--&lt;bean id="jedisCluster" class="redis.clients.jedis.JedisCluster"&gt;--&gt;</span>        <span class="hljs-comment">&lt;!--&lt;constructor-arg&gt;--&gt;</span>            <span class="hljs-comment">&lt;!--&lt;set&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;bean class="redis.clients.jedis.HostAndPort"&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="host" value="$&#123;redis.cluster.01.host&#125;"/&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="port" value="$&#123;redis.cluster.01.port&#125;"/&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;bean class="redis.clients.jedis.HostAndPort"&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="host" value="$&#123;redis.cluster.02.host&#125;"/&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="port" value="$&#123;redis.cluster.02.port&#125;"/&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;bean class="redis.clients.jedis.HostAndPort"&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="host" value="$&#123;redis.cluster.03.host&#125;"/&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="port" value="$&#123;redis.cluster.03.port&#125;"/&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;bean class="redis.clients.jedis.HostAndPort"&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="host" value="$&#123;redis.cluster.04.host&#125;"/&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="port" value="$&#123;redis.cluster.04.port&#125;"/&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;bean class="redis.clients.jedis.HostAndPort"&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="host" value="$&#123;redis.cluster.05.host&#125;"/&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="port" value="$&#123;redis.cluster.05.port&#125;"/&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;bean class="redis.clients.jedis.HostAndPort"&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="host" value="$&#123;redis.cluster.06.host&#125;"/&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="port" value="$&#123;redis.cluster.06.port&#125;"/&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span>            <span class="hljs-comment">&lt;!--&lt;/set&gt;--&gt;</span>        <span class="hljs-comment">&lt;!--&lt;/constructor-arg&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><h3 id="2-3-Service-层代码"><a href="#2-3-Service-层代码" class="headerlink" title="2.3 Service 层代码"></a>2.3 Service 层代码</h3><p>首先我们注入了 <code>JedisClient</code>，然后从配置文件取到了 key 的名字 <code>CONTENT_KEY</code>。</p><p>在 <code>listByCategoryId()</code> 方法中，我们先查询 Redis 中是否有存在的 field，如果有，直接返回；如果没有，先查询数据库，然后存入缓存。</p><p>为了<strong>保证缓存的同步</strong>，在添加和删除方法中，我直接删除掉了相应 field 的缓存，这样当执行查询方法时，会重新保存缓存。</p><p>需要注意的是，<strong>Redis 的正常/异常与否，不应当影响程序的正常运行</strong>。因为即使没有 Redis 程序也是可以正常运行的，因此我们在 Redis 操作的地方，需要 <code>try-catch</code>，在 catch 中可以打印日志信息等操作，我这里只是简单的输出在控制台。</p><blockquote><p>注：JedisClient 接口和其单机/集群实现类代码省略，需要请看上一节。</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TbContentServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceImpl</span>&lt;<span class="hljs-title">TbContentMapper</span>, <span class="hljs-title">TbContent</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">TbContentService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> TbContentMapper contentMapper;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> JedisClient jedisClient;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;redis.CONTENT_KEY&#125;"</span>)    <span class="hljs-keyword">private</span> String CONTENT_KEY;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除CONTENT_KEY中指定field</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteContentKeyFromRedis</span><span class="hljs-params">(Long cid)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            jedisClient.hdel(CONTENT_KEY, cid + <span class="hljs-string">""</span>);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;TbContent&gt; <span class="hljs-title">listByCategoryId</span><span class="hljs-params">(Long cid)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 如果缓存存在的话，直接从缓存中取</span>            String json = jedisClient.hget(CONTENT_KEY, cid + <span class="hljs-string">""</span>);            <span class="hljs-keyword">if</span>(StringUtils.isNotBlank(json)) &#123;                <span class="hljs-keyword">return</span> JsonUtils.jsonToList(json, TbContent<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        List&lt;TbContent&gt; contents = contentMapper.selectList(<span class="hljs-keyword">new</span> EntityWrapper&lt;TbContent&gt;() .eq(<span class="hljs-string">"category_id"</span>, cid));        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 加入缓存</span>            jedisClient.hset(CONTENT_KEY, cid+<span class="hljs-string">""</span>, JsonUtils.objectToJson(contents));        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> contents;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addContent</span><span class="hljs-params">(TbContent tbContent)</span> </span>&#123;        <span class="hljs-comment">// 更新缓存</span>        deleteContentKeyFromRedis(tbContent.getCategoryId());        tbContent.setCreated(<span class="hljs-keyword">new</span> Date());        tbContent.setUpdated(<span class="hljs-keyword">new</span> Date());                contentMapper.insert(tbContent);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteById</span><span class="hljs-params">(Long id)</span> </span>&#123;        <span class="hljs-keyword">if</span>(id == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 更新缓存</span>        TbContent tbContent = contentMapper.selectById(id);        deleteContentKeyFromRedis(tbContent.getCategoryId());        contentMapper.deleteById(id);    &#125;&#125;</code></pre></div><h3 id="2-4-Web-层代码"><a href="#2-4-Web-层代码" class="headerlink" title="2.4 Web 层代码"></a>2.4 Web 层代码</h3><p>我们设首页轮播图的 id 为 <code>ad1Id</code>，直接调用 <code>tbContentService.listByCategoryId(ad1Id)</code> 即可。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageController</span> </span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;ad1.id&#125;"</span>)    <span class="hljs-keyword">private</span> Long ad1Id;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> TbContentService tbContentService;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/index"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">showIndex</span><span class="hljs-params">(Model model)</span> </span>&#123;        <span class="hljs-comment">// 得到首页大轮播图的List</span>        List&lt;TbContent&gt; ad1List = tbContentService.listByCategoryId(ad1Id);        model.addAttribute(<span class="hljs-string">"ad1List"</span>, ad1List);        <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;    &#125;&#125;</code></pre></div><h2 id="三、验证"><a href="#三、验证" class="headerlink" title="三、验证"></a>三、验证</h2><p>服务器启动单机版 Redis，当我们刷新首页的时候，就会将缓存保存到了 Redis 中。</p><p>Key 为 <code>CONTENT_KEY</code>，field 目前只有一个，即首页轮播图，其值为89，value 为转换为 json 的数据：</p><p><img src="https://img-blog.csdnimg.cn/2020060616020848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>当我在后台为首页添加一个轮播图后，该 Field 被删除掉了（这里之所以连 key 也被删掉了，是因为该 key 中只有一个field，因此唯一的 field 被删掉了，key 也就删掉了）：</p><div class="hljs"><pre><code class="hljs shell">127.0.0.1:6379&gt; keys *(empty list or set)</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200606160231372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>重新刷新首页，正确显示三张：</p><p><img src="https://img-blog.csdnimg.cn/2020060616025755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>再次查看 Redis：</p><p><img src="https://img-blog.csdnimg.cn/20200606160316730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7. Redis--Redis操纵集群</title>
    <link href="/2020/06/06/7-Redis-Redis%E6%93%8D%E7%BA%B5%E9%9B%86%E7%BE%A4/"/>
    <url>/2020/06/06/7-Redis-Redis%E6%93%8D%E7%BA%B5%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<p>在<a href="https://www.jitwxs.cn/baef2507.html" target="_blank" rel="noopener">《Redis 初探（2）——Jedis 的使用》</a>中，我们已经学会了Jedis操纵单机Redis的简单使用，本章将继续深入，介绍Jedis对集群的操纵。</p><h2 id="一、Jedis-连接单机"><a href="#一、Jedis-连接单机" class="headerlink" title="一、Jedis 连接单机"></a>一、Jedis 连接单机</h2><p>在开始介绍 Jedis 连接集群之前，先简单回顾下连接单机的使用。</p><h3 id="1-1-简单使用"><a href="#1-1-简单使用" class="headerlink" title="1.1 简单使用"></a>1.1 简单使用</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJedis</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 1.获得连接对象。参数为redis所在的服务器地址及端口号</span>    Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">6379</span>);    <span class="hljs-comment">// 2.获得数据</span>    String age = jedis.get(<span class="hljs-string">"age"</span>);    System.out.println(age);    jedis.close();&#125;</code></pre></div><h3 id="1-2-使用连接池"><a href="#1-2-使用连接池" class="headerlink" title="1.2 使用连接池"></a>1.2 使用连接池</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJedisPool</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//1. 创建Jedis连接池配置（包含许多配置，这里只配置了3个）</span>    JedisPoolConfig poolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();    <span class="hljs-comment">// 设置最小和最大闲置个数</span>    poolConfig.setMinIdle(<span class="hljs-number">5</span>);    poolConfig.setMaxIdle(<span class="hljs-number">10</span>);    <span class="hljs-comment">// 设置连接池最大个数</span>    poolConfig.setMaxTotal(<span class="hljs-number">30</span>);    <span class="hljs-comment">//2. 创建Jedis连接池</span>    JedisPool pool = <span class="hljs-keyword">new</span> JedisPool(poolConfig,<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">6379</span>);    <span class="hljs-comment">//3. 从连接池中获取Jedis对象</span>    Jedis jedis = pool.getResource();    <span class="hljs-comment">//4.操纵数据</span>    jedis.set(<span class="hljs-string">"sex"</span>, <span class="hljs-string">"male"</span>);    System.out.println(jedis.get(<span class="hljs-string">"sex"</span>));    <span class="hljs-comment">//5.关闭资源</span>    jedis.close();    pool.close();&#125;</code></pre></div><h2 id="二、Jedis-连接集群"><a href="#二、Jedis-连接集群" class="headerlink" title="二、Jedis 连接集群"></a>二、Jedis 连接集群</h2><p>Jedis 连接集群也是十分简单，首先创建一个 <code>HostAndPort</code> 的集合，里面存放着集群中的每一个节点，然后创建 <code>JedisCluster</code> 对象，直接操纵该对象即可。</p><p><code>JedisCluster</code> 在项目中<strong>单例存在</strong>即可。第三步的关闭可省略（因为单例存在，如果关掉了，即整个项目要结束了）。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJedisCluster</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">// 1.创建一个JedisCluster对象。第一个参数nodes是一个set类型，set中包含若干个HostAndPort对象</span>    Set&lt;HostAndPort&gt; nodes = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    nodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">7001</span>));    nodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">7002</span>));    nodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">7003</span>));    nodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">7004</span>));    nodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">7005</span>));    nodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">7006</span>));    JedisCluster cluster = <span class="hljs-keyword">new</span> JedisCluster(nodes);    <span class="hljs-comment">// 2.直接使用JedisCluster对象操作redis，单例存在即可。</span>    cluster.set(<span class="hljs-string">"test"</span>, <span class="hljs-string">"123"</span>);    System.out.println(cluster.get(<span class="hljs-string">"test"</span>));    <span class="hljs-comment">// 3.关闭JedisCluster对象。</span>    cluster.close();&#125;</code></pre></div><h2 id="三、Jedis-的实际应用"><a href="#三、Jedis-的实际应用" class="headerlink" title="三、Jedis 的实际应用"></a>三、Jedis 的实际应用</h2><p>在实际项目中，测试环境一般使用单机版，生产环境使用集群版。为了避免代码的不必要改动，我们使用<code>策略模式</code>，<code>面向接口开发</code>。</p><h3 id="3-1-JedisClient-接口"><a href="#3-1-JedisClient-接口" class="headerlink" title="3.1 JedisClient 接口"></a>3.1 JedisClient 接口</h3><p>定义一个 <code>JedisClient</code> 的接口，里面封装了常用的一些方法，主要是对 <code>String</code> 类型和 <code>Hash</code> 类型的操作，可以根据实际情况进行修改。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">JedisClient</span> </span>&#123;    <span class="hljs-function">String <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span></span>;    <span class="hljs-function">String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span></span>;    <span class="hljs-function">Boolean <span class="hljs-title">exists</span><span class="hljs-params">(String key)</span></span>;    <span class="hljs-function">Long <span class="hljs-title">expire</span><span class="hljs-params">(String key, <span class="hljs-keyword">int</span> seconds)</span></span>;    <span class="hljs-function">Long <span class="hljs-title">ttl</span><span class="hljs-params">(String key)</span></span>;    <span class="hljs-function">Long <span class="hljs-title">incr</span><span class="hljs-params">(String key)</span></span>;    <span class="hljs-function">Long <span class="hljs-title">hset</span><span class="hljs-params">(String key, String field, String value)</span></span>;    <span class="hljs-function">String <span class="hljs-title">hget</span><span class="hljs-params">(String key, String field)</span></span>;    <span class="hljs-function">Long <span class="hljs-title">hdel</span><span class="hljs-params">(String key, String... field)</span></span>;    <span class="hljs-function">Boolean <span class="hljs-title">hexists</span><span class="hljs-params">(String key, String field)</span></span>;    <span class="hljs-function">List&lt;String&gt; <span class="hljs-title">hvals</span><span class="hljs-params">(String key)</span></span>;    <span class="hljs-function">Long <span class="hljs-title">del</span><span class="hljs-params">(String key)</span></span>;&#125;</code></pre></div><h3 id="3-2-单机实现类"><a href="#3-2-单机实现类" class="headerlink" title="3.2 单机实现类"></a>3.2 单机实现类</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<span class="hljs-keyword">import</span> redis.clients.jedis.JedisPool;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisClientPool</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">JedisClient</span> </span>&#123;        <span class="hljs-keyword">private</span> JedisPool jedisPool;    <span class="hljs-function"><span class="hljs-keyword">public</span> JedisPool <span class="hljs-title">getJedisPool</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisPool;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setJedisPool</span><span class="hljs-params">(JedisPool jedisPool)</span> </span>&#123;        <span class="hljs-keyword">this</span>.jedisPool = jedisPool;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        String result = jedis.set(key, value);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        String result = jedis.get(key);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">exists</span><span class="hljs-params">(String key)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Boolean result = jedis.exists(key);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">expire</span><span class="hljs-params">(String key, <span class="hljs-keyword">int</span> seconds)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Long result = jedis.expire(key, seconds);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">ttl</span><span class="hljs-params">(String key)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Long result = jedis.ttl(key);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">incr</span><span class="hljs-params">(String key)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Long result = jedis.incr(key);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">hset</span><span class="hljs-params">(String key, String field, String value)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Long result = jedis.hset(key, field, value);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hget</span><span class="hljs-params">(String key, String field)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        String result = jedis.hget(key, field);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">hdel</span><span class="hljs-params">(String key, String... field)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Long result = jedis.hdel(key, field);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">hexists</span><span class="hljs-params">(String key, String field)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Boolean result = jedis.hexists(key, field);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">hvals</span><span class="hljs-params">(String key)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        List&lt;String&gt; result = jedis.hvals(key);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">del</span><span class="hljs-params">(String key)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Long result = jedis.del(key);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre></div><h3 id="3-3-集群实现类"><a href="#3-3-集群实现类" class="headerlink" title="3.3 集群实现类"></a>3.3 集群实现类</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> redis.clients.jedis.JedisCluster;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisClientCluster</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">JedisClient</span> </span>&#123;        <span class="hljs-keyword">private</span> JedisCluster jedisCluster;        <span class="hljs-function"><span class="hljs-keyword">public</span> JedisCluster <span class="hljs-title">getJedisCluster</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setJedisCluster</span><span class="hljs-params">(JedisCluster jedisCluster)</span> </span>&#123;        <span class="hljs-keyword">this</span>.jedisCluster = jedisCluster;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.set(key, value);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.get(key);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">exists</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.exists(key);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">expire</span><span class="hljs-params">(String key, <span class="hljs-keyword">int</span> seconds)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.expire(key, seconds);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">ttl</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.ttl(key);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">incr</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.incr(key);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">hset</span><span class="hljs-params">(String key, String field, String value)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.hset(key, field, value);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hget</span><span class="hljs-params">(String key, String field)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.hget(key, field);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">hdel</span><span class="hljs-params">(String key, String... field)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.hdel(key, field);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">hexists</span><span class="hljs-params">(String key, String field)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.hexists(key, field);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">hvals</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.hvals(key);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">del</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.del(key);    &#125;&#125;</code></pre></div><h3 id="3-4-实战演示"><a href="#3-4-实战演示" class="headerlink" title="3.4 实战演示"></a>3.4 实战演示</h3><p>（1）首先准备一个配置文件 <code>cfg.properties</code>，在配置文件中加入关于 redis 的信息：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-comment"># redis单机</span><span class="hljs-attr">redis.standalone.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.standalone.port</span>=<span class="hljs-number">6379</span><span class="hljs-comment">#redis集群</span><span class="hljs-attr">redis.cluster.01.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.01.port</span>=<span class="hljs-number">7001</span><span class="hljs-attr">redis.cluster.02.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.02.port</span>=<span class="hljs-number">7002</span><span class="hljs-attr">redis.cluster.03.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.03.port</span>=<span class="hljs-number">7003</span><span class="hljs-attr">redis.cluster.04.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.04.port</span>=<span class="hljs-number">7004</span><span class="hljs-attr">redis.cluster.05.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.05.port</span>=<span class="hljs-number">7005</span><span class="hljs-attr">redis.cluster.06.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.06.port</span>=<span class="hljs-number">7006</span></code></pre></div><p>（2）准备 Spring 关于 redis 的配置文件 <code>applicationContext-redis.xml</code>：</p><p>需要注意的是，单机和集群同时<strong>只能放开一个，另一个必须注释掉</strong>。因为我们取Bean是取接口，即 <code>JedisClient</code>，这两个都是 <code>JedisClient</code> 的实现类。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="hljs-tag"><span class="hljs-string">    http://www.springframework.org/schema/context</span></span><span class="hljs-tag"><span class="hljs-string">    http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 注意：单机和集群同时只能放开一个 --&gt;</span>    <span class="hljs-comment">&lt;!-- 加载配置文件 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:cfg.properties"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 配置Redis单机 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jedisClientPool"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"jit.wxs.common.jedis.JedisClientPool"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"jedisPool"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"jedisPool"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jedisPool"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.JedisPool"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.standalone.host&#125;"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.standalone.port&#125;"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置Redis集群 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jedisClientCluster"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"jit.wxs.common.jedis.JedisClientCluster"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"jedisCluster"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"jedisCluster"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jedisCluster"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.JedisCluster"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.HostAndPort"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.01.host&#125;"</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.01.port&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.HostAndPort"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.02.host&#125;"</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.02.port&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.HostAndPort"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.03.host&#125;"</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.03.port&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.HostAndPort"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.04.host&#125;"</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.04.port&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.HostAndPort"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.05.host&#125;"</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.05.port&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.HostAndPort"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.06.host&#125;"</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.06.port&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>（3）编写测试方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    ApplicationContext ac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:applicationContext-redis.xml"</span>);    JedisClient jedisClient = ac.getBean(JedisClient<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    jedisClient.set(<span class="hljs-string">"author"</span>, <span class="hljs-string">"jitwxs"</span>);    String result = jedisClient.get(<span class="hljs-string">"author"</span>);    System.out.println(result);&#125;</code></pre></div><p>因为我们是面向接口开发，因此当我们切换单机和集群时，这段代码不需要任何修改，只需要修改配置文件即可。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6. Redis--Redis集群</title>
    <link href="/2020/06/06/6-Redis-Redis%E9%9B%86%E7%BE%A4/"/>
    <url>/2020/06/06/6-Redis-Redis%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<p>之前我们所学习的都是 Redis 的单机版，我们知道 Redis 之所以读取速度快是因为它是<strong>存储在内存</strong>中的。内存的容量是有限的，单台 Redis 会碰到性能瓶颈，这就需要使用 <code>Redis集群（Redis-cluster）</code>。</p><h2 id="一、集群原理"><a href="#一、集群原理" class="headerlink" title="一、集群原理"></a>一、集群原理</h2><h3 id="1-1-集群架构"><a href="#1-1-集群架构" class="headerlink" title="1.1 集群架构"></a>1.1 集群架构</h3><p><img src="https://img-blog.csdnimg.cn/20200606125039833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>如上图所示，每一个蓝色圆圈就是一个 Redis 节点，这些节点组成了一个 <code>Redis集群（Redis-cluster）</code>。节点之间使用 <code>Ping——Pong</code> 机制进行互联，其内部用二进制协议优化传输速度和带宽。</p><p>Redis客户端和节点<strong>直接连接</strong>即可，无需中间件，一台客户端连接一个节点即可，Client 访问时直接访问任意一个Redis节点即可。</p><h3 id="1-2-负载均衡"><a href="#1-2-负载均衡" class="headerlink" title="1.2 负载均衡"></a>1.2 负载均衡</h3><p>当我们搭建了集群后，其是如何实现负载均衡的呢？</p><p>Redis 集群中内置了 <strong>16384</strong> 个<code>哈希槽（slot）</code>，它会把所有的物理节点都映射到<strong>[0,16383]</strong>的slot上。</p><p>当我们需要在Redis集群中放置一个 key-value 时，Redis 先对 key 使用 <code>crc16</code> 算法得出一个结果，然后将结果<strong>对16384取余</strong>，这样<strong>每一个 key 都会对应一个编号在0 ~16383的 哈希槽</strong>。</p><p>Redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。例如我们有三个节点，其每个节点哈希槽范围为：0 ~ 5000，5001 ~ 10000，10001~ 16383。</p><p><img src="https://img-blog.csdnimg.cn/20200606130442462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>当我们存储一个名为 Hello1 的 key 时，其通过 <code>crc16</code> 算法计算出的结果为1500，Redis 集群就会将这个 key 放在对应1500的<code>哈希槽</code>中，又因为哈希槽0~ 5000被映射到了 Server1，则 Hello1 就被放置在了 Server1。</p><p><img src="https://img-blog.csdnimg.cn/2020060613054833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="1-3-容错机制"><a href="#1-3-容错机制" class="headerlink" title="1.3 容错机制"></a>1.3 容错机制</h3><p>通过上面的负载均衡的原理，知道其实<strong>每一台</strong> Redis 客户端保存的<strong>内容都是不一样</strong>的，那么当Redis集群中<strong>任意一个节点挂掉</strong>（连接失败）时，<strong>整个集群就挂了</strong>。</p><p>为了实现 Redis 的高可用，需要<strong>为每一个节点添加备用机</strong>，即<code>主备机制</code>。</p><p>一般集群都有集群管理工具，但是 Redis 集群没有，它是通过<code>投票机制</code>来实现的。</p><p>以下图为例简单说一下投票机制：</p><ol><li>当黄色节点发现无法 ping 通红色节点，它就觉得红色节点可能挂掉了，于是它会<strong>发起投票</strong>。</li><li>其他节点会尝试去 ping 红色节点，只要有<strong>超过半数</strong>的节点无法 ping 通红色节点，就<strong>判定红色节点挂掉</strong>（即使它实际上可能并没有挂掉）。</li><li>当红色节点被判定挂掉后，会<strong>启动该节点的备用机</strong>。如果该节点不存在备用机，或备用机也挂掉，那么<strong>整个Redis集群就挂掉了</strong>。</li></ol><p><img src="https://www.jitwxs.cn/images/posts/20180408222553762.png" srcset="/img/loading.gif" alt="img"></p><h2 id="二、搭建集群"><a href="#二、搭建集群" class="headerlink" title="二、搭建集群"></a>二、搭建集群</h2><blockquote><p>说明：在实际项目中，搭建集群都是搞运维的负责的，如果是专门的研发人员，其实可以不用知道如何搭建集群。</p></blockquote><p>Redis 集群为了实现容错机制，<strong>最少需要三个节点</strong>（一个出错，另外两个投票），又因为<strong>每个节点至少要有一台备份机</strong>，因此一个<strong>最简单的 Redis 集群需要6个 Redis 客户端</strong>。</p><p>这里只是演示一下，使用<code>伪集群</code>，即6台 Redis 搭建在一台 Linux 上，仅使用端口号进行区分，设端口号范围为7001 ~ 7006。</p><h3 id="2-1-准备原始-Redis"><a href="#2-1-准备原始-Redis" class="headerlink" title="2.1 准备原始 Redis"></a>2.1 准备原始 Redis</h3><blockquote><p>注：<a href="https://www.jitwxs.cn/e331e26a.html" target="_blank" rel="noopener">《Redis 初探（1）——Redis 的安装》</a>这篇文章中源码和安装后的文件是在同一文件夹下，本篇文章不使用这种方法。</p></blockquote><p>准备一个 Redis 安装包，将源码解压到当前文件夹：</p><div class="hljs"><pre><code class="hljs shell">wxs@ubuntu:~$ lsDesktop  redis-4.0.8.tar.gzwxs@ubuntu:~$ tar zxvf redis-4.0.8.tar.gz</code></pre></div><p>进入解压后文件夹，执行 make 编译：</p><div class="hljs"><pre><code class="hljs shell">wxs@ubuntu:~$ cd redis-4.0.8/wxs@ubuntu:~/redis-4.0.8$ make</code></pre></div><blockquote><p>注：所有源码安装需要自行编译的都需要 gcc、g++ 等相关软件支持</p></blockquote><p>将其安装到<code>/usr/local/redis</code>目录下：</p><div class="hljs"><pre><code class="hljs shell">wxs@ubuntu:~/redis-4.0.8$ sudo make install PREFIX=/usr/local/redis</code></pre></div><p>该目录下只有一个 bin 目录，存放 redis 的可执行文件，我们从源码包中拷贝一份 redis 配置文件过来：</p><div class="hljs"><pre><code class="hljs shell">wxs@ubuntu:/usr/local/redis$ lsbinwxs@ubuntu:/usr/local/redis$ sudo cp ~/redis-4.0.8/redis.conf .wxs@ubuntu:/usr/local/redis$ lsbin  redis.conf</code></pre></div><p>编辑该配置文件：</p><p>（1）修改 bind 端口号为 <code>0.0.0.0</code>，使其支持远程访问。</p><p><img src="https://img-blog.csdnimg.cn/20200606135013850.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>（2）开启后端模式。</p><p><img src="https://img-blog.csdnimg.cn/20200606135225299.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>（3）设置日志文件位置</p><p><img src="https://img-blog.csdnimg.cn/20200606135249116.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>（4）开启 AOF 持久化</p><p><img src="https://img-blog.csdnimg.cn/20200606135308180.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="2-2-准备-Redis-集群客户端"><a href="#2-2-准备-Redis-集群客户端" class="headerlink" title="2.2 准备 Redis 集群客户端"></a>2.2 准备 Redis 集群客户端</h3><p><strong>注意：</strong>用来做集群的客户端<strong>必须是干净的客户端</strong>，像备份文件 <code>dump.rdb</code>、<code>appendonly.aof</code> 等应当先删除掉，避免不必要的错误。</p><p>在 <code>/usr/local</code> 中创建 <code>redis-cluster</code> 文件夹，拷贝六份原始 Redis：</p><div class="hljs"><pre><code class="hljs shell">wxs@ubuntu:/usr/local/redis-cluster$ sudo cp -r ../redis redis01wxs@ubuntu:/usr/local/redis-cluster$ sudo cp -r ../redis redis02wxs@ubuntu:/usr/local/redis-cluster$ sudo cp -r ../redis redis03wxs@ubuntu:/usr/local/redis-cluster$ sudo cp -r ../redis redis04wxs@ubuntu:/usr/local/redis-cluster$ sudo cp -r ../redis redis05wxs@ubuntu:/usr/local/redis-cluster$ sudo cp -r ../redis redis06wxs@ubuntu:/usr/local/redis-cluster$ lsredis01  redis02  redis03  redis04  redis05  redis06</code></pre></div><p>以 redis01 为例，编辑其 <code>redis.conf</code> 文件：</p><p>（1）修改端口号为 7001</p><p><img src="https://img-blog.csdnimg.cn/20200606135324484.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>（2）修改 pidfile</p><p><img src="https://img-blog.csdnimg.cn/20200606135353518.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>（3）开启集群开关</p><p><img src="https://img-blog.csdnimg.cn/20200606135404621.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>依次修改其他客户端，端口号范围从7001 ~ 7006。</p><p>编写一个启动这些客户端的批处理 <code>startup.sh</code>：</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> redis01/binsudo ./redis-server ../redis.conf<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis02/binsudo ./redis-server ../redis.conf<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis03/binsudo ./redis-server ../redis.conf<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis04/binsudo ./redis-server ../redis.conf<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis05/binsudo ./redis-server ../redis.conf<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis06/binsudo ./redis-server ../redis.conf<span class="hljs-built_in">cd</span> ../../</code></pre></div><p>执行脚本，启动成功：</p><p><img src="https://img-blog.csdnimg.cn/20200606135422369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>编写一个关闭这些客户端的批处理 <code>shutdown.sh</code>：</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> redis01/binsudo ./redis-cli -p 7001 shutdown<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis02/binsudo ./redis-cli -p 7002 shutdown<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis03/binsudo ./redis-cli -p 7003 shutdown<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis04/binsudo ./redis-cli -p 7004 shutdown<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis05/binsudo ./redis-cli -p 7005 shutdown<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis06/binsudo ./redis-cli -p 7006 shutdown<span class="hljs-built_in">cd</span> ../../</code></pre></div><p>执行脚本，关闭成功：</p><p><img src="https://img-blog.csdnimg.cn/20200606135446595.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>目录结构如下：</p><div class="hljs"><pre><code class="hljs shell">wxs@ubuntu:/usr/local/redis-cluster$ lsredis01  redis02  redis03  redis04  redis05  redis06  shutdown.sh  startup.sh</code></pre></div><h3 id="2-3-搭建集群"><a href="#2-3-搭建集群" class="headerlink" title="2.3 搭建集群"></a>2.3 搭建集群</h3><p>从 redis 源码的 src 目录中拷贝 <code>redis-trib.rb</code> 过来：</p><div class="hljs"><pre><code class="hljs shell">wxs@ubuntu:/usr/local/redis-cluster$ sudo cp ~/redis-4.0.8/src/redis-trib.rb .wxs@ubuntu:/usr/local/redis-cluster$ lsredis01  redis03  redis05  redis-trib.rb  startup.shredis02  redis04  redis06  shutdown.sh</code></pre></div><p>因为这是一个 <code>shell</code> 文件，需要安装 shell 和 shell 包管理器：</p><div class="hljs"><pre><code class="hljs shell">wxs@ubuntu:/usr/local/redis-cluster$ sudo apt-get install shell shellgems</code></pre></div><p>安装 shell 关于 Redis 的库,可以执行 <code>gem install redis</code> 或者<a href="https://shellgems.org/gems/redis/versions/" target="_blank" rel="noopener">前往官网</a>下载安装包后安装。</p><div class="hljs"><pre><code class="hljs shell">wxs@ubuntu:/usr/local/redis-cluster$ sudo gem install redisFetching: redis-4.0.1.gem (100%)Successfully installed redis-4.0.1Parsing documentation for redis-4.0.1Installing ri documentation for redis-4.0.1Done installing documentation for redis after 0 seconds1 gem installed</code></pre></div><p>执行 <code>redis-trib.rb</code> 时需要附带参数，格式如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606135501801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>先启动所有客户端，然后执行脚本：</p><div class="hljs"><pre><code class="hljs shell">wxs@ubuntu:/usr/local/redis-cluster$ ./startup.sh wxs@ubuntu:/usr/local/redis-cluster$ ./redis-trib.rb create --replicas 1 192.168.30.155:7001 192.168.30.155:7002 192.168.30.155:7003 192.168.30.155:7004 192.168.30.155:7005  192.168.30.155:7006</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200606135527930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>创建成功：</p><p><img src="https://img-blog.csdnimg.cn/20200606135550905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>最后说两句：</p><ol><li>如果你不是伪集群，真的在服务器上搭建了集群，即 <code>真集群</code>，那么只需要在任意一台上执行 <code>redis-trib.rb</code> 即可。</li><li>在真集群的情况下，除了在配置文件中要 <code>bind 0.0.0.0</code> 以外，还要注意关闭防火墙，不然无法搭建。</li><li>如果关闭所有 redis 客户端后，想要重新开启集群，在客户端都启动后，进入任意客户端执行<code>cluster nodes</code>即可。</li><li>如果想要重新生成集群，需要删除每个 Redis 中生成的持久化文件。</li></ol><h2 id="三、使用-redis-cli-连接集群"><a href="#三、使用-redis-cli-连接集群" class="headerlink" title="三、使用 redis-cli 连接集群"></a>三、使用 redis-cli 连接集群</h2><p>使用任意一个 <code>redis-cli</code>（以redis01的为例），使用 <code>-h</code> 指定ip地址（默认连接127.0.0.1），使用 <code>-p</code> 参数指定端口号（默认连接原始的端口为6379的 redis），使用 <code>-c</code> 参数指定是集群（不加会导致无法将 key 放入对应的客户端中）。</p><div class="hljs"><pre><code class="hljs shell">wxs@ubuntu:/usr/local/redis-cluster$ ./redis01/bin/redis-cli -h 192.168.30.155 -p 7001 -c</code></pre></div><p>当我在7001中添加了一个 <code>name jitwxs</code> 后，它计算出 key 的哈希槽为5798，这个范围在7002中，因此这个 key 被移动到了7002中，并且当前连接重定向到了7002。</p><p><img src="https://img-blog.csdnimg.cn/20200606135606467.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs shell">192.168.30.155:7002&gt; keys *1) "name"192.168.30.155:7001&gt; keys *(empty list or set)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5. Redis--Redis的持久化</title>
    <link href="/2020/06/06/5-Redis-Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/2020/06/06/5-Redis-Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>Redis 的高性能是由其将所有数据都存储在了内存中，需要使用时直接从内存调用即可。为了使 Redis 在重启之后仍然能保证数据不丢失，需要将数据从内存同步到数据库中，这一过程就是<code>持久化</code>。</p><p>Redis 支持两种持久化方式，一种是 <code>RDB方式</code>，一种是 <code>AOF方式</code>。可以单独使用其中一种或将两种结合使用。</p><ul><li>RDB (默认) 在<strong>指定的时间间隔</strong>内将内存中的数据快照写入磁盘。</li><li>AOF 以<strong>日志</strong>的形式记录服务器处理的<strong>每一个写操作</strong>，在Redis服务器启动之初会读取该文件来重新构建数据库，以保证启动后数据库中的数据是完整的。</li></ul><h2 id="一、RDB"><a href="#一、RDB" class="headerlink" title="一、RDB"></a>一、RDB</h2><h3 id="1-1-实现步骤"><a href="#1-1-实现步骤" class="headerlink" title="1.1 实现步骤"></a>1.1 实现步骤</h3><ol><li>Redis 执行 <code>fork</code> 命令创建子进程。</li><li>父进程继续处理 client 请求，子进程负责将内存内容写入到临时文件。由于 OS 的写时复制机制父子进程会共享相同的物理页面，当父进程处理写请求时OS会为父进程要修改的页面创建副本，而不是写共享的页面。所以子进程的地址空间内的数据是 fork 时刻整个数据库的一个<strong>快照</strong>。</li><li>当子进程将快照写入临时文件完毕后，用临时文件替换原来的快照文件，然后子进程退出。</li></ol><p>需要注意的是，每次 RDB 都是将<strong>内存数据完整写入到磁盘一次</strong>，并<strong>不是在原有数据的基础上增加数据</strong>。如果数据量大的话，而且写操作比较多，必然会引起大量的磁盘IO操作，可能会严重影响性能。</p><h3 id="1-2-优势"><a href="#1-2-优势" class="headerlink" title="1.2 优势"></a>1.2 优势</h3><ol><li>一旦采用该方式，那么你的整个 Redis 数据库将<strong>只包含一个文件</strong>，这样非常<strong>方便备份</strong>。</li><li>方便移植，我们可以很容易的将一个一个 RDB 文件移动到其他的存储介质上。</li><li>RDB 在恢复大数据集时的速度比 AOF 的<strong>恢复速度要快</strong>。</li><li>RDB 可以<strong>最大化 Redis 的性能</strong>（父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 IO 操作）。</li></ol><h3 id="1-3-劣势"><a href="#1-3-劣势" class="headerlink" title="1.3 劣势"></a>1.3 劣势</h3><ol><li>如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么 RDB 将不是一个很好的选择。 因为系统一旦在定时持久化之前发生宕机， 你就可能会<strong>丢失这之间的数据</strong>。</li><li>因为 RDB 是通过 fork 子进程来协助完成持久化工作的，因此当数据集较大时，会<strong>影响服务器性能</strong>。</li></ol><h3 id="1-4-RDB-配置"><a href="#1-4-RDB-配置" class="headerlink" title="1.4 RDB 配置"></a>1.4 RDB 配置</h3><p>在 <code>redis.conf</code> 中可以配置和RDF相关的信息：</p><p>(1) 配置 RDB 文件位置</p><p><img src="https://img-blog.csdnimg.cn/20200606122136837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>(2) 配置 RDB 保存时机</p><p><img src="https://img-blog.csdnimg.cn/20200606122206950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="二、AOF"><a href="#二、AOF" class="headerlink" title="二、AOF"></a>二、AOF</h2><p>采用 AOF 方式，Redis 会将每一个收到的写命令都通过 <code>write</code> 函数写入到 AOF 文件中。当 Redis 重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。</p><p>AOF 的方式也同时带来了另一个问题：<strong>持久化文件会变的越来越大</strong>。例如我们调用 <code>incr num</code> 命令100次，文件中必须保存全部的100条命令，其实有99条都是多余的，因为要恢复数据库的状态其实文件中保存一条 <code>set num 100</code> 就够了。</p><h3 id="2-1-实现步骤"><a href="#2-1-实现步骤" class="headerlink" title="2.1 实现步骤"></a>2.1 实现步骤</h3><ol><li>Redis调用<code>fork</code>命令创建子进程。</li><li>子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令。</li><li>父进程继续处理client请求，除了把写命令写入到原来的AOF文件中，同时缓存新收到的写命令。</li><li>子进程把快照内容写入到临时文件后，子进程发信号通知父进程，然后父进程把缓存的写命令也写入到临时文件。</li><li>父进程使用临时文件替换老的AOF文件，并重命名，后面收到的写命令也开始往新的AOF文件中追加。</li></ol><p>需要注意的是，重写AOF文件的操作并没有读取旧的AOF文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的AOF文件，这点和快照有点类似。</p><h3 id="2-2-优势"><a href="#2-2-优势" class="headerlink" title="2.2 优势"></a>2.2 优势</h3><ol><li>AOF 提供的三种同步策略，使得数据安全性更高。</li><li>因为 AOF 对日志文件的写入操作采用的是<code>append 模式</code>，因此在写入过程中即使出现宕机现象，也不会破坏日志文件已经存在的内容。</li><li>如果 AOF 日志文件过大，Redis可以自动启用 <code>rewrite 机制</code>，使 Redis 以 append 模式不断的将修改数据写入到老的磁盘文件中，同时 Redis 还会创建一个新的文件用于记录此期间有哪些命令被执行。因此在进行 rewrite 切换时可以更好的保证数据安全性。</li></ol><h3 id="2-3-劣势"><a href="#2-3-劣势" class="headerlink" title="2.3 劣势"></a>2.3 劣势</h3><ol><li>对于相同数量的数据集而言，AOF 文件通常要大于 RDB 文件。</li><li>根据同步策略的不同，AOF 在运行效率上往往会慢于 RDB。</li></ol><h3 id="2-4-AOF-配置"><a href="#2-4-AOF-配置" class="headerlink" title="2.4 AOF 配置"></a>2.4 AOF 配置</h3><p>AOF 默认是关闭的，修改配置文件 <code>redis.conf</code> 来打开 AOF：</p><p><img src="https://img-blog.csdnimg.cn/20200606122949195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>AOF 具有三种同步策略，在配置文件 <code>redis.conf</code> 中进行配置：</p><p><img src="https://img-blog.csdnimg.cn/20200606123020516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>除了满足同步策略来自动同步外，可以手动同步，执行命令 <code>bgrewriteaof</code> 即可。</p><p>下面演示下 AOF 恢复：</p><div class="hljs"><pre><code class="hljs elixir">wxs<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:/usr/local/redis/src</span><span class="hljs-variable">$ </span>./redis-cli <span class="hljs-number">127.0</span>.0.<span class="hljs-number">1:6379</span>&gt; keys *(empty list <span class="hljs-keyword">or</span> set)<span class="hljs-number">127.0</span>.0.<span class="hljs-number">1:6379</span>&gt; set name jitwxs <span class="hljs-comment">#设置一个key</span>OK<span class="hljs-number">127.0</span>.0.<span class="hljs-number">1:6379</span>&gt; flushdb <span class="hljs-comment">#清空数据库</span>OK<span class="hljs-number">127.0</span>.0.<span class="hljs-number">1:6379</span>&gt; exitwxs<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:/usr/local/redis/src</span><span class="hljs-variable">$ </span>ps auxc | grep rediswxs        <span class="hljs-number">5974</span>  0.<span class="hljs-number">1</span>  0.<span class="hljs-number">4</span>  <span class="hljs-number">51828</span>  <span class="hljs-number">8368</span> ?        Ssl  <span class="hljs-number">21:23</span>   0<span class="hljs-symbol">:</span>00 redis-serverwxs<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:/usr/local/redis/src</span><span class="hljs-variable">$ </span>kill <span class="hljs-number">5974</span> <span class="hljs-comment">#停止服务</span>wxs<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:/usr/local/redis/src</span><span class="hljs-variable">$ </span>vim ../redis_dbfile/appendonly.aof <span class="hljs-comment">#修改AOF文件并删除掉最后一行的flushdb命令</span>wxs<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:/usr/local/redis/src</span><span class="hljs-variable">$ </span>./redis-server ../redis.conf <span class="hljs-comment">#重新启动服务，数据被恢复</span>wxs<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:/usr/local/redis/src</span><span class="hljs-variable">$ </span>./redis-cli <span class="hljs-number">127.0</span>.0.<span class="hljs-number">1:6379</span>&gt; keys *<span class="hljs-number">1</span>) <span class="hljs-string">"name"</span></code></pre></div><blockquote><p>注：这里只是说明Redis持久化配置相关的内容，实际配置由于本人使用的是Docker容器生成的Redis，所以有些地方跟上述不一致，所以仅仅作为参考，后续会更新完善。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4. Redis--Redis的特性</title>
    <link href="/2020/06/06/4-Redis-Redis%E7%9A%84%E7%89%B9%E6%80%A7/"/>
    <url>/2020/06/06/4-Redis-Redis%E7%9A%84%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="一、多数据库"><a href="#一、多数据库" class="headerlink" title="一、多数据库"></a>一、多数据库</h2><p>每一个 Redis 实例可以包括多个数据库，客户端可以指定连接某个 Redis 实例的某个数据库。一个Redis实例最多可以提供 <strong>16</strong> 个数据库，下标从 0 到 15，客户端<strong>默认连接第 0 号数据库</strong>。</p><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>选择第 n 号数据库</td><td>select n</td></tr><tr><td>将当前库的 key 转移到第 n 号数据库</td><td>move key n</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/20200606100035439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>这里补充下之前没有提到的 Redis 服务器的一些命令：</p><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>测试连接状态是否可用</td><td>ping</td></tr><tr><td>命令行中打印内容</td><td>echo xxx</td></tr><tr><td>返回当前数据库中 key 的数目</td><td>dbsize</td></tr><tr><td>获取服务器的信息和统计</td><td>info</td></tr><tr><td>删除当前选择数据库中所有key</td><td>flushdb</td></tr><tr><td>删除所有数据库中所有key</td><td>flushall</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-symbol">wxs@</span>ubuntu:/usr/local/redis/src$ ./redis-cli<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; select <span class="hljs-number">1</span> #进入<span class="hljs-number">1</span>号数据库OK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">1</span>]&gt; ping #检查连接状态PONG<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">1</span>]&gt; dbsize #获取当前数据库key数目(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">1</span>]&gt; flushdb #清空当前数据库OK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">1</span>]&gt; keys *(empty list <span class="hljs-keyword">or</span> <span class="hljs-keyword">set</span>)<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">1</span>]&gt; flushall #清空所有数据库OK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">1</span>]&gt; select <span class="hljs-number">0</span>OK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; keys *(empty list <span class="hljs-keyword">or</span> <span class="hljs-keyword">set</span>)</code></pre></div><h2 id="二、消息订阅与发布"><a href="#二、消息订阅与发布" class="headerlink" title="二、消息订阅与发布"></a>二、消息订阅与发布</h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。Redis 客户端可以订阅<strong>任意数量</strong>的频道。</p><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>订阅频道</td><td>subscribe cctv</td></tr><tr><td>批量订阅频道</td><td>psubscribe cctv*</td></tr><tr><td>在指定频道中发送消息</td><td>publish cctv “hello”</td></tr></tbody></table><p>实现消息的订阅和发布至少需要两个终端，我们在终端1中订阅 cctv 这个频道的消息：</p><p><img src="https://img-blog.csdnimg.cn/20200606103425153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>在终端2中向 cctv 这个频道发布消息：从上面的图可以看到，推送的消息已经被订阅者收到。</p><p><img src="https://img-blog.csdnimg.cn/20200606103500275.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>我们也可以以一种正则的形式订阅多个频道，比如 cctv 下面有多个频道，例如 cctv-1、cctv-2 等等，我们只需订阅这个即可：</p><div class="hljs"><pre><code class="hljs nginx"><span class="hljs-attribute">psubscribe</span> cctv*</code></pre></div><h2 id="三、事务"><a href="#三、事务" class="headerlink" title="三、事务"></a>三、事务</h2><p>Redis 和其他数据库一样，也支持事务功能，但是 Redis 的数据库<strong>并不是一种真正的事务</strong>，它其实<strong>更像是一种批处理</strong>。</p><p>传统数据库意义上的事务，是将多条 SQL 语句作为一个整体，如果其中任何一条语句执行失败，那么这些语句都不会被执行。但是Redis的事务，<strong>如果有某一条命令执行失败，其后的命令仍然会执行</strong>。</p><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>开启事务(类似：begin transaction)</td><td>multi</td></tr><tr><td>提交事务（类似：commit）</td><td>exec</td></tr><tr><td>事务回滚（类似：rollback）</td><td>discard</td></tr></tbody></table><div class="hljs"><pre><code class="hljs accesslog">wxs@ubuntu:/usr/local/redis/src$ ./redis-cli <span class="hljs-number">127.0.0.1:6379</span>&gt; set num <span class="hljs-number">1</span>OK<span class="hljs-number">127.0.0.1:6379</span>&gt; set name jitwxsOK<span class="hljs-number">127.0.0.1:6379</span>&gt; multi #开启事务OK<span class="hljs-number">127.0.0.1:6379</span>&gt; incr numQUEUED<span class="hljs-number">127.0.0.1:6379</span>&gt; incr nameQUEUED<span class="hljs-number">127.0.0.1:6379</span>&gt; set age <span class="hljs-number">20</span>QUEUED<span class="hljs-number">127.0.0.1:6379</span>&gt; exec #执行事务<span class="hljs-number">1</span>) (integer) <span class="hljs-number">2</span><span class="hljs-number">2</span>) (error) ERR value is not an integer or out of range #命令报错<span class="hljs-number">3</span>) OK #前面命令出错后这条命令仍然执行了<span class="hljs-number">127.0.0.1:6379</span>&gt; get num<span class="hljs-string">"2"</span><span class="hljs-number">127.0.0.1:6379</span>&gt; get name<span class="hljs-string">"jitwxs"</span><span class="hljs-number">127.0.0.1:6379</span>&gt; get age #该命令的确执行了<span class="hljs-string">"20"</span><span class="hljs-number">127.0.0.1:6379</span>&gt;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. Redis--Redis的数据类型</title>
    <link href="/2020/06/05/3-Redis-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2020/06/05/3-Redis-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>Redis支持以下五种数据结构：</p><ul><li>String类型</li><li>List类型</li><li>Set类型</li><li>SortedSet类型</li><li>Hash类型</li></ul><table><thead><tr><th>存储极限</th><th>大小</th></tr></thead><tbody><tr><td>String类型的value大小</td><td>512M</td></tr><tr><td>Hash类型key的键值对大小</td><td>4294967295</td></tr><tr><td>List类型的key个数</td><td>4294967295</td></tr><tr><td>Set/SortedSet类型的key个数</td><td>4294967295</td></tr></tbody></table><h2 id="一、String（字符串）类型"><a href="#一、String（字符串）类型" class="headerlink" title="一、String（字符串）类型"></a>一、String（字符串）类型</h2><p>在前面两章中，我们存储的都是 String 类型。该类型增加和删除一个键值对十分简单，如下：</p><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>获取值</td><td>get key</td></tr><tr><td>添加一个键值对</td><td>set key value</td></tr><tr><td>获取并重置一个键值对</td><td>getset key value</td></tr><tr><td>删除一个键值对</td><td>del key</td></tr></tbody></table><p>字符串也可以进行数值操作（Redis内部自动将value转换为数值型），方法如下：</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>incr key</td><td>值加1</td></tr><tr><td>decr key</td><td>值减1</td></tr><tr><td>incrby key n</td><td>值加n</td></tr><tr><td>decrby key n</td><td>值减n</td></tr></tbody></table><p>如果key值不存在，当做0处理，如果value值无法转换为整型时，会返回错误信息：</p><p><img src="https://img-blog.csdnimg.cn/20200605223023304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>介绍一下字符串拼接方法，如下：</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>append key</td><td>拼接字符串</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/2020060522335293.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="二、Hash（散列）类型"><a href="#二、Hash（散列）类型" class="headerlink" title="二、Hash（散列）类型"></a>二、Hash（散列）类型</h2><p>散列，即 Hash，Redis 中的 Hash 类型可以看成<strong>Map集合</strong>。Hash 类型的<strong>每一个 key 的 value 对应于一个 Map，该Map包含多个键值对的数据</strong>，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200605231035860.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="2-1-赋值"><a href="#2-1-赋值" class="headerlink" title="2.1 赋值"></a>2.1 赋值</h3><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>hset key field value</td><td>为指定key设置一个键值对</td></tr><tr><td>hmset key field value[field2 value2…]</td><td>为指定key设置多个键值对</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/2020060523171942.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="2-2-取值"><a href="#2-2-取值" class="headerlink" title="2.2 取值"></a>2.2 取值</h3><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>hget key field</td><td>返回指定 key 中 field 的值</td></tr><tr><td>hmget key filed[field2…]</td><td>返回指定 key 中多个 field 的值</td></tr><tr><td>hgetall key</td><td>返回指定 key 中所有 field-value</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/2020060523191135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="2-3-删除"><a href="#2-3-删除" class="headerlink" title="2.3 删除"></a>2.3 删除</h3><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>hdel key field[field2…]</td><td>删除指定 key 一个或多个 field</td></tr><tr><td>del key</td><td>清空 Hash</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/20200605232227429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="2-4-扩展命令"><a href="#2-4-扩展命令" class="headerlink" title="2.4 扩展命令"></a>2.4 扩展命令</h3><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>hexists key field</td><td>判断指定 key 中 field 是否存在</td></tr><tr><td>hlen key</td><td>返回指定 key 中 field 的数量</td></tr><tr><td>hkeys key</td><td>获取指定 key 中所有的 field</td></tr><tr><td>hvals key</td><td>获取指定 key 中所有的 value</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hmset myHash name yyj age <span class="hljs-number">20</span> sex maleOK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hexists myHash name(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hexists myHash unknown(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">0</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hlen myHash(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hkeys myHash<span class="hljs-number">1</span>) <span class="hljs-string">"name"</span><span class="hljs-number">2</span>) <span class="hljs-string">"age"</span><span class="hljs-number">3</span>) <span class="hljs-string">"sex"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hvals myHash<span class="hljs-number">1</span>) <span class="hljs-string">"yyj"</span><span class="hljs-number">2</span>) <span class="hljs-string">"20"</span><span class="hljs-number">3</span>) <span class="hljs-string">"male"</span></code></pre></div><h2 id="三、List-类型"><a href="#三、List-类型" class="headerlink" title="三、List 类型"></a>三、List 类型</h2><p>Redis 的 List 类型有点像 Java 中的 LinkList，内部实现是一个<code>双向链表</code>，双向链表的知识点参考文章：<a href="https://www.jitwxs.cn/abd3f641.html" target="_blank" rel="noopener">《数据结构 第二章 线性表》</a>。</p><h3 id="3-1-添加"><a href="#3-1-添加" class="headerlink" title="3.1 添加"></a>3.1 添加</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>从左端添加多个value</td><td>lpush key value[value2…]</td></tr><tr><td>从右端添加多个value</td><td>rpush key value[value2…]</td></tr></tbody></table><p><strong>注：</strong> 如果 key 不存在会先创建 key，然后添加。</p><p><img src="https://img-blog.csdnimg.cn/20200605233016372.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="3-2-查看"><a href="#3-2-查看" class="headerlink" title="3.2 查看"></a>3.2 查看</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>获取 list 从 start 到 end 的值</td><td>lrange key start end</td></tr><tr><td>获取 list 中元素数量</td><td>llen key</td></tr></tbody></table><p>因为 List 内部是一个双向链表，因此链表<strong>首元素下标为0，尾元素下标为-1</strong>，因此查看所有元素即：<code>lrange key 0 -1</code>。</p><p><img src="https://img-blog.csdnimg.cn/20200605233241255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="3-3-删除"><a href="#3-3-删除" class="headerlink" title="3.3 删除"></a>3.3 删除</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>返回并弹出左端元素</td><td>lpop key</td></tr><tr><td>返回并弹出右端元素</td><td>rpop key</td></tr></tbody></table><p><strong>注：</strong> 如果 key 不存在，返回nil。</p><p><img src="https://img-blog.csdnimg.cn/20200605233444391.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="3-4-扩展命令"><a href="#3-4-扩展命令" class="headerlink" title="3.4 扩展命令"></a>3.4 扩展命令</h3><h4 id="3-4-1-添加前检查-key-的存在性"><a href="#3-4-1-添加前检查-key-的存在性" class="headerlink" title="3.4.1 添加前检查 key 的存在性"></a>3.4.1 添加前检查 key 的存在性</h4><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>从左端添加多个 value</td><td>lpushx key value[value2…]</td></tr><tr><td>从右端添加多个 value</td><td>rpushx key value[value2…]</td></tr></tbody></table><p>这两个方法加了 <code>x</code> 的和之前不加 <code>x</code> 的不同之处是：如果 key 不存在，将<strong>不进行插入</strong>。</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; del myList(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lpushx myList a b c(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">0</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span>(empty list <span class="hljs-keyword">or</span> <span class="hljs-keyword">set</span>)</code></pre></div><h4 id="3-4-2-根据-value-删除"><a href="#3-4-2-根据-value-删除" class="headerlink" title="3.4.2 根据 value 删除"></a>3.4.2 根据 value 删除</h4><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>删除 count 个值为 value 的元素</td><td>lrem key count value</td></tr></tbody></table><p>若 count &gt; 0，则从左到右删除：</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush myList <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">6</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"2"</span><span class="hljs-number">3</span>) <span class="hljs-string">"1"</span><span class="hljs-number">4</span>) <span class="hljs-string">"3"</span><span class="hljs-number">5</span>) <span class="hljs-string">"5"</span><span class="hljs-number">6</span>) <span class="hljs-string">"1"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrem myList <span class="hljs-number">2</span> <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">2</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"2"</span><span class="hljs-number">2</span>) <span class="hljs-string">"3"</span><span class="hljs-number">3</span>) <span class="hljs-string">"5"</span><span class="hljs-number">4</span>) <span class="hljs-string">"1"</span></code></pre></div><p>若 count &lt; 0，则从右向左删除：</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush myList <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">6</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"2"</span><span class="hljs-number">3</span>) <span class="hljs-string">"1"</span><span class="hljs-number">4</span>) <span class="hljs-string">"3"</span><span class="hljs-number">5</span>) <span class="hljs-string">"5"</span><span class="hljs-number">6</span>) <span class="hljs-string">"1"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrem myList <span class="hljs-number">-2</span> <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">2</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"2"</span><span class="hljs-number">3</span>) <span class="hljs-string">"3"</span><span class="hljs-number">4</span>) <span class="hljs-string">"5"</span></code></pre></div><p>若 count = 0，删除所有：</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush myList <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">6</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"2"</span><span class="hljs-number">3</span>) <span class="hljs-string">"1"</span><span class="hljs-number">4</span>) <span class="hljs-string">"3"</span><span class="hljs-number">5</span>) <span class="hljs-string">"5"</span><span class="hljs-number">6</span>) <span class="hljs-string">"1"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrem myList <span class="hljs-number">0</span> <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"2"</span><span class="hljs-number">2</span>) <span class="hljs-string">"3"</span><span class="hljs-number">3</span>) <span class="hljs-string">"5"</span></code></pre></div><h4 id="3-4-3-根据下标设置-value"><a href="#3-4-3-根据下标设置-value" class="headerlink" title="3.4.3 根据下标设置 value"></a>3.4.3 根据下标设置 value</h4><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>设置下标为 index 的元素值。0代表最左边元素，-1代表最右边元素，下标不存在时抛出异常。</td><td>lset key index value</td></tr></tbody></table><div class="hljs"><pre><code class="hljs tcl"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush myList <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>(integer) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">lset</span> myList <span class="hljs-number">1</span> <span class="hljs-number">5</span>OK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">lrange</span> myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"5"</span><span class="hljs-number">3</span>) <span class="hljs-string">"3"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">lset</span> myList <span class="hljs-number">3</span> <span class="hljs-number">5</span>(<span class="hljs-keyword">error</span>) ERR index out of range</code></pre></div><h4 id="3-4-4-相对于某元素插入-value"><a href="#3-4-4-相对于某元素插入-value" class="headerlink" title="3.4.4 相对于某元素插入 value"></a>3.4.4 相对于某元素插入 value</h4><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>在 pivot 元素前插入value</td><td>linsert key before pivot value</td></tr><tr><td>在 pivot 元素后插入value</td><td>linsert key after pivot value</td></tr></tbody></table><p>注：如果 pivot 不存在，不插入。</p><div class="hljs"><pre><code class="hljs tcl"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush myList <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>(integer) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">linsert</span> myList before <span class="hljs-number">2</span> a(integer) <span class="hljs-number">4</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">linsert</span> myList <span class="hljs-keyword">after</span> <span class="hljs-number">2</span> b(integer) <span class="hljs-number">5</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">lrange</span> myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"a"</span><span class="hljs-number">3</span>) <span class="hljs-string">"2"</span><span class="hljs-number">4</span>) <span class="hljs-string">"b"</span><span class="hljs-number">5</span>) <span class="hljs-string">"3"</span></code></pre></div><h4 id="3-4-5-将链表-A-右边元素移出并添加到链表B-左边"><a href="#3-4-5-将链表-A-右边元素移出并添加到链表B-左边" class="headerlink" title="3.4.5 将链表 A 右边元素移出并添加到链表B 左边"></a>3.4.5 将链表 A 右边元素移出并添加到链表B 左边</h4><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>将链表 A 右边元素移出并添加到链表 B 左边</td><td>rpoplpush listA listB</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush myListA <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush myListB a b c(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpoplpush myListA myListB<span class="hljs-string">"3"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myListA <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"2"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myListB <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"3"</span><span class="hljs-number">2</span>) <span class="hljs-string">"a"</span><span class="hljs-number">3</span>) <span class="hljs-string">"b"</span><span class="hljs-number">4</span>) <span class="hljs-string">"c"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpoplpush myListA myListA<span class="hljs-string">"2"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myListA <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"2"</span><span class="hljs-number">2</span>) <span class="hljs-string">"1"</span></code></pre></div><h2 id="四、Set-类型"><a href="#四、Set-类型" class="headerlink" title="四、Set 类型"></a>四、Set 类型</h2><p>Redis 的 Set 类型和 Java 中的 Set 类型一样，它具有两个重要的特点：<code>无序性</code>和<code>唯一性</code>，具体不再赘述。</p><h3 id="4-1-基本操作"><a href="#4-1-基本操作" class="headerlink" title="4.1 基本操作"></a>4.1 基本操作</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>向 set 中添加成员，如果成员已存在，不再添加</td><td>sadd key member[member2…]</td></tr><tr><td>向 set 中删除成员，如果不存在，也不会报错</td><td>srem key member[member2…]</td></tr><tr><td>获取 set 中所有成员</td><td>smembers key</td></tr><tr><td>判断指定成员是否存在于 set 中</td><td>sismember key member</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sadd mySet <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; smembers mySet<span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"2"</span><span class="hljs-number">3</span>) <span class="hljs-string">"3"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; srem mySet <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">2</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; smembers mySet<span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sismember mySet <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sismember mySet <span class="hljs-number">2</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">0</span></code></pre></div><h3 id="4-2-集合操作"><a href="#4-2-集合操作" class="headerlink" title="4.2 集合操作"></a>4.2 集合操作</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>集合的差集</td><td>sdiff key1 key2[key3…]</td></tr><tr><td>集合的交集</td><td>sinter key1 key2[key3…]</td></tr><tr><td>集合的并集</td><td>sunion key1 key2[key3…]</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sadd mySet1 a b c <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">4</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sadd mySet2 <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> b(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">4</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sdiff mySet1 mySet2<span class="hljs-number">1</span>) <span class="hljs-string">"a"</span><span class="hljs-number">2</span>) <span class="hljs-string">"c"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sdiff mySet2 mySet1<span class="hljs-number">1</span>) <span class="hljs-string">"2"</span><span class="hljs-number">2</span>) <span class="hljs-string">"3"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sinter mySet1 mySet2<span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"b"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sunion mySet1 mySet2<span class="hljs-number">1</span>) <span class="hljs-string">"c"</span><span class="hljs-number">2</span>) <span class="hljs-string">"1"</span><span class="hljs-number">3</span>) <span class="hljs-string">"b"</span><span class="hljs-number">4</span>) <span class="hljs-string">"2"</span><span class="hljs-number">5</span>) <span class="hljs-string">"a"</span><span class="hljs-number">6</span>) <span class="hljs-string">"3"</span></code></pre></div><h3 id="4-3-扩展命令"><a href="#4-3-扩展命令" class="headerlink" title="4.3 扩展命令"></a>4.3 扩展命令</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>求 set 中成员数量</td><td>scard key</td></tr><tr><td>随机返回一个成员</td><td>srandmember key</td></tr><tr><td>将多个集合的差集存储在 desc 中</td><td>sdiffstore desc key1 key2[key3…]</td></tr><tr><td>将多个集合的交集存储在 desc 中</td><td>sinterstore desc key1 key2[key3…]</td></tr><tr><td>将多个集合的并集存储在 desc 中</td><td>sunionstore desc key1 key2[key3…]</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; smembers mySet1<span class="hljs-number">1</span>) <span class="hljs-string">"a"</span><span class="hljs-number">2</span>) <span class="hljs-string">"c"</span><span class="hljs-number">3</span>) <span class="hljs-string">"1"</span><span class="hljs-number">4</span>) <span class="hljs-string">"b"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; smembers mySet2<span class="hljs-number">1</span>) <span class="hljs-string">"3"</span><span class="hljs-number">2</span>) <span class="hljs-string">"b"</span><span class="hljs-number">3</span>) <span class="hljs-string">"2"</span><span class="hljs-number">4</span>) <span class="hljs-string">"1"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; scard mySet1(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">4</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; srandmember mySet1<span class="hljs-string">"c"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sdiffstore mySet3 mySet1 mySet2(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">2</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; smembers mySet3<span class="hljs-number">1</span>) <span class="hljs-string">"a"</span><span class="hljs-number">2</span>) <span class="hljs-string">"c"</span></code></pre></div><h2 id="五、SortedSet-类型"><a href="#五、SortedSet-类型" class="headerlink" title="五、SortedSet 类型"></a>五、SortedSet 类型</h2><p>SortedSet 和 Set 的区别是，SortedSet 中每一个成员都有一个 <code>score（分数）</code>与之关联，Redis 通过 score 来为集合中的元素进行排序（默认为升序）。</p><h3 id="5-1-添加-获取元素"><a href="#5-1-添加-获取元素" class="headerlink" title="5.1 添加/获取元素"></a>5.1 添加/获取元素</h3><table><thead><tr><th align="left">含义</th><th>方法</th></tr></thead><tbody><tr><td align="left">添加成员。如果成员存在，会用新的 score 替代原有的 score，返回值是新加入到集合中的成员个数</td><td>zadd key score member[score2 member2… ]</td></tr><tr><td align="left">获取指定成员的 score</td><td>zscore key member</td></tr><tr><td align="left">获取 key 中成员个数</td><td>scard key</td></tr><tr><td align="left">获取集合中下标从 start 到 end 的成员，[withscores]表明返回的成员包含其 score</td><td>zrange key start end[withscores]</td></tr><tr><td align="left">上面方法的反转</td><td>zrevrange key start end[withscores]</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zadd mySort <span class="hljs-number">82</span> wangnima <span class="hljs-number">100</span> cat <span class="hljs-number">33</span> dog <span class="hljs-number">43</span> jitwxs <span class="hljs-number">80</span> zhouyang <span class="hljs-number">60</span> liuchang(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">6</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zscore mySort jitwxs<span class="hljs-string">"100"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zcard mySort(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">6</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"dog"</span><span class="hljs-number">2</span>) <span class="hljs-string">"liuchang"</span><span class="hljs-number">3</span>) <span class="hljs-string">"zhouyang"</span><span class="hljs-number">4</span>) <span class="hljs-string">"wangnima"</span><span class="hljs-number">5</span>) <span class="hljs-string">"cat"</span><span class="hljs-number">6</span>) <span class="hljs-string">"jitwxs"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span> withscores <span class="hljs-number">1</span>) <span class="hljs-string">"dog"</span> <span class="hljs-number">2</span>) <span class="hljs-string">"33"</span> <span class="hljs-number">3</span>) <span class="hljs-string">"liuchang"</span> <span class="hljs-number">4</span>) <span class="hljs-string">"60"</span> <span class="hljs-number">5</span>) <span class="hljs-string">"zhouyang"</span> <span class="hljs-number">6</span>) <span class="hljs-string">"80"</span> <span class="hljs-number">7</span>) <span class="hljs-string">"wangnima"</span> <span class="hljs-number">8</span>) <span class="hljs-string">"82"</span> <span class="hljs-number">9</span>) <span class="hljs-string">"cat"</span><span class="hljs-number">10</span>) <span class="hljs-string">"100"</span><span class="hljs-number">11</span>) <span class="hljs-string">"jitwxs"</span><span class="hljs-number">12</span>) <span class="hljs-string">"100"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrevrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span> withscores <span class="hljs-number">1</span>) <span class="hljs-string">"jitwxs"</span> <span class="hljs-number">2</span>) <span class="hljs-string">"100"</span> <span class="hljs-number">3</span>) <span class="hljs-string">"cat"</span> <span class="hljs-number">4</span>) <span class="hljs-string">"100"</span> <span class="hljs-number">5</span>) <span class="hljs-string">"wangnima"</span> <span class="hljs-number">6</span>) <span class="hljs-string">"82"</span> <span class="hljs-number">7</span>) <span class="hljs-string">"zhouyang"</span> <span class="hljs-number">8</span>) <span class="hljs-string">"80"</span> <span class="hljs-number">9</span>) <span class="hljs-string">"liuchang"</span><span class="hljs-number">10</span>) <span class="hljs-string">"60"</span><span class="hljs-number">11</span>) <span class="hljs-string">"dog"</span><span class="hljs-number">12</span>) <span class="hljs-string">"33"</span></code></pre></div><h3 id="5-2-删除元素"><a href="#5-2-删除元素" class="headerlink" title="5.2 删除元素"></a>5.2 删除元素</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>删除成员</td><td>zrem key member[member2…]</td></tr><tr><td>按照下标范围删除成员</td><td>zremrangebyrank key start stop</td></tr><tr><td>按照 score 范围删除成员</td><td>zremrangebyscore key min max</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrem mySort wangnima(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zcard mySort(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">5</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"dog"</span><span class="hljs-number">2</span>) <span class="hljs-string">"liuchang"</span><span class="hljs-number">3</span>) <span class="hljs-string">"zhouyang"</span><span class="hljs-number">4</span>) <span class="hljs-string">"cat"</span><span class="hljs-number">5</span>) <span class="hljs-string">"jitwxs"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zremrangebyrank mySort <span class="hljs-number">0</span> <span class="hljs-number">2</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"cat"</span><span class="hljs-number">2</span>) <span class="hljs-string">"jitwxs"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span> withscores <span class="hljs-number">1</span>) <span class="hljs-string">"dog"</span> <span class="hljs-number">2</span>) <span class="hljs-string">"33"</span> <span class="hljs-number">3</span>) <span class="hljs-string">"jitwxs"</span> <span class="hljs-number">4</span>) <span class="hljs-string">"43"</span> <span class="hljs-number">5</span>) <span class="hljs-string">"liuchang"</span> <span class="hljs-number">6</span>) <span class="hljs-string">"60"</span> <span class="hljs-number">7</span>) <span class="hljs-string">"zhouyang"</span> <span class="hljs-number">8</span>) <span class="hljs-string">"80"</span> <span class="hljs-number">9</span>) <span class="hljs-string">"wangnima"</span><span class="hljs-number">10</span>) <span class="hljs-string">"82"</span><span class="hljs-number">11</span>) <span class="hljs-string">"cat"</span><span class="hljs-number">12</span>) <span class="hljs-string">"100"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zremrangebyscore mySort <span class="hljs-number">50</span> <span class="hljs-number">85</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span> withscores<span class="hljs-number">1</span>) <span class="hljs-string">"dog"</span><span class="hljs-number">2</span>) <span class="hljs-string">"33"</span><span class="hljs-number">3</span>) <span class="hljs-string">"jitwxs"</span><span class="hljs-number">4</span>) <span class="hljs-string">"43"</span><span class="hljs-number">5</span>) <span class="hljs-string">"cat"</span><span class="hljs-number">6</span>) <span class="hljs-string">"100"</span></code></pre></div><h3 id="5-3-扩展方法"><a href="#5-3-扩展方法" class="headerlink" title="5.3 扩展方法"></a>5.3 扩展方法</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>返回 score 在[min,max]的成员并按照 score 排序。[withscores]：显示 score；[limit offset count]：从 offst 开始返回 count 个成员</td><td>zrangebyscore key min max[withscores] [limit offset count]</td></tr><tr><td>设置指定成员增加的分数，返回值是修改后的分数</td><td>zincrby key increment member</td></tr><tr><td>获取分树在[min,max]的成员数量</td><td>zcount key min max</td></tr><tr><td>返回成员在集合中的排名（升序）</td><td>zrank key member</td></tr><tr><td>返回成员在集合中的排名（降序）</td><td>zrevrank key member</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span> withscores <span class="hljs-number">1</span>) <span class="hljs-string">"dog"</span> <span class="hljs-number">2</span>) <span class="hljs-string">"33"</span> <span class="hljs-number">3</span>) <span class="hljs-string">"jitwxs"</span> <span class="hljs-number">4</span>) <span class="hljs-string">"43"</span> <span class="hljs-number">5</span>) <span class="hljs-string">"liuchang"</span> <span class="hljs-number">6</span>) <span class="hljs-string">"60"</span> <span class="hljs-number">7</span>) <span class="hljs-string">"zhouyang"</span> <span class="hljs-number">8</span>) <span class="hljs-string">"80"</span> <span class="hljs-number">9</span>) <span class="hljs-string">"wangnima"</span><span class="hljs-number">10</span>) <span class="hljs-string">"82"</span><span class="hljs-number">11</span>) <span class="hljs-string">"cat"</span><span class="hljs-number">12</span>) <span class="hljs-string">"100"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrangebyscore mySort <span class="hljs-number">30</span> <span class="hljs-number">86</span> limit <span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-number">1</span>) <span class="hljs-string">"liuchang"</span><span class="hljs-number">2</span>) <span class="hljs-string">"zhouyang"</span><span class="hljs-number">3</span>) <span class="hljs-string">"wangnima"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zcount mySort <span class="hljs-number">0</span> <span class="hljs-number">60</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zincrby mySort <span class="hljs-number">17</span> jitwxs<span class="hljs-string">"60"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrank mySort jitwxs(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrevrank mySort jitwxs(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">4</span></code></pre></div><h2 id="六、key-的通用命令"><a href="#六、key-的通用命令" class="headerlink" title="六、key 的通用命令"></a>六、key 的通用命令</h2><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>获取所有于 pattern 匹配的 key。*：任意一个或多个字符，？：任意一个字符</td><td>keys pattern</td></tr><tr><td>删除指定 key</td><td>del key[key2…]</td></tr><tr><td>判断 key 是否存在</td><td>exists key</td></tr><tr><td>为 key 重命名</td><td>rename key newKey</td></tr><tr><td>设置过期时间（单位s）</td><td>expire key</td></tr><tr><td>获取key 剩余的过期时间（单位s）。若没有设置过期时间，返回-1；超时不存在返回-2</td><td>ttl key</td></tr><tr><td>获取 key 类型，key 不存在返回none</td><td>type key</td></tr></tbody></table><p>注：如果你设置了一个 key 的过期时间，如果又不想让它过期，可以执行命令 <code>persist key</code>。</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; keys * <span class="hljs-number">1</span>) <span class="hljs-string">"unknown"</span> <span class="hljs-number">2</span>) <span class="hljs-string">"mySet2"</span> <span class="hljs-number">3</span>) <span class="hljs-string">"float_num"</span> <span class="hljs-number">4</span>) <span class="hljs-string">"myListB"</span> <span class="hljs-number">5</span>) <span class="hljs-string">"mySet3"</span> <span class="hljs-number">6</span>) <span class="hljs-string">"userName"</span> <span class="hljs-number">7</span>) <span class="hljs-string">"myListA"</span> <span class="hljs-number">8</span>) <span class="hljs-string">"int_num"</span> <span class="hljs-number">9</span>) <span class="hljs-string">"mySort"</span><span class="hljs-number">10</span>) <span class="hljs-string">"mySet1"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; del unknown(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; type myListAlist<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rename myListA myListOK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; exists myListA(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">0</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; ttl mySort(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">-1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; expire mySort <span class="hljs-number">30</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; ttl mySort(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">-2</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; keys *<span class="hljs-number">1</span>) <span class="hljs-string">"mySet2"</span><span class="hljs-number">2</span>) <span class="hljs-string">"myList"</span><span class="hljs-number">3</span>) <span class="hljs-string">"float_num"</span><span class="hljs-number">4</span>) <span class="hljs-string">"myListB"</span><span class="hljs-number">5</span>) <span class="hljs-string">"mySet3"</span><span class="hljs-number">6</span>) <span class="hljs-string">"userName"</span><span class="hljs-number">7</span>) <span class="hljs-string">"int_num"</span><span class="hljs-number">8</span>) <span class="hljs-string">"mySet1"</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. Redis--Jedis的使用</title>
    <link href="/2020/06/05/2-Redis-Jedis%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/06/05/2-Redis-Jedis%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>在Linux中开启redis服务，并传入一个变量username，赋值为yyj：<br><img src="https://img-blog.csdnimg.cn/20200605211103310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="第一个Jedis程序"><a href="#第一个Jedis程序" class="headerlink" title="第一个Jedis程序"></a>第一个Jedis程序</h1><h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-pool<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hamcrest<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hamcrest-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//1.获得连接对象，参数为redis所在的服务器地址及端口号</span>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">"192.168.75.130"</span>, <span class="hljs-number">6379</span>);        <span class="hljs-comment">//2.获得数据</span>        String username = jedis.get(<span class="hljs-string">"username"</span>);        System.out.println(username);        jedis.close();    &#125;&#125;</code></pre></div><p>这里的redis服务器地址查找方式：</p><div class="hljs"><pre><code class="hljs java">yyj<span class="hljs-meta">@yyj</span>-virtual-machine:~$ ifconfig -a</code></pre></div><p>这样我们通过运行Redis的主机IP地址和Redis的端口号，然后就可以直接get到username的值了。</p><h1 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h1><p>Jedis和数据库连接库一样，都有连接池，即JedisPool，通过简单的配置即可直接从连接池中取Jedis对象。<br>测试代码如下：</p><div class="hljs"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//1.创建Jedis连接池配置</span>        JedisPoolConfig jedisPoolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();        <span class="hljs-comment">//设置最小和最大闲置个数</span>        jedisPoolConfig.setMaxIdle(<span class="hljs-number">5</span>);        jedisPoolConfig.setMaxIdle(<span class="hljs-number">10</span>);        <span class="hljs-comment">//设置连接池最大个数</span>        jedisPoolConfig.setMaxTotal(<span class="hljs-number">30</span>);        <span class="hljs-comment">//2. 创建Jedis连接池</span>        JedisPool jedisPool = <span class="hljs-keyword">new</span> JedisPool(jedisPoolConfig, <span class="hljs-string">"192.168.75.130"</span>, <span class="hljs-number">6379</span>);        <span class="hljs-comment">//3.从连接池中获取Jedis对象</span>        Jedis jedis = jedisPool.getResource();        <span class="hljs-comment">//4.操纵数据</span>        jedis.set(<span class="hljs-string">"age"</span>,<span class="hljs-string">"20"</span>);        System.out.println(jedis.get(<span class="hljs-string">"age"</span>));        <span class="hljs-comment">//5.关闭资源</span>        jedis.close();        jedisPool.close();    &#125;&#125;</code></pre></div><h1 id="封装成工具类"><a href="#封装成工具类" class="headerlink" title="封装成工具类"></a>封装成工具类</h1><p>将上面的Redis连接池封装成一个工具类，其他地方的代码直接调用工具类来执行即可。<br>首先在src下的resource目录下新建一个配置文件redis.properties，把一些配置信息存储在配置文件中：</p><div class="hljs"><pre><code class="hljs java">#Redis连接信息redis.ip = <span class="hljs-number">192.168</span><span class="hljs-number">.75</span><span class="hljs-number">.130</span>redis.port = <span class="hljs-number">6379</span>#Redis配置信息redis.minIdle = <span class="hljs-number">5</span>redis.maxIdle = <span class="hljs-number">30</span>redis.maxTotal = <span class="hljs-number">30</span></code></pre></div><p>新建 JedisUtils.java：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisUtils</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool jedisPool = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">/** 获取连接 **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title">getJedis</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(jedisPool == <span class="hljs-keyword">null</span>)&#123;            initJedisPool();        &#125;        <span class="hljs-keyword">return</span> jedisPool.getResource();    &#125;        <span class="hljs-comment">/** 关闭连接 **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeJedis</span><span class="hljs-params">(Jedis jedis)</span> </span>&#123;        jedis.close();    &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initJedisPool</span><span class="hljs-params">()</span> </span>&#123;        InputStream in = JedisUtils.class.getClassLoader().getResourceAsStream("redis.properties");        Properties properties = <span class="hljs-keyword">new</span> Properties();        <span class="hljs-keyword">try</span> &#123;            properties.load(in);            JedisPoolConfig poolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();            poolConfig.setMinIdle(Integer.parseInt(properties.getProperty(<span class="hljs-string">"redis.minIdle"</span>)));            poolConfig.setMaxIdle(Integer.parseInt(properties.getProperty(<span class="hljs-string">"redis.maxIdle"</span>)));            poolConfig.setMaxTotal(Integer.parseInt(properties.getProperty(<span class="hljs-string">"redis.maxTotal"</span>)));            jedisPool = <span class="hljs-keyword">new</span> JedisPool(                    poolConfig,                    properties.getProperty(<span class="hljs-string">"redis.ip"</span>),                    Integer.parseInt(properties.getProperty(<span class="hljs-string">"redis.port"</span>)));        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            System.out.println(<span class="hljs-string">"载入配置文件错误"</span>);            e.printStackTrace();        &#125;    &#125;&#125;</code></pre></div><p>测试代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;    Jedis jedis = JedisUtils.getJedis();    System.out.println(jedis.get(<span class="hljs-string">"age"</span>));    JedisUtils.closeJedis(jedis);&#125;</code></pre></div><p>目录结构如下：<br><img src="https://img-blog.csdnimg.cn/2020060522103795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. Redis--安装Redis</title>
    <link href="/2020/06/05/1-Redis-%E5%AE%89%E8%A3%85Redis/"/>
    <url>/2020/06/05/1-Redis-%E5%AE%89%E8%A3%85Redis/</url>
    
    <content type="html"><![CDATA[<h2 id="1-1-什么是-Redis"><a href="#1-1-什么是-Redis" class="headerlink" title="1.1 什么是 Redis"></a>1.1 什么是 Redis</h2><p>Redis 是使用 C 语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，Redis 支持以下五种数据类型：</p><ul><li>String 类型</li><li>List 类型</li><li>Set 类型</li><li>SortedSet 类型</li><li>Hash类型</li></ul><h2 id="1-2-Redis-应用场景"><a href="#1-2-Redis-应用场景" class="headerlink" title="1.2 Redis 应用场景"></a>1.2 Redis 应用场景</h2><ul><li>缓存</li><li>分布式集群架构中session分离</li><li>任务队列</li><li>…</li></ul><h2 id="1-3-安装-Redis"><a href="#1-3-安装-Redis" class="headerlink" title="1.3 安装 Redis"></a>1.3 安装 Redis</h2><p>这里我是基于Docker安装Redis</p><ol><li><p>先搜索Redis镜像</p><div class="hljs"><pre><code><pre><code class="hljs linux">yyj@yyj-virtual-machine:~$ docker search redis</code></pre></div></code></pre><p><img src="https://img-blog.csdnimg.cn/20200605201628811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li><li><p>拉取镜像</p> <div class="hljs"><pre><code class="hljs java">sudo docker pull redis:tag</code></pre></div><p><code>:tag</code>是可选的，tag表示软件的版本，默认是latest。</p><h2 id="1-4-根据镜像启动redis"><a href="#1-4-根据镜像启动redis" class="headerlink" title="1.4 根据镜像启动redis"></a>1.4 根据镜像启动redis</h2></li></ol><p><img src="https://img-blog.csdnimg.cn/20200605202515325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="!\[在这里插入图片描述\](https://img-blog.csdnimg.cn/20200605202139539.png?x-oss-process=image/watermark,type_ZmFuZ3"><br>其中 Port 表示redis的端口号，PID 表示改进程的 pid 号，下方光标不停的闪动，此时 redis 就已经启动了。<br>新开一个窗口，运行redis-cli<br><img src="https://img-blog.csdnimg.cn/20200605202656380.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>测试效果：<br><img src="https://img-blog.csdnimg.cn/20200605202757404.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>Tips:如果我们要连接远程Redis，可以加参数： <code>-h IP地址</code><br>如果要指定端口，可以加参数：<code>-p 端口号</code></p></blockquote><h2 id="1-5-后端模式"><a href="#1-5-后端模式" class="headerlink" title="1.5 后端模式"></a>1.5 后端模式</h2><p>如果觉得开多个窗口麻烦，可以设置Redis启动模式为后端启动即可，仅仅只需要在运行redis的时候加上<code>-d</code>。<br><img src="https://img-blog.csdnimg.cn/20200605203644657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="1-6-退出Redis"><a href="#1-6-退出Redis" class="headerlink" title="1.6 退出Redis"></a>1.6 退出Redis</h2><p><img src="https://img-blog.csdnimg.cn/20200605203404108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13.Netty--使用UDP广播事件</title>
    <link href="/2020/06/03/13-Netty-%E4%BD%BF%E7%94%A8UDP%E5%B9%BF%E6%92%AD%E4%BA%8B%E4%BB%B6/"/>
    <url>/2020/06/03/13-Netty-%E4%BD%BF%E7%94%A8UDP%E5%B9%BF%E6%92%AD%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>UDP概述</li><li>一个广播应用程序示例</li></ul></blockquote><h1 id="UDP的基础知识"><a href="#UDP的基础知识" class="headerlink" title="UDP的基础知识"></a>UDP的基础知识</h1><p>面向连接的传输（如TCP）管理了两个网络端点之间的连接的建立，在连接的生命周期内的有序和可靠的消息传输，以及最后连接的有序终止。<br>类似于UDP这样的无连接协议中，并没有持久化连接这样的概念，并且每个消息（一个UDP数据报）都是一个单独的传输单元。</p><h1 id="UDP广播"><a href="#UDP广播" class="headerlink" title="UDP广播"></a>UDP广播</h1><p>UDP提供了向多个接收者发送消息的额外传输模式：<br>多播：传播到一个预定义的主机组<br>广播：传输到网络上的所有主机</p><h1 id="UDP示例应用程序"><a href="#UDP示例应用程序" class="headerlink" title="UDP示例应用程序"></a>UDP示例应用程序</h1><p>发布/订阅模式:一个生产者或者服务发布事件，而多个客户端进行订阅以接收它们。<br><img src="https://img-blog.csdnimg.cn/20200603212624678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>所有的在该UDP端口上监听的事件监视器都将会接收到广播消息。</p><h1 id="消息POJO：LogEvent"><a href="#消息POJO：LogEvent" class="headerlink" title="消息POJO：LogEvent"></a>消息POJO：LogEvent</h1><p>在消息处理应用程序中，数据通常由POJO表示，除了实际上的消息内容，其还可以包含配置或处理信息，在这个应用程序中，我们将会把消息作为事件处理，并且由于该数据来自于日志文件，所以我们称它为LogEvent。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogEvent</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> SEPARATOR = (<span class="hljs-keyword">byte</span>) <span class="hljs-string">':'</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> InetSocketAddress source;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String logfile;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String msg;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> received;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LogEvent</span><span class="hljs-params">(String logfile, String msg)</span> </span>&#123; <span class="hljs-comment">// 用于传出消息的构造函数</span>        <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, -<span class="hljs-number">1</span>, logfile, msg);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LogEvent</span><span class="hljs-params">(InetSocketAddress source, <span class="hljs-keyword">long</span> received, String logfile, String msg)</span> </span>&#123; <span class="hljs-comment">// 用于 传入消息的构造函数</span>        <span class="hljs-keyword">this</span>.source = source;        <span class="hljs-keyword">this</span>.logfile = logfile;        <span class="hljs-keyword">this</span>.msg = msg;        <span class="hljs-keyword">this</span>.received = received;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> InetSocketAddress <span class="hljs-title">getSource</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 返回发送LogEvent 的源的InetSocketAddress</span>        <span class="hljs-keyword">return</span> source;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLogfile</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 返回所发送的LogEvent 的日志文件的名称</span>        <span class="hljs-keyword">return</span> logfile;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMsg</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 返回消息内容</span>        <span class="hljs-keyword">return</span> msg;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getReceivedTimestamp</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 返回接收LogEvent的时间</span>        <span class="hljs-keyword">return</span> received;    &#125;&#125;</code></pre></div><p>定义好了消息组件，接下来便可以实现该应用程序的广播逻辑了。</p><h1 id="编写广播者"><a href="#编写广播者" class="headerlink" title="编写广播者"></a>编写广播者</h1><p>Netty提供了大量的类来支持UDP应用程序的编写<br><img src="https://img-blog.csdnimg.cn/20200603213229555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Netty 的DatagramPacket 是一个简单的消息容器，DatagramChannel 实现用它来和远程节点通信。它包含了接收者（和可选的发送者）的地址以及消息的有效负载本身。<br>下图展示了正在广播的3个日志条目，每个都将通过一个专门的DatagramPacket进行广播：<br><img src="https://img-blog.csdnimg.cn/20200603213320917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>下图呈现了该LogEventBroadcaster的ChannelPipeline的一个高级别视图，展示了LogEvent消息是如何流经它的。<br><img src="https://img-blog.csdnimg.cn/20200603213516499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>所有的将要被传输的数据都被封装在了LogEvent消息中，LogEventBroadcaster将把这些写入到Channel中，并通过ChannelPipeline发送它们，在那里他们将会被转换（编码）为DatagramPacket消息，最后，它们都将通过UDP被广播，并由远程节点（监视器）所捕获。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogEventEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageEncoder</span>&lt;<span class="hljs-title">LogEvent</span>&gt;</span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> InetSocketAddress remoteAddress;     <span class="hljs-comment">//LogEventEncoder创建了即将被发送到指定的InetSocketAddress的DatagramPacket消息</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LogEventEncoder</span><span class="hljs-params">(InetSocketAddress remoteAddress)</span></span>&#123;        <span class="hljs-keyword">this</span>.remoteAddress = remoteAddress;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                          LogEvent logEvent, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">byte</span>[] file = logEvent.getLogfile().getBytes(CharsetUtil.UTF_8);        <span class="hljs-keyword">byte</span>[] msg = logEvent.getMsg().getBytes(CharsetUtil.UTF_8);        ByteBuf buf = channelHandlerContext.alloc().buffer(file.length + msg.length + <span class="hljs-number">1</span>);        <span class="hljs-comment">//将文件名写入到ByteBuf中</span>        buf.writeBytes(file);        <span class="hljs-comment">//添加一个SEPARATOR</span>        buf.writeByte(LogEvent.SEPARATOR);        <span class="hljs-comment">//将日志消息写入ByteBuf中</span>        buf.writeBytes(msg);        <span class="hljs-comment">//将一个拥有数据和目的地地址的新DatagramPacket添加到出站的消息列表中</span>        out.add(<span class="hljs-keyword">new</span> io.netty.channel.socket.DatagramPacket(buf,remoteAddress));    &#125;&#125;</code></pre></div><p>在LogEventEncoder被实现之后，我们已经准备好了引导该服务器，其包括设置各种各样的ChannelOption，以及在ChannelPipeline中安装所需要的ChannelHandler。这将通过主类LogEventBroadcaster完成。如下代码所示。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogEventBroadcaster</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventLoopGroup group;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Bootstrap bootstrap;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> File file;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LogEventBroadcaster</span><span class="hljs-params">(InetSocketAddress address, File file)</span></span>&#123;        group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        bootstrap = <span class="hljs-keyword">new</span> Bootstrap();        <span class="hljs-comment">//引导该NioDatagramChannel（无连接）</span>        bootstrap.group(group).channel(NioDatagramChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                //设置<span class="hljs-title">SO_BROADCAST</span>套接字选项</span><span class="hljs-class">                .<span class="hljs-title">option</span>(<span class="hljs-title">ChannelOption</span>.<span class="hljs-title">SO_BROADCAST</span>,<span class="hljs-title">true</span>)</span><span class="hljs-class">                .<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">LogEventEncoder</span>(<span class="hljs-title">address</span>))</span>;        <span class="hljs-keyword">this</span>.file = file;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        <span class="hljs-comment">//绑定Channel</span>        Channel ch = bootstrap.bind(<span class="hljs-number">0</span>).sync().channel();        <span class="hljs-keyword">long</span> pointer = <span class="hljs-number">0</span>;        <span class="hljs-comment">//启动主处理循环</span>        <span class="hljs-keyword">for</span> (;;)&#123;            <span class="hljs-keyword">long</span> len = file.length();            <span class="hljs-keyword">if</span> (len &lt; pointer)&#123;                <span class="hljs-comment">//file was reset</span>                <span class="hljs-comment">//如果有必要，将文件指针设置到该文件的最后一个字符</span>                pointer = len;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len &gt; pointer)&#123;                <span class="hljs-comment">//Content was added</span>                RandomAccessFile raf = <span class="hljs-keyword">new</span> RandomAccessFile(file,<span class="hljs-string">"r"</span>);                <span class="hljs-comment">//设置当前的文件指针，以确保没有任何的旧日志被发送</span>                raf.seek(pointer);                String line;                <span class="hljs-keyword">while</span>((line = raf.readLine()) != <span class="hljs-keyword">null</span>)&#123;                    <span class="hljs-comment">//对于每条日志条目。，写入一个LogEvent到Channel中</span>                    ch.writeAndFlush(<span class="hljs-keyword">new</span> LogEvent(<span class="hljs-keyword">null</span>,-<span class="hljs-number">1</span>,file.getAbsolutePath(),line));                &#125;                <span class="hljs-comment">//存储其在文件中的当前位置</span>                pointer = raf.getFilePointer();                raf.close();            &#125;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//休眠1秒，如果被中断，则退出循环，否则重新处理它</span>                Thread.sleep(<span class="hljs-number">1000</span>);            &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;                Thread.interrupted();                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>&#123;        group.shutdownGracefully();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        <span class="hljs-keyword">if</span> (args.length != <span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();        &#125;        LogEventBroadcaster broadcaster = <span class="hljs-keyword">new</span> LogEventBroadcaster(                <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"255.255.255.255"</span>,Integer.parseInt(args[<span class="hljs-number">0</span>])),<span class="hljs-keyword">new</span> File(args[<span class="hljs-number">1</span>]));        <span class="hljs-keyword">try</span> &#123;            broadcaster.run();        &#125;<span class="hljs-keyword">finally</span> &#123;            broadcaster.stop();        &#125;    &#125;&#125;</code></pre></div><p>6、编写监视器</p><p>目标是将netcat替换为一个更加完整的事件消费者，我们称之为LogEventMonitor。这个程序将：</p><p>（1）接收有LogEventBroadcaster广播的UDP DatagramPacket</p><p>（2）将它们解码为LogEvent消息</p><p>（3）将LogEvent消息写到System.out</p><p>和之前一样，该逻辑由一组自定义的ChannelHandler实现——对于我们的解码器来说，我们将扩展MessageToMessageDecoder。下图描绘LogEventMonitor的ChannelPipeline，并且展示了LogEvnet是如何流经它的。<br><img src="https://img-blog.csdnimg.cn/20200603214313967.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>ChannelPipeline中的第一个解码器LogEventDecoder负责传入的DatagramPacket解码为LogEvent消息（一个用于转换入站数据的任何Netty应用程序的典型设置）</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogEventDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageDecoder</span>&lt;<span class="hljs-title">DatagramPacket</span>&gt;</span>&#123;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                          DatagramPacket datagramPacket, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//获取对DatagramPacket中的数据的引用</span>        ByteBuf data = datagramPacket.content();        <span class="hljs-comment">//获取该SEPARATOR的索引</span>        <span class="hljs-keyword">int</span> idx = data.indexOf(<span class="hljs-number">0</span>,data.readableBytes(),LogEvent.SEPARATOR);        <span class="hljs-comment">//提取文件名</span>        String fileName = data.slice(<span class="hljs-number">0</span>,idx).toString(CharsetUtil.UTF_8);        <span class="hljs-comment">//提取日志消息</span>        String logMsg = data.slice(idx + <span class="hljs-number">1</span>,data.readableBytes()).toString(CharsetUtil.UTF_8);        <span class="hljs-comment">//构建一个新的LogEvent对象，并且将它添加到列表中</span>        LogEvent event = <span class="hljs-keyword">new</span> LogEvent(datagramPacket.sender(),System.currentTimeMillis(),fileName,logMsg);        out.add(event);    &#125;&#125;</code></pre></div><p>第二个ChannelHandler的工作是对第一个ChannelHandler所创建的LogEvent消息执行一些处理。在这个场景下，它只是简单地将它们写到System.out。在真实世界的应用程序中，你可能需要聚合来源于不同日志文件的事件，或者将它们发布到数据库中。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogEventHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">LogEvent</span>&gt;</span>&#123;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//当异常发生时，打印栈跟踪信息，并关闭对应的Channel</span>        cause.printStackTrace();        ctx.close();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                                LogEvent event)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//创建StringBuilder，并且构建输出的字符串</span>        StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();        builder.append(event.getReceived());        builder.append(<span class="hljs-string">" ["</span>);        builder.append(event.getSource().toString());        builder.append(<span class="hljs-string">"] ["</span>);        builder.append(event.getLogfile());        builder.append(<span class="hljs-string">"] : "</span>);        builder.append(event.getMsg());        <span class="hljs-comment">//打印LogEvent的数据</span>        System.out.println(builder.toString());    &#125;&#125;</code></pre></div><p>LogEventHandler将以一种简单易读的格式打印LogEvent消息，现在我们需要将我们的LogEventDecoder和LogEventHandler安装到ChannelPipeline中。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogEventMonitor</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventLoopGroup group;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Bootstrap bootstrap;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LogEventMonitor</span><span class="hljs-params">(InetSocketAddress address)</span></span>&#123;        group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        bootstrap = <span class="hljs-keyword">new</span> Bootstrap();        bootstrap.group(group)                .channel(NioDatagramChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                .<span class="hljs-title">option</span>(<span class="hljs-title">ChannelOption</span>.<span class="hljs-title">SO_BROADCAST</span>,<span class="hljs-title">true</span>)</span><span class="hljs-class">                .<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt;() </span>&#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel channel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        ChannelPipeline pipeline = channel.pipeline();                        pipeline.addLast(<span class="hljs-keyword">new</span> LogEventDecoder());                        pipeline.addLast(<span class="hljs-keyword">new</span> LogEventHandler());                    &#125;                &#125;).localAddress(address);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Channel <span class="hljs-title">bind</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> bootstrap.bind().syncUninterruptibly().channel();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>&#123;        group.shutdownGracefully();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        <span class="hljs-keyword">if</span> (args.length != <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Usage:LoEventMonitor &lt;port&gt;"</span>);        &#125;        LogEventMonitor monitor = <span class="hljs-keyword">new</span> LogEventMonitor(<span class="hljs-keyword">new</span> InetSocketAddress(Integer.parseInt(args[<span class="hljs-number">0</span>])));        <span class="hljs-keyword">try</span> &#123;            Channel channel = monitor.bind();            System.out.println(<span class="hljs-string">"LogEventMonitor running"</span>);            channel.closeFuture().sync();        &#125;<span class="hljs-keyword">finally</span> &#123;            monitor.stop();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12.Netty--WebSocket</title>
    <link href="/2020/06/03/12-Netty-WebSocket/"/>
    <url>/2020/06/03/12-Netty-WebSocket/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>实时Web的概念</li><li>WebSocket协议</li><li>使用Netty构建一个基于WebSocket的聊天室服务器</li></ul></blockquote><h1 id="WebSocket简介"><a href="#WebSocket简介" class="headerlink" title="WebSocket简介"></a>WebSocket简介</h1><p>WebSocket协议是完全重新设计的协议，旨在为Web上的双向数据传输问题提供一个切实可行的解决方案，使得客户端与服务器之间可以在任意时刻传输消息。</p><h1 id="我们的WebSocket示例应用程序"><a href="#我们的WebSocket示例应用程序" class="headerlink" title="我们的WebSocket示例应用程序"></a>我们的WebSocket示例应用程序</h1><p><img src="https://img-blog.csdnimg.cn/20200603155650935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="添加WebSocket支持"><a href="#添加WebSocket支持" class="headerlink" title="添加WebSocket支持"></a>添加WebSocket支持</h1><p><img src="https://img-blog.csdnimg.cn/20200603155948230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="处理HTTP请求"><a href="#处理HTTP请求" class="headerlink" title="处理HTTP请求"></a>处理HTTP请求</h2><p>首先我们需要实现处理HTTP请求的组件，这个组件将提供用于访问聊天室并显示由连接的客户端发送的消息的网页。channelRead0()方法的实现是如何转发任何目标URI为/ws的请求的。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpRequestHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">FullHttpRequest</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String wsUri;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> File INDEX;    <span class="hljs-keyword">static</span> &#123;        URL location = HttpRequestHandler<span class="hljs-class">.<span class="hljs-keyword">class</span></span><span class="hljs-class">            .<span class="hljs-title">getProtectionDomain</span>()</span><span class="hljs-class">            .<span class="hljs-title">getCodeSource</span>().<span class="hljs-title">getLocation</span>()</span>;        <span class="hljs-keyword">try</span> &#123;            String path = location.toURI() + <span class="hljs-string">"index.html"</span>;            path = !path.contains(<span class="hljs-string">"file:"</span>) ? path : path.substring(<span class="hljs-number">5</span>);            INDEX = <span class="hljs-keyword">new</span> File(path);        &#125; <span class="hljs-keyword">catch</span> (URISyntaxException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Unable to locate index.html"</span>, e);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpRequestHandler</span><span class="hljs-params">(String wsUri)</span> </span>&#123;        <span class="hljs-keyword">this</span>.wsUri = wsUri;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,FullHttpRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 如果请求了WebSocket协议升级，则增加引用计数（调用retain()方法），并将它传递给下一个 ChannelInboundHandler</span>        <span class="hljs-keyword">if</span> (wsUri.equalsIgnoreCase(request.getUri())) &#123;            ctx.fireChannelRead(request.retain());         &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 处理100 Continue请求以符合HTTP1.1 规范</span>            <span class="hljs-keyword">if</span> (HttpHeaders.is100ContinueExpected(request)) &#123;                 send100Continue(ctx);            &#125;            <span class="hljs-comment">// 读取index.html</span>            RandomAccessFile file = <span class="hljs-keyword">new</span> RandomAccessFile(INDEX, <span class="hljs-string">"r"</span>);             HttpResponse response = <span class="hljs-keyword">new</span> DefaultHttpResponse(            request.getProtocolVersion(), HttpResponseStatus.OK);            response.headers().set(HttpHeaders.Names.CONTENT_TYPE,<span class="hljs-string">"text/plain; charset=UTF-8"</span>);            <span class="hljs-keyword">boolean</span> keepAlive = HttpHeaders.isKeepAlive(request);            <span class="hljs-keyword">if</span> (keepAlive) &#123;                response.headers().set(HttpHeaders.Names.CONTENT_LENGTH, file.length());                response.headers().set( HttpHeaders.Names.CONNECTION,HttpHeaders.Values.KEEP_ALIVE);            &#125;            <span class="hljs-comment">// 将HttpResponse写到客户端</span>            ctx.write(response);             <span class="hljs-keyword">if</span> (ctx.pipeline().get(SslHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>== <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 将index.html写到客户端</span>                ctx.write(<span class="hljs-keyword">new</span> DefaultFileRegion(file.getChannel(), <span class="hljs-number">0</span>, file.length()));             &#125; <span class="hljs-keyword">else</span> &#123;                ctx.write(<span class="hljs-keyword">new</span> ChunkedNioFile(file.getChannel()));            &#125;            <span class="hljs-comment">// 写LastHttpContent并冲刷至客户端</span>            ChannelFuture future = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);             <span class="hljs-comment">// 如果没有请求keep-alive，则在写操作完成后关闭Channel</span>            <span class="hljs-keyword">if</span> (!keepAlive) &#123;                 future.addListener(ChannelFutureListener.CLOSE);            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send100Continue</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;        FullHttpResponse response = <span class="hljs-keyword">new</span> DefaultFullHttpResponse(        HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE);        ctx.writeAndFlush(response);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre></div><p>如果该HTTP请求指向了地址为/ws的URI，那么HttpRequestHandler将调用FullHttpRequest对象上的retain()方法，并通过调用fireChannelRead(msg)方法将它转发给下一个ChannelInboundHandler。之所以需要调用retain()方法，是因为调用channelRead()方法完成之后，它将调用FullHttpRequest对象上的release()方法来释放它的资源。</p><h2 id="处理WebSocket帧"><a href="#处理WebSocket帧" class="headerlink" title="处理WebSocket帧"></a>处理WebSocket帧</h2><p><img src="https://img-blog.csdnimg.cn/20200603203324279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>TextWebSocketFrame是我们唯一真正需要处理的帧类型。Netty提供了WebSocketServerProtocolHandler来处理其他类型的帧。<br>下面代码展示了我们用于处理TextWebSocketFrame的ChannelInboundHandler，其还将在它的ChannelGroup中跟踪所有活动的WebSocket连接。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextWebSocketFrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">TextWebSocketFrame</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelGroup group;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TextWebSocketFrameHandler</span><span class="hljs-params">(ChannelGroup group)</span> </span>&#123;        <span class="hljs-keyword">this</span>.group = group;    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 重写userEventTriggered()方法以处理自定义事件</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 如果该事件表示握手成功，则从该Channelipeline中移除HttpRequestHandler，因为将不会接收到任何HTTP 消息了</span>        <span class="hljs-keyword">if</span> (evt == WebSocketServerProtocolHandler.ServerHandshakeStateEvent.HANDSHAKE_COMPLETE) &#123;            ctx.pipeline().remove(HttpRequestHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            <span class="hljs-comment">// 通知所有已经连接的WebSocket 客户端新的客户端已经连接上了</span>            group.writeAndFlush(<span class="hljs-keyword">new</span> TextWebSocketFrame(<span class="hljs-string">"Client "</span> + ctx.channel() + <span class="hljs-string">" joined"</span>));            <span class="hljs-comment">// 将新的WebSocket Channel添加到ChannelGroup 中，以便它可以接收到所有的消息</span>            group.add(ctx.channel());        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">super</span>.userEventTriggered(ctx, evt);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,TextWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">// 增加消息的引用计数，并将它写到ChannelGroup 中所有已经连接的客户端</span>        group.writeAndFlush(msg.retain());     &#125;&#125;</code></pre></div><p>和之前一样，对于retain()方法的调用是必需的，因为当channelRead0()方法返回时，TextWebSocketFrame 的引用计数将会被减少。由于所有的操作都是异步的，因此，writeAndFlush()方法可能会在channelRead0()方法返回之后完成，而且它绝对不能访问一个已经失效的引用。</p><h2 id="初始化ChannelPipeline"><a href="#初始化ChannelPipeline" class="headerlink" title="初始化ChannelPipeline"></a>初始化ChannelPipeline</h2><p>为了将ChannelHandler安装到ChannelPipeline中，需要扩展ChannelInitializer，并实现initChannel()方法。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatServerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelGroup group;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ChatServerInitializer</span><span class="hljs-params">(ChannelGroup group)</span> </span>&#123;        <span class="hljs-keyword">this</span>.group = group;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//将所有有需要的ChannelHandler添加到ChannelPipeline中</span>        ChannelPipeline pipeline = ch.pipeline();        pipeline.addLast(<span class="hljs-keyword">new</span> HttpServerCodec());        pipeline.addLast(<span class="hljs-keyword">new</span> ChunkedWriteHandler());        pipeline.addLast(<span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">64</span> * <span class="hljs-number">1024</span>));        pipeline.addLast(<span class="hljs-keyword">new</span> HttpRequestHandler(<span class="hljs-string">"/ws"</span>));        pipeline.addLast(<span class="hljs-keyword">new</span> WebSocketServerProtocolHandler(<span class="hljs-string">"/ws"</span>));        pipeline.addLast(<span class="hljs-keyword">new</span> TextWebSocketFrameHandler(group));    &#125;&#125;</code></pre></div><p>下面是基于WebSocket聊天服务器的ChannelHandler及各自的职责：<br><img src="https://img-blog.csdnimg.cn/20200603204803165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Netty的WebSocketServerProtocolHandler处理了所有委托管理的WebSocket帧类型以及升级握手本身，如果握手成功，那么所需的ChannelHandler将会被添加到ChannelPipeline中，而那些不再需要的ChannelHandler则将会被移除。<br>WebSocket 协议升级之前的ChannelPipeline：<br><img src="https://img-blog.csdnimg.cn/20200603205148885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>WebSocket 协议升级完成之后的ChannelPipeline：<br><img src="https://img-blog.csdnimg.cn/20200603205201947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h2><p>由ChatServer类来引导服务器，并安装ChatServerInitializer的代码。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatServer</span> </span>&#123;<span class="hljs-comment">//创建DefaultChannelGroup，其将保存所有已经连接的WebSocketChannel</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelGroup channelGroup =            <span class="hljs-keyword">new</span> DefaultChannelGroup(ImmediateEventExecutor.INSTANCE);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();    <span class="hljs-keyword">private</span> Channel channel;    <span class="hljs-comment">//引导服务器</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">start</span><span class="hljs-params">(InetSocketAddress address)</span> </span>&#123;        ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();        bootstrap.group(group)                .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                .<span class="hljs-title">childHandler</span>(<span class="hljs-title">createInitializer</span>(<span class="hljs-title">channelGroup</span>))</span>;        ChannelFuture future = bootstrap.bind(address);        future.syncUninterruptibly();        channel = future.channel();        <span class="hljs-keyword">return</span> future;    &#125;    <span class="hljs-comment">//创建ChatServerInitializer</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> ChannelInitializer&lt;Channel&gt; <span class="hljs-title">createInitializer</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            ChannelGroup group)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ChatServerInitializer(group);    &#125;    <span class="hljs-comment">//处理服务器关闭，并释放所有的资源</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>) &#123;            channel.close();        &#125;        channelGroup.close();        group.shutdownGracefully();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">if</span> (args.length != <span class="hljs-number">1</span>) &#123;            System.err.println(<span class="hljs-string">"Please give port as argument"</span>);            System.exit(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">int</span> port = Integer.parseInt(args[<span class="hljs-number">0</span>]);        <span class="hljs-keyword">final</span> ChatServer endpoint = <span class="hljs-keyword">new</span> ChatServer();        ChannelFuture future = endpoint.start(                <span class="hljs-keyword">new</span> InetSocketAddress(port));        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                endpoint.destroy();            &#125;        &#125;);        future.channel().closeFuture().syncUninterruptibly();    &#125;&#125;</code></pre></div><h1 id="测试该应用程序"><a href="#测试该应用程序" class="headerlink" title="测试该应用程序"></a>测试该应用程序</h1><p>略</p><h2 id="如何进行加密"><a href="#如何进行加密" class="headerlink" title="如何进行加密"></a>如何进行加密</h2><p>为ChannelPipeline加密：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//扩展ChatServerInitializer来加密</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecureChatServerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChatServerInitializer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SslContext context;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SecureChatServerInitializer</span><span class="hljs-params">(ChannelGroup group, SslContext context)</span> </span>&#123;        <span class="hljs-keyword">super</span>(group);        <span class="hljs-keyword">this</span>.context = context;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">super</span>.initChannel(ch);        <span class="hljs-comment">//调用父类的initChannel()方法</span>        SSLEng.ine engine = context.newEngine(ch.alloc());        engine.setUseClientMode(<span class="hljs-keyword">false</span>);        <span class="hljs-comment">//将SslHandler添加到ChannelPipeline中</span>        ch.pipeline().addFirst(<span class="hljs-keyword">new</span> SslHandler(engine));    &#125;&#125;</code></pre></div><p>最后一步是调整ChatServer以使用SecureChatServerInitializer，以便在ChannelPipeline中安装SslHandler。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecureChatServer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChatServer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SslContext context;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SecureChatServer</span><span class="hljs-params">(SslContext context)</span> </span>&#123;        <span class="hljs-keyword">this</span>.context = context;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> ChannelInitializer&lt;Channel&gt; <span class="hljs-title">createInitializer</span><span class="hljs-params">(ChannelGroup group)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SecureChatServerInitializer(group, context); <span class="hljs-comment">// 返回之前创建的SecureChatServerInitializer 以启用加密</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">if</span> (args.length != <span class="hljs-number">1</span>) &#123;            System.err.println(<span class="hljs-string">"Please give port as argument"</span>);            System.exit(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">int</span> port = Integer.parseInt(args[<span class="hljs-number">0</span>]);        SelfSignedCertificate cert = <span class="hljs-keyword">new</span> SelfSignedCertificate();        SslContext context = SslContext.newServerContext(cert.certificate(), cert.privateKey());        <span class="hljs-keyword">final</span> SecureChatServer endpoint = <span class="hljs-keyword">new</span> SecureChatServer(context);        ChannelFuture future = endpoint.start(<span class="hljs-keyword">new</span> InetSocketAddress(port));        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                endpoint.destroy();            &#125;        &#125;);        future.channel().closeFuture().syncUninterruptibly();    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11.Netty--预置的ChannelHandler和编解码器</title>
    <link href="/2020/06/03/11-Netty-%E9%A2%84%E7%BD%AE%E7%9A%84ChannelHandler%E5%92%8C%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/"/>
    <url>/2020/06/03/11-Netty-%E9%A2%84%E7%BD%AE%E7%9A%84ChannelHandler%E5%92%8C%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>通过SSL/TLS保护Netty应用程序；</li><li>构建基于Netty的HTTP/HTTPS应用程序</li><li>处理空闲的连接和超时</li><li>解码基于分隔符的协议和基于长度的协议</li><li>写大型数据</li><li>Netty为许多通用协议提供了编解码器和处理器，几乎可以开箱即用。</li></ul></blockquote><h1 id="通过SSL-TLS保护Netty应用程序"><a href="#通过SSL-TLS保护Netty应用程序" class="headerlink" title="通过SSL/TLS保护Netty应用程序"></a>通过SSL/TLS保护Netty应用程序</h1><p>为了支持SSL/TLS，Java提供了javax.net.ssl包，它的SSLContext和SSLEngine类使得实现解密和加密相当简单直接。Netty通过一个名为SslHandler的ChannelHandler实现利用了这个API，其中SslHandler在内部使用了SSLEngine来完成实际的工作。<br>下图是通过SslHandler进行解密和加密的数据流。<br><img src="https://img-blog.csdnimg.cn/20200603120939780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Netty还提供了使用OpenSSL工具包的SSLEngine实现，该类提供了比JDK提供的SSLEngine具有更好的性能。<br>下面的代码展示了如何使用ChannelInitializer来将SslHandler添加到ChannelPipeline中。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SslChannelInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt;</span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SslContext context; <span class="hljs-comment">// 传入要使用的SslContext</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> startTls; <span class="hljs-comment">// 如果设置为true，第一个写入的消息将不会被加密（客户端应该设置为true）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SslChannelInitializer</span><span class="hljs-params">(SslContext context,<span class="hljs-keyword">boolean</span> startTls)</span> </span>&#123;        <span class="hljs-keyword">this</span>.context = context;        <span class="hljs-keyword">this</span>.startTls = startTls;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 对于每个SslHandler实例，都使用Channel的ByteBufAllocator从SslContext获取一个新的SSLEngine</span>        SSLEngine engine = context.newEngine(ch.alloc());        <span class="hljs-comment">// 将SslHandler 作为第一个ChannelHandler 添加到ChannelPipeline 中</span>        ch.pipeline().addFirst(<span class="hljs-string">"ssl"</span>,<span class="hljs-keyword">new</span> SslHandler(engine, startTls));    &#125;&#125;</code></pre></div><p>在大多数情况下，SslHandler将是ChannelPipeline中的第一个ChannelHandler，这确保了只有在所有其他的ChannelHandler将他们的逻辑应用到数据之后，才会进行加密。<br>SslHandler提供的一些方法：<br><img src="https://img-blog.csdnimg.cn/20200603121820849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="构建基于Netty的HTTP-HTTPS应用程序"><a href="#构建基于Netty的HTTP-HTTPS应用程序" class="headerlink" title="构建基于Netty的HTTP/HTTPS应用程序"></a>构建基于Netty的HTTP/HTTPS应用程序</h1><h2 id="HTTP解码器、编码器和编解码器"><a href="#HTTP解码器、编码器和编解码器" class="headerlink" title="HTTP解码器、编码器和编解码器"></a>HTTP解码器、编码器和编解码器</h2><p>HTTP是基于请求/响应模式的：客户端向服务器发送一个HTTP请求，然后服务器将会返回一个HTTP响应。<br>下图分别展示了生产和消费HTTP请求和HTTP响应的方法：<br>HTTP 请求的组成部分：<br><img src="https://img-blog.csdnimg.cn/20200603122819791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="HTTP 请求的组成部分"><br>HTTP 响应的组成部分：<br><img src="https://img-blog.csdnimg.cn/20200603122907848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>下面的代码展示了将HTTP支持添加到你的应用程序，几乎只需要将正确的ChannelHandler添加到ChannelPipeline中。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpPipelineInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> client;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpPipelineInitializer</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> client)</span> </span>&#123;        <span class="hljs-keyword">this</span>.client = client;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        <span class="hljs-keyword">if</span> (client) &#123;         <span class="hljs-comment">// 如果是客户端，则添加HttpResponseDecoder来处理来自服务器的响应</span>            pipeline.addLast(<span class="hljs-string">"decoder"</span>, <span class="hljs-keyword">new</span> HttpResponseDecoder());            <span class="hljs-comment">//如果是客户端，则添加HttpRequestEncoder来向服务器发送请求</span>            pipeline.addLast(<span class="hljs-string">"encoder"</span>, <span class="hljs-keyword">new</span> HttpRequestEncoder());        &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//如果是服务器，则添加HttpRequestDecoder来接收来自客户端的请求</span>            pipeline.addLast(<span class="hljs-string">"decoder"</span>, <span class="hljs-keyword">new</span> HttpRequestDecoder());            <span class="hljs-comment">//如果是服务器，则添加HttpResponseEncoder以向客户端发送响应</span>            pipeline.addLast(<span class="hljs-string">"encoder"</span>, <span class="hljs-keyword">new</span> HttpResponseEncoder());        &#125;    &#125;&#125;</code></pre></div><h2 id="聚合HTTP消息"><a href="#聚合HTTP消息" class="headerlink" title="聚合HTTP消息"></a>聚合HTTP消息</h2><p>由于HTTP 的请求和响应可能由许多部分组成，因此你需要聚合它们以形成完整的消息。为了消除这项繁琐的任务，Netty 提供了一个聚合器，它可以将多个消息部分合并为FullHttpRequest 或者FullHttpResponse 消息。<br>引入这种自动聚合机制只不过是向ChannelPipeline中添加另外一个ChannelHandler罢了。<br>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 自动聚合HTTP 的消息片段</span><span class="hljs-comment">*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpAggregatorInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isClient;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpAggregatorInitializer</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isClient)</span> </span>&#123;        <span class="hljs-keyword">this</span>.isClient = isClient;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        <span class="hljs-keyword">if</span> (isClient) &#123;            pipeline.addLast(<span class="hljs-string">"codec"</span>, <span class="hljs-keyword">new</span> HttpClientCodec());        &#125; <span class="hljs-keyword">else</span> &#123;            pipeline.addLast(<span class="hljs-string">"codec"</span>, <span class="hljs-keyword">new</span> HttpServerCodec());        &#125;        <span class="hljs-comment">//将最大的消息大小为512KB的HttpObjectAggregator添加到ChannelPipeline</span>        pipeline.addLast(<span class="hljs-string">"aggregator"</span>,<span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">512</span> * <span class="hljs-number">1024</span>));    &#125;&#125;</code></pre></div><h2 id="HTTP压缩"><a href="#HTTP压缩" class="headerlink" title="HTTP压缩"></a>HTTP压缩</h2><p>Netty 为压缩和解压缩提供了ChannelHandler 实现，它们同时支持gzip 和deflate 编码。<br>客户端可以通过提供以下头部信息来指示服务器它所支持的压缩格式：</p><div class="hljs"><pre><code class="hljs markup">GET &#x2F;encrypted-area HTTP&#x2F;1.1Host: www.example.comAccept-Encoding: gzip, deflate</code></pre></div><p>注意：服务器不需要压缩它所发送的数据<br>下面代码展示了自动压缩HTTP消息</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 自动压缩HTTP 消息</span><span class="hljs-comment">*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpCompressionInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isClient;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpCompressionInitializer</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isClient)</span> </span>&#123;        <span class="hljs-keyword">this</span>.isClient = isClient;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        <span class="hljs-keyword">if</span> (isClient) &#123;            pipeline.addLast(<span class="hljs-string">"codec"</span>, <span class="hljs-keyword">new</span> HttpClientCodec());            <span class="hljs-comment">// 如果是客户端，则添加HttpContentDecompressor 以处理来自服务器的压缩内容.</span>            pipeline.addLast(<span class="hljs-string">"decompressor"</span>,<span class="hljs-keyword">new</span> HttpContentDecompressor());        &#125; <span class="hljs-keyword">else</span> &#123;            pipeline.addLast(<span class="hljs-string">"codec"</span>, <span class="hljs-keyword">new</span> HttpServerCodec());            <span class="hljs-comment">// 如果是服务器，则添加HttpContentCompressor来压缩数据（如果客户端支持它）</span>            pipeline.addLast(<span class="hljs-string">"compressor"</span>,<span class="hljs-keyword">new</span> HttpContentCompressor());        &#125;    &#125;&#125;</code></pre></div><h2 id="使用HTTPS"><a href="#使用HTTPS" class="headerlink" title="使用HTTPS"></a>使用HTTPS</h2><p>启用HTTPS只需要将SslHandler添加到ChannelPipeline的ChannelHandler组合中。<br>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpsCodecInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SslContext context;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isClient;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpsCodecInitializer</span><span class="hljs-params">(SslContext context, <span class="hljs-keyword">boolean</span> isClient)</span> </span>&#123;        <span class="hljs-keyword">this</span>.context = context;        <span class="hljs-keyword">this</span>.isClient = isClient;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        SSLEngine engine = context.newEngine(ch.alloc());        <span class="hljs-comment">//将SslHandler添加到ChannelPipeline中以使用HTTPS</span>        pipeline.addFirst(<span class="hljs-string">"ssl"</span>, <span class="hljs-keyword">new</span> SslHandler(engine));        <span class="hljs-comment">//如果是客户端，则添加HttpClientCodec</span>        <span class="hljs-keyword">if</span> (isClient) &#123;            pipeline.addLast(<span class="hljs-string">"codec"</span>, <span class="hljs-keyword">new</span> HttpClientCodec());        <span class="hljs-comment">//如果是服务器，则添加HttpServerCodec</span>        &#125; <span class="hljs-keyword">else</span> &#123;            pipeline.addLast(<span class="hljs-string">"codec"</span>, <span class="hljs-keyword">new</span> HttpServerCodec());        &#125;    &#125;&#125;</code></pre></div><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket为网页和远程服务器之间的双向通信提供了一种替代HTTP轮询的方案。<br>如果想要在应用程序中添加对于WebSocket的支持，只需要将适当的客户端或者服务器WebSocketChannelHandler添加到ChannelPipeline中，这个类将处理由WebSocket定义的称为帧的特殊消息类型。<br>WebSocket协议如下：<br><img src="https://img-blog.csdnimg.cn/2020060313363214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>WebSocketFrame可以被归类于数据帧或者控制帧，主要类型如下：<br><img src="https://img-blog.csdnimg.cn/20200603133805130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在服务器端支持WebSocket的代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketServerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt;</span>&#123;    <span class="hljs-meta">@Override</span>        ch.pipeline().addLast(        <span class="hljs-keyword">new</span> HttpServerCodec(),        <span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">65536</span>), <span class="hljs-comment">// 为握手提供聚合的HttpRequest</span>        <span class="hljs-keyword">new</span> WebSocketServerProtocolHandler(<span class="hljs-string">"/websocket"</span>), <span class="hljs-comment">// 如果被请求的端点是"/websocket"，则处理该升级握手</span>        <span class="hljs-keyword">new</span> TextFrameHandler(), <span class="hljs-comment">// TextFrameHandler 处理TextWebSocketFrame</span>        <span class="hljs-keyword">new</span> BinaryFrameHandler(),        <span class="hljs-keyword">new</span> ContinuationFrameHandler());    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextFrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">TextWebSocketFrame</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,TextWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Handle text frame</span>        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryFrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">BinaryWebSocketFrame</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,BinaryWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Handle binary frame</span>        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContinuationFrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ContinuationWebSocketFrame</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,ContinuationWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Handle continuation frame</span>        &#125;    &#125;&#125;</code></pre></div><p>想要为WebSocket添加安全性，只需要将SslHandler作为第一个ChannelHandler添加到ChannelPipeline中。</p><h1 id="空闲的连接和超时"><a href="#空闲的连接和超时" class="headerlink" title="空闲的连接和超时"></a>空闲的连接和超时</h1><p>检测空闲连接以及超时连接对于及时释放资源来说是至关重要的，Netty特地为它提供了几个ChannelHandler实现。<br><img src="https://img-blog.csdnimg.cn/20200603142124762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>下列代码展示了当我们通常的发送心跳消息到远程节点的方法时，如果在60s内没有接收或者发送任何的数据，我们将如何得到通知；如果没有响应，则连接会被关闭。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdleStateHandlerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        <span class="hljs-comment">// IdleStateHandler 将在被触发时发送一个IdleStateEvent 事件</span>        pipeline.addLast(<span class="hljs-keyword">new</span> IdleStateHandler(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS));        <span class="hljs-comment">//将一个HeartbeatHandler添加到ChannelPipeline中</span>        pipeline.addLast(<span class="hljs-keyword">new</span> HeartbeatHandler());    &#125;    <span class="hljs-comment">//实现userEventTriggered()方法以发送心跳消息</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeartbeatHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-comment">//发送到远程节点的心跳消息</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ByteBuf HEARTBEAT_SEQUENCE =Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(<span class="hljs-string">"HEARTBEAT"</span>, CharsetUtil.ISO_8859_1));        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx,Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-keyword">if</span> (evt <span class="hljs-keyword">instanceof</span> IdleStateEvent) &#123;             <span class="hljs-comment">// 发送心跳消息，并在发送失败时关闭该连接</span>                ctx.writeAndFlush(HEARTBEAT_SEQUENCE.duplicate())                    .addListener(ChannelFutureListener.CLOSE_ON_FAILURE);            &#125; <span class="hljs-keyword">else</span> &#123;             <span class="hljs-comment">// 不是IdleStateEvent事件，所以将它传递给下一个ChannelInboundHandler</span>                <span class="hljs-keyword">super</span>.userEventTriggered(ctx, evt);            &#125;        &#125;    &#125;&#125;</code></pre></div><p>上面这个示例演示了如何使用IdleStateHandler来测试远程节点是否仍然还活着，并且在它失活时通过关闭连接来释放资源。<br>如果连接超过60s没有接收或者发送任何的数据，那么IdleStateHandler将会使用一个IdleStateEvent事件来调用fireUserEventTriggered()方法。HeartbeatHandler实现了userEventTriggered()方法，如果这个方法检测到IdleSstateEvent事件，它将会发送心跳消息，并且添加一个将在发送操作失败时关闭该连接的ChannelFutureListener。</p><h1 id="解码基于分隔符的协议和基于长度的协议"><a href="#解码基于分隔符的协议和基于长度的协议" class="headerlink" title="解码基于分隔符的协议和基于长度的协议"></a>解码基于分隔符的协议和基于长度的协议</h1><h2 id="基于分隔符的协议"><a href="#基于分隔符的协议" class="headerlink" title="基于分隔符的协议"></a>基于分隔符的协议</h2><p>基于分隔符的（delimited）消息协议使用定义的字符来标记的消息或者消息段（通常被称为帧）的开头或者结尾。由RFC文档正式定义的许多协议（如SMTP、POP3、IMAP以及Telnet）都是这样的。<br><img src="https://img-blog.csdnimg.cn/20200603143648459.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>下图展示了当帧由行尾序列\r\n分割时是如何被处理的：<br><img src="https://img-blog.csdnimg.cn/20200603143900748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LineBasedHandlerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        <span class="hljs-comment">//该LineBasedFrameDecoder将提取的帧转发给下一个ChannelInboundHandler</span>        pipeline.addLast(<span class="hljs-keyword">new</span> LineBasedFrameDecoder(<span class="hljs-number">64</span> * <span class="hljs-number">1024</span>));        <span class="hljs-comment">//添加FrameHandler来接收帧</span>        pipeline.addLast(<span class="hljs-keyword">new</span> FrameHandler());    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-comment">//传入了单个帧的内容</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Do something with the data extracted from the frame</span>        &#125;    &#125;&#125;</code></pre></div><p>作为示例，我们将使用下面的协议规范：<br>1.传入数据流是一系列的帧，每个帧都由换行符（\n）分隔；<br>2.每个帧都由一系列的元素组成，每个元素都由单个空格字符分隔；<br>3.一个帧的内容代表一个命令，定义为一个命令名称后跟着数目可变的参数。<br>我们用于这个协议的自定义解码器将定义以下类：<br>1.Cmd—将帧（命令）的内容存储在ByteBuf 中，一个ByteBuf 用于名称，另一个用于参数；<br>2.CmdDecoder—从被重写了的decode()方法中获取一行字符串，并从它的内容构建一个Cmd 的实例；<br>3.CmdHandler —从CmdDecoder 获取解码的Cmd 对象，并对它进行一些处理；<br>4.CmdHandlerInitializer —为了简便起见，我们将会把前面的这些类定义为专门的ChannelInitializer 的嵌套类，其将会把这些ChannelInboundHandler 安装到ChannelPipeline 中。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CmdHandlerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> SPACE = (<span class="hljs-keyword">byte</span>)<span class="hljs-string">' '</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        pipeline.addLast(<span class="hljs-keyword">new</span> CmdDecoder(<span class="hljs-number">64</span> * <span class="hljs-number">1024</span>)); <span class="hljs-comment">// 添加CmdDecoder 以提取Cmd 对象，并将它转发给下一个ChannelInboundHandler</span>        pipeline.addLast(<span class="hljs-keyword">new</span> CmdHandler()); <span class="hljs-comment">// 添加CmdHandler 以接收和处理Cmd 对象</span>    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cmd</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ByteBuf name;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ByteBuf args;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cmd</span><span class="hljs-params">(ByteBuf name, ByteBuf args)</span> </span>&#123;            <span class="hljs-keyword">this</span>.name = name;            <span class="hljs-keyword">this</span>.args = args;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> name;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title">args</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> args;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CmdDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LineBasedFrameDecoder</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CmdDecoder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxLength)</span> </span>&#123;            <span class="hljs-keyword">super</span>(maxLength);        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf buffer)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//从ByteBuf中提取由行尾符序列分割的帧</span>            ByteBuf frame = (ByteBuf) <span class="hljs-keyword">super</span>.decode(ctx, buffer);            <span class="hljs-keyword">if</span> (frame == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            <span class="hljs-comment">// 查找第一个空格字符的索引。前面是命令名称，接着是参数</span>            <span class="hljs-keyword">int</span> index = frame.indexOf(frame.readerIndex(),frame.writerIndex(), SPACE);            <span class="hljs-comment">// 使用包含有命令名称和参数的切片创建新的Cmd 对象</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Cmd(frame.slice(frame.readerIndex(), index),frame.slice(index + <span class="hljs-number">1</span>, frame.writerIndex()));        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CmdHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">Cmd</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, Cmd msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Do something with the command(获取Cmd对象进一步操作)</span>        &#125;    &#125;&#125;</code></pre></div><h2 id="基于长度的协议"><a href="#基于长度的协议" class="headerlink" title="基于长度的协议"></a>基于长度的协议</h2><p><img src="https://img-blog.csdnimg.cn/20200603144720346.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200603144751918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>如果遇到被编码到消息头部的帧大小不是固定值的协议，为了处理这种变长帧，可以使用LengthFieldBasedFrameDecoder，它将从头部字段确定帧长，然后从数据流中提取指定的字节数。<br><img src="https://img-blog.csdnimg.cn/20200603145131132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LengthBasedInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        pipeline.addLast(<span class="hljs-keyword">new</span> LengthFieldBasedFrameDecoder(<span class="hljs-number">64</span> * <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>));        pipeline.addLast(<span class="hljs-keyword">new</span> FrameHandler());    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Do something with the frame</span>        &#125;    &#125;&#125;</code></pre></div><h1 id="写大型数据"><a href="#写大型数据" class="headerlink" title="写大型数据"></a>写大型数据</h1><p>由于写操作是非阻塞的，所在存在内存耗尽的风险，因此在写大型数据时，需要准备好处理到远程节点的连接是慢速连接的情况，这种情况会导致内存释放的延迟。<br>下面代码展示了如何通过从FileInputStream创建一个DefaultRegion，并将其写入Channel，从而利用零拷贝特性来传输一个文件的内容。</p><div class="hljs"><pre><code class="hljs java">FileInputStream in = <span class="hljs-keyword">new</span> FileInputStream(file);<span class="hljs-comment">// 以该文件的完整长度创建一个新的DefaultFileRegion</span>FileRegion region = <span class="hljs-keyword">new</span> DefaultFileRegion(in.getChannel(), <span class="hljs-number">0</span>, file.length());<span class="hljs-comment">// 发送该DefaultFileRegion，并注册一个ChannelFutureListener</span>channel.writeAndFlush(region).addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">if</span> (!future.isSuccess()) &#123;            Throwable cause = future.cause(); <span class="hljs-comment">// 处理失败</span>            <span class="hljs-comment">// Do something</span>        &#125;    &#125;&#125;);</code></pre></div><p>这个示例只适用于文件内容的直接传输，不包括应用程序对数据的任何处理。在需要将数据从文件系统复制到用户内存中时，可以使用ChunkedWriteHandler，它支持异步写大型数据流，而又不会导致大量的内存消耗。<br><img src="https://img-blog.csdnimg.cn/20200603150611949.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>下面代码展示了ChunkedStream的用法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChunkedWriteHandlerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> File file;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SslContext sslCtx;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ChunkedWriteHandlerInitializer</span><span class="hljs-params">(File file, SslContext sslCtx)</span> </span>&#123;        <span class="hljs-keyword">this</span>.file = file;        <span class="hljs-keyword">this</span>.sslCtx = sslCtx;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        <span class="hljs-comment">//将SslHandler添加到ChannelPipeline中</span>        pipeline.addLast(<span class="hljs-keyword">new</span> SslHandler(sslCtx.newEngine(ch.alloc());        <span class="hljs-comment">//添加ChunkedWritHandler以处理作为ChunkedInput传入的数据</span>        pipeline.addLast(<span class="hljs-keyword">new</span> ChunkedWriteHandler());        <span class="hljs-comment">// 一旦连接建立，WriteStreamHandler就开始写文件数据</span>        pipeline.addLast(<span class="hljs-keyword">new</span> WriteStreamHandler());     &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteStreamHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-comment">//当连接建立时，channelActive()方法将使用ChunkedInput写文件数据</span>        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span><span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-keyword">super</span>.channelActive(ctx);            ctx.writeAndFlush(<span class="hljs-keyword">new</span> ChunkedStream(<span class="hljs-keyword">new</span> FileInputStream(file)));        &#125;    &#125;&#125;</code></pre></div><h1 id="序列化数据"><a href="#序列化数据" class="headerlink" title="序列化数据"></a>序列化数据</h1><h2 id="JDK序列化"><a href="#JDK序列化" class="headerlink" title="JDK序列化"></a>JDK序列化</h2><p><img src="https://img-blog.csdnimg.cn/20200603151321484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="JBoss-Marshalling序列化"><a href="#JBoss-Marshalling序列化" class="headerlink" title="JBoss Marshalling序列化"></a>JBoss Marshalling序列化</h2><p><img src="https://img-blog.csdnimg.cn/20200603151359976.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>下面代码展示了如何使用MarshallingDecoder和MarshallingEncoder：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MarshallingInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MarshallerProvider marshallerProvider;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UnmarshallerProvider unmarshallerProvider;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MarshallingInitializer</span><span class="hljs-params">(UnmarshallerProvider unmarshallerProvider,MarshallerProvider marshallerProvider)</span> </span>&#123;        <span class="hljs-keyword">this</span>.marshallerProvider = marshallerProvider;        <span class="hljs-keyword">this</span>.unmarshallerProvider = unmarshallerProvider;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel channel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = channel.pipeline();        <span class="hljs-comment">//添加MarshallingDecoder以将ByteBuf转换为POJO</span>        pipeline.addLast(<span class="hljs-keyword">new</span> MarshallingDecoder(unmarshallerProvider));        <span class="hljs-comment">//添加MarshallingEncoder以将POJO转换为ByteBuf</span>        pipeline.addLast(<span class="hljs-keyword">new</span> MarshallingEncoder(marshallerProvider));        <span class="hljs-comment">// 添加ObjectHandler，以处理普通的实现了Serializable 接口的POJO</span>        pipeline.addLast(<span class="hljs-keyword">new</span> ObjectHandler());     &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">Serializable</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext,Serializable serializable)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Do something</span>        &#125;    &#125;&#125;</code></pre></div><h2 id="Protocol-Buffers序列化"><a href="#Protocol-Buffers序列化" class="headerlink" title="Protocol Buffers序列化"></a>Protocol Buffers序列化</h2><p>Protocol Buffers 以一种紧凑而高效的方式对结构化的数据进行编码以及解码。它具有许多的编程语言绑定，使得它很适合跨语言的项目。(由Google公司开发的、现在已经开源的数据交换格式。)<br><img src="https://img-blog.csdnimg.cn/20200603151801160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProtoBufInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MessageLite lite;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProtoBufInitializer</span><span class="hljs-params">(MessageLite lite)</span> </span>&#123;        <span class="hljs-keyword">this</span>.lite = lite;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        pipeline.addLast(<span class="hljs-keyword">new</span> ProtobufVarint32FrameDecoder());        pipeline.addLast(<span class="hljs-keyword">new</span> ProtobufEncoder()); ①        pipeline.addLast(<span class="hljs-keyword">new</span> ProtobufDecoder(lite));        pipeline.addLast(<span class="hljs-keyword">new</span> ObjectHandler());    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Do something with the object</span>        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10.Netty--编解码器框架</title>
    <link href="/2020/06/02/10-Netty-%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E6%A1%86%E6%9E%B6/"/>
    <url>/2020/06/02/10-Netty-%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>解码器、编码器以及编解码器的概述</li><li>Netty的编解码器类</li></ul></blockquote><h2 id="什么是编解码器"><a href="#什么是编解码器" class="headerlink" title="什么是编解码器"></a>什么是编解码器</h2><ul><li><p>编码器是将消息转换为适合于传输的格式（最有可能的就是字节流）；</p></li><li><p>解码器则是将网络字节流换回应用程序的消息格式；</p></li><li><p>编码器操作出站数据，解码器处理入站数据；</p></li></ul><h2 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h2><ul><li><p>将字节码解码为消息———ByteToMessageDecoder和ReplayingDecoder；</p></li><li><p>将一种消息类型解码为另一种———MessageToMessagedecoder</p></li></ul><p>因为解码器是负责将入站数据从一种格式转换到另一种格式，所以Netty的解码器实现了ChannelInboundHandler。</p><p>每当需要为ChannelPipeline中的下一个ChannelInboundHanler转换入站数据时会用到解码器，可以将多个解码器链接在一起，以实现任意复杂的转换逻辑。</p><h3 id="抽象类ByteToMessageDecoder"><a href="#抽象类ByteToMessageDecoder" class="headerlink" title="抽象类ByteToMessageDecoder"></a>抽象类ByteToMessageDecoder</h3><p>由于你不可能知道远程节点是否会一次性地发送一个完整的消息，所以这个类会对入站数据进行缓冲，直到它准备好处理。</p><p>ByteToMessageDecoder方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>decode(ChannelHandlerContext ctx,ByteBuf in,List<Objext> out)</td><td>decode()方法被调用时将会传入一个包含了传入数据的ByteBuf，以及一个用来添加解码消息的List，对这个方法的调用将会重复进行，直到确定没有新的元素被添加到该List，或者该ByteBuf中没有更多可读取的字节时为止。然后，如果该List不为空，那么它的内容将会被传递给ChannelPipeline中的下一个ChannelInboundHandler。</td></tr><tr><td>decodeLast(ChannelHandlerContext ctx,ByteBuf in,Lists<Object>out)</td><td>默认实现只是简单地调用了decode()方法，当Channel的状态变为非活动时，这个方法将会被调用一次，可以重写该方法来提供特殊的处理，比如用来产生一个LastHttpContent消息</td></tr></tbody></table><p>示例：假设你接收了一个包含简单int的字节流，每个int都需要被单独处理，在这种情况下，你需要从入站ByteBuf中读取每个int，并将它传递给ChannelPipeline中的下一个ChannelInboundHandler。为了解码这个字节流，你要扩展ByteToMessageDecoder类。</p><p><img src="https://img-blog.csdnimg.cn/20200603100430311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToIntegerDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in,</span></span><span class="hljs-function"><span class="hljs-params">        List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//检查是否至少有 4 字节可读（一个 int 的字节长度）</span>        <span class="hljs-keyword">if</span> (in.readableBytes() &gt;= <span class="hljs-number">4</span>) &#123;            <span class="hljs-comment">//从入站 ByteBuf 中读取一个 int，并将其添加到解码消息的 List 中</span>            out.add(in.readInt());        &#125;    &#125;&#125;</code></pre></div><h3 id="抽象类ReplayingDecoder"><a href="#抽象类ReplayingDecoder" class="headerlink" title="抽象类ReplayingDecoder"></a>抽象类ReplayingDecoder</h3><p>ReplayingDecoder扩展了ByteToMessageDecoder类，不必调用readableBytes()方法。它通过使用一个自定义的ByteBuf也就是ReplayingDecoderByteBuf来实现，包装传入的ByteBuf实现了这一点，readableBytes()方法将在内部执行。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToIntegerDecoder2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReplayingDecoder</span>&lt;<span class="hljs-title">Void</span>&gt; </span>&#123; <span class="hljs-comment">// 扩展ReplayingDecoder&lt;Void&gt;以将字节解码为消息</span>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 传入的ByteBuf 是ReplayingDecoderByteBuf</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in,List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;     <span class="hljs-comment">//从入站ByteBuf中读取一个int，并将其添加</span>        out.add(in.readInt());    &#125;&#125;</code></pre></div><p>如果没有足够的字节可用，这个readInt()方法的实现将会抛出一个Error（实际上是Signal），其将在基类中被捕获并处理，当有更多的数据可供读取时，该decode()方法将会被再次调用。<br>这里有一个简单的准则：如果使用ByteToMessageDecoder 不会引入太多的复杂性，那么请使用它；否则，请使用ReplayingDecoder。</p><h2 id="抽象类MessageToMessageDecoder"><a href="#抽象类MessageToMessageDecoder" class="headerlink" title="抽象类MessageToMessageDecoder"></a>抽象类MessageToMessageDecoder</h2><p>这里我们将编写一个IntegerToStringDecoder解码器来扩展MessageToMessageDecoder<Integer>,尖括号里面的参数代表了输入参数的类型。<br><img src="https://img-blog.csdnimg.cn/20200603102908817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerToStringDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageDecoder</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        out.add(String.valueOf(msg));    &#125;&#125;</code></pre></div><h2 id="TooLongFrameException类"><a href="#TooLongFrameException类" class="headerlink" title="TooLongFrameException类"></a>TooLongFrameException类</h2><p>Netty提供了TooLongFrameException类，其将由解码器在帧超出指定的大小限制时抛出。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SafeByteToMessageDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_FRAME_SIZE = <span class="hljs-number">1024</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in,</span></span><span class="hljs-function"><span class="hljs-params">        List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">int</span> readable = in.readableBytes();        <span class="hljs-keyword">if</span> (readable &gt; MAX_FRAME_SIZE) &#123; <span class="hljs-comment">// 检查缓冲区中是否有超过MAX_FRAME_SIZE个字节</span>            in.skipBytes(readable); <span class="hljs-comment">// 跳过所有的可读字节，抛出TooLongFrameException 并通知ChannelHandler</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TooLongFrameException(<span class="hljs-string">"Frame too big!"</span>);        &#125;        <span class="hljs-comment">// do something</span>        ...    &#125;&#125;</code></pre></div><h1 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h1><p>编码器实现了ChannelOutBoundHandler，并将出站数据从一种格式转换为另一种格式。Netty提供了一组类，用于帮助你编写具有以下功能的编码器：<br>将消息编码为字节；<br>将消息编码为另一种格式的消息；</p><h2 id="抽象类MessageToByteEncoder"><a href="#抽象类MessageToByteEncoder" class="headerlink" title="抽象类MessageToByteEncoder"></a>抽象类MessageToByteEncoder</h2><p><img src="https://img-blog.csdnimg.cn/20200603103905581.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>这个类只有一个方法，而解码器有两个，这是因为解码器通常需要在Channel关闭之后产生最后一个消息，因此也就有了decodeLast()方法，但是编码器就没必要在连接被关闭后仍产生消息了。<br>示例：接收一个Short类型的实例作为消息，将它编码为Short的原子类型，并将它写入ByteBuf中，其将随后被转发给ChannelPipeline中的下一个ChannelOutboundHandler，每个传出的Short值都将会被占用ByteBuf中的2字节。<br><img src="https://img-blog.csdnimg.cn/20200603104641304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShortToByteEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">Short</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Short msg, ByteBuf out)</span><span class="hljs-keyword">throws</span> Exception </span>&#123;        out.writeShort(msg);    &#125;&#125;</code></pre></div><h2 id="抽象类MessageToMessageEncoder"><a href="#抽象类MessageToMessageEncoder" class="headerlink" title="抽象类MessageToMessageEncoder"></a>抽象类MessageToMessageEncoder</h2><p>示例：使用IntegerToStringEncoder扩展了MessageToMessageEncoder，设计如图所示：<br><img src="https://img-blog.csdnimg.cn/20200603105140614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerToStringEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageEncoder</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        out.add(String.valueOf(msg));    &#125;&#125;</code></pre></div><h1 id="抽象的编解码器类"><a href="#抽象的编解码器类" class="headerlink" title="抽象的编解码器类"></a>抽象的编解码器类</h1><h2 id="抽象类ByteToMessageCodec"><a href="#抽象类ByteToMessageCodec" class="headerlink" title="抽象类ByteToMessageCodec"></a>抽象类ByteToMessageCodec</h2><p>应用场景：我们需要将字节解码为某种形式的消息，随后再次对它进行编码。<br><img src="https://img-blog.csdnimg.cn/20200603110056715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="抽象类MessageToMessageCodec"><a href="#抽象类MessageToMessageCodec" class="headerlink" title="抽象类MessageToMessageCodec"></a>抽象类MessageToMessageCodec</h2><p><img src="https://img-blog.csdnimg.cn/20200603111222346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>下面代码展示了Web浏览器与服务器之间的双向通信可能的实现方式：我们的WebSocketConvertHandler在参数化MessageToMessageCodec时将使用INBOUN_IN类型的WebSocketFrame，以及OUTBOUND_IN类型的MyWebSocketFrame，后者是WebSocketConvertHandler本身的一个静态嵌套类。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketConvertHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageCodec</span>&lt;<span class="hljs-title">WebSocketFrame</span>, <span class="hljs-title">WebSocketConvertHandler</span>.<span class="hljs-title">MyWebSocketFrame</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 将MyWebSocketFrame 编码为指定的WebSocketFrame 子类型</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, WebSocketConvertHandler.MyWebSocketFrame msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ByteBuf payload = msg.getData().duplicate().retain();        <span class="hljs-keyword">switch</span> (msg.getType()) &#123; <span class="hljs-comment">// 实例化一个指定子类型的WebSocketFrame</span>            <span class="hljs-keyword">case</span> BINARY:                out.add(<span class="hljs-keyword">new</span> BinaryWebSocketFrame(payload));                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> TEXT:                out.add(<span class="hljs-keyword">new</span> TextWebSocketFrame(payload));                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> CLOSE:                out.add(<span class="hljs-keyword">new</span> CloseWebSocketFrame(<span class="hljs-keyword">true</span>, <span class="hljs-number">0</span>, payload));                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> CONTINUATION:                out.add(<span class="hljs-keyword">new</span> ContinuationWebSocketFrame(payload));                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> PONG:                out.add(<span class="hljs-keyword">new</span> PongWebSocketFrame(payload));                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> PING:                out.add(<span class="hljs-keyword">new</span> PingWebSocketFrame(payload));                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(                        <span class="hljs-string">"Unsupported websocket msg "</span> + msg);        &#125;    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 将WebSocketFrame 解码为MyWebSocketFrame，并设置FrameType</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, WebSocketFrame msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ByteBuf payload = msg.content().duplicate().retain();        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> BinaryWebSocketFrame) &#123;            out.add(<span class="hljs-keyword">new</span> MyWebSocketFrame(                    MyWebSocketFrame.FrameType.BINARY, payload));        &#125; <span class="hljs-keyword">else</span>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> CloseWebSocketFrame) &#123;            out.add(<span class="hljs-keyword">new</span> MyWebSocketFrame (                    MyWebSocketFrame.FrameType.CLOSE, payload));        &#125; <span class="hljs-keyword">else</span>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> PingWebSocketFrame) &#123;            out.add(<span class="hljs-keyword">new</span> MyWebSocketFrame (                    MyWebSocketFrame.FrameType.PING, payload));        &#125; <span class="hljs-keyword">else</span>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> PongWebSocketFrame) &#123;            out.add(<span class="hljs-keyword">new</span> MyWebSocketFrame (                    MyWebSocketFrame.FrameType.PONG, payload));        &#125; <span class="hljs-keyword">else</span>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> TextWebSocketFrame) &#123;            out.add(<span class="hljs-keyword">new</span> MyWebSocketFrame (                    MyWebSocketFrame.FrameType.TEXT, payload));        &#125; <span class="hljs-keyword">else</span>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> ContinuationWebSocketFrame) &#123;            out.add(<span class="hljs-keyword">new</span> MyWebSocketFrame (                    MyWebSocketFrame.FrameType.CONTINUATION, payload));        &#125; <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(                    <span class="hljs-string">"Unsupported websocket msg "</span> + msg);        &#125;    &#125;    <span class="hljs-comment">//声明WebSocketConvertHandler所使用的OUTBOUND_IN类型</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebSocketFrame</span> </span>&#123;    <span class="hljs-comment">//定义拥有被包装的有效负载的WebSocketFrame的类型</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> FrameType &#123;            BINARY,            CLOSE,            PING,            PONG,            TEXT,            CONTINUATION        &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> FrameType type;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ByteBuf data;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyWebSocketFrame</span><span class="hljs-params">(FrameType type, ByteBuf data)</span> </span>&#123;            <span class="hljs-keyword">this</span>.type = type;            <span class="hljs-keyword">this</span>.data = data;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> FrameType <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> type;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> data;        &#125;    &#125;&#125;</code></pre></div><h2 id="CombinedChannelDuplexHandler类"><a href="#CombinedChannelDuplexHandler类" class="headerlink" title="CombinedChannelDuplexHandler类"></a>CombinedChannelDuplexHandler类</h2><p>结合一个解码器和编码器可能会对可重用性造成影响。但是，有一种方法既能够避免这种惩罚，又不会牺牲将一个解码器和一个编码器作为一个单独的单元部署所带来的便利性。CombinedChannelDuplexHandler 提供了这个解决方案，其声明为：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CombinedChannelDuplexHandler</span> &lt;<span class="hljs-title">I</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandler</span>,<span class="hljs-title">O</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelOutboundHandler</span>&gt;</span></code></pre></div><p>首先看看ByteToCharDecoder类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteToCharDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in,</span></span><span class="hljs-function"><span class="hljs-params">        List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">while</span> (in.readableBytes() &gt;= <span class="hljs-number">2</span>) &#123;            out.add(in.readChar());        &#125;    &#125;&#125;</code></pre></div><p>这里的decode()方法一次将从ByteBuf中提取2字节，并将它们作为char写入到List中，其将会被自动装箱为Character对象。<br>再来看看CharToByteEncoder类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CharToByteEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">Character</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Character msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        out.writeChar(msg);    &#125;&#125;</code></pre></div><p>既然我们有了编码器和解码器，我们可以将它们结合起来构建一个编解码器：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//通过该编码器和解码器实现参数化CombinnedByteCharCodec</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CombinedByteCharCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CombinedChannelDuplexHandler</span>&lt;<span class="hljs-title">ByteToCharDecoder</span>, <span class="hljs-title">CharToByteEncoder</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CombinedByteCharCodec</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//将委托实例传递给父类</span>        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> ByteToCharDecoder(), <span class="hljs-keyword">new</span> CharToByteEncoder());    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.Netty--单元测试</title>
    <link href="/2020/06/02/9-Netty-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <url>/2020/06/02/9-Netty-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>单元测试</li><li>EmbeddedChannel概述</li><li>使用EmbeddedChannel测试ChannelHandler</li></ul></blockquote><p>单元测试的标准：不仅能够证明你的实现是正确的，而且还要能够很容易地隔离那些因修改代码而突然出现的问题。</p><p>因为正在被测试的代码模块或者单元将在它正常的运行环境之外被执行，所以还需要一个框架或者脚手架以便在其中运行它（这里我们选择的是JUnit4）。</p><h2 id="EmbeddedChannel概述"><a href="#EmbeddedChannel概述" class="headerlink" title="EmbeddedChannel概述"></a>EmbeddedChannel概述</h2><p>我们的业务逻辑是通过将ChannelPipeline中的ChannelHandler实现链接在一起来完成的，每个ChannelHandler都将处理一个明确定义的任务或者是步骤。</p><p>Netty提供了EmbeddedChannel，用于测试ChannelHandler，其原理就是将入站数据或者出站数据写入EmbeddedChannel中，然后检查是否有任何东西到达了ChannelPipeline的尾端，以这种方式便可以确定消息是否已经被编译或者被解码过了，以及是否触发了任何的ChannelHandler动作。</p><p>EmbeddedChannel方法：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>writeInbound(Object…msgs)</td><td>将入站消息写入到EmbeddedChannel中，如果可以通过readInbound()方法从EmbeddedChannel中读取数据，则返回true</td></tr><tr><td>readInbound()</td><td>从EmbeddedChannel中读取一个入站消息，任何返回的消息都经过了整个ChannelPipeline，如果没有数据则返回null</td></tr><tr><td>writeOutbound(…)</td><td>将出站消息写入到EmbeddedChannel中，如果可以通过readOutbound()方法从EmbeddedChannel中读取数据，则返回true</td></tr><tr><td>readOutbound(…)</td><td>从EmbeddedChannel中读取一个出站消息，任何返回的消息都经过了整个ChannelPipeline，如果没有数据则返回null</td></tr><tr><td>finish()</td><td>结束EmbeddedChannel，如果里面有任何类型的可读数据都会返回true，它也会调用Channel的close方法</td></tr></tbody></table><p>EmbeededChannel的处理过程如图所示：</p><p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2399198972,3683808923&fm=15&gp=0.jpg" srcset="/img/loading.gif" alt="img"></p><h2 id="使用EmbeededChannel测试ChannelHandler"><a href="#使用EmbeededChannel测试ChannelHandler" class="headerlink" title="使用EmbeededChannel测试ChannelHandler"></a>使用EmbeededChannel测试ChannelHandler</h2><h3 id="JUnit断言"><a href="#JUnit断言" class="headerlink" title="JUnit断言"></a>JUnit断言</h3><p>org.junit.Assert类提供了很多用于测试的静态方法，失败的断言将导致一个异常被抛出，并将终止当前正在执行的测试。</p><h3 id="测试入站消息"><a href="#测试入站消息" class="headerlink" title="测试入站消息"></a>测试入站消息</h3><p>接下来实现一个简单的ByteToMessageDecoder，给定足够的数据，然后这个解码器将产生固定大小的帧，如果没有足够的数据可供的读取，它将等待下一个数据块的到来，并将再次检查是否能够产生一个新的帧。</p><p>我们代码是这个解码器产生固定为3个字节大小的帧，它可能会需要多个事件来提供足够的字节数来产生一个帧，最终每个帧都会被传递给ChannelPipeline中的下一个ChannelHandler。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FixedLengthFrameDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> frameLength;    <span class="hljs-comment">//指定要生成的帧的长度</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FixedLengthFrameDecoder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> frameLength)</span> </span>&#123;        <span class="hljs-keyword">if</span> (frameLength &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(                <span class="hljs-string">"frameLength must be a positive integer: "</span> + frameLength);        &#125;        <span class="hljs-keyword">this</span>.frameLength = frameLength;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in,</span></span><span class="hljs-function"><span class="hljs-params">        List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//检查是否有足够的字节可以被读取，以生成下一个帧</span>        <span class="hljs-keyword">while</span> (in.readableBytes() &gt;= frameLength) &#123;            <span class="hljs-comment">//从 ByteBuf 中读取一个新帧</span>            ByteBuf buf = in.readBytes(frameLength);            <span class="hljs-comment">//将该帧添加到已被解码的消息列表中</span>            out.add(buf);        &#125;    &#125;&#125;</code></pre></div><p>现在创建一个单元测试：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FixedLengthFrameDecoderTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>                           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFramesDecoded</span><span class="hljs-params">()</span></span>&#123;        ByteBuf buffer = Unpooled.buffer();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;            buffer.writeByte(i);        &#125;        ByteBuf duplicate = buffer.duplicate();        <span class="hljs-comment">//创建一个EmbeddedChannel，并添加一个FixedLengthFramesDecoded，将其以3字节的帧长度被测试</span>        EmbeddedChannel embeddedChannel = <span class="hljs-keyword">new</span> EmbeddedChannel(<span class="hljs-keyword">new</span> FixedLengthFrameDecoder(<span class="hljs-number">3</span>));        <span class="hljs-comment">//将数据写入EmbeddedChannel</span>        Assert.assertTrue(embeddedChannel.writeInbound(duplicate.retain()));        <span class="hljs-comment">//标记Channel为已完成的状态</span>        Assert.assertTrue(embeddedChannel.finish());                <span class="hljs-comment">//读取所生成的消息，并且验证是否有3帧，其中每帧都为3字节</span>        ByteBuf read = (ByteBuf) embeddedChannel.readInbound();        Assert.assertEquals(buffer.readSlice(<span class="hljs-number">3</span>),read);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; read.capacity(); i++) &#123;            System.out.println(read.getByte(i));        &#125;        read.release();        read = (ByteBuf)embeddedChannel.readInbound();        Assert.assertEquals(buffer.readSlice(<span class="hljs-number">3</span>),read);        read.release();        read = embeddedChannel.readInbound();        Assert.assertEquals(buffer.readSlice(<span class="hljs-number">3</span>),read);        read.release();        Assert.assertNull(embeddedChannel.readInbound());        buffer.release();    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFramesDecoded2</span><span class="hljs-params">()</span></span>&#123;        ByteBuf buffer = Unpooled.buffer();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;            buffer.writeByte(i);        &#125;        ByteBuf duplicate = buffer.duplicate();        EmbeddedChannel embeddedChannel = <span class="hljs-keyword">new</span> EmbeddedChannel(<span class="hljs-keyword">new</span> FixedLengthFrameDecoder(<span class="hljs-number">3</span>));        <span class="hljs-comment">//返回false，因为没有一个完整的可供读取的帧</span>        Assert.assertFalse(embeddedChannel.writeInbound(buffer.readBytes(<span class="hljs-number">2</span>)));        Assert.assertTrue(embeddedChannel.writeInbound(buffer.readBytes(<span class="hljs-number">7</span>)));        Assert.assertTrue(embeddedChannel.finish());        <span class="hljs-comment">//读取所生成的消息，并且验证是否有3帧，其中每帧都为3字节</span>        ByteBuf read = (ByteBuf) embeddedChannel.readInbound();        Assert.assertEquals(buffer.readSlice(<span class="hljs-number">3</span>),read);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; read.capacity(); i++) &#123;            System.out.println(read.getByte(i));        &#125;        read.release();        read = (ByteBuf)embeddedChannel.readInbound();        Assert.assertEquals(buffer.readSlice(<span class="hljs-number">3</span>),read);        read.release();        read = embeddedChannel.readInbound();        Assert.assertEquals(buffer.readSlice(<span class="hljs-number">3</span>),read);        read.release();        Assert.assertNull(embeddedChannel.readInbound());        buffer.release();    &#125;&#125;</code></pre></div><h3 id="测试出站消息"><a href="#测试出站消息" class="headerlink" title="测试出站消息"></a>测试出站消息</h3><p>利用EmbeddedChannel来测试一个编码器形式的ChannelOutboundHandler，这里我们只是简单的将负数转换为绝对值。</p><p>步骤：</p><ul><li>持有AbsIntegerEncoder的EmbeddedChannel将会以4字节的负整数的形式写出站数据；</li><li>编码器将从传入的ByteBuf中读取每个负整数，并将会调用Math.abs()方法来获取其绝对值；</li><li>编码器将会把每个负整数的绝对值写到ChannelPipeline中</li></ul><p>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbsIntegerEncoder</span> <span class="hljs-keyword">extends</span></span><span class="hljs-class">    <span class="hljs-title">MessageToMessageEncoder</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">        ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//检查是否有足够的字节用来编码</span>        <span class="hljs-keyword">while</span> (in.readableBytes() &gt;= <span class="hljs-number">4</span>) &#123;            <span class="hljs-comment">//从输入的 ByteBuf中读取下一个整数，并且计算其绝对值</span>            <span class="hljs-keyword">int</span> value = Math.abs(in.readInt());            <span class="hljs-comment">//将该整数写入到编码消息的 List 中</span>            out.add(value);        &#125;    &#125;&#125;</code></pre></div><p>使用了EmbeddedChannel来测试代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbsIntegerEncoderTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testEncoded</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//创建一个ByteBuf，并且写入9个负整数</span>        ByteBuf buf = Unpooled.buffer();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            buf.writeInt(i * -<span class="hljs-number">1</span>);        &#125;        <span class="hljs-comment">//创建一个EmbeddedChannel，并安装一个要测试的AbsIntegerEncoder</span>        EmbeddedChannel channel = <span class="hljs-keyword">new</span> EmbeddedChannel(<span class="hljs-keyword">new</span> AbsIntegerEncoder());        <span class="hljs-comment">//写入ByteBuf,并断言调用readOutbound()方法将会产生数据</span>        assertTrue(channel.writeOutbound(buf));        <span class="hljs-comment">//将该Channel标记为已完成状态</span>        assertTrue(channel.finish());        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            assertEquals(i,channel.readOutbound());        &#125;        assertNull(channel.readOutbound());    &#125;&#125;</code></pre></div><h2 id="测试异常处理"><a href="#测试异常处理" class="headerlink" title="测试异常处理"></a>测试异常处理</h2><p>示例：如果所读取的字节数超出了某个特定的限制，我们将会抛出一个TooLongFrameException，这是一种经常用来防范资源被耗尽的方法。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrameChunkDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxFrameSize;    <span class="hljs-comment">//指定将要产生的帧的最大允许大小</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FrameChunkDecoder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxFrameSize)</span> </span>&#123;        <span class="hljs-keyword">this</span>.maxFrameSize = maxFrameSize;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in,</span></span><span class="hljs-function"><span class="hljs-params">        List&lt;Object&gt; out)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">int</span> readableBytes = in.readableBytes();        <span class="hljs-keyword">if</span> (readableBytes &gt; maxFrameSize) &#123;            <span class="hljs-comment">// discard the bytes</span>            <span class="hljs-comment">//如果该帧太大，则丢弃它并抛出一个 TooLongFrameException……</span>            in.clear();            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TooLongFrameException();        &#125;        <span class="hljs-comment">//……否则，从 ByteBuf 中读取一个新的帧</span>        ByteBuf buf = in.readBytes(readableBytes);        <span class="hljs-comment">//将该帧添加到解码 读取一个新的帧消息的 List 中</span>        out.add(buf);    &#125;&#125;</code></pre></div><p>然后使用EmbeddedChannel来测试之前的代码是否正确：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrameChunkDecoderTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFramesDecoded</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//创建一个ByteBuf,并向它写入9字节</span>        ByteBuf buf = Unpooled.buffer();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;            buf.writeByte(i);        &#125;        ByteBuf input = buf.duplicate();        <span class="hljs-comment">//创建一个EmbeddedChannel，并向其安装一个帧大小为3字节的FrameChunkDecoder</span>        EmbeddedChannel channel = <span class="hljs-keyword">new</span> EmbeddedChannel(<span class="hljs-keyword">new</span> FrameChunkDecoder(<span class="hljs-number">3</span>));        <span class="hljs-comment">//向它写入2字节，并断言它们将会产生一个新帧</span>        assertTrue(channel.writeInbound(<span class="hljs-number">2</span>));        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//写入4字节大小的帧，并捕获预期的TooLongFrameException</span>            channel.writeInbound(input.readBytes(<span class="hljs-number">4</span>));            <span class="hljs-comment">//如果上面没有捕获，那么就会到达这个断言，并且测试失败</span>            fail();        &#125;<span class="hljs-keyword">catch</span> (TooLongFrameException e)&#123;            <span class="hljs-comment">//</span>        &#125;        <span class="hljs-comment">//因为之前的异常拦截里面没有做任何处理，所以程序可以继续执行，写入剩余的2字节，并断言将会产生一个有效帧</span>        assertTrue(channel.writeInbound(input.readBytes(<span class="hljs-number">3</span>)));        <span class="hljs-comment">//将该Channel标记为已完成状态</span>        assertTrue(channel.finish());        <span class="hljs-comment">//读取产生的消息，并且验证值</span>        ByteBuf read = (ByteBuf) channel.readInbound();        assertEquals(buf.readSlice(<span class="hljs-number">2</span>),read);        read.release();        read = (ByteBuf)channel.readInbound();        assertEquals(buf.skipBytes(<span class="hljs-number">4</span>).readSlice(<span class="hljs-number">3</span>),read);        read.release();        buf.release();    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.Netty--引导</title>
    <link href="/2020/06/02/8-Netty-%E5%BC%95%E5%AF%BC/"/>
    <url>/2020/06/02/8-Netty-%E5%BC%95%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>引导客户端和服务器</li><li>从Channel内引导客户端</li><li>添加ChannelHandler</li><li>使用ChannelOption和属性</li></ul></blockquote><h2 id="Bootstrap类"><a href="#Bootstrap类" class="headerlink" title="Bootstrap类"></a>Bootstrap类</h2><p>引导类的层次结构：</p><p><img src="https://img-blog.csdnimg.cn/20200602152558618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>服务器致力于使用一个父Channel来接收来自客户端的连接，并创建子Channel以用于它们之间的通信；而客户端一般只需要一个单独的、没有父Channel的Channel来用于所有的网络交互。</p><p>首先聊聊为什么引导类是Cloneable的？</p><p>当我们需要创建多个具有类似配置或者完全相同配置的Channel的时候，可以通过在一个已经配置完成的引导类实例上调用clone（）方法来返回另一个可以立即使用的引导类实例。</p><p>这种方式只会创建引导类实例的EventLoopGroup的一个浅拷贝，被浅拷贝的EventLoopGroup将在所有克隆的Channel实例之间共享。</p><h2 id="引导客户端和无连接协议"><a href="#引导客户端和无连接协议" class="headerlink" title="引导客户端和无连接协议"></a>引导客户端和无连接协议</h2><p>Bootstrap类被用于客户端或者使用了无连接协议的应用程序中，主要方法有如下：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>group</td><td>设置 EventLoopGroup 用于处理所有的 Channel 的事件</td></tr><tr><td>channel channelFactory</td><td>channel() 指定 Channel 的实现类。如果类没有提供一个默认的构造函数,你可以调用 channelFactory() 来指定一个工厂类被 bind() 调用。</td></tr><tr><td>localAddress</td><td>指定Channel应该绑定到本地地址 。如果不提供,将由操作系统创建一个随机的。或者,您可以使用 bind() 或 connect()指定localAddress</td></tr><tr><td>option</td><td>设置 ChannelOption，其将被应用到新创建 Channel 的 ChannelConfig。这些选项将被 bind 或 connect 设置在Channel,这取决于哪个被首先调用。这个方法在创建Channel后没有影响。所支持 ChannelOption 取决于使用的Channel类型</td></tr><tr><td>attr</td><td>指定新创建的Channel属性值，这些属性值通过 bind 或 connect 设置在Channel,这取决于哪个被首先调用。这个方法在创建Channel后没有影响。所支持 ChannelOption 取决于使用的Channel类型</td></tr><tr><td>handler</td><td>设置添加到 ChannelPipeline 中的 ChannelHandler 接收事件通知。</td></tr><tr><td>clone</td><td>创建一个当前 Bootstrap的克隆拥有原来相同的设置。</td></tr><tr><td>remoteAddress</td><td>设置远程地址。此外,您可以通过 connect() 指定</td></tr><tr><td>connect</td><td>连接到远端，返回一个 ChannelFuture, 用于通知连接操作完成</td></tr><tr><td>bind</td><td>将通道绑定并返回一个 ChannelFuture,用于通知绑定操作完成后,必须调用 Channel.connect() 来建立连接。</td></tr></tbody></table><h3 id="引导客户端"><a href="#引导客户端" class="headerlink" title="引导客户端"></a>引导客户端</h3><p>引导过程如下图所示：</p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1591084964998&di=f47186a7d9c0c972d4a0146152c6db5d&imgtype=0&src=http%3A%2F%2Fww1.sinaimg.cn%2Flarge%2F66bbf30bly1g35jn06modj20rq0i6gp3.jpg" srcset="/img/loading.gif" alt="img"></p><p>引导一个客户端代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BootstrapClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;        BootstrapClient client = <span class="hljs-keyword">new</span> BootstrapClient();        client.bootstrap();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 代码清单 8-1 引导一个客户端</span><span class="hljs-comment">     * */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bootstrap</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//设置 EventLoopGroup，提供用于处理 Channel 事件的 EventLoop</span>        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-comment">//创建一个Bootstrap类的实例以创建和连接新的客户端Channel</span>        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();        bootstrap.group(group)            <span class="hljs-comment">//指定要使用的Channel 实现</span>            .channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">            //设置用于 <span class="hljs-title">Channel</span> 事件和数据的<span class="hljs-title">ChannelInboundHandler</span></span><span class="hljs-class">            .<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt;() </span>&#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">                    ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                    ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    System.out.println(<span class="hljs-string">"Received data"</span>);                &#125;                &#125;);        <span class="hljs-comment">//连接到远程主机</span>        ChannelFuture future = bootstrap.connect(            <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"www.manning.com"</span>, <span class="hljs-number">80</span>));        future.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span></span><span class="hljs-function">                <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-keyword">if</span> (channelFuture.isSuccess()) &#123;                    System.out.println(<span class="hljs-string">"Connection established"</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    System.err.println(<span class="hljs-string">"Connection attempt failed"</span>);                    channelFuture.cause().printStackTrace();                &#125;            &#125;        &#125;);    &#125;&#125;</code></pre></div><h3 id="Channel和EventLoopGroup的兼容性"><a href="#Channel和EventLoopGroup的兼容性" class="headerlink" title="Channel和EventLoopGroup的兼容性"></a>Channel和EventLoopGroup的兼容性</h3><p>在引导的过程中，在调用bind（）或者connect（）方法之前，必须调用一下方法来设置所需的组件：</p><ul><li>group()</li><li>channel()或者channelFactory()</li><li>handler()</li></ul><p>如果不这样做，则将会导致IllegalStateException，尤其是handler（）方法，因为它需要配置好的ChannelPipeline。</p><h2 id="引导服务器"><a href="#引导服务器" class="headerlink" title="引导服务器"></a>引导服务器</h2><h3 id="ServerBootstrap类"><a href="#ServerBootstrap类" class="headerlink" title="ServerBootstrap类"></a>ServerBootstrap类</h3><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>group</td><td>设置ServerBootstrap要用的EventLoopGroup，这个 EventLoopGroup 提供 ServerChannel 的 I/O 处理并且接收 Channel</td></tr><tr><td>channel channelFactory</td><td>channel() 指定 Channel 的实现类。如果Channel没有提供一个默认的构造函数,你可以提供一个 ChannelFactory。</td></tr><tr><td>localAddress</td><td>指定 ServerChannel 应该绑定到的本地地址。如果不提供,将由操作系统创建一个随机的。或者,您可以使用 bind() 或 connect()指定localAddress</td></tr><tr><td>option</td><td>指定一个 ChannelOption 来用于新创建的 ServerChannel 的 ChannelConfig 。这些选项将被设置在Channel的 bind() 或 connect(),这取决于谁首先被调用。在此调用这些方法之后设置或更改 ChannelOption 是无效的。</td></tr><tr><td>childOption</td><td>当Channel已被接受，指定一个 ChannelOption 应用于 Channel 的 ChannelConfig。</td></tr><tr><td>attr</td><td>指定 ServerChannel 的属性。这些属性可以被子Channel的 bind() 设置。当调用 bind() 之后，修改它们不会生效。</td></tr><tr><td>childAttr</td><td>应用属性到接收到的子Channel上。后续调用没有效果。</td></tr><tr><td>handler</td><td>设置添加到 ServerChannel 的 ChannelPipeline 中的 ChannelHandler。</td></tr><tr><td>childHandler</td><td>设置添加到接收到的 Channel 的 ChannelPipeline 中的 ChannelHandler。handler() 和 childHandler()之间的区别是前者是接收和处理ServerChannel，同时 childHandler() 添加处理器用于处理和接收 Channel。后者代表一个套接字绑定到一个远端。</td></tr><tr><td>clone</td><td>克隆 ServerBootstrap 用于连接到不同的远端，通过设置相同的原始 ServerBoostrap。</td></tr><tr><td>bind</td><td>绑定 ServerChannel 并且返回一个 ChannelFuture,用于通知连接操作完成了（结果可以是成功或者失败）</td></tr></tbody></table><h3 id="引导服务器-1"><a href="#引导服务器-1" class="headerlink" title="引导服务器"></a>引导服务器</h3><p>ServerBootstrap类比Bootstrap类多了一些childXXX()方法，这是因为ServerChannel的实现负责创建子Channel，这些子Channel代表了已被接受的连接，用这些方法来简化将设置应用到已被接受的子Channel的ChannelConfig的任务。</p><p>下图展示了ServerBootstrap在bind（）方法被调用时创建了一个ServerChannel，并且该ServerChannel管理了多个子Channel。</p><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1542357931,1822191383&fm=15&gp=0.jpg" srcset="/img/loading.gif" alt="img"></p><p>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bootstrap</span><span class="hljs-params">()</span> </span>&#123;        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-comment">//创建 Server Bootstrap</span>        ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();        <span class="hljs-comment">//设置 EventLoopGroup，其提供了用于处理 Channel 事件的EventLoop</span>        bootstrap.group(group)            <span class="hljs-comment">//指定要使用的 Channel 实现</span>            .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">            //设置用于处理已被接受的子 <span class="hljs-title">Channel</span> 的<span class="hljs-title">I</span>/<span class="hljs-title">O</span>及数据的 <span class="hljs-title">ChannelInboundHandler</span></span><span class="hljs-class">            .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt;() </span>&#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                    ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    System.out.println(<span class="hljs-string">"Received data"</span>);                &#125;            &#125;);        <span class="hljs-comment">//通过配置好的 ServerBootstrap 的实例绑定该 Channel</span>        ChannelFuture future = bootstrap.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));        future.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span></span><span class="hljs-function">                <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-keyword">if</span> (channelFuture.isSuccess()) &#123;                    System.out.println(<span class="hljs-string">"Server bound"</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    System.err.println(<span class="hljs-string">"Bind attempt failed"</span>);                    channelFuture.cause().printStackTrace();                &#125;            &#125;        &#125;);    &#125;</code></pre></div><h2 id="从Channel引导客户端"><a href="#从Channel引导客户端" class="headerlink" title="从Channel引导客户端"></a>从Channel引导客户端</h2><p>在实际项目开发中有时需要从已经被接受的子Channel中引导一个客户端Channel，我们可以创建一个新的Bootstrap实例，但是这样会产生额外的线程，以及在已被接受的子Channel和客户端Channel之间交换数据时带来的上下文切换。</p><p>一个更好的解决方案是：通过将已被接受的子Channel的EventLoop传递给Bootstrap的group（）方法来共享该EventLoop。</p><p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=2705103063,4189013526&fm=26&gp=0.jpg" srcset="/img/loading.gif" alt="img"></p><p>代码实现如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bootstrap</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//创建 ServerBootstrap 以创建 ServerSocketChannel，并绑定它</span>        ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();        <span class="hljs-comment">//设置 EventLoopGroup，其将提供用以处理 Channel 事件的 EventLoop</span>        bootstrap.group(<span class="hljs-keyword">new</span> NioEventLoopGroup(), <span class="hljs-keyword">new</span> NioEventLoopGroup())            <span class="hljs-comment">//指定要使用的 Channel 实现</span>            .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">            //设置用于处理已被接受的子 <span class="hljs-title">Channel</span> 的 <span class="hljs-title">I</span>/<span class="hljs-title">O</span> 和数据的 <span class="hljs-title">ChannelInboundHandler</span></span><span class="hljs-class">            .<span class="hljs-title">childHandler</span>(</span><span class="hljs-class">                <span class="hljs-title">new</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt;() </span>&#123;                    ChannelFuture connectFuture;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span></span><span class="hljs-function">                        <span class="hljs-keyword">throws</span> Exception </span>&#123;                        <span class="hljs-comment">//创建一个 Bootstrap 类的实例以连接到远程主机</span>                        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();                        <span class="hljs-comment">//指定 Channel 的实现</span>                        bootstrap.channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">handler</span>(</span><span class="hljs-class">                            //为入站 <span class="hljs-title">I</span>/<span class="hljs-title">O</span> 设置 <span class="hljs-title">ChannelInboundHandler</span></span><span class="hljs-class">                            <span class="hljs-title">new</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt;() </span>&#123;                                <span class="hljs-meta">@Override</span>                                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">                                    ChannelHandlerContext ctx, ByteBuf in)</span></span><span class="hljs-function">                                    <span class="hljs-keyword">throws</span> Exception </span>&#123;                                    System.out.println(<span class="hljs-string">"Received data"</span>);                                &#125;                            &#125;);                        <span class="hljs-comment">//使用与分配给已被接受的子Channel相同的EventLoop</span>                        bootstrap.group(ctx.channel().eventLoop());                        connectFuture = bootstrap.connect(                            <span class="hljs-comment">//连接到远程节点</span>                            <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"www.manning.com"</span>, <span class="hljs-number">80</span>));                    &#125;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">                        ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                            ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        <span class="hljs-keyword">if</span> (connectFuture.isDone()) &#123;                            <span class="hljs-comment">//当连接完成时，执行一些数据操作（如代理）</span>                            <span class="hljs-comment">// do something with the data</span>                        &#125;                    &#125;                &#125;);        <span class="hljs-comment">//通过配置好的 ServerBootstrap 绑定该 ServerSocketChannel</span>        ChannelFuture future = bootstrap.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));        future.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span></span><span class="hljs-function">                <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-keyword">if</span> (channelFuture.isSuccess()) &#123;                    System.out.println(<span class="hljs-string">"Server bound"</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    System.err.println(<span class="hljs-string">"Bind attempt failed"</span>);                    channelFuture.cause().printStackTrace();                &#125;            &#125;        &#125;);    &#125;</code></pre></div><p>编写Netty应用程序的一个一般原则：尽可能地重用EventLoop，以减少线程创建所带来的开销。</p><h2 id="在引导过程中添加多个ChannelHandler"><a href="#在引导过程中添加多个ChannelHandler" class="headerlink" title="在引导过程中添加多个ChannelHandler"></a>在引导过程中添加多个ChannelHandler</h2><p>之前的代码中，我们调用handler（）或者childHandler（）方法来添加单个的ChannelHandler。Netty提供了一个特殊的ChannelInboundHandlerAdapter（）子类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Channel</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span></span></code></pre></div><p>通过它的<code>protected abstract void initChannel(C ch) throws Exception</code>方法来讲多个ChannelHandler添加到一个ChannelPipeLine中的简便方法。你只需要简单的向Bootstrap或ServerBootstrap的实例提供你的ChannelInitializer实现即可，在该方法返回之后，ChannelInitializer的实例将会从ChannelPipeline中移除它自己。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bootstrap</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">//创建 ServerBootstrap 以创建和绑定新的 Channel</span>        ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();        <span class="hljs-comment">//设置 EventLoopGroup，其将提供用以处理 Channel 事件的 EventLoop</span>        bootstrap.group(<span class="hljs-keyword">new</span> NioEventLoopGroup(), <span class="hljs-keyword">new</span> NioEventLoopGroup())            <span class="hljs-comment">//指定 Channel 的实现</span>            .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">            //注册一个 <span class="hljs-title">ChannelInitializerImpl</span> 的实例来设置 <span class="hljs-title">ChannelPipeline</span></span><span class="hljs-class">            .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializerImpl</span>())</span>;        <span class="hljs-comment">//绑定到地址</span>        ChannelFuture future = bootstrap.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));        future.sync();    &#125;    <span class="hljs-comment">//用以设置 ChannelPipeline 的自定义 ChannelInitializerImpl 实现</span>    <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChannelInitializerImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-comment">//将所需的 ChannelHandler 添加到 ChannelPipeline</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            ChannelPipeline pipeline = ch.pipeline();            pipeline.addLast(<span class="hljs-keyword">new</span> HttpClientCodec());            pipeline.addLast(<span class="hljs-keyword">new</span> HttpObjectAggregator(Integer.MAX_VALUE));        &#125;    &#125;</code></pre></div><p>如果你的应用程序使用了多个ChannelHandler，自己定义一个ChannelInitializer的实现来将它们安装到ChannelPipeline中即可。</p><h2 id="使用Netty的ChannelOption和属性"><a href="#使用Netty的ChannelOption和属性" class="headerlink" title="使用Netty的ChannelOption和属性"></a>使用Netty的ChannelOption和属性</h2><p>在每个Channel创建时都手动配置它很麻烦，这时我们可以通过option()方法来讲ChannelOption应用到引导，我们提供的值将会被自动应用到引导所创建的所有Channel。</p><p>Netty提供了AttributeMap抽象以及AttributeKey等工具来实现任何类型的数据项与客户端和服务器Channel之间安全地关联。</p><p>下面代码展示了如何使用ChannelOption来配置Channel，以及如何使用属性来存储整型值。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bootstrap</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//创建一个 AttributeKey 以标识该属性</span>        <span class="hljs-keyword">final</span> AttributeKey&lt;Integer&gt; id = AttributeKey.newInstance(<span class="hljs-string">"ID"</span>);        <span class="hljs-comment">//创建一个 Bootstrap 类的实例以创建客户端 Channel 并连接它们</span>        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();        <span class="hljs-comment">//设置 EventLoopGroup，其提供了用于处理 Channel 事件的 EventLoop</span>        bootstrap.group(<span class="hljs-keyword">new</span> NioEventLoopGroup())            <span class="hljs-comment">//指定 Channel 的实现</span>            .channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">            .<span class="hljs-title">handler</span>(</span><span class="hljs-class">                //设置用以处理 <span class="hljs-title">Channel</span> 的 <span class="hljs-title">I</span>/<span class="hljs-title">O</span> 以及数据的 <span class="hljs-title">ChannelInboundHandler</span></span><span class="hljs-class">                <span class="hljs-title">new</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt;() </span>&#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRegistered</span><span class="hljs-params">(ChannelHandlerContext ctx)</span></span><span class="hljs-function">                        <span class="hljs-keyword">throws</span> Exception </span>&#123;                        <span class="hljs-comment">//使用 AttributeKey 检索属性以及它的值</span>                        Integer idValue = ctx.channel().attr(id).get();                        <span class="hljs-comment">// do something with the idValue</span>                    &#125;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">                        ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                        ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        System.out.println(<span class="hljs-string">"Received data"</span>);                    &#125;                &#125;            );        <span class="hljs-comment">//设置 ChannelOption，其将在 connect()或者bind()方法被调用时被设置到已经创建的 Channel 上</span>        bootstrap.option(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)            .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">5000</span>);        <span class="hljs-comment">//存储该 id 属性</span>        bootstrap.attr(id, <span class="hljs-number">123456</span>);        <span class="hljs-comment">//使用配置好的 Bootstrap 实例连接到远程主机</span>        ChannelFuture future = bootstrap.connect(            <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"www.manning.com"</span>, <span class="hljs-number">80</span>));        future.syncUninterruptibly();    &#125;</code></pre></div><h2 id="引导DatagramChannel"><a href="#引导DatagramChannel" class="headerlink" title="引导DatagramChannel"></a>引导DatagramChannel</h2><p>前面提到的都是基于TCP协议的SocketChannel，但是Bootstrap类也可以被用于无连接的协议，Netty提供了各种DatagramChannel的实现，唯一区别就是，不再调用connect()方法，而是只调用bind()方法，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bootstrap</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//创建一个 Bootstrap 的实例以创建和绑定新的数据报 Channel</span>        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();        <span class="hljs-comment">//设置 EventLoopGroup，其提供了用以处理 Channel 事件的 EventLoop</span>        bootstrap.group(<span class="hljs-keyword">new</span> OioEventLoopGroup()).channel(            <span class="hljs-comment">//指定 Channel 的实现</span>            OioDatagramChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">handler</span>(</span><span class="hljs-class">            //设置用以处理 <span class="hljs-title">Channel</span> 的 <span class="hljs-title">I</span>/<span class="hljs-title">O</span> 以及数据的 <span class="hljs-title">ChannelInboundHandler</span></span><span class="hljs-class">            <span class="hljs-title">new</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">DatagramPacket</span>&gt;() </span>&#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,</span></span><span class="hljs-function"><span class="hljs-params">                    DatagramPacket msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    <span class="hljs-comment">// Do something with the packet</span>                &#125;            &#125;        );        <span class="hljs-comment">//调用 bind() 方法，因为该协议是无连接的</span>        ChannelFuture future = bootstrap.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">0</span>));        future.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span></span><span class="hljs-function">               <span class="hljs-keyword">throws</span> Exception </span>&#123;               <span class="hljs-keyword">if</span> (channelFuture.isSuccess()) &#123;                   System.out.println(<span class="hljs-string">"Channel bound"</span>);               &#125; <span class="hljs-keyword">else</span> &#123;                   System.err.println(<span class="hljs-string">"Bind attempt failed"</span>);                   channelFuture.cause().printStackTrace();               &#125;            &#125;        &#125;);    &#125;</code></pre></div><h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><p><strong>最重要的是关闭EventLoopGroup</strong>，通过调用EventLoopGroup.shutdownGracefully()方法。这个调用将返回一个 Future 用来通知关闭完成。注意,shutdownGracefully()也是一个异步操作,所以你需要阻塞,直到它完成或注册一个侦听器直到返回的 Future 来通知完成。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bootstrap</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//创建处理 I/O 的EventLoopGroup</span>        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-comment">//创建一个 Bootstrap 类的实例并配置它</span>        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();        bootstrap.group(group)             .channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">        //...</span><span class="hljs-class">             .<span class="hljs-title">handler</span>(</span><span class="hljs-class">                <span class="hljs-title">new</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt;() </span>&#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">                            ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                            ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        System.out.println(<span class="hljs-string">"Received data"</span>);                    &#125;                &#125;             );        bootstrap.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"www.manning.com"</span>, <span class="hljs-number">80</span>)).syncUninterruptibly();        <span class="hljs-comment">//,,,</span>        <span class="hljs-comment">//shutdownGracefully()方法将释放所有的资源，并且关闭所有的当前正在使用中的 Channel</span>        Future&lt;?&gt; future = group.shutdownGracefully();        <span class="hljs-comment">// block until the group has shutdown</span>        future.syncUninterruptibly();    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.Netty--EventLoop和线程模型</title>
    <link href="/2020/06/01/7-Netty-EventLoop%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/06/01/7-Netty-EventLoop%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>线程模型概述</li><li>事件循环的概念和实现</li><li>任务调度</li><li>实现细节</li></ul></blockquote><h2 id="线程模型概述"><a href="#线程模型概述" class="headerlink" title="线程模型概述"></a>线程模型概述</h2><p>基本的线程池化模式可以描述为：</p><ul><li><p>从池的空闲列表中选择一个Thread，并且指派它去运行一个已提交的任务（一个Runnable的实现）；</p></li><li><p>当任务完成时，将该Thread返回给该列表，使其可被重用。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200602154938594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>（1）要执行的任务；</p><p>（2）任务递交给了线程池；</p><p>（3）从线程池中拉取一个可用的Thread，并执行任务，当任务完成时，将该Thread返回给空闲列表，使其可被重用</p><h2 id="EventLoop接口"><a href="#EventLoop接口" class="headerlink" title="EventLoop接口"></a>EventLoop接口</h2><p>EventLoop是协同设计的一部分，采用了两个基本的API：并发和网络编程。</p><p><img src="https://img-blog.csdnimg.cn/20200602155018734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>一个EventLoop将由一个永远都不会改变的Thread驱动，同时任务（Runnable或者Callable）可以直接提交给EventLoop实现，以立即执行或者调度执行。根据配置和可用核心不同，可能会创建多个EventLoop实例用以优化资源的使用，并且单个EventLoop可能会被指派用于服务多个Channel。</p><h3 id="Netty4中的I-O和事件处理"><a href="#Netty4中的I-O和事件处理" class="headerlink" title="Netty4中的I/O和事件处理"></a>Netty4中的I/O和事件处理</h3><p>所有的I/O操作和事件都由已经被分配给了EventLoop的那个Thread来处理。</p><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>常见的用例是：发送心跳消息到远程节点，以检查连接是否还活着。</p><h3 id="JDK的任务调度API"><a href="#JDK的任务调度API" class="headerlink" title="JDK的任务调度API"></a>JDK的任务调度API</h3><p>java.util.concurrent.Executors类的工厂方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>newScheduledThreadPool(int corePoolSize)<br /><br />newScheduledThreadPool(int corePoolSize,<br />ThreadFactory threadFactory)</td><td>创建一个ScheduledThreadExecutorService，用于调度命令在指定延迟之后运行或者周期性地执行。它使用corePoolSize参数来计算线程数</td></tr><tr><td>newSingleThreadScheduledExecutor（）<br /><br />newSingleThreadScheduledExecutor(ThreadFactory threadFactory)</td><td>创建一个ScheduledThreadExecutorService，用于调度命令在指定延迟之后运行或者周期性地执行。它使用一个线程来执行被调度的任务。</td></tr></tbody></table><p>下面代码展示了如何使用ScheduledExecutorService来在60s的延迟之后执行一个任务：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//创建一个其线程池具有 10 个线程的ScheduledExecutorService</span>        ScheduledExecutorService executor =                Executors.newScheduledThreadPool(<span class="hljs-number">10</span>);        ScheduledFuture&lt;?&gt; future = executor.schedule(            <span class="hljs-comment">//创建一个 Runnable，以供调度稍后执行</span>            <span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-comment">//该任务要打印的消息</span>                System.out.println(<span class="hljs-string">"Now it is 60 seconds later"</span>);            &#125;        <span class="hljs-comment">//调度任务在从现在开始的 60 秒之后执行</span>        &#125;, <span class="hljs-number">60</span>, TimeUnit.SECONDS);        <span class="hljs-comment">//...</span>        <span class="hljs-comment">//一旦调度任务执行完成，就关闭 ScheduledExecutorService 以释放资源</span>        executor.shutdown();    &#125;</code></pre></div><p>高负载下性能上不佳</p><h3 id="使用EventLoop调度任务"><a href="#使用EventLoop调度任务" class="headerlink" title="使用EventLoop调度任务"></a>使用EventLoop调度任务</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleViaEventLoop</span><span class="hljs-params">()</span> </span>&#123;     Channel ch = CHANNEL_FROM_SOMEWHERE; <span class="hljs-comment">// get reference from somewhere</span>     ScheduledFuture&lt;?&gt; future = ch.eventLoop().schedule(         <span class="hljs-comment">//创建一个 Runnable以供调度稍后执行</span>         <span class="hljs-keyword">new</span> Runnable() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;             <span class="hljs-comment">//要执行的代码</span>             System.out.println(<span class="hljs-string">"60 seconds later"</span>);         &#125;         <span class="hljs-comment">//调度任务在从现在开始的 60 秒之后执行</span>     &#125;, <span class="hljs-number">60</span>, TimeUnit.SECONDS); &#125;</code></pre></div><p>如果要调度任务以每隔60s执行一次，则使用ScheduleAtFixedRate()方法。</p><p>要想取消或者检查（被调度任务的）执行状态，可以使用每隔异步操作所返回的ScheduledFuture。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancelingTaskUsingScheduledFuture</span><span class="hljs-params">()</span></span>&#123;       Channel ch = CHANNEL_FROM_SOMEWHERE; <span class="hljs-comment">// get reference from somewhere</span>       <span class="hljs-comment">//...</span>       <span class="hljs-comment">//调度任务，并获得所返回的ScheduledFuture</span>       ScheduledFuture&lt;?&gt; future = ch.eventLoop().scheduleAtFixedRate(               <span class="hljs-keyword">new</span> Runnable() &#123;                   <span class="hljs-meta">@Override</span>                   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                       System.out.println(<span class="hljs-string">"Run every 60 seconds"</span>);                   &#125;               &#125;, <span class="hljs-number">60</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS);       <span class="hljs-comment">// Some other code that runs...</span>       <span class="hljs-keyword">boolean</span> mayInterruptIfRunning = <span class="hljs-keyword">false</span>;       <span class="hljs-comment">//取消该任务，防止它再次运行</span>       future.cancel(mayInterruptIfRunning);   &#125;</code></pre></div><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h3><p>Netty线程模型的卓越性能取决于对于当前执行的Thread的身份的确定（通过调用EventLoop的inEventLoop（Thread）方法实现），也就是说，确定它是否是分配给当前Channel以及它的EventLoop的那一个线程。</p><p>如果当前调用线程正是支撑EventLoop的线程，那么所提交的代码块将会被直接执行，否则，EventLoop将调度该任务以便稍后执行，并将它放入到内部队列中，当EventLoop下次处理它的事件时，它会执行队列中的那些任务/事件。</p><p>注意：每个EventLoop都有他自己的任务队列，独立于任何其他的EventLoop。</p><p><img src="https://img-blog.csdnimg.cn/20200602155127463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="EventLoop-线程的分配"><a href="#EventLoop-线程的分配" class="headerlink" title="EventLoop/线程的分配"></a>EventLoop/线程的分配</h3><h4 id="异步传输"><a href="#异步传输" class="headerlink" title="异步传输"></a>异步传输</h4><p>异步传输实现只使用了少量的EventLoop（以及和它们相关联的Thread），而且在当前的线程模型中，它们可能会被多个Channel所共享。这使得可以通过尽可能少的Thread来支撑大量的Channel，而不是每个Channel分配一个Thread。</p><p><img src="https://img-blog.csdnimg.cn/20200602155138107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>EventLoopGroup负责为每个新创建的Channel分配一个EventLoop，并且相同的Event Loop可能会被分配给多个Channel。</p><p>一旦一个Channel被分配给要给EventLoop，它将在它的整个生命周期中都使用整个EventLoop（以及相关联的Thread）。</p><h4 id="阻塞传输"><a href="#阻塞传输" class="headerlink" title="阻塞传输"></a>阻塞传输</h4><p>每个Channel都将会被分配给一个EventLoop（以及它的Thread）</p><p><img src="https://img-blog.csdnimg.cn/2020060215514520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.Netty--ChannelHandler和ChannelPipeline</title>
    <link href="/2020/05/31/6-Netty-ChannelHandler%E5%92%8CChannelPipeline/"/>
    <url>/2020/05/31/6-Netty-ChannelHandler%E5%92%8CChannelPipeline/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>ChannelHandler和ChannelPipeline</li><li>检测资源泄漏</li><li>异常处理</li></ul></blockquote><h2 id="ChannelHandler家族"><a href="#ChannelHandler家族" class="headerlink" title="ChannelHandler家族"></a>ChannelHandler家族</h2><h3 id="Channel的生命周期"><a href="#Channel的生命周期" class="headerlink" title="Channel的生命周期"></a>Channel的生命周期</h3><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>ChannelUnregistered</td><td>Channel已经被创建，但还未注册到EventLoop</td></tr><tr><td>ChannelRegistered</td><td>Channel已经被注册到了EventLoop</td></tr><tr><td>ChannelActive</td><td>Channel处于活动状态（已连接到远程节点），可以接收和发送数据了</td></tr><tr><td>ChannelInactive</td><td>Channel没有连接到远程节点</td></tr></tbody></table><p>Channel的正常生命周期如下图所示，当这些状态发生改变时，将会生成对应的事件，这些事件将会被转发给ChannelPipeline中的ChannelHandler，其可以随后对它们做出响应。</p><p><img src="https://img-blog.csdnimg.cn/20200601160759198.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="ChannelHandler的生命周期"><a href="#ChannelHandler的生命周期" class="headerlink" title="ChannelHandler的生命周期"></a>ChannelHandler的生命周期</h3><p>ChannelHandler的生命周期方法主要有下面几种，这些方法都有一个ChannelHandlerContext参数，在ChannelHandler被添加到ChannelPipeline中或者从ChannelPipeline中移除时都会调用这些操作。</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>handlerAdded</td><td>当把ChannelHandler添加到ChannelPipeline中时被调用</td></tr><tr><td>handlerRemoved</td><td>当从ChannelPineline中移除ChannelHandler时被调用</td></tr><tr><td>exceptionCaught</td><td>当处理过程中在ChannelPipeline中有错误产生时被调用</td></tr></tbody></table><p>Netty定义了两个重要的ChannelHandler子接口：</p><ul><li>ChannelInboundHandler：处理入站数据以及各种状态变化；</li><li>ChannelOutboundHandler：处理出站数据并且允许拦截所有的操作；</li></ul><h3 id="ChannelInboundHandler接口"><a href="#ChannelInboundHandler接口" class="headerlink" title="ChannelInboundHandler接口"></a>ChannelInboundHandler接口</h3><p>下面这些是ChannelInboundHandler的生命周期方法，将会在数据被接收时或者与其对应的Channel状态发生改变时被调用。</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>ChannelUnregistered</td><td>当Channel从它的EventLoop注销并且无法处理任何I/O时被调用</td></tr><tr><td>ChannelRegistered</td><td>当Channel已经注册到它的EventLoop，并且能够处理I/O时被调用</td></tr><tr><td>ChannelActive</td><td>当Channel处于活动状态（已连接到远程节点）时被调用</td></tr><tr><td>ChannelInactive</td><td>当Channel离开活动状态并且不再连接它的远程节点时被调用</td></tr><tr><td>ChannelReadComplete</td><td>当Channel上的一个读操作完成时被调用</td></tr><tr><td>ChannelRead</td><td>当从Channel读取数据时被调用</td></tr><tr><td>ChannelWritabilityChanged</td><td>当Channel的可写状态发生改变时被调用</td></tr><tr><td>userEventTriggered</td><td>当调用ChannelInboundHandler.fireUserEventTriggered()方法时被调用</td></tr></tbody></table><p>当某个ChannelInboundHandler的实现重写了channelRead（）方法时，它将负责显示地释放与池化的ByteBuf实例相关的内存。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;        <span class="hljs-comment">//丢弃已接收的消息</span>        ReferenceCountUtil.release(msg);    &#125;&#125;</code></pre></div><p>不过我们一般使用SimpleChannelInboundHandler来自动释放资源。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleDiscardHandler</span></span><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,</span></span><span class="hljs-function"><span class="hljs-params">        Object msg)</span> </span>&#123;        <span class="hljs-comment">//不需要任何显式的资源释放</span>        <span class="hljs-comment">// No need to do anything special</span>    &#125;&#125;</code></pre></div><p>由于使用SimpleChannelInboundHandler会自动释放资源，所以不能存储指向任何消息的引用供将来使用。</p><h3 id="ChannelOutboundHandler接口"><a href="#ChannelOutboundHandler接口" class="headerlink" title="ChannelOutboundHandler接口"></a>ChannelOutboundHandler接口</h3><p>用来处理出站操作，它的方法将被Channel、ChannelPipeline以及ChannelHandlerContext调用。</p><p>ChannelOutboundHandler的一个强大的功能就是可以按需推迟操作或者事件，比如到远程节点的写入被暂停了，你可以推迟冲刷操作并在稍后继续。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ChannelOutboundHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelHandler</span> </span>&#123;<span class="hljs-comment">//当请求将Channel绑定到本地地址时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bind</span><span class="hljs-params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-comment">//当请求将Channel连接到远程节点时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            ChannelHandlerContext ctx, SocketAddress remoteAddress,</span></span><span class="hljs-function"><span class="hljs-params">            SocketAddress localAddress, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-comment">//当请求将Channel从远程节点断开时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">disconnect</span><span class="hljs-params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-comment">//当请求关闭Channel时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-comment">//当请求将Channel从它的EventLoop注销时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deregister</span><span class="hljs-params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-comment">//当请求从Channel读取更多的数据时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-comment">//当请求通过Channel将数据写到远程节点时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-comment">//当请求通过Channel将入队数据冲刷到远程节点时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception</span>;&#125;</code></pre></div><p>ChannelOutboundHandler中的大部分方法都需要一个ChannelPromise参数，以便在操作完成时得到通知。ChannelPromise是ChannelFuture的一个子类，其定义了一些可写的方法，如setSuccess（）和setFailure（），从而使ChannelFuture不可变。</p><h3 id="ChannelHandler适配器"><a href="#ChannelHandler适配器" class="headerlink" title="ChannelHandler适配器"></a>ChannelHandler适配器</h3><p>我们可以使用ChannelInboundHandlerAdapter和ChannelOutboundHandlerAdapter类作为自己的ChannelHandler的起始点。这两个适配器分别提供了ChannelInboundHandler和ChannelOutboundHandler的基本实现，通过扩展抽象类ChannelHandlerAdapter，他们获得了ChannelHandler的方法。生成的类的层次结构如下图</p><p><img src="https://img-blog.csdnimg.cn/20200601160813550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200601160827702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>在ChannelInboundHandlerAdapter和ChannelOutboundHandlerAdapter中所提供的方法体调用了其相关联的ChannelHandlerContext上的等效方法，从而将事件转发到了ChannelPipeline中的下一个ChannelHandler中。</p><h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><p>每当通过调用ChannelInboundHandler.channelRead()或者ChannelOutboundHandler.write()方法来处理数据时，你都需要确保没有任何的资源泄露。</p><p>Netty提供了4种泄漏检测级别，分别如下：</p><ul><li><p>DISABLED——禁用泄露检测</p></li><li><p>SIMPLE——使用1%的默认采样率检测并报告任何发现的泄露</p></li><li><p>ADVANCED——使用默认的采样率，报告所发现的任何的泄露以及对应的消息被访问的位置</p></li><li><p>PARANOID——类似于ADVANCED，但是其将会对每次访问都进行采样，这对性能将会有很大的影响，应该只在调试阶段使用</p></li></ul><p>泄露检测级别可以通过将下面的Java系统属性设置为表中的一个值来定义：</p><div class="hljs"><pre><code class="hljs java">java -Dio.netty.leakDetectionLevel = ADVANCED</code></pre></div><p>消费入站可以通过SimpleChannelInboundHandler类来实现，在消息被channelRead0()方法消费之后自动释放消息。</p><p>如果是出站消息，丢弃并释放资源的代码参考如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardOutboundHandler</span></span><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelOutboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx,</span></span><span class="hljs-function"><span class="hljs-params">        Object msg, ChannelPromise promise)</span> </span>&#123;        <span class="hljs-comment">//通过使用 ReferenceCountUtil.realse(...)方法释放资源</span>        ReferenceCountUtil.release(msg);        <span class="hljs-comment">//通知 ChannelPromise数据已经被处理了</span>        promise.setSuccess();    &#125;&#125;</code></pre></div><p>这里要注意的是，我们不仅要释放资源，同时也要通知ChannelPromise，否则可能会出现ChannelFutureListener收不到某个消息已经被处理的通知。</p><h2 id="ChannelPipeline接口"><a href="#ChannelPipeline接口" class="headerlink" title="ChannelPipeline接口"></a>ChannelPipeline接口</h2><p>每个新建的Channel都会被分配一个新的ChannelPipeline，Channel既不能附加另一个ChannelPipeline，也不能分离当前的。</p><p>根据事件的起源，事件将会被ChannelInboundHandler或者ChannelOutboundHandler处理，随后通过调用ChannelHandlerContext的实现，它将被转发给同一超类型的下一个ChannelHandler。</p><p>ChannelHandlerContext的作用就是使得ChannelHandler能够和它的ChannelPipeline以及其他的ChannelHandler交互。</p><p>下图是一个典型的同时具有入站和出站ChannelHandler的ChannelPipeline的布局：</p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1590999092320&di=27fc68aadc3a9af02ab63d0231dcb6d5&imgtype=0&src=http%3A%2F%2Fimg3.imgtn.bdimg.com%2Fit%2Fu%3D1589654393%2C4151543914%26fm%3D214%26gp%3D0.jpg" srcset="/img/loading.gif" alt="img"></p><p>Netty总是将ChannelPipeline的入站口作为头部，而将出站口作为尾部，在ChannelPipeline传播事件时，它会测试ChannelPipeline中下一个ChannelHandler的类型是否和事件的运动方向相匹配，如果不匹配就跳过，直到找到和该事件所期望的方向相匹配的为止。</p><h3 id="修改ChannelPipeline"><a href="#修改ChannelPipeline" class="headerlink" title="修改ChannelPipeline"></a>修改ChannelPipeline</h3><p>通过调用ChannelPipeline上的相关方法，ChannelHandler可以添加、删除或者替换其他的ChannelHandler，从而实时地修改ChannelPipeline的布局。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">modifyPipeline</span><span class="hljs-params">()</span> </span>&#123;        ChannelPipeline pipeline = CHANNEL_PIPELINE_FROM_SOMEWHERE; <span class="hljs-comment">// get reference to pipeline;</span>        <span class="hljs-comment">//创建一个 FirstHandler 的实例</span>        FirstHandler firstHandler = <span class="hljs-keyword">new</span> FirstHandler();        <span class="hljs-comment">//将该实例作为"handler1"添加到ChannelPipeline 中</span>        pipeline.addLast(<span class="hljs-string">"handler1"</span>, firstHandler);        <span class="hljs-comment">//将一个 SecondHandler的实例作为"handler2"添加到 ChannelPipeline的第一个槽中。这意味着它将被放置在已有的"handler1"之前</span>        pipeline.addFirst(<span class="hljs-string">"handler2"</span>, <span class="hljs-keyword">new</span> SecondHandler());        <span class="hljs-comment">//将一个 ThirdHandler 的实例作为"handler3"添加到 ChannelPipeline 的最后一个槽中</span>        pipeline.addLast(<span class="hljs-string">"handler3"</span>, <span class="hljs-keyword">new</span> ThirdHandler());        <span class="hljs-comment">//...</span>        <span class="hljs-comment">//通过名称移除"handler3"</span>        pipeline.remove(<span class="hljs-string">"handler3"</span>);        <span class="hljs-comment">//通过引用移除FirstHandler（它是唯一的，所以不需要它的名称）</span>        pipeline.remove(firstHandler);        <span class="hljs-comment">//将 SecondHandler("handler2")替换为 FourthHandler:"handler4"</span>        pipeline.replace(<span class="hljs-string">"handler2"</span>, <span class="hljs-string">"handler4"</span>, <span class="hljs-keyword">new</span> FourthHandler());    &#125;</code></pre></div><p>通常ChannelPipeline中的每个ChannelHandler都是通过它的EventLoop（I/O线程）来处理传递给它的事件的。</p><h3 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h3><ul><li>ChannelPipeline保存了与Channel相关联的ChannelHandler；</li></ul><ul><li>ChannelPipeline可以根据需要、通过添加或者删除ChannelHandler来动态修改；</li></ul><ul><li>ChannelPipeline有着丰富的API用以被调用、以响应入站和出站事件。</li></ul><h2 id="ChannelHandlerContext接口"><a href="#ChannelHandlerContext接口" class="headerlink" title="ChannelHandlerContext接口"></a>ChannelHandlerContext接口</h2><p>前面也提到了，ChannelHandlerContext代表了ChannelHandler和ChannelPipeline之间的关联，ChannelHandlerContext的主要功能就是管理它所关联的ChannelHandler和在同一个ChannelPipeline中的其他ChannelHandler之间的交互。</p><p>ChannelHandlerContext本身很多方法在Channel和ChannelPipeline中也存在，但是如果调用Channel或者ChannelPipeline上的这些方法，它们将沿着整个ChannelPipeline进行传播，而调用位于ChannelHandlerContext上的这些方法，则将从当前所关联的ChannelHandler开始，并且只会传播给位于该ChannelPipeline中的下一个能够处理该事件的ChannelHandler因此它会产生更短的事件流，性能会得到提高。</p><p>另外，ChannelHandlerContext和ChannelHandler之间的关联（绑定）是永远不会改变的，所以缓存对它的引用是安全的。</p><h3 id="使用ChannelHandlerContext"><a href="#使用ChannelHandlerContext" class="headerlink" title="使用ChannelHandlerContext"></a>使用ChannelHandlerContext</h3><p>Channel、ChannelPipeline、ChannelHandler以及ChannelHandlerContext之间的关系如下图：</p><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=777592249,3155125613&fm=15&gp=0.jpg" srcset="/img/loading.gif" alt="img"></p><p>为什么想要从channelPipeline中的某个特定点开始传播事件呢？</p><ul><li><p>为了减少将事件经传对它不感兴趣的ChannelHandler所带来的开销；</p></li><li><p>为了避免将事件传经那些可能会对它感兴趣的ChannelHandler。</p></li></ul><p>如果想调用从某个特定的ChannelHandler开始的处理过程，必须获取到在（ChannelPipeline）该ChannelHandler之前的ChannelHandler所关联的ChannelHandlerContext，这个ChannelHandlerContext将调用和它所关联的ChannelHandler之后的ChannelHandler。</p><p>通过ChannelHandlerContext触发的操作的事件流如下图所示：</p><p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=770095752,3504408543&fm=15&gp=0.jpg" srcset="/img/loading.gif" alt="img"></p><h3 id="ChannelHandler和ChannelHandlerContext的高级用法"><a href="#ChannelHandler和ChannelHandlerContext的高级用法" class="headerlink" title="ChannelHandler和ChannelHandlerContext的高级用法"></a>ChannelHandler和ChannelHandlerContext的高级用法</h3><p>通过调用ChannelHandlerContext上的pipeline()方法来获得被封闭的ChannelPipeline的引用，这使得运行时得以操作ChannelPipeline的ChannelHandler。如可以通过将ChannelHandler添加到ChannelPipeline中来实现动态的协议切换；还可以缓存ChannelHandlerContext的引用以供后面使用。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelHandlerAdapter</span> </span>&#123;    <span class="hljs-keyword">private</span> ChannelHandlerContext ctx;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;        <span class="hljs-comment">//存储到 ChannelHandlerContext的引用以供稍后使用</span>        <span class="hljs-keyword">this</span>.ctx = ctx;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(String msg)</span> </span>&#123;        <span class="hljs-comment">//使用之前存储的到 ChannelHandlerContext的引用来发送消息</span>        ctx.writeAndFlush(msg);    &#125;&#125;</code></pre></div><p>因为一个ChannelHandler可以从属于多个ChannelPipeline，所以也可以绑定多个ChannelHandlerContext实例，但是ChannelHandler必须使用@Sharable注解，并且ChannelHandler必须是线程安全的。</p><p>看个错误示例：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Sharable</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsharableHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;        <span class="hljs-comment">//将 count 字段的值加 1</span>        count++;        <span class="hljs-comment">//记录方法调用，并转发给下一个ChannelHandler</span>        System.out.println(<span class="hljs-string">"inboundBufferUpdated(...) called the "</span>                + count + <span class="hljs-string">" time"</span>);        ctx.fireChannelRead(msg);    &#125;&#125;</code></pre></div><p>为什么要共享一个ChannelHandler？</p><p>主要是用于收集跨越多个Channel的统计信息。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="处理入站异常"><a href="#处理入站异常" class="headerlink" title="处理入站异常"></a>处理入站异常</h3><p>要想处理入站异常，需要在自己的ChannelInboundHandler实现中重写exceptionCaught（）方法。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InboundExceptionHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx,</span></span><span class="hljs-function"><span class="hljs-params">        Throwable cause)</span> </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre></div><ul><li>ChannelHandler.exceptionCaught()的默认实现是简单地将当前异常转发给ChannelPipeline中的下一个ChannelHandler；</li><li>如果异常到达了ChannelPipeline的尾端，它将会被记录为未被处理；</li><li>要想自定义处理逻辑，需要重写exceptionCaught（）方法，然后决定是否需要将异常传播出去。</li></ul><h3 id="处理出站异常"><a href="#处理出站异常" class="headerlink" title="处理出站异常"></a>处理出站异常</h3><p>用于处理出站操作中的正常完成以及异常完成的选项，都基于以下的通知机制：</p><ul><li>每个出站操作都将返回一个ChannelFuture。注册到ChannelFuture的ChannelFutureListener将在操作完成时被通知该操作是成功了还是失败了；</li><li>几乎所有的ChannelOutboundHandler上的方法都会传入一个ChannelPromise的实例，作为ChannelFuture的子类，ChannelPromise也可以被分配用于异步通知的监听器。</li></ul><p>添加ChannelFutureListener到ChannelFuture的代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addingChannelFutureListener</span><span class="hljs-params">()</span></span>&#123;        Channel channel = CHANNEL_FROM_SOMEWHERE; <span class="hljs-comment">// get reference to pipeline;</span>        ByteBuf someMessage = SOME_MSG_FROM_SOMEWHERE; <span class="hljs-comment">// get reference to pipeline;</span>        <span class="hljs-comment">//...</span>        io.netty.channel.ChannelFuture future = channel.write(someMessage);        future.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(io.netty.channel.ChannelFuture f)</span> </span>&#123;                <span class="hljs-keyword">if</span> (!f.isSuccess()) &#123;                    f.cause().printStackTrace();                    f.channel().close();                &#125;            &#125;        &#125;);    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.Netty--ByteBuf</title>
    <link href="/2020/05/31/5-Netty-ByteBuf/"/>
    <url>/2020/05/31/5-Netty-ByteBuf/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>ByteBuf：Netty的数据容器</li><li>API的详细信息</li><li>用例</li><li>内存分配</li></ul></blockquote><h2 id="ByteBuf的API"><a href="#ByteBuf的API" class="headerlink" title="ByteBuf的API"></a>ByteBuf的API</h2><p>Java NIO虽然提供了ByteBuffer作为字节容器，但是其使用过于复杂和繁琐，因此用ByteBuf来代替ByteBuffer。</p><p>优点：</p><ul><li>可以被用户自定义的缓冲区类型扩展</li><li>通过内置的复合缓冲区类型实现了透明的零拷贝</li><li>容量可以按需增长</li><li>在读和写这两种模式之间切换不需要调用ByteBuffer的flip（）方法；</li><li>读和写使用了不同的索引；</li><li>支持方法的链式调用</li><li>支持引用计数</li><li>支持<a href="https://blog.csdn.net/syviah/article/details/46550161" target="_blank" rel="noopener">池化</a></li></ul><h2 id="ByteBuf类"><a href="#ByteBuf类" class="headerlink" title="ByteBuf类"></a>ByteBuf类</h2><h3 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h3><p>ByteBuf维护了两个不同的索引：一个用于读取，一个用于写入。当你从ByteBuf读取时，它的readIndex将会被递增已经被读取的字节数，同样，当你写入ByteBuf时，它的writerIndex也会被递增。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy84MTk2OTQxLTIyYjg2MzlkMGY0Njg0MDAucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="img"></p><h3 id="ByteBuf的使用模式"><a href="#ByteBuf的使用模式" class="headerlink" title="ByteBuf的使用模式"></a>ByteBuf的使用模式</h3><h4 id="堆缓冲区"><a href="#堆缓冲区" class="headerlink" title="堆缓冲区"></a>堆缓冲区</h4><p>将数据存储在JVM的堆空间中，这种模式被称为支撑数组，它能在没有使用<a href="https://blog.csdn.net/syviah/article/details/46550161" target="_blank" rel="noopener">池化</a>的情况下提供快速的分配和释放。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapBuffer</span><span class="hljs-params">()</span> </span>&#123;        ByteBuf heapBuf = BYTE_BUF_FROM_SOMEWHERE; <span class="hljs-comment">//get reference form somewhere</span>        <span class="hljs-comment">//检查 ByteBuf 是否有一个支撑数组</span>        <span class="hljs-keyword">if</span> (heapBuf.hasArray()) &#123;            <span class="hljs-comment">//如果有，则获取对该数组的引用</span>            <span class="hljs-keyword">byte</span>[] array = heapBuf.array();            <span class="hljs-comment">//计算第一个字节的偏移量</span>            <span class="hljs-keyword">int</span> offset = heapBuf.arrayOffset() + heapBuf.readerIndex();            <span class="hljs-comment">//获得可读字节数</span>            <span class="hljs-keyword">int</span> length = heapBuf.readableBytes();            <span class="hljs-comment">//使用数组、偏移量和长度作为参数调用你的方法</span>            handleArray(array, offset, length);        &#125;    &#125;</code></pre></div><h4 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h4><p>直接缓冲区时另一种ByteBuf模式，它的内容将驻留在常规的会被垃圾回收的堆之外，相对于堆缓冲区，它的分配和释放都较为昂贵，另外因为数据不是在堆上，所以还要进行一次复制。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">directBuffer</span><span class="hljs-params">()</span> </span>&#123;        ByteBuf directBuf = BYTE_BUF_FROM_SOMEWHERE; <span class="hljs-comment">//get reference form somewhere</span>        <span class="hljs-comment">//检查 ByteBuf 是否由数组支撑。如果不是，则这是一个直接缓冲区</span>        <span class="hljs-keyword">if</span> (!directBuf.hasArray()) &#123;            <span class="hljs-comment">//获取可读字节数</span>            <span class="hljs-keyword">int</span> length = directBuf.readableBytes();            <span class="hljs-comment">//分配一个新的数组来保存具有该长度的字节数据</span>            <span class="hljs-keyword">byte</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length];            <span class="hljs-comment">//将字节复制到该数组</span>            directBuf.getBytes(directBuf.readerIndex(), array);            <span class="hljs-comment">//使用数组、偏移量和长度作为参数调用你的方法</span>            handleArray(array, <span class="hljs-number">0</span>, length);        &#125;    &#125;</code></pre></div><h4 id="复合缓冲区"><a href="#复合缓冲区" class="headerlink" title="复合缓冲区"></a>复合缓冲区</h4><p>Netty通过一个ByteBuf子类CompositeByteBuf来提供一个将多个缓冲区表示为单个合并缓冲区的虚拟表示。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">byteBufComposite</span><span class="hljs-params">()</span> </span>&#123;        CompositeByteBuf messageBuf = Unpooled.compositeBuffer();        ByteBuf headerBuf = BYTE_BUF_FROM_SOMEWHERE; <span class="hljs-comment">// can be backing or direct</span>        ByteBuf bodyBuf = BYTE_BUF_FROM_SOMEWHERE;   <span class="hljs-comment">// can be backing or direct</span>        <span class="hljs-comment">//将 ByteBuf 实例追加到 CompositeByteBuf</span>        messageBuf.addComponents(headerBuf, bodyBuf);        <span class="hljs-comment">//...</span>        <span class="hljs-comment">//删除位于索引位置为 0（第一个组件）的 ByteBuf</span>        messageBuf.removeComponent(<span class="hljs-number">0</span>); <span class="hljs-comment">// remove the header</span>        <span class="hljs-comment">//循环遍历所有的 ByteBuf 实例</span>        <span class="hljs-keyword">for</span> (ByteBuf buf : messageBuf) &#123;            System.out.println(buf.toString());        &#125;    &#125;</code></pre></div><p>CompositeByteBuf可能不支持访问其支撑数组，因此访问CompositeByteBuf中的数据类似于访问直接缓冲区，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">byteBufCompositeArray</span><span class="hljs-params">()</span> </span>&#123;        CompositeByteBuf compBuf = Unpooled.compositeBuffer();        <span class="hljs-comment">//获得可读字节数</span>        <span class="hljs-keyword">int</span> length = compBuf.readableBytes();        <span class="hljs-comment">//分配一个具有可读字节数长度的新数组</span>        <span class="hljs-keyword">byte</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length];        <span class="hljs-comment">//将字节读到该数组中</span>        compBuf.getBytes(compBuf.readerIndex(), array);        <span class="hljs-comment">//使用偏移量和长度作为参数使用该数组</span>        handleArray(array, <span class="hljs-number">0</span>, array.length);    &#125;</code></pre></div><h2 id="字节级操作"><a href="#字节级操作" class="headerlink" title="字节级操作"></a>字节级操作</h2><h3 id="随机访问索引"><a href="#随机访问索引" class="headerlink" title="随机访问索引"></a>随机访问索引</h3><p>ByteBuf的索引也是从零开始的，访问数据的代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">byteBufRelativeAccess</span><span class="hljs-params">()</span> </span>&#123;        ByteBuf buffer = BYTE_BUF_FROM_SOMEWHERE; <span class="hljs-comment">//get reference form somewhere</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; buffer.capacity(); i++) &#123;            <span class="hljs-keyword">byte</span> b = buffer.getByte(i);            System.out.println((<span class="hljs-keyword">char</span>) b);        &#125;    &#125;</code></pre></div><h3 id="顺序访问索引"><a href="#顺序访问索引" class="headerlink" title="顺序访问索引"></a>顺序访问索引</h3><p>ByteBuf被读索引和写索引划分为了三个区域：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczAuYmRzdGF0aWMuY29tLzcwY0Z1SFNoX1ExWW54R2twb1dLMUhGNmhoeS9pdC91PTI2NDQwMjEyMDgsMzczMDkyNDY5OCZmbT0xNSZncD0wLmpwZw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="img"></p><h3 id="可丢弃字节"><a href="#可丢弃字节" class="headerlink" title="可丢弃字节"></a>可丢弃字节</h3><p>可丢弃字节的分段包含了已经被读过的字节。通过调用discardReadBytes()方法，可以丢弃它们并回收空间，变成可写字节，但是不建议频繁调用discardReadBytes()方法，因为可读字节必须被移动到缓冲区的开始位置。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy84MTk2OTQxLTY2MjFjZGQ2MjQwNzdkODcucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="img"></p><h3 id="可读字节"><a href="#可读字节" class="headerlink" title="可读字节"></a>可读字节</h3><p>存储了实际数据，任何名称以read 或者skip 开头的操作都将检索或者跳过位于当前readerIndex 的数据，并且将它增加已读字节数。</p><h3 id="可写字节"><a href="#可写字节" class="headerlink" title="可写字节"></a>可写字节</h3><p>拥未定义内容的、写入就绪的内存区域，任何名称以write开头的操作都将从当前的writerIndex处开始写数据，并将它增加已经写入的字节数。</p><h3 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h3><p>通过调用markReaderIndex()、markWriterIndex()、resetWriterIndex()和resetReaderIndex()来标记和重置ByteBuf 的readerIndex 和writerIndex。可以通过调用clear()方法来将readerIndex 和writerIndex 都设置为0，但是这并不会清除内存中的内容。</p><p>clear（）方法调用前：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy84MTk2OTQxLTZlMzMxM2E5NTA4NmRkMDgucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="img"></p><p>clear（）方法调用后：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy84MTk2OTQxLTYxNDdhYmM0M2MwNTYwZTYucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="img"></p><h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><ul><li><p>boolean process(byte value) 检查输入值是否是正在查找的值</p></li><li><p>forEachByte(ByteBufProcessor.FIND_NUL) 和以NULL结尾的内容的Flash套接字集成</p></li></ul><h3 id="派生缓冲区"><a href="#派生缓冲区" class="headerlink" title="派生缓冲区"></a>派生缓冲区</h3><p>1.duplicate()；<br> 2.slice()；<br> 3.slice(int, int)；<br> 4.Unpooled.unmodifiableBuffer(…)；<br> 5.order(ByteOrder)；<br> 6.readSlice(int)。</p><p>以上这些方法都将返回一个新的ByteBuf实例，它具有自己的读索引、写索引和标记索引，其内部存储和JDK的ByteBuffer一样也是共享的，因此如果修改了它的内容，那么同时也就修改了其对应的源实例。</p><p>如果需要一个现有缓冲区的真实副本，使用copy()或者copy(int,int)方法。</p><p>下面代码展示了如何使用slice(int,int)方法来操作ByteBuf的一个分段：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">byteBufSlice</span><span class="hljs-params">()</span> </span>&#123;      Charset utf8 = Charset.forName(<span class="hljs-string">"UTF-8"</span>);      <span class="hljs-comment">//创建一个用于保存给定字符串的字节的 ByteBuf</span>      ByteBuf buf = Unpooled.copiedBuffer(<span class="hljs-string">"Netty in Action rocks!"</span>, utf8);      <span class="hljs-comment">//创建该 ByteBuf 从索引 0 开始到索引 15 结束的一个新切片</span>      ByteBuf sliced = buf.slice(<span class="hljs-number">0</span>, <span class="hljs-number">15</span>);      <span class="hljs-comment">//将打印“Netty in Action”</span>      System.out.println(sliced.toString(utf8));      <span class="hljs-comment">//更新索引 0 处的字节</span>      buf.setByte(<span class="hljs-number">0</span>, (<span class="hljs-keyword">byte</span>)<span class="hljs-string">'J'</span>);      <span class="hljs-comment">//将会成功，因为数据是共享的，对其中一个所做的更改对另外一个也是可见的</span>      <span class="hljs-keyword">assert</span> buf.getByte(<span class="hljs-number">0</span>) == sliced.getByte(<span class="hljs-number">0</span>);  &#125;</code></pre></div><p>如果有可能，建议使用slice()方法来避免复制内存的开销。</p><h3 id="读-写操作"><a href="#读-写操作" class="headerlink" title="读/写操作"></a>读/写操作</h3><p>有两种类别的读/写操作：</p><ul><li><p>get()和set()操作，从给定的索引开始，并且保持索引不变；</p></li><li><p>read()和write()操作，从给定的索引开始，并且会根据已经访问过的字节数对索引进行调整。</p></li></ul><p>测试代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">byteBufSetGet</span><span class="hljs-params">()</span> </span>&#123;        Charset utf8 = Charset.forName(<span class="hljs-string">"UTF-8"</span>);        <span class="hljs-comment">//创建一个新的 ByteBuf以保存给定字符串的字节</span>        ByteBuf buf = Unpooled.copiedBuffer(<span class="hljs-string">"Netty in Action rocks!"</span>, utf8);        <span class="hljs-comment">//打印第一个字符'N'</span>        System.out.println((<span class="hljs-keyword">char</span>)buf.getByte(<span class="hljs-number">0</span>));        <span class="hljs-comment">//存储当前的 readerIndex 和 writerIndex</span>        <span class="hljs-keyword">int</span> readerIndex = buf.readerIndex();        <span class="hljs-keyword">int</span> writerIndex = buf.writerIndex();        <span class="hljs-comment">//将索引 0 处的字 节更新为字符'B'</span>        buf.setByte(<span class="hljs-number">0</span>, (<span class="hljs-keyword">byte</span>)<span class="hljs-string">'B'</span>);        <span class="hljs-comment">//打印第一个字符，现在是'B'</span>        System.out.println((<span class="hljs-keyword">char</span>)buf.getByte(<span class="hljs-number">0</span>));        <span class="hljs-comment">//将会成功，因为这些操作并不会修改相应的索引</span>        <span class="hljs-keyword">assert</span> readerIndex == buf.readerIndex();        <span class="hljs-keyword">assert</span> writerIndex == buf.writerIndex();    &#125;</code></pre></div><h2 id="ByteBufHolder接口"><a href="#ByteBufHolder接口" class="headerlink" title="ByteBufHolder接口"></a>ByteBufHolder接口</h2><p>Netty提供了ByteBufHolder来提供高级特性的支持，如存储各种属性值（HTTP响应中字节的内容，状态码，cookie等），缓冲区池化等。</p><p>ByteBufHolder只有几种用于访问底层数据和引用计数的方法：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>content()</td><td>返回由这个ByteBufHolder所持有的ByteBuf</td></tr><tr><td>copy()</td><td>返回这个ByteBufHolder的一个深拷贝，包括一个其所包含的ByteBuf 的非共享拷贝</td></tr><tr><td>duplicate()</td><td>返回这个ByteBufHolder 的一个浅拷贝，包括一个其所包含的ByteBuf 的共享拷贝</td></tr></tbody></table><h2 id="ByteBuf-分配"><a href="#ByteBuf-分配" class="headerlink" title="ByteBuf 分配"></a>ByteBuf 分配</h2><h3 id="按需分配：ByteBufAllocator-接口"><a href="#按需分配：ByteBufAllocator-接口" class="headerlink" title="按需分配：ByteBufAllocator 接口"></a>按需分配：ByteBufAllocator 接口</h3><p>Netty 通过<code>ByteBufAllocator</code>接口 实现了（ByteBuf 的）<a href="https://blog.csdn.net/syviah/article/details/46550161" target="_blank" rel="noopener">池化</a> ，它可以用来分配我们所描述过的任意类型的ByteBuf实例。</p><p>Netty提供了两种ByteBufAllocator 的实现： <code>PooledByteBufAllocator</code>和<code>UnpooledByteBufAllocator</code>。前者池化了ByteBuf的实例以提高性能并最大限度地减少内存碎片(一种称为jemalloc的已被大量现代操作系统所采用的高效方法来分配内存).后者的实现不池化ByteBuf实例，并且在每次它被调用时都会返回一个新的实例。</p><h3 id="Unpooled缓冲区"><a href="#Unpooled缓冲区" class="headerlink" title="Unpooled缓冲区"></a>Unpooled缓冲区</h3><p>提供静态的辅助方法来创建未池化的ByteBuf实例：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>buffer()<br/>buffer(int initialCapacity)<br/>buffer(int initialCapacity, int maxCapacity)</td><td>返回一个未池化的基于堆内存存储的ByteBuf</td></tr><tr><td>directBuffer()<br/>directBuffer(int initialCapacity)<br/>directBuffer(int initialCapacity, int maxCapacity)</td><td>返回一个未池化的基于直接内存存储的ByteBuf</td></tr><tr><td>wrappedBuffer()</td><td>返回一个包装了给定数据的ByteBuf</td></tr><tr><td>copiedBuffer()</td><td>返回一个复制了给定数据的ByteBuf</td></tr></tbody></table><h3 id="ByteBufUtil-类"><a href="#ByteBufUtil-类" class="headerlink" title="ByteBufUtil 类"></a>ByteBufUtil 类</h3><p>提供了用于操作ByteBuf的静态的辅助方法，有两个非常有用的方法：</p><ul><li>hexdump() 以十六进制的表示形式打印ByteBuf 的内容</li><li>equals(ByteBuf, ByteBuf) 它被用来判断两个ByteBuf实例的相等性</li></ul><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>引用计数是一种通过在某个对象所持有的资源不再被其他对象引用时释放该对象所持有的资源来优化内存使用和性能的技术。</p><p>引用计数对于池化实现（如PooledByteBufAllocator）来说是至关重要的，它降低了内存分配的开销。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">referenceCounting</span><span class="hljs-params">()</span></span>&#123;     Channel channel = CHANNEL_FROM_SOMEWHERE; <span class="hljs-comment">//get reference form somewhere</span>     <span class="hljs-comment">//从 Channel 获取ByteBufAllocator</span>     ByteBufAllocator allocator = channel.alloc();     <span class="hljs-comment">//...</span>     <span class="hljs-comment">//从 ByteBufAllocator分配一个 ByteBuf</span>     ByteBuf buffer = allocator.directBuffer();     <span class="hljs-comment">//检查引用计数是否为预期的 1</span>     <span class="hljs-keyword">assert</span> buffer.refCnt() == <span class="hljs-number">1</span>;     <span class="hljs-comment">//...</span> &#125;</code></pre></div><p>释放引用计数的对象：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseReferenceCountedObject</span><span class="hljs-params">()</span></span>&#123;      ByteBuf buffer = BYTE_BUF_FROM_SOMEWHERE; <span class="hljs-comment">//get reference form somewhere</span>      <span class="hljs-comment">//减少到该对象的活动引用。当减少到 0 时，该对象被释放，并且该方法返回 true</span>      <span class="hljs-keyword">boolean</span> released = buffer.release();      <span class="hljs-comment">//...</span>  &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.Netty--传输</title>
    <link href="/2020/05/31/4-Netty-%E4%BC%A0%E8%BE%93/"/>
    <url>/2020/05/31/4-Netty-%E4%BC%A0%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>OIO：阻塞传输</li><li>NIO：异步传输</li><li>Local：JVM内部的异步通信</li><li>Embedded：测试你的ChannelHandler</li></ul></blockquote><h2 id="案例研究：传输迁移"><a href="#案例研究：传输迁移" class="headerlink" title="案例研究：传输迁移"></a>案例研究：传输迁移</h2><h3 id="不通过Netty使用OIO和NIO"><a href="#不通过Netty使用OIO和NIO" class="headerlink" title="不通过Netty使用OIO和NIO"></a>不通过Netty使用OIO和NIO</h3><p>未使用Netty的阻塞网络编程代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlainOioServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//将服务器绑定到指定端口</span>        ServerSocket socket = <span class="hljs-keyword">new</span> ServerSocket(port);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span>(;;)&#123;                <span class="hljs-comment">//接收连接</span>                <span class="hljs-keyword">final</span> Socket clientSocket = socket.accept();                System.out.println(<span class="hljs-string">"Accepted connection from "</span>+ clientSocket);                <span class="hljs-comment">//创建一个新的线程来处理该连接</span>                <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                        OutputStream out;                        <span class="hljs-keyword">try</span> &#123;                            out = clientSocket.getOutputStream();                            out.write(<span class="hljs-string">"Hi!\r\n"</span>.getBytes(CharsetUtil.UTF_8));                            <span class="hljs-comment">//关闭连接</span>                            clientSocket.close();                        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                            e.printStackTrace();                        &#125;                        <span class="hljs-keyword">finally</span> &#123;                            <span class="hljs-keyword">try</span> &#123;                                clientSocket.close();                            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                                                            &#125;                        &#125;                    &#125;                &#125;).start();<span class="hljs-comment">//启动线程</span>            &#125;        &#125;        <span class="hljs-keyword">catch</span> (IOException e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre></div><p>未使用Netty的异步网络编程代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlainNioServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        ServerSocketChannel serverChannel = ServerSocketChannel.open();        serverChannel.configureBlocking(<span class="hljs-keyword">false</span>);        ServerSocket serverSocket = serverChannel.socket();        InetSocketAddress address = <span class="hljs-keyword">new</span> InetSocketAddress(port);        <span class="hljs-comment">//将服务器绑定到选定的端口</span>        serverSocket.bind(address);        <span class="hljs-comment">//打开Selector来处理Channel</span>        Selector selector = Selector.open();        <span class="hljs-comment">//将ServerSocket注册到Selector来接收连接</span>        serverChannel.register(selector, SelectionKey.OP_ACCEPT);        <span class="hljs-keyword">final</span> ByteBuffer msg = ByteBuffer.wrap(<span class="hljs-string">"Hi!\r\n"</span>.getBytes());        <span class="hljs-comment">//等待需要处理的新事件，阻塞将一直持续到下一个传入事件</span>        <span class="hljs-keyword">for</span> (;;)&#123;            <span class="hljs-keyword">try</span> &#123;                selector.select();            &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;                e.printStackTrace();                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-comment">//获取所有接收事件的SelectorKey实例</span>            Set&lt;SelectionKey&gt; readKeys = selector.selectedKeys();            Iterator&lt;SelectionKey&gt; iterator = readKeys.iterator();            <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;                SelectionKey key = iterator.next();                iterator.remove();                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">//检测事件是否是一个新的并且已经就绪可以被接收的连接</span>                    <span class="hljs-keyword">if</span>(key.isAcceptable())&#123;                        ServerSocketChannel server = (ServerSocketChannel) key.channel();                        SocketChannel client = server.accept();                        client.configureBlocking(<span class="hljs-keyword">false</span>);                        <span class="hljs-comment">//接收客户端，并将它注册到选择器</span>                        client.register(selector,SelectionKey.OP_WRITE |                                 SelectionKey.OP_READ,msg.duplicate());                        System.out.println(<span class="hljs-string">"Accepted connection from "</span> + client);                    &#125;                    <span class="hljs-comment">//检查套接字是否已经准备好写数据</span>                    <span class="hljs-keyword">if</span>(key.isWritable())&#123;                        SocketChannel client = (SocketChannel) key.channel();                        ByteBuffer buffer = (ByteBuffer) key.attachment();                        <span class="hljs-keyword">while</span>(buffer.hasRemaining())&#123;                            <span class="hljs-comment">//将数据写到已连接的客户端</span>                            <span class="hljs-keyword">if</span>(client.write(buffer) == <span class="hljs-number">0</span>)&#123;                                <span class="hljs-keyword">break</span>;                            &#125;                        &#125;                        <span class="hljs-comment">//关闭连接</span>                        client.close();                    &#125;                &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;                    key.cancel();                    <span class="hljs-keyword">try</span> &#123;                        key.channel().close();                    &#125;<span class="hljs-keyword">catch</span> (IOException ex)&#123;                                            &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="通过Netty使用OIO和NIO"><a href="#通过Netty使用OIO和NIO" class="headerlink" title="通过Netty使用OIO和NIO"></a>通过Netty使用OIO和NIO</h3><p>使用Netty的阻塞网络处理代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyOioServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">final</span> ByteBuf buf = Unpooled.unreleasableBuffer(                Unpooled.copiedBuffer(<span class="hljs-string">"Hi!\r\n"</span>, CharsetUtil.UTF_8));        OioEventLoopGroup group = <span class="hljs-keyword">new</span> OioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建ServerBootstrap</span>            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();            b.group(group)                    <span class="hljs-comment">//使用OioEventLoopGroup以允许阻塞模式</span>                    .channel(OioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                    .<span class="hljs-title">localAddress</span>(<span class="hljs-title">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-title">port</span>))</span><span class="hljs-class">                    //指定<span class="hljs-title">ChannelInitializer</span>，对于每个已接收的连接都调用它</span><span class="hljs-class">                    .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            <span class="hljs-comment">//添加一个ChannelInboundHandlerAdapter以拦截和处理事件</span>                            socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;                                <span class="hljs-meta">@Override</span>                                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span></span>&#123;                                    <span class="hljs-comment">//将消息写到客户端，并添加ChannelFutureListener，以便消息一被写完就关闭连接</span>                                    ctx.writeAndFlush(buf.duplicate()).addListener(ChannelFutureListener.CLOSE);                                &#125;                            &#125;);                        &#125;                    &#125;);            ChannelFuture f = b.bind().sync();            f.channel().closeFuture().sync();        &#125;<span class="hljs-keyword">finally</span> &#123;            group.shutdownGracefully().sync();        &#125;            &#125;&#125;</code></pre></div><p>非阻塞的Netty版本</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyNioServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">final</span> ByteBuf buf = Unpooled.unreleasableBuffer(                Unpooled.copiedBuffer(<span class="hljs-string">"Hi!\r\n"</span>, CharsetUtil.UTF_8));        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<span class="hljs-comment">//</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建ServerBootstrap</span>            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();            b.group(group)                    <span class="hljs-comment">//使用OioEventLoopGroup以允许阻塞模式</span>                    .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)//</span><span class="hljs-class">                    .<span class="hljs-title">localAddress</span>(<span class="hljs-title">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-title">port</span>))</span><span class="hljs-class">                    //指定<span class="hljs-title">ChannelInitializer</span>，对于每个已接收的连接都调用它</span><span class="hljs-class">                    .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            <span class="hljs-comment">//添加一个ChannelInboundHandlerAdapter以拦截和处理事件</span>                            socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;                                <span class="hljs-meta">@Override</span>                                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span></span>&#123;                                    <span class="hljs-comment">//将消息写到客户端，并添加ChannelFutureListener，以便消息一被写完就关闭连接</span>                                    ctx.writeAndFlush(buf.duplicate()).addListener(ChannelFutureListener.CLOSE);                                &#125;                            &#125;);                        &#125;                    &#125;);            ChannelFuture f = b.bind().sync();            f.channel().closeFuture().sync();        &#125;<span class="hljs-keyword">finally</span> &#123;            group.shutdownGracefully().sync();        &#125;    &#125;&#125;</code></pre></div><p>我们发现使用Netty框架，从阻塞传输切换到非阻塞传输代码要做的更改非常小。</p><h2 id="传输API"><a href="#传输API" class="headerlink" title="传输API"></a>传输API</h2><p>传输API 的核心就是Channel接口，它被用于所有的I/O操作，其层次结构如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200531232951464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>如图所示，每个Channel都将会被分配一个ChannelPipeline和ChannelConfig，ChannelConfig包含了该Channel的所有配置设置，并且支持热更新。</p><p>ChannelPipeline持有所有将应用于入站和出站数据以及事件的ChannelHandler实例，这些ChannelHandler实现了应用程序用于处理状态变化以及数据处理的逻辑。</p><p>ChannelHandler的典型用途包括：</p><ul><li>将数据从一种格式转换为另一种格式：</li><li>提供异常的通知；</li><li>提供Channel变为活动的或者非活动的通知；</li><li>提供当Channel注册到EventLoop或者从EventLoop注销时的通知；</li><li>提供有关用户自定义事件的通知。</li></ul><p>channel的方法：</p><table><thead><tr><th align="center">方法名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">eventLoop</td><td align="left">返回分配给Channel的EventLoop</td></tr><tr><td align="center">pipeline</td><td align="left">返回分配给Channel的ChannelPipeline</td></tr><tr><td align="center">isActive</td><td align="left">如果Channel是活动的，则返回true</td></tr><tr><td align="center">localAddress</td><td align="left">返回本地的SocketAddress</td></tr><tr><td align="center">remoteAddress</td><td align="left">返回远程的SocketAddress</td></tr><tr><td align="center">write</td><td align="left">将数据写到远程节点，这个数据将被传递给ChannelPipeline，并且排队直到它被冲刷</td></tr><tr><td align="center">flush</td><td align="left">将之前已写的数据冲刷到底层传输，如一个Socket</td></tr><tr><td align="center">writeAndFlush</td><td align="left">等同于调用write()并接着调用flush()方法</td></tr></tbody></table><p>前面我们也提到过，Netty的Channel实现是线程安全的，因此我们可以存储一个到Channel的引用，并且每当需要向远程节点写数据时，都可以使用它。</p><p>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChannelOperationExamples</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Channel CHANNEL_FROM_SOMEWHERE = <span class="hljs-keyword">new</span> NioSocketChannel();  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writingToChannelFromManyThreads</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 存储一个Channel的引用</span>        <span class="hljs-keyword">final</span> Channel channel = CHANNEL_FROM_SOMEWHERE;         <span class="hljs-comment">//创建持有要写数据的ByteBuf</span>        <span class="hljs-keyword">final</span> ByteBuf buf = Unpooled.copiedBuffer(<span class="hljs-string">"your data"</span>,                CharsetUtil.UTF_8);        <span class="hljs-comment">//创建将数据写到Channel 的 Runnable</span>        Runnable writer = <span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                channel.write(buf.duplicate());            &#125;        &#125;;        <span class="hljs-comment">//获取到线程池Executor 的引用</span>        Executor executor = Executors.newCachedThreadPool();        <span class="hljs-comment">//递交写任务给线程池以便在某个线程中执行</span>        executor.execute(writer);        <span class="hljs-comment">//递交另一个写任务以便在另一个线程中执行</span>        executor.execute(writer);        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><h2 id="内置的传输"><a href="#内置的传输" class="headerlink" title="内置的传输"></a>内置的传输</h2><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>NIO</td><td>基于选择器的方式</td></tr><tr><td>Epoll</td><td>由JNI驱动的epoll()和非阻塞IO，支持只有在Linux上可用的多种特性，如SO_REUSEPORT，比NIO传输更快，完全非阻塞</td></tr><tr><td>OIO</td><td>阻塞IO</td></tr><tr><td>Local</td><td>可以在VM内部通过管道进行通信的本地传输</td></tr><tr><td>Embedded</td><td>允许使用ChannelHandler而又不需要一个真正的基于网络的传输，主要用于测试</td></tr></tbody></table><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>NIO提供了一个所有I/O操作的全异步的实现，利用选择器来获取Channel状态改变时的通知，可能的状态变化有：</p><ul><li>新的Channel已被接收并且就绪；</li><li>Channel连接已经完成；</li><li>Channel有已经就绪的可供读取的数据；</li><li>Channel可用于写数据。</li></ul><p>选择器运行在一个检查状态变化并对其做出响应的线程上，在应用程序对状态的改变作出响应之后，选择器将会被重置，并将重复这个过程。</p><p>选择操作的位模式：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>OP_ACCEPT</td><td>请求在接收新连接并创建Channel时获得通知</td></tr><tr><td>OP_CONNECT</td><td>请求在建立一个连接时获得通知</td></tr><tr><td>OP_READ</td><td>请求当数据已经就绪，可以从Channel中读取时获得通知</td></tr><tr><td>OP_WRITE</td><td>请求当可以向Channel中写入更多的数据时获得通知</td></tr></tbody></table><p>处理流程如下：</p><p><img src="https://img-blog.csdnimg.cn/20200531232937617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>知识点扩展：</p><p>零拷贝：零拷贝时一种目前只有在使用NIO和Epoll传输时才可使用的特性，可以快速高效地将数据从文件系统移动到网络接口，而不需要将其从<strong>内核空间</strong>复制到<strong>用户空间</strong>，因此CPU不需要为数据在内存之间的拷贝消耗资源。但是它对于实现了数据加密或者压缩的文件系统是不可用的，只能传输文件的原始内容。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.Netty--Netty的组件和设计</title>
    <link href="/2020/05/31/3-Netty-Netty%E7%9A%84%E7%BB%84%E4%BB%B6%E5%92%8C%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/05/31/3-Netty-Netty%E7%9A%84%E7%BB%84%E4%BB%B6%E5%92%8C%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>Netty的技术和体系结构方面的内容</li><li>Channel、EventLoop和ChannelFuture</li><li>ChannelHandler和ChannelPipeline</li><li>引导</li></ul></blockquote><p>学习Netty是因为它是基于Java NIO 的异步和事件驱动的实现，保证了高负载下应用程序性能的最大化和可伸缩性；同时它包含了一组设计模式，实现了应用程序逻辑从网络层解耦，简化了开发过程，最大限度地提高了可测试性、模块化以及代码的可重用性。</p><h2 id="1-Channel、EventLoop和ChannelFuture"><a href="#1-Channel、EventLoop和ChannelFuture" class="headerlink" title="1. Channel、EventLoop和ChannelFuture"></a>1. Channel、EventLoop和ChannelFuture</h2><ul><li><p>Channel：Socket；</p></li><li><p>EventLoop：控制流、多线程处理、并发；</p></li><li><p>ChannelFuture：异步通知</p></li></ul><h3 id="Channel接口"><a href="#Channel接口" class="headerlink" title="Channel接口"></a>Channel接口</h3><p>基本的I/O操作（bind、connect、read、write）都依赖于底层网络传送所提供的原语，也就是Socket，而Netty中的Channel就是简化Socket编程的复杂性。</p><h3 id="EventLoop接口"><a href="#EventLoop接口" class="headerlink" title="EventLoop接口"></a>EventLoop接口</h3><p>用于处理连接的生命周期中所发生的事件。</p><p><img src="https://img-blog.csdnimg.cn/20200531232619159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>其关系是：</p><ul><li>一个EventLoopGroup包含一个或多个EventLoop；</li><li>一个EventLoop在它的生命周期内只和一个Thread绑定；</li><li>所有由EventLoop处理的I/O事件都将在它专有的Thread上被处理（<strong>消除了对同步的需求</strong>）</li><li>一个Channel在它的生命周期内只注册于一个EventLoop；</li><li>一个EventLoop可能会被分配给一个或多个Channel。</li></ul><h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><p>正因为Netty中所有的I/O操作都是异步的，其执行结果不会立即返回，所以Netty提供了ChannelFuture接口，其addListener()方法注册了一个ChannelFutureListener，以便在某个操作完成时(无论是否成功)都能得到通知。</p><h2 id="2-ChannelHandler和ChannelPipeline"><a href="#2-ChannelHandler和ChannelPipeline" class="headerlink" title="2. ChannelHandler和ChannelPipeline"></a>2. ChannelHandler和ChannelPipeline</h2><p>管理数据流以及执行应用程序处理逻辑的组件</p><h3 id="ChannelHandler接口"><a href="#ChannelHandler接口" class="headerlink" title="ChannelHandler接口"></a>ChannelHandler接口</h3><p>充当了所有处理入站和出站数据的应用程序逻辑的容器，因为<code>ChannelHandler</code>的方法是由<strong>网络事件触发</strong>的。</p><h3 id="ChannelPipeline接口"><a href="#ChannelPipeline接口" class="headerlink" title="ChannelPipeline接口"></a>ChannelPipeline接口</h3><p>提供了ChannelHandler链的容器，并定义了用于在该链上传播入站和出站事件流的API，当Channel被创建时，他会被自动的分配到它专属的ChannelPipeline。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//在创建Channel时向ChannelPipeline中添加一个EchoClientHandler实例</span>.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> EchoClientHandler());    &#125;&#125;);</code></pre></div><p><img src="https://img-blog.csdnimg.cn/2020053123263110.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>执行顺序由添加顺序所决定，ChannelHandler处理完后将数据传递给链中的下一个ChannelHandler，该ChanelHandler不一定会去修改数据，如果数据到达ChannelPipeline一端，也就说明处理结束。</p><p>当ChannelHandler被添加到ChannelPipeline时，它将会被分配一个ChannelHandlerContext，其代表了ChannelHandler和ChannelPipeline之间的绑定，主要用于写出站数据。</p><p>在Netty中有两种发送消息的方式，直接写到Channel中，也可以写到ChannelHandlerContext对象中，前一种方式将会导致消息从ChannelPipeline的尾端开始流动，后者将导致消息从ChannelPipeline中的下一个ChannelHandler开始流动。</p><h3 id="编码器和解码器"><a href="#编码器和解码器" class="headerlink" title="编码器和解码器"></a>编码器和解码器</h3><p>因为网络数据总是一系列的字节，而我们写的代码是一些对象</p><p>所有由Netty提供的编码器/解码器适配器类都实现了ChannelInboundHandler接口或者ChannelOutboundHandler接口。</p><h3 id="抽象类SimpleChannelInboundHandler"><a href="#抽象类SimpleChannelInboundHandler" class="headerlink" title="抽象类SimpleChannelInboundHandler"></a>抽象类SimpleChannelInboundHandler</h3><p>当我们利用一个ChannelHandler来接收解码消息，并对该数据应用业务逻辑，基本上只需要扩展基类SimpleChannelInboundHandler<T>，其中T就是我们要处理的Java类型。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;<span class="hljs-comment">//这里的ByteBuf应该是跟服务端代码没有关系的，根据我们自身的业务需求来定的</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">"Client received: "</span>+ byteBuf.toString(CharsetUtil.UTF_8));    &#125;</code></pre></div><h3 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h3><p>Netty的引导类为应用程序的<strong>网络层</strong>配置提供了容器，有两种类型的引导：一种用于客户端，另一种用于服务器，区别如下：</p><table><thead><tr><th align="center">区别</th><th align="center">BootStrap</th><th align="center">ServerBootStrap</th></tr></thead><tbody><tr><td align="center">网络编程中的作用</td><td align="center">连接到远程主机和端口</td><td align="center">绑定到一个本地端口</td></tr><tr><td align="center">EventLoopGroup的数目</td><td align="center">1</td><td align="center">2</td></tr></tbody></table><p>为什么ServerBootStrap需要两个EventLoopGroup呢？</p><p>因为服务器需要两组不同的Channel，第一组将只包含一个ServerChannel，代表服务器自身的已绑定到某个本地端口的正在监听的套接字，而第二组将包含所有已创建的用来处理传入客户端连接的Channel。</p><p><img src="https://img-blog.csdnimg.cn/20200531232645361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.Netty--你的第一款Netty应用</title>
    <link href="/2020/05/31/2-Netty-%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%BENetty%E5%BA%94%E7%94%A8/"/>
    <url>/2020/05/31/2-Netty-%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%BENetty%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li><p>设置开发环境</p></li><li><p>编写Echo服务器和客户端</p></li><li><p>构建并测试应用程序</p></li></ul></blockquote><h3 id="1-设置开发环境"><a href="#1-设置开发环境" class="headerlink" title="1.设置开发环境"></a>1.设置开发环境</h3><p>准备好JDK和Maven</p><h3 id="2-Netty客户端-服务器概览"><a href="#2-Netty客户端-服务器概览" class="headerlink" title="2.Netty客户端/服务器概览"></a>2.Netty客户端/服务器概览</h3><p><img src="https://img-blog.csdnimg.cn/20200531232146835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>在客户端建立一个连接之后，它会向服务器发送一个或多个消息，反过来，服务器又会将每个消息回送给客户端。</p><h3 id="3-编写Echo服务器"><a href="#3-编写Echo服务器" class="headerlink" title="3.编写Echo服务器"></a>3.编写Echo服务器</h3><p>首先明确的一点是，所有的Netty服务器都需要以下两部分：</p><ul><li>至少一个ChannelHandler：用户实现服务器对从客户端接收的数据的处理，即业务逻辑。</li><li>引导：配置服务器的启动代码，如将服务器绑定到它需要监听连接请求的端口上。</li></ul><h4 id="3-1ChannelHandler和业务逻辑"><a href="#3-1ChannelHandler和业务逻辑" class="headerlink" title="3.1ChannelHandler和业务逻辑"></a>3.1ChannelHandler和业务逻辑</h4><p>ChannelHandler是一个父接口，它的实现负责接收并响应事件通知。</p><p>这里我们的Echo服务器需要响应传入的消息，所以需要实现ChannelInboundHandler接口，用来定义响应入站事件的方法，这里我们继承ChannelInboundHandlerAdapter类。</p><p>主要有如下方法可以调用：</p><ul><li><p>channelRead(): 对于每个传入的消息都要调用</p></li><li><p>channelReadComplete()：表明了本次从 Socket 读了数据，但是否是完整的数据它其实并不知道</p></li><li><p>exceptionCaught()：在读取操作期间 ，有异常抛出时会调用</p></li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/** Sharable标识一个ChannelHandler可以被多个Channel安全地共享 **/</span><span class="hljs-meta">@ChannelHandler</span>.Sharable<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ByteBuf in = (ByteBuf)msg;        System.out.println(<span class="hljs-string">"Server received: "</span> + in.toString(CharsetUtil.UTF_8));        <span class="hljs-comment">//将接收到的消息写给发送者</span>        ctx.write(in);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//将消息冲刷到客户端，并且关闭该Channel</span>        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//打印异常栈跟踪</span>        cause.printStackTrace();        <span class="hljs-comment">//关闭该Channel</span>        ctx.close();    &#125;&#125;</code></pre></div><h4 id="3-2-引导服务器"><a href="#3-2-引导服务器" class="headerlink" title="3.2 引导服务器"></a>3.2 引导服务器</h4><p>主要内容如下：</p><ul><li>绑定服务器将在其上监听并接收传入连接请求的端口；</li><li>配置Channel，以将有关的入站消息通知给EchoServerHandler实例</li></ul><p>编写EchoServer类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EchoServer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;        <span class="hljs-keyword">this</span>.port = port;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">//设置端口值不正确</span>        <span class="hljs-keyword">if</span>(args.length != <span class="hljs-number">1</span>)&#123;            System.err.print("Usage: "+EchoServer.class.getSimpleName() + "&lt;port&gt;");        &#125;        <span class="hljs-keyword">int</span> port = Integer.parseInt(args[<span class="hljs-number">0</span>]);        <span class="hljs-comment">//调用服务器的start()方法</span>        <span class="hljs-keyword">new</span> EchoServer(port).start();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">final</span> EchoServerHandler serverHandler = <span class="hljs-keyword">new</span> EchoServerHandler();        <span class="hljs-comment">//创建EventLoopGroup，因为我们使用的是NIO传输，所以要指定NioEventLoopGroup来接收和处理新的连接</span>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建ServerBootstrap</span>            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();            b.group(group)                    <span class="hljs-comment">//指定所使用的NIO传输Channel，同理因为NIO传输</span>                    .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                    //使用指定的端口设置套接字地址，服务器将绑定到这个地址以监听新的连接请求</span><span class="hljs-class">                    .<span class="hljs-title">localAddress</span>(<span class="hljs-title">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-title">port</span>))</span><span class="hljs-class">                    //当一个新的连接被接收时，一个新的子<span class="hljs-title">Channel</span>将会被创建，<span class="hljs-title">ChannelInitializer</span>会把<span class="hljs-title">EchoServerHandler</span>的实例添加到<span class="hljs-title">Channel</span>的<span class="hljs-title">ChannelPipeline</span>中,这个<span class="hljs-title">ChannelHandler</span>会接收入站消息的通知。</span><span class="hljs-class">                    .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            <span class="hljs-comment">//由于EchoServerHandler被标注位@Shareable，所以我们使用的是同一个EchoServerHandler</span>                            socketChannel.pipeline().addLast(serverHandler);                        &#125;                    &#125;);            <span class="hljs-comment">//异步的绑定服务器，调用sync()方法阻塞等待直到绑定完成</span>            ChannelFuture f = b.bind().sync();            <span class="hljs-comment">//获取Channel的CloseFuture，并且阻塞当前线程直到它完成</span>            f.channel().closeFuture().sync();        &#125;<span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//关闭EventLoopGroup，并且释放所有的资源</span>            group.shutdownGracefully().sync();        &#125;    &#125;&#125;</code></pre></div><p>主要步骤：</p><ul><li>EchoServerHandler实现业务逻辑；</li><li>main()方法引导了服务器</li></ul><p>在引导过程中的步骤：</p><ul><li><p>使用一个EchoServerHandler实例来初始化每一个新的Channel</p></li><li><p>创建并分配一个NioEventLoopGroup实例以进行事件的处理，如接收新连接以及读/写数据；</p></li><li><p>创建一个ServerBootstrap的实例以引导和绑定服务器；</p></li><li><p>指定服务器绑定的本地InetSocketAddress</p></li><li><p>调用ServerBootstrap.bind()方法来绑定服务器</p></li></ul><h3 id="4-编写Echo客户端"><a href="#4-编写Echo客户端" class="headerlink" title="4. 编写Echo客户端"></a>4. 编写Echo客户端</h3><p>Echo客户端主要任务：</p><ul><li>连接到服务端</li><li>发送一个或多个消息；</li><li>对于每个消息，等待并接收从服务器发回的消息；</li><li>关闭连接</li></ul><p>客户端所涉及到的两个主要代码部分也是业务逻辑和引导</p><h4 id="4-1-通过ChannelHandler实现客户端逻辑"><a href="#4-1-通过ChannelHandler实现客户端逻辑" class="headerlink" title="4.1 通过ChannelHandler实现客户端逻辑"></a>4.1 通过ChannelHandler实现客户端逻辑</h4><p>客户端也拥有一个用来处理数据的ChannelInboundHandler，这里我们扩展SimpleChannelInboundHandler类来处理所有必须的任务，重写以下方法：</p><ul><li><p>channelActive()：在到服务器的连接已经建立之后将被调用</p></li><li><p>channel Read0()：当从服务器接收到一条消息时被调用</p></li><li><p>exceptionCaught()：在处理过程中引发异常时被调用</p></li></ul><p>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;    <span class="hljs-comment">/** 连接服务器后调用该方法 **/</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">"Netty rocks!"</span>, CharsetUtil.UTF_8));    &#125;    <span class="hljs-comment">/** 从服务器接收到消息后调用该方法 **/</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">"Client received: "</span>+ byteBuf.toString(CharsetUtil.UTF_8));    &#125;    <span class="hljs-comment">/** 发生异常时，记录错误并关闭Channel **/</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre></div><p>注意： 从服务器发送的消息可能会被分块接收，channelRead0()方法因此有可能被调用多次。</p><p>还有一点值得注意的是Echo 服务端使用的ChannelHandler是 ChannelInboundHandlerAdapter，而 Echo 客户端使用的却是 SimpleChannelInboundHandler，其实它们是继承关系。</p><p><img src="https://img-blog.csdnimg.cn/20200531232251632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>既然是继承关系，也就是说，”你有的我也有，你没有的我还有。” 那么 SimpleChannelInboundHandler 里面肯定重写或者新增了 ChannelInboundHandlerAdapter 里面的方法功能 - channelRead0 和 channelRead()。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, I msg)</span> <span class="hljs-keyword">throws</span> Exception</span>;</code></pre></div><p>至于为什么会这样设计，原因是在客户端，当 channelRead0() 方法完成时，你已经有了传入消息，并且已经处理完它了。当该方法返回时，SimpleChannelInboundHandler负责释放指向保存该消息的ByteBuf的内存引用。而在服务端，你仍然需要将传入消息回送给发送者，而 write() 操作是异步的，直到 channelRead() 方法返回后可能仍然没有完成。为此，EchoServerHandler扩展了 ChannelInboundHandlerAdapter ，其在这个时间点上不会释放消息。</p><h4 id="4-2-引导客户端"><a href="#4-2-引导客户端" class="headerlink" title="4.2 引导客户端"></a>4.2 引导客户端</h4><p>客户端使用主机和端口号来连接远程地址</p><p>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoClient</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String host;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EchoClient</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port)</span> </span>&#123;        <span class="hljs-keyword">this</span>.host = host;        <span class="hljs-keyword">this</span>.port = port;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">if</span>(args.length != <span class="hljs-number">2</span>)&#123;            System.err.println("Usage: "+ EchoClient.class.getSimpleName()+"&lt;host&gt; &lt;port&gt;");            <span class="hljs-keyword">return</span>;        &#125;        String host = args[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> port = Integer.parseInt(args[<span class="hljs-number">1</span>]);        <span class="hljs-keyword">new</span> EchoClient(host,port).start();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            Bootstrap b = <span class="hljs-keyword">new</span> Bootstrap();            b.group(group)                    .channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                    .<span class="hljs-title">remoteAddress</span>(<span class="hljs-title">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-title">host</span>,<span class="hljs-title">port</span>))</span><span class="hljs-class">                    //在创建<span class="hljs-title">Channel</span>时向<span class="hljs-title">ChannelPipeline</span>中添加一个<span class="hljs-title">EchoClientHandler</span>实例</span><span class="hljs-class">                    .<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> EchoClientHandler());                        &#125;                    &#125;);            ChannelFuture f = b.connect().sync();            f.channel().closeFuture().sync();        &#125;<span class="hljs-keyword">finally</span> &#123;            group.shutdownGracefully().sync();        &#125;    &#125;&#125;</code></pre></div><h3 id="5-构建和运行Echo服务器和客户端"><a href="#5-构建和运行Echo服务器和客户端" class="headerlink" title="5. 构建和运行Echo服务器和客户端"></a>5. 构建和运行Echo服务器和客户端</h3><p>目录如下：</p><p><img src="https://img-blog.csdnimg.cn/20200531231945351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>注意要在pom.xml文件中引入netty依赖以及编译maven模板需要的插件。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.netty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>netty-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.42.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.mojo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>exec-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>                  <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>                      <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                          <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>                      <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>                  <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                  <span class="hljs-comment">&lt;!--指定main文件,不指定会报错，如果是client就要变成EchoClient--&gt;</span>                  <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>EchoServer<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><p>先执行<code>mvn clean package</code>来清除指定的包，然后<code>cd server</code>，执行<code>exec:java -Dexec.args=&quot;1&quot;</code>,接下来点击右下角的加号新建一个终端，然后<code>cd client</code>，执行<code>exec:java -Dexec.args=&quot;0 1&quot;</code>，即可看到效果。一定一定要先开启服务器然后再开客户端，否则会报错。</p><p>效果：</p><p><img src="https://img-blog.csdnimg.cn/20200531231925350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>补充一个遇到的坑：</p><p><img src="https://img-blog.csdnimg.cn/20200531231845780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>如果在执行<code>mvn exec:java -Dexec.args=&quot;0 1&quot;</code>的时候出现上面错误，首先去自己的maven的目录下查看配置文件setting.xml</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\Software\apache-maven-3.6.1\repository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span></code></pre></div><p>看路径是否正确，其次检查IDEA中的MAVEN配置。</p><p><img src="https://img-blog.csdnimg.cn/20200531232454527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.Netty--异步和事件驱动</title>
    <link href="/2020/05/30/1-Netty-%E5%BC%82%E6%AD%A5%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/"/>
    <url>/2020/05/30/1-Netty-%E5%BC%82%E6%AD%A5%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本系列文章主要来自《Netty IN ACTION》</p><p>本章主要内容：</p><ul><li><p>Java网络编程</p></li><li><p>Netty简介</p></li><li><p>Netty核心组件</p></li></ul></blockquote><h2 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h2><p>首先来看一个典型的阻塞I/O示例：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//创建一个新的ServerSocket，用于监听指定端口上的连接请求</span>ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(portNumber);<span class="hljs-comment">//1</span><span class="hljs-comment">//以阻塞的方式来调用accept()方法，直到一个连接建立</span>Socket clientSocket = serverSocket.accept();<span class="hljs-comment">//2</span><span class="hljs-comment">//BufferedReader和PrintWriter分别用于从字符输入流中读取文本和将对象格式化到文本输出流</span>BufferedReader in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(clientSocket.getInputStream()));PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(clientSocket.getOutputStream(),<span class="hljs-keyword">true</span>);String request,response;<span class="hljs-comment">//循环对输入流进行判断处理</span><span class="hljs-keyword">while</span>((request = in.readLine()) != <span class="hljs-keyword">null</span>)&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-string">"Done"</span>.equals(request))&#123;        <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-comment">//服务器处理客户端的请求，并作出响应</span>    response = processRequest(request);    <span class="hljs-comment">//输出响应</span>    out.println(response);</code></pre></div><p>这里<code>ServerSocket</code>的作用是监听某一路端口是否有连接，如果有连接就会创建一个新的<code>Socket</code>用于客户端和服务器进行通信，而此时<code>ServerSocket</code>并不会断开连接，而是会继续监听传入的连接。</p><p><img src="https://img-blog.csdnimg.cn/20200531231530747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>这里就体现出弊端了，如果有多个并发客户端，那就需要为每个客户端Socket创建一个Thread，弊端有三：</p><ul><li>资源浪费，并不是每时每刻都有数据在传输，大部分情况下线程都处在休眠状态；</li><li>内存消耗，需要为每个线程的调度栈分配内存；</li><li>上下文切换带来的开销大；</li></ul><h3 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h3><p>使用setSockopt()方法配置套接字，以便读/写调用在没有数据的时候立即返回</p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>使用<code>java.nio.channels.Selector</code>这个类，利用事件通知API来确定在一组非阻塞套接字中有哪些已经就绪能够进行I/O相关的操作。</p><p><img src="https://img-blog.csdnimg.cn/20200531231550220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="Netty简介"><a href="#Netty简介" class="headerlink" title="Netty简介"></a>Netty简介</h2><p>Netty是一个<strong>NIO</strong>客户端/服务器<strong>框架</strong>，支持快速、简单地开发网络应用，如协议服务器和客户端。</p><h2 id="Netty核心组件"><a href="#Netty核心组件" class="headerlink" title="Netty核心组件"></a>Netty核心组件</h2><p>Netty的主要构建块：</p><ul><li>Channel</li><li>回调</li><li>Future</li><li>事件和Channelhandler</li></ul><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>简单理解就是传入或者传出数据的载体，可以被打开或者被关闭，连接或者断开连接。</p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>回调其实就是一个方法，回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。Netty内部使用了回调来处理事件，当一个回调被触发时，相关的事件被一个ChannelHandler的实现来处理，</p><p>看下面一段代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(channelHandlerContect ctx)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        System.out.println(<span class="hljs-string">"Client "</span> + ctx.channel().remoteAddress() + <span class="hljs-string">" connected"</span>);    &#125;&#125;</code></pre></div><p>当一个新的连接已经被建立时，ChannelHandler的channelActive()回调方法将会被调用，并将打印一条信息。</p><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>可以看作是一个异步操作的结果的占位符，可以在未来提供对其结果的访问；</p><p>Netty提供了自己的ChannelFuture，用于在执行异步操作的时候使用。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectExample</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Channel CHANNEL_FROM_SOMEWHERE = <span class="hljs-keyword">new</span> NioSocketChannel();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">()</span> </span>&#123;        Channel channel = CHANNEL_FROM_SOMEWHERE;         <span class="hljs-comment">//异步地连接到远程节点</span>        ChannelFuture future = channel.connect(                <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"192.168.0.1"</span>, <span class="hljs-number">25</span>));        <span class="hljs-comment">//注册一个 ChannelFutureListener，以便在操作完成时获得通知</span>        future.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> </span>&#123;                <span class="hljs-comment">//检查操作的状态</span>                <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;                    <span class="hljs-comment">//如果操作是成功的，则创建一个 ByteBuf 以持有数据</span>                    ByteBuf buffer = Unpooled.copiedBuffer(                            <span class="hljs-string">"Hello"</span>, Charset.defaultCharset());                    <span class="hljs-comment">//将数据异步地发送到远程节点。返回一个 ChannelFuture</span>                    ChannelFuture wf = future.channel()                            .writeAndFlush(buffer);                    <span class="hljs-comment">// ...</span>                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">//如果发生错误，则访问描述原因的 Throwable</span>                    Throwable cause = future.cause();                    cause.printStackTrace();                &#125;            &#125;        &#125;);    &#125;&#125;</code></pre></div><p>可以看到，回调和Future是相互补充的机制，而ChannelFutureListener可以看作是回调的一个更加精细的版本。</p><h3 id="事件和Channelhandler"><a href="#事件和Channelhandler" class="headerlink" title="事件和Channelhandler"></a>事件和Channelhandler</h3><p>Netty使用不同的事件来通知我们状态的改变或者是操作的状态，因此我们可以利用事件来进行相应的处理，比如：</p><ul><li>记录日志</li><li>数据转换</li><li>流控制</li><li>应用程序逻辑</li></ul><p>Netty作为一个网络编程框架，主要事件分为入站事件和出站事件，入站事件包括：</p><ul><li>连接已被激活或者连接失活</li><li>数据读取</li><li>用户事件</li><li>错误事件</li></ul><p>出站事件包括：</p><ul><li>打开或者关闭远程节点的连接</li><li>将数据写到或者冲刷到套接字</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(9)--角色继承</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-9-%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-9-%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<p>在本节中，补充下<strong>角色继承</strong>的知识点。角色继承其实是一个十分常见的需求，因为一般系统中角色权限呈金字塔型，高层用户拥有底层用户的权限。</p><p>例如存在以下角色：普通用户、VIP 用户、SVIP 用户、星悦会员，那么对应的权限可以是“星悦会员 &gt; SVIP 用户 &gt; VIP 用户 &gt; 普通用户”。那么如何在 Spring Security 中实现这样的功能呢？</p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>为了简便起见，我直接使用<a href="https://www.jitwxs.cn/5f5715e6.html" target="_blank" rel="noopener">《SpringBoot 集成 Spring Security（1）——入门程序》</a> 的代码。</p><p>在该章中，我们存在两个角色，<code>ROLE_ADMIN</code> 和 <code>ROLE_USER</code>，并且经过我们的实验，<code>/admin</code> 接口只有 ROLE_ADMIN 有权限，<code>/user</code> 接口只有 ROLE_USER 有权限。</p><p>但是如果我想让 ROLE_ADMIN 用户继承 ROLE_USER 用户的所有权限，该如何做呢？</p><h3 id="RoleHierarchy"><a href="#RoleHierarchy" class="headerlink" title="RoleHierarchy"></a>RoleHierarchy</h3><p>这里就需要引入 <code>RoleHierarch</code>了，我们只需要自定义一个 RoleHierarchy，并将其注入容器即可。修改 <code>WebSecurityConfig</code>，在其中注入 RoleHierarchy：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> RoleHierarchy <span class="hljs-title">roleHierarchy</span><span class="hljs-params">()</span></span>&#123;    RoleHierarchyImpl roleHierarchy = <span class="hljs-keyword">new</span> RoleHierarchyImpl();    String hierarchy = <span class="hljs-string">"ROLE_ADMIN &gt; ROLE_USER"</span>;    roleHierarchy.setHierarchy(hierarchy);    <span class="hljs-keyword">return</span> roleHierarchy;&#125;</code></pre></div><p><code>roleHierarchy.setHierarchy()</code> 指定了角色的继承关系，参数就是一个字符串，比大小即可，是不是非常简单？</p><p>让我们使用 ROLE_ADMIN 账号登陆，发现原本无法访问的 <code>/user</code> 接口也可以访问了：</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>角色关系的实现也比较简单，本质就是将字符串使用正则切分，并将角色关系存放进一个 Map 中，map 的 key 是大的角色，value 是一个 Set，存放所有比它小的角色。然后交由后续处理，有兴趣的可以继续阅读源码。</p><p><img src="https://www.jitwxs.cn/images/posts/20190902233900717.png" srcset="/img/loading.gif" alt="buildRolesReachableInOneStepMap()"></p><p>如果有多个继承关系，在 SpringBoot 2.1 中，就应该改写为：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> RoleHierarchy <span class="hljs-title">roleHierarchy</span><span class="hljs-params">()</span> </span>&#123;    String separator = System.lineSeparator();        RoleHierarchyImpl roleHierarchy = <span class="hljs-keyword">new</span> RoleHierarchyImpl();    String hierarchy = <span class="hljs-string">"ROLE_ADMIN &gt; ROLE_USER "</span> + separator + <span class="hljs-string">" ROLE_USER &gt; ROLE_TOURISTS"</span>;    roleHierarchy.setHierarchy(hierarchy);    <span class="hljs-keyword">return</span> roleHierarchy;&#125;</code></pre></div><p>另外换行符大家都知道在不同系统中表示不一样，例如 Windows 中为 <code>\r\n</code>，Mac 为 <code>\r</code>，Linux 为 <code>\n</code>，因此以上代码我是用的 <code>java.lang</code> 包的 System 类中封装的方法，不用判断当前操作系统。</p>]]></content>
    
    
    <categories>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(8)--短信验证码登录</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-8-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E5%BD%95/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-8-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一、理论说明"><a href="#一、理论说明" class="headerlink" title="一、理论说明"></a>一、理论说明</h2><p>在开始编码前，先理解下短信验证码的实现流程。如果你能对<a href="https://www.jitwxs.cn/a28c0db7.html" target="_blank" rel="noopener">《SpringBoot集成Spring Security（7）——认证流程》</a>这篇文章有一定的了解的话，那么这篇文章的学习你会轻松许多。</p><h3 id="1-1-用户名密码登录逻辑"><a href="#1-1-用户名密码登录逻辑" class="headerlink" title="1.1 用户名密码登录逻辑"></a>1.1 用户名密码登录逻辑</h3><p>废话不多说，在上一篇文章中，以标准的用户名密码登录为例，讲解了整个认证流程。大致流程如下：</p><ol><li><p>先进入 <code>UsernamePasswordAuthenticationFilter</code> 中，根据输入的用户名和密码信息，构造出一个暂时没有鉴权的 <code>UsernamePasswordAuthenticationToken</code>，并将 UsernamePasswordAuthenticationToken 交给 <code>AuthenticationManager</code>处理。</p></li><li><p><code>AuthenticationManager</code>本身并不做验证处理，他通过 for-each 遍历找到符合当前登录方式的一个 AuthenticationProvider，并交给它进行验证处理，对于用户名密码登录方式，这个 Provider 就是 <code>DaoAuthenticationProvider</code>。</p></li><li><p>在这个 Provider 中进行一系列的验证处理，如果验证通过，就会重新构造一个添加了鉴权的 <code>UsernamePasswordAuthenticationToken</code>，并将这个 token 传回到 <code>UsernamePasswordAuthenticationFilter</code> 中。</p></li><li><p>在该 Filter 的父类 <code>AbstractAuthenticationProcessingFilter</code> 中，会根据上一步验证的结果，跳转到 successHandler 或者是 failureHandler。</p><p><img src="https://www.jitwxs.cn/images/posts/20181202095539982.png" srcset="/img/loading.gif" alt="img"></p><p>​                                                    Spring Security 认证流程（部分）</p></li></ol><h3 id="1-2-短信验证码登录逻辑"><a href="#1-2-短信验证码登录逻辑" class="headerlink" title="1.2 短信验证码登录逻辑"></a>1.2 短信验证码登录逻辑</h3><p>我们可以仿照用户名密码登录的逻辑，来实现短信验证码的登录逻辑。</p><ol><li>用户名密码登录有个 <code>UsernamePasswordAuthenticationFilter</code> ，我们搞一个 <code>SmsAuthenticationFilter</code>，代码粘过来改一改。</li><li>用户名密码登录需要 <code>UsernamePasswordAuthenticationToken</code>，我们搞一个 <code>SmsAuthenticationToken</code>，代码粘过来改一改。</li><li>用户名密码登录需要 <code>DaoAuthenticationProvider</code>，我们模仿它也implenments AuthenticationProvider，叫做 <code>SmsAuthenticationProvider</code>。</li></ol><p><img src="https://www.jitwxs.cn/images/posts/2019010916114182.png" srcset="/img/loading.gif" alt="短信登录验证逻辑"></p><p>​                                                                                短信登录验证逻辑</p><p>我们自己搞了上面三个类以后，想要实现的效果如上图所示。当我们使用短信验证码登录的时候：</p><ol><li>先经过 <code>SmsAuthenticationFilter</code>，构造一个没有鉴权的 <code>SmsAuthenticationToken</code>，然后交给 AuthenticationManager 处理。</li><li>AuthenticationManager 通过 for-each 挑选出一个合适的 provider 进行处理，当然我们希望这个 provider 要是 <code>SmsAuthenticationProvider</code>。</li><li>验证通过后，重新构造一个有鉴权的 <code>SmsAuthenticationToken</code>，并返回给 <code>SmsAuthenticationFilter</code>。</li><li>filter 根据上一步的验证结果，跳转到成功或者失败的处理逻辑。</li></ol><h2 id="二、代码实战"><a href="#二、代码实战" class="headerlink" title="二、代码实战"></a>二、代码实战</h2><p>请通过 github 链接下载第一章代码，或者参看<a href="https://www.jitwxs.cn/5f5715e6.html" target="_blank" rel="noopener">《SpringBoot集成Spring Security（1）——入门程序》</a>初始化项目，这里就不再赘述了。</p><h3 id="2-1-SmsAuthenticationToken"><a href="#2-1-SmsAuthenticationToken" class="headerlink" title="2.1 SmsAuthenticationToken"></a>2.1 SmsAuthenticationToken</h3><p>首先我们编写 <code>SmsAuthenticationToken</code>，这里直接参考 <code>UsernamePasswordAuthenticationToken</code> 源码，直接粘过来，改一改。</p><p><strong>步骤：</strong></p><ol><li><code>principal</code> 原本代表用户名，这里保留，只是代表了手机号码。</li><li><code>credentials</code> 原本代码密码，短信登录用不到，直接删掉。</li><li><code>SmsCodeAuthenticationToken()</code> 两个构造方法一个是构造没有鉴权的，一个是构造有鉴权的。</li><li>剩下的几个方法去除无用属性即可。</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsAuthenticationToken</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAuthenticationToken</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-comment">/** 表示用户的手机号 **/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object principal;    <span class="hljs-comment">/** 构建一个没有鉴权的SmsAuthenticationToken **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmsAuthenticationToken</span><span class="hljs-params">(Object principal)</span></span>&#123;        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">null</span>);        <span class="hljs-keyword">this</span>.principal = principal;        setAuthenticated(<span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-comment">/** 构建一个有鉴权的SmsAuthenticationToken **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmsAuthenticationToken</span><span class="hljs-params">(Collection&lt;? extends GrantedAuthority&gt; authorities, Object principal)</span> </span>&#123;        <span class="hljs-keyword">super</span>(authorities);        <span class="hljs-keyword">this</span>.principal = principal;        <span class="hljs-keyword">super</span>.setAuthenticated(<span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getPrincipal</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.principal;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getCredentials</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthenticated</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isAuthenticated)</span></span>&#123;        <span class="hljs-keyword">if</span>(isAuthenticated)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Cannot set this token to trusted-user constructor which takes a GrantedAuthority list instead"</span>);        &#125;        <span class="hljs-keyword">super</span>.setAuthenticated(<span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eraseCredentials</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.eraseCredentials();    &#125;&#125;</code></pre></div><h3 id="2-2-SmsAuthenticationFilter"><a href="#2-2-SmsAuthenticationFilter" class="headerlink" title="2.2 SmsAuthenticationFilter"></a>2.2 SmsAuthenticationFilter</h3><p>然后编写 <code>SmsAuthenticationFilter</code>，参考 UsernamePasswordAuthenticationFilter 的源码，直接粘过来，改一改。</p><p><strong>步骤：</strong></p><ol><li><p>原本的静态字段有 username 和 password，都干掉，换成我们的手机号字段。</p></li><li><p><code>SmsCodeAuthenticationFilter()</code> 中指定了这个 filter 的拦截 Url，我指定为 post 方式的 <code>/sms/login</code>。</p></li><li><p>剩下来的方法把无效的删删改改就好了。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsAuthenticationFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAuthenticationProcessingFilter</span> </span>&#123;    <span class="hljs-comment">/** form表单中手机号码的字段name **/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SPRING_SECURITY_FORM_MOBILE_KEY = <span class="hljs-string">"mobile"</span>;    <span class="hljs-keyword">private</span> String mobileParameter = SPRING_SECURITY_FORM_MOBILE_KEY;    <span class="hljs-comment">/** 是否仅为post方式 **/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> postOnly = <span class="hljs-keyword">true</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmsAuthenticationFilter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//短信登录请求post方式的/sms/login</span>        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> AntPathRequestMatcher(<span class="hljs-string">"/sms/login"</span>,<span class="hljs-string">"POST"</span>));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException, IOException, ServletException </span>&#123;        <span class="hljs-keyword">if</span>(postOnly &amp;&amp; !request.getMethod().equals(<span class="hljs-string">"POST"</span>))&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">"Authentication method not support:"</span>+request.getMethod());        &#125;        String mobile = obtainMobile(request);                <span class="hljs-keyword">if</span>(mobile == <span class="hljs-keyword">null</span>)&#123;            mobile = <span class="hljs-string">""</span>;        &#125;        mobile = mobile.trim();        SmsAuthenticationToken authRequest = <span class="hljs-keyword">new</span> SmsAuthenticationToken(mobile);        setDetails(request,authRequest);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDetails</span><span class="hljs-params">(HttpServletRequest request, SmsAuthenticationToken authRequest)</span> </span>&#123;        authRequest.setDetails(authenticationDetailsSource.buildDetails(request));    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">obtainMobile</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;        <span class="hljs-keyword">return</span> request.getParameter(mobileParameter);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMobileParameter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> mobileParameter;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMobileParameter</span><span class="hljs-params">(String mobileParameter)</span> </span>&#123;        Assert.hasText(mobileParameter,<span class="hljs-string">"Mobile parameter must not be empty or null"</span>);        <span class="hljs-keyword">this</span>.mobileParameter = mobileParameter;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPostOnly</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> postOnly;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPostOnly</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> postOnly)</span> </span>&#123;        <span class="hljs-keyword">this</span>.postOnly = postOnly;    &#125;&#125;</code></pre></div></li></ol><h3 id="2-3-SmsAuthenticationProvider"><a href="#2-3-SmsAuthenticationProvider" class="headerlink" title="2.3 SmsAuthenticationProvider"></a>2.3 SmsAuthenticationProvider</h3><p>这个方法比较重要，这个方法首先能够在使用短信验证码登录时候被 <code>AuthenticationManager</code> 挑中，其次要在这个类中处理验证逻辑。</p><p><strong>步骤：</strong></p><ol><li><p>实现 AuthenticationProvider 接口，实现 authenticate() 和 supports() 方法。</p></li><li><p><code>supports()</code>方法决定了这个 Provider 要怎么被 AuthenticationManager 挑中，</p><p>我这里通过 <code>return SmsCodeAuthenticationToken.class.isAssignableFrom(authentication)</code>，处理所有 SmsCodeAuthenticationToken 及其子类或子接口。</p></li><li><p><code>authenticate()</code>方法处理验证逻辑。</p><ol><li>首先将 authentication 强转为 <code>SmsCodeAuthenticationToken</code>。</li><li>从中取出登录的 principal，也就是手机号。</li><li>调用自己写的 checkSmsCode() 方法，进行验证码校验，如果不合法，抛出 AuthenticationException 异常。</li><li>如果此时仍然没有异常，通过调用 <code>loadUserByUsername(mobile)</code> 读取出数据库中的用户信息。</li><li>如果仍然能够成功读取，没有异常，这里验证就完成了。</li><li>重新构造鉴权后的 SmsCodeAuthenticationToken，并返回给 SmsCodeAuthenticationFilter 。</li></ol></li><li><p>SmsCodeAuthenticationFilter 的父类在 <code>doFilter()</code> 方法中处理是否有异常，是否成功，根据处理结果跳转到登录成功/失败逻辑。</p></li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsAuthenticationProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationProvider</span> </span>&#123;    <span class="hljs-keyword">private</span> UserDetailsService userDetailsService;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        SmsAuthenticationToken authenticationToken = (SmsAuthenticationToken) authentication;        String mobile = (String) authenticationToken.getPrincipal();        <span class="hljs-comment">//验证码校验</span>        checkSmsCode(mobile);        UserDetails userDetails = userDetailsService.loadUserByUsername(mobile);        <span class="hljs-comment">// 此时鉴权成功后，应当重新 new 一个拥有鉴权的 authenticationResult 返回</span>        SmsAuthenticationToken smsAuthenticationToken = <span class="hljs-keyword">new</span> SmsAuthenticationToken(userDetails.getAuthorities(), userDetails);        smsAuthenticationToken.setDetails(authenticationToken.getDetails());        <span class="hljs-keyword">return</span> smsAuthenticationToken;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkSmsCode</span><span class="hljs-params">(String mobile)</span> </span>&#123;        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();        String inputCode = request.getParameter(<span class="hljs-string">"smsCode"</span>);        Map&lt;String, Object&gt; smsCode = (Map&lt;String, Object&gt;) request.getSession().getAttribute(<span class="hljs-string">"smsCode"</span>);        <span class="hljs-keyword">if</span>(smsCode == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">"未检测到申请验证码"</span>);        &#125;        String applyMobile = (String) smsCode.get(<span class="hljs-string">"mobile"</span>);        <span class="hljs-keyword">int</span> code = (<span class="hljs-keyword">int</span>) smsCode.get(<span class="hljs-string">"code"</span>);        <span class="hljs-keyword">if</span>(!applyMobile.equals(mobile))&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">"申请的手机号与登录的手机号不一致"</span>);        &#125;        <span class="hljs-keyword">if</span>(code != Integer.parseInt(inputCode))&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">"验证码错误"</span>);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; authentication)</span> </span>&#123;        <span class="hljs-comment">//判断Authentication是不是SmsCodeAuthenticationToken的子类或子接口</span>        <span class="hljs-keyword">return</span>  SmsAuthenticationToken<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">isAssignableFrom</span>(<span class="hljs-title">authentication</span>)</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetailsService <span class="hljs-title">getUserDetailsService</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> userDetailsService;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserDetailsService</span><span class="hljs-params">(UserDetailsService userDetailsService)</span> </span>&#123;        <span class="hljs-keyword">this</span>.userDetailsService = userDetailsService;    &#125;&#125;</code></pre></div><h3 id="2-4-成功与失败处理逻辑"><a href="#2-4-成功与失败处理逻辑" class="headerlink" title="2.4 成功与失败处理逻辑"></a>2.4 成功与失败处理逻辑</h3><p>上面最后说到，在 SmsCodeAuthenticationFilter 的父类，会根据验证结果跳转到成功或失败处理逻辑，现在我们就编写下这个的处理。</p><p>这里之前也说过了，直接贴代码了，如果有疑问，请参考<a href="https://www.jitwxs.cn/59f4016e.html" target="_blank" rel="noopener">《SpringBoot集成Spring Security（6）——登录管理》</a>。</p><p><strong>验证成功处理：</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationSuccessHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationSuccessHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Autowired</span>    ObjectMapper objectMapper;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        logger.info(<span class="hljs-string">"登录成功"</span>);        response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);        response.getWriter().write(objectMapper.writeValueAsString(authentication));    &#125;&#125;</code></pre></div><p><strong>验证失败处理</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationFailurehandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationFailureHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Autowired</span>    ObjectMapper objectMapper;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        logger.info(<span class="hljs-string">"登陆失败"</span>);        response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);        response.getWriter().write(objectMapper.writeValueAsString(exception.getMessage()));    &#125;&#125;</code></pre></div><h3 id="2-5-SmsCodeAuthenticationSecurityConfig"><a href="#2-5-SmsCodeAuthenticationSecurityConfig" class="headerlink" title="2.5 SmsCodeAuthenticationSecurityConfig"></a>2.5 SmsCodeAuthenticationSecurityConfig</h3><p>下面我们需要把我们自己写的这么多类添加进 Spring Security 框架中，在以往，我们都是直接往 WebSecurityConfig 中加，但是这样会导致 WebSecurityConfig 内容太多，难以维护。</p><p>因此我们可以为每种登录方式都建议一个专属于它的配置文件，再把这个配置文件加入到 WebSecurityConfig 中，进行解耦。</p><p>因此建立短信验证码登录的配置文件 <code>SmsCodeAuthenticationSecurityConfig</code>:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsCodeAuthenticationSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SecurityConfigurerAdapter</span>&lt;<span class="hljs-title">DefaultSecurityFilterChain</span>, <span class="hljs-title">HttpSecurity</span>&gt; </span>&#123;    <span class="hljs-meta">@Autowired</span>    UserDetailsService userDetailsService;    <span class="hljs-meta">@Autowired</span>    CustomAuthenticationSuccessHandler customAuthenticationSuccessHandler;    <span class="hljs-meta">@Autowired</span>    CustomAuthenticationFailureHandler customAuthenticationFailureHandler;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity builder)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        SmsAuthenticationFilter smsAuthenticationFilter = <span class="hljs-keyword">new</span> SmsAuthenticationFilter();        smsAuthenticationFilter.setAuthenticationManager(builder.getSharedObject(AuthenticationManager<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;        smsAuthenticationFilter.setAuthenticationSuccessHandler(customAuthenticationSuccessHandler);        smsAuthenticationFilter.setAuthenticationFailureHandler(customAuthenticationFailureHandler);                SmsAuthenticationProvider smsAuthenticationProvider = <span class="hljs-keyword">new</span> SmsAuthenticationProvider();        smsAuthenticationProvider.setUserDetailsService(userDetailsService);                builder.authenticationProvider(smsAuthenticationProvider).addFilterAfter(smsAuthenticationFilter, UsernamePasswordAuthenticationFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;&#125;</code></pre></div><p>在这个配置文件中，首先给 SmsCodeAuthenticationFilter 指定了：</p><ol><li>AuthenticationManager：不指定这个上面的流程图就断掉了。</li><li>指定登录成功/失败处理逻辑，方便其父类调用。</li></ol><p>然后指定了 SmsCodeAuthenticationProvider，并指定了 UserDetailsService ，方便在验证处理时候通过 <code>loadUserByUsername()</code> 读取出数据库中的用户信息。</p><p>最后将 filter 和 provider 都加入 HttpSecurity 配置中。</p><p><strong>另外说两句：</strong></p><blockquote><p>开头就说过了，为了方便介绍，写最少的代码，因此这是一个假的短信登录。如果你看这里的 UserDetailsService 的代码话，你会发现它是从数据库中根据 name 获取信息的，我其实就是把用户名来当手机号用。</p><p>因此，如果你想根据数据库中其他字段，例如 phone 来得到用户信息，可以再写一个叫做 SmsUserDetailsService，在这里注入到 provider 中。</p></blockquote><h3 id="2-6-WebSecurityConfig"><a href="#2-6-WebSecurityConfig" class="headerlink" title="2.6 WebSecurityConfig"></a>2.6 WebSecurityConfig</h3><p>下面我们就需要把自己写的 SmsCodeAuthenticationSecurityConfig 加入到 WebSecurityConfig 中了。</p><p>首先将 SmsCodeAuthenticationSecurityConfig 注入进来，然后通过 <code>http.apply(xxx)</code> 添加进去。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="hljs-keyword">true</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SmsCodeAuthenticationSecurityConfig smsCodeAuthenticationSecurityConfig;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.apply(smsCodeAuthenticationSecurityConfig)            .and()            .authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span>                .antMatchers(<span class="hljs-string">"/sms/**"</span>).permitAll()                .anyRequest().authenticated()                .and()                <span class="hljs-comment">// 设置登陆页</span>                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                <span class="hljs-comment">// 设置登陆成功页</span>                .defaultSuccessUrl(<span class="hljs-string">"/"</span>).permitAll()                .and()                .logout().permitAll();        <span class="hljs-comment">// 关闭CSRF跨域</span>        http.csrf().disable();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 设置拦截忽略文件夹，可以对静态资源放行</span>        web.ignoring().antMatchers(<span class="hljs-string">"/css/**"</span>, <span class="hljs-string">"/js/**"</span>);    &#125;&#125;</code></pre></div><h3 id="2-7-接口与页面"><a href="#2-7-接口与页面" class="headerlink" title="2.7 接口与页面"></a>2.7 接口与页面</h3><p>然后在 controller 中写一个读取验证码的接口，注意这个接口在 <code>WebSecurityConfig</code> 中要放行：</p><div class="hljs"><pre><code class="hljs java">   <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/sms/code"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sms</span><span class="hljs-params">(String mobile, HttpSession session)</span></span>&#123;        <span class="hljs-keyword">int</span> code = (<span class="hljs-keyword">int</span>)Math.ceil(Math.random()*<span class="hljs-number">9000</span>+<span class="hljs-number">1000</span>);        Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">16</span>);        map.put(<span class="hljs-string">"mobile"</span>,mobile);        map.put(<span class="hljs-string">"code"</span>,code);                session.setAttribute(<span class="hljs-string">"smsCode"</span>,map);        logger.info(<span class="hljs-string">"&#123;&#125;:为&#123;&#125;设置短信验证码：&#123;&#125;"</span>,session.getId(),mobile,code);    &#125;&#125;</code></pre></div><p>然后修改 login.html 页面，添加短信登录的内容：</p><blockquote><p>注意这里的登录 Url <code>/sms/login</code> 是配置在 SmsAuthenticationFilter 中的 Url。</p></blockquote><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>欢迎来到登录页面<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>立即登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/sms/login"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        手机号：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mobile"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mobile"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jitwxs"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        验证码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"smsCode"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"javascript:;"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"sendSms()"</span>&gt;</span>获取验证码<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>立即登陆<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendSms</span><span class="hljs-params">()</span> </span>&#123;</span><span class="javascript">        <span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">'/sms/code?mobile='</span> + <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"mobile"</span>).value;</span>    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="三、测试代码"><a href="#三、测试代码" class="headerlink" title="三、测试代码"></a>三、测试代码</h2><p>因此只是测试，所以页面懒得弄了，当你输入手机号（实际上就是用户名），点击获取验证码，页面会跳转出去，然后自己再按一下浏览器的后退键退回来。</p><p>在控制台就会打印当前用户的 sessionId，以及为哪一个手机号所申请的验证码。</p>]]></content>
    
    
    <categories>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(7)--认证流程</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-7-%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-7-%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>在前面的六章中，介绍了 Spring Security 的基础使用，在继续深入向下的学习前，有必要理解清楚 Spring Security 的认证流程，这样才能理解为什么要这样写代码，也方便后续的扩展。</p><h2 id="一、认证流程"><a href="#一、认证流程" class="headerlink" title="一、认证流程"></a>一、认证流程</h2><p><img src="https://www.jitwxs.cn/images/posts/20181202095539982.png" srcset="/img/loading.gif" alt="Spring Security 认证流程（部分）"></p><blockquote><p>上图是 Spring Security 认证流程的一部分，下面的讲解以上图为依据。</p></blockquote><p><strong>（1）</strong> 用户发起表单登录请求后，首先进入 <code>UsernamePasswordAuthenticationFilter</code>：</p><p><img src="https://www.jitwxs.cn/images/posts/2018120210045295.png" srcset="/img/loading.gif" alt="UsernamePasswordAuthenticationFilter"></p><p>​                                                                        UsernamePasswordAuthenticationFilter</p><p>在 UsernamePasswordAuthenticationFilter 中根据用户输入的用户名、密码构建了 <code>UsernamePasswordAuthenticationToken</code>，并将其交给 AuthenticationManager 来进行认证处理。</p><p>AuthenticationManager 本身不包含认证逻辑，其核心是用来管理所有的 <code>AuthenticationProvider</code>，通过交由合适的 AuthenticationProvider 来实现认证。</p><p><strong>（2）</strong> 下面跳转到了 <code>ProviderManager</code> ，该类是 AuthenticationManager 的实现类：</p><p><img src="https://www.jitwxs.cn/images/posts/20181202102203137.png" srcset="/img/loading.gif" alt="ProviderManager"></p><p>​                                                                                        ProviderManager</p><p>我们知道不同的登录逻辑它的认证方式是不一样的，比如我们表单登录需要认证用户名和密码，但是当我们使用三方登录时就不需要验证密码。</p><p>Spring Security 支持多种认证逻辑，<strong>每一种认证逻辑的认证方式其实就是一种 AuthenticationProvider</strong>。通过 <code>getProviders()</code> 方法就能获取所有的 AuthenticationProvider，通过 <code>provider.supports()</code> 来判断 provider 是否支持当前的认证逻辑。</p><p>当选择好一个合适的 AuthenticationProvider 后，通过 <code>provider.authenticate(authentication)</code> 来让 AuthenticationProvider 进行认证。</p><p><strong>（3）</strong> 传统表单登录的 AuthenticationProvider 主要是由 <code>AbstractUserDetailsAuthenticationProvider</code> 来进行处理的，我们来看下它的 <code>authenticate()</code>方法。</p><p>首先通过 <code>retrieveUser()</code> 方法读取到数据库中的用户信息：</p><div class="hljs"><pre><code class="hljs java">user = retrieveUser(username,(UsernamePasswordAuthenticationToken) authentication);</code></pre></div><p>retrieveUser() 的具体实现在 <code>DaoAuthenticationProvider</code> 中，代码如下：</p><p><img src="https://www.jitwxs.cn/images/posts/20181202103804350.png" srcset="/img/loading.gif" alt="DaoAuthenticationProvider"></p><p>​                                                                                DaoAuthenticationProvider</p><p><img src="https://www.jitwxs.cn/images/posts/20181202105844461.png" srcset="/img/loading.gif" alt="AbstractUserDetailsAuthenticationProvider"></p><p>​                                                                                AbstractUserDetailsAuthenticationProvider</p><p>在上图中，我们可以看到认证校验分为 <strong>前校验</strong>、<strong>附加校验</strong>和<strong>后校验</strong>，如果任何一个校验出错，就会抛出相应的异常。所有校验都通过后，调用 <code>createSuccessAuthentication()</code> 返回认证信息。</p><p><img src="https://www.jitwxs.cn/images/posts/20181202111353423.png" srcset="/img/loading.gif" alt="createSuccessAuthentication()"></p><p>​                                                                                        createSuccessAuthentication()</p><p>在<code>createSuccessAuthentication</code>方法中，我们发现它重新 new 了一个 <code>UsernamePasswordAuthenticationToken</code>，因为到这里认证已经通过了，所以将 authorities 注入进去，并设置 authenticated 为 true，即已经认证。</p><p>（4）至此认证信息就被传递回 UsernamePasswordAuthenticationFilter 中，在 UsernamePasswordAuthenticationFilter 的父类 <code>AbstractAuthenticationProcessingFilter</code> 的 <code>doFilter()</code> 中，会根据认证的成功或者失败调用相应的 handler：</p><p><img src="https://www.jitwxs.cn/images/posts/20181202113101881.png" srcset="/img/loading.gif" alt="AbstractAuthenticationProcessingFilter"></p><p>​                                                                            AbstractAuthenticationProcessingFilter</p><p>这里调用的 handler 实际就是在<a href="https://www.jitwxs.cn/59f4016e.html" target="_blank" rel="noopener">《SpringBoot集成Spring Security（6）——登录管理》</a>中我们在配置文件中配置的 <code>successHandler()</code> 和 <code>failureHandler()</code>。</p><h2 id="二、多个请求共享认证信息"><a href="#二、多个请求共享认证信息" class="headerlink" title="二、多个请求共享认证信息"></a>二、多个请求共享认证信息</h2><p>Spring Security 通过 <code>Session</code> 来保存用户的认证信息，那么 Spring Security 到底是在什么时候将认证信息放入 Session，又在什么时候将认证信息从 Session 中取出来的呢？</p><p>下面将 Spring Security 的认证流程补充完整，如下图：</p><p><img src="https://www.jitwxs.cn/images/posts/20180630104958316.png" srcset="/img/loading.gif" alt="Spring Security 认证流程"></p><p>​                                                                                                    Spring Security 认证流程</p><p>在上一节认证成功的 <code>successfulAuthentication()</code>方法中，有一行语句：</p><div class="hljs"><pre><code class="hljs java">SecurityContextHolder.getContext().setAuthentication(authResult);</code></pre></div><p>其实就是在这里将认证信息放入 Session 中。</p><p>查看 <code>SecurityContext</code> 源码，发现内部就是对 Authentication 的封装，提供了 equals、hashcode、toString等方法，而<code>SecurityContextHolder</code> 可以理解为线程中的 <code>ThreadLocal</code>。</p><p>我们知道一个 HTTP 请求和响应都是在一个线程中执行，因此在整个处理的任何一个方法中都可以通过 <code>SecurityContextHolder.getContext()</code>来取得存放进去的认证信息。</p><p>从 Session 中对认证信息的处理由 <code>SecurityContextPersistenceFilter</code> 来处理，它位于 Spring Security 过滤器链的最前面，它的主要作用是：</p><ul><li>当请求时，检查 Session 中是否存在 SecurityContext，如果有将其放入到线程中</li><li>当响应时，检查线程中是否存在 SecurityContext，如果有将其放入到 Session 中</li></ul><p><img src="https://www.jitwxs.cn/images/posts/20180630114216422.png" srcset="/img/loading.gif" alt="img"></p><h2 id="三、获取用户认证信息"><a href="#三、获取用户认证信息" class="headerlink" title="三、获取用户认证信息"></a>三、获取用户认证信息</h2><p>通过调用 <code>SecurityContextHolder.getContext().getAuthentication()</code> 就能够取得认证信息：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/me"</span>)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">me</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> SecurityContextHolder.getContext().getAuthentication();&#125;</code></pre></div><p><img src="https://www.jitwxs.cn/images/posts/20181202140404470.png" srcset="/img/loading.gif" alt="img"></p><p>上面的写法有点啰嗦，我们可以简写成下面这种， Spring MVC 会自动帮我们从 Spring Security 中注入：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/me"</span>)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">me</span><span class="hljs-params">(Authentication authentication)</span> </span>&#123;    <span class="hljs-keyword">return</span> authentication;&#125;</code></pre></div><p>如果你仅想获取 <code>UserDetails</code> 对象，也是可以的，写法如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/me"</span>)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">me</span><span class="hljs-params">(@AuthenticationPrincipal UserDetails userDetails)</span> </span>&#123;    <span class="hljs-keyword">return</span> userDetails;&#125;</code></pre></div><p><img src="https://www.jitwxs.cn/images/posts/20181202140702514.png" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(6)--登录管理</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-6-%E7%99%BB%E5%BD%95%E7%AE%A1%E7%90%86/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-6-%E7%99%BB%E5%BD%95%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="一、自定义认证成功、失败处理"><a href="#一、自定义认证成功、失败处理" class="headerlink" title="一、自定义认证成功、失败处理"></a>一、自定义认证成功、失败处理</h2><p>有些时候我们想要在认证成功后做一些业务处理，例如添加积分；有些时候我们想要在认证失败后也做一些业务处理，例如记录日志。</p><p>在之前的文章中，关于认证成功、失败后的处理都是如下配置的：</p><div class="hljs"><pre><code class="hljs java">http.authorizeRequests()    <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span><span class="hljs-comment">//    .antMatchers().permitAll()</span>    .anyRequest().authenticated().and()    <span class="hljs-comment">// 设置登录页</span>    .formLogin().loginPage(<span class="hljs-string">"/login"</span>)    .failureUrl(<span class="hljs-string">"/login/error"</span>)    .defaultSuccessUrl(<span class="hljs-string">"/"</span>)    .permitAll()    ...;</code></pre></div><p>即 <code>failureUrl()</code> 指定认证失败后Url，<code>defaultSuccessUrl()</code> 指定认证成功后Url。我们可以通过设置 <code>successHandler()</code> 和 <code>failureHandler()</code> 来实现自定义认证成功、失败处理。</p><blockquote><p>PS：当我们设置了这两个后，需要去除 <code>failureUrl()</code> 和 <code>defaultSuccessUrl()</code> 的设置，否则无法生效。这两套配置同时只能存在一套。</p></blockquote><h3 id="1-1-CustomAuthenticationSuccessHandler"><a href="#1-1-CustomAuthenticationSuccessHandler" class="headerlink" title="1.1 CustomAuthenticationSuccessHandler"></a>1.1 CustomAuthenticationSuccessHandler</h3><p>自定义 CustomAuthenticationSuccessHandler 类来实现 <code>AuthenticationSuccessHandler</code> 接口，用来处理认证成功后逻辑：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationSuccessHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationSuccessHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,                 Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        logger.info(<span class="hljs-string">"登录成功，&#123;&#125;"</span>,authentication);                response.sendRedirect(<span class="hljs-string">"/"</span>);    &#125;&#125;</code></pre></div><p><code>onAuthenticationSuccess()</code> 方法的第三个参数 <code>Authentication</code> 为认证后该用户的认证信息，这里打印日志后，重定向到了首页。</p><h3 id="1-2-CustomAuthenticationFailureHandler"><a href="#1-2-CustomAuthenticationFailureHandler" class="headerlink" title="1.2 CustomAuthenticationFailureHandler"></a>1.2 CustomAuthenticationFailureHandler</h3><p>自定义 CustomAuthenticationFailureHandler 类来实现 <code>AuthenticationFailureHandler</code> 接口，用来处理认证失败后逻辑：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationFailureHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationFailureHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Autowired</span>    ObjectMapper objectMapper;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        logger.info(<span class="hljs-string">"登录失败"</span>);        response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());        response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);        response.getWriter().write(objectMapper.writeValueAsString(exception.getMessage()));    &#125;&#125;</code></pre></div><p><code>onAuthenticationFailure()</code>方法的第三个参数 <code>exception</code> 为认证失败所产生的异常，这里也是简单的返回到前台。</p><h3 id="1-3-修改-WebSecurityConfig"><a href="#1-3-修改-WebSecurityConfig" class="headerlink" title="1.3 修改 WebSecurityConfig"></a>1.3 修改 WebSecurityConfig</h3><div class="hljs"><pre><code class="hljs java">    <span class="hljs-meta">@Autowired</span>    CustomAuthenticationSuccessHandler authenticationSuccessHandler;    <span class="hljs-meta">@Autowired</span>    CustomAuthenticationFailureHandler authenticationFailureHandler; <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span><span class="hljs-comment">//                .antMatchers().permitAll()</span>                .anyRequest().authenticated()                .and()                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                .successHandler(authenticationSuccessHandler)                .failureHandler(authenticationFailureHandler)            .permitAll() <span class="hljs-comment">//很关键</span><span class="hljs-comment">//                .defaultSuccessUrl("/").permitAll()</span>                .and()                .logout()                .logoutSuccessUrl(<span class="hljs-string">"/logout"</span>)                .permitAll();        <span class="hljs-comment">//关闭CRSF跨域</span>        http.csrf().disable();    &#125;</code></pre></div><ol><li>首先将 <code>customAuthenticationSuccessHandler</code> 和 <code>customAuthenticationFailureHandler</code>注入进来</li><li>配置 <code>successHandler()</code> 和 <code>failureHandler()</code></li><li>注释 <code>failureUrl()</code> 和 <code>defaultSuccessUrl()</code></li></ol><h3 id="1-4-运行程序"><a href="#1-4-运行程序" class="headerlink" title="1.4 运行程序"></a>1.4 运行程序</h3><p>运行程序，当我们成功登陆后，发现日志信息被打印出来，页面被重定向到了首页：</p><p><img src="https://www.jitwxs.cn/images/posts/20190110174809434.png" srcset="/img/loading.gif" alt="img"></p><p>当我们认证失败后，发现日志中“登陆失败”被打印出来，页面展示了认证失败的异常消息：</p><p><img src="https://www.jitwxs.cn/images/posts/20190110174827988.png" srcset="/img/loading.gif" alt="img"></p><h2 id="二、Session-超时"><a href="#二、Session-超时" class="headerlink" title="二、Session 超时"></a>二、Session 超时</h2><p>当用户登录后，我们可以设置 session 的超时时间，当达到超时时间后，自动将用户退出登录。</p><p>Session 超时的配置是 SpringBoot 原生支持的，我们只需要在 <code>application.properties</code> 配置文件中配置：</p><div class="hljs"><pre><code class="hljs java">server.servlet.session.timeout=<span class="hljs-number">60</span>s</code></pre></div><blockquote><p>Tip：<br>从用户最后一次操作开始计算过期时间。<br>过期时间最小值为 60 秒，如果你设置的值小于 60 秒，也会被更改为 60 秒。</p></blockquote><p>我们可以在 Spring Security 中配置处理逻辑，在 session 过期退出时调用。修改 WebSecurityConfig 的 <code>configure()</code> 方法，添加：</p><div class="hljs"><pre><code class="hljs java">.sessionManagement()    <span class="hljs-comment">// 以下二选一</span>    <span class="hljs-comment">//.invalidSessionStrategy()</span>    <span class="hljs-comment">//.invalidSessionUrl();</span></code></pre></div><p>Spring Security 提供了两种处理配置，一个是 <code>invalidSessionStrategy()</code>，另外一个是 <code>invalidSessionUrl()</code>。</p><p>这两个的区别就是一个是前者是在一个类中进行处理，后者是直接跳转到一个 Url。简单起见，我就直接用 <code>invalidSessionUrl()</code>了，跳转到 <code>/login/invalid</code>，我们需要把该 Url 设置为免授权访问， 配置如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http.authorizeRequests()            <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span>            .antMatchers(<span class="hljs-string">"/login/invalid"</span>).permitAll()            .anyRequest().authenticated().and()            ...            .sessionManagement()                .invalidSessionUrl(<span class="hljs-string">"/login/invalid"</span>);    <span class="hljs-comment">// 关闭CSRF跨域</span>    http.csrf().disable();&#125;</code></pre></div><p>在 controller 中写一个接口进行处理：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/login/invalid"</span>)<span class="hljs-meta">@ResponseStatus</span>(HttpStatus.UNAUTHORIZED)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">invalid</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"Session 已过期，请重新登录"</span>;&#125;</code></pre></div><p>运行程序，登录成功后等待一分钟（或者重启服务器），刷新页面：</p><p><img src="https://www.jitwxs.cn/images/posts/20190110171026663.png" srcset="/img/loading.gif" alt="session 过期"></p><h2 id="三、限制最大登录数"><a href="#三、限制最大登录数" class="headerlink" title="三、限制最大登录数"></a>三、限制最大登录数</h2><p>接下来实现限制最大登录数，原理就是限制单个用户能够存在的最大 session 数。</p><p>在上一节的基础上，修改 <code>configure()</code> 为：</p><div class="hljs"><pre><code class="hljs java">.sessionManagement()    .invalidSessionUrl(<span class="hljs-string">"/login/invalid"</span>)    .maximumSessions(<span class="hljs-number">1</span>)    <span class="hljs-comment">// 当达到最大值时，是否保留已经登录的用户</span>    .maxSessionsPreventsLogin(<span class="hljs-keyword">false</span>)    <span class="hljs-comment">// 当达到最大值时，旧用户被踢出后的操作</span>    .expiredSessionStrategy(<span class="hljs-keyword">new</span> CustomExpiredSessionStrategy())</code></pre></div><p>增加了下面三行代码，其中：</p><ul><li><code>maximumSessions(int)</code>：指定最大登录数</li><li><code>maxSessionsPreventsLogin(boolean)</code>：是否保留已经登录的用户；为true，新用户无法登录；为 false，旧用户被踢出</li><li><code>expiredSessionStrategy(SessionInformationExpiredStrategy)</code>：旧用户被踢出后处理方法</li></ul><blockquote><p><code>maxSessionsPreventsLogin()</code>可能不太好理解，这里我们先设为 false，效果和 QQ 登录是一样的，登录后之前登录的账户被踢出。</p></blockquote><p>编写 CustomExpiredSessionStrategy 类，来处理旧用户登录失败的逻辑：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomExpiredSessionStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SessionInformationExpiredStrategy</span> </span>&#123;    <span class="hljs-keyword">private</span> ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();<span class="hljs-comment">//    private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onExpiredSessionDetected</span><span class="hljs-params">(SessionInformationExpiredEvent event)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        Map&lt;String,Object&gt;map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">16</span>);        map.put(<span class="hljs-string">"code"</span>,<span class="hljs-number">0</span>);        map.put(<span class="hljs-string">"msg"</span>,<span class="hljs-string">"已经另一台机器登录，您被迫下线"</span>);        <span class="hljs-comment">//Map -&gt; json</span>        String json = objectMapper.writeValueAsString(map);        event.getResponse().setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);        event.getResponse().getWriter().write(json);                <span class="hljs-comment">//如果是跳转html页面，url代表跳转的地址</span><span class="hljs-comment">//        redirectStrategy.sendRedirect(event.getRequest(),event.getResponse(),"url");</span>    &#125;&#125;</code></pre></div><p>在 <code>onExpiredSessionDetected()</code> 方法中，处理相关逻辑，我这里只是简单的返回一句话。</p><p>执行程序，打开两个浏览器，登录同一个账户。因为我设置了 <code>maximumSessions(1)</code>，也就是单个用户只能存在一个 session，因此当你刷新先登录的那个浏览器时，被提示踢出了。</p><p><img src="https://www.jitwxs.cn/images/posts/2019011017515758.png" srcset="/img/loading.gif" alt="maxSessionsPreventsLogin 为 false"></p><p>下面我们来测试下 <code>maxSessionsPreventsLogin(true)</code> 时的情况，我们发现第一个浏览器登录后，第二个浏览器无法登录：</p><p><img src="https://www.jitwxs.cn/images/posts/20190110175325653.png" srcset="/img/loading.gif" alt="maxSessionsPreventsLogin 为 true"></p><h2 id="四、踢出用户"><a href="#四、踢出用户" class="headerlink" title="四、踢出用户"></a>四、踢出用户</h2><p>下面来看下如何主动踢出一个用户。</p><p>首先需要在容器中注入名为 <code>SessionRegistry</code> 的 Bean，这里我就简单的写在 WebSecurityConfig 中：</p><p>修改 WebSecurityConfig 的 configure() 方法，在最后添加一行 <code>.sessionRegistry()</code>：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    ...    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SessionRegistry <span class="hljs-title">sessionRegistry</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SessionRegistryImpl();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span>                .antMatchers(<span class="hljs-string">"/login/invalid"</span>).permitAll()                .anyRequest().authenticated().and()                <span class="hljs-comment">// 设置登录页</span>                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                .successHandler(customAuthenticationSuccessHandler)                .failureHandler(customAuthenticationFailureHandler)                .permitAll().and()                .logout().and()                .sessionManagement()                    .invalidSessionUrl(<span class="hljs-string">"/login/invalid"</span>)                    .maximumSessions(<span class="hljs-number">1</span>)                    <span class="hljs-comment">// 当达到最大值时，是否保留已经登录的用户</span>                    .maxSessionsPreventsLogin(<span class="hljs-keyword">false</span>)                    <span class="hljs-comment">// 当达到最大值时，旧用户被踢出后的操作</span>                    .expiredSessionStrategy(<span class="hljs-keyword">new</span> CustomExpiredSessionStrategy())                    .sessionRegistry(sessionRegistry());        <span class="hljs-comment">// 关闭CSRF跨域</span>        http.csrf().disable();    &#125;&#125;</code></pre></div><p>编写一个接口用于测试踢出用户：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SessionRegistry sessionRegistry;    ...    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/kick"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">removeUserSessionByUsername</span><span class="hljs-params">(@RequestParam String username)</span> </span>&#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 获取session中所有的用户信息</span>        List&lt;Object&gt; users = sessionRegistry.getAllPrincipals();        <span class="hljs-keyword">for</span> (Object principal : users) &#123;            <span class="hljs-keyword">if</span> (principal <span class="hljs-keyword">instanceof</span> User) &#123;                String principalName = ((User)principal).getUsername();                <span class="hljs-keyword">if</span> (principalName.equals(username)) &#123;                    <span class="hljs-comment">// 参数二：是否包含过期的Session</span>                    List&lt;SessionInformation&gt; sessionsInfo = sessionRegistry.getAllSessions(principal, <span class="hljs-keyword">false</span>);                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != sessionsInfo &amp;&amp; sessionsInfo.size() &gt; <span class="hljs-number">0</span>) &#123;                        <span class="hljs-keyword">for</span> (SessionInformation sessionInformation : sessionsInfo) &#123;                            sessionInformation.expireNow();                            count++;                        &#125;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">"操作成功，清理session共"</span> + count + <span class="hljs-string">"个"</span>;    &#125;&#125;</code></pre></div><ol><li><code>sessionRegistry.getAllPrincipals();</code> 获取所有 principal 信息</li><li>通过 <code>principal.getUsername</code>是否等于输入值，获取到指定用户的 principal</li><li><code>sessionRegistry.getAllSessions(principal, false)</code>获取该 principal 上的所有 session</li><li>通过 <code>sessionInformation.expireNow()</code> 使得 session 过期</li></ol><p>运行程序，分别使用 admin 和 jitwxs 账户登录，admin 访问 <code>/kick?username=jitwxs</code> 来踢出用户 jitwxs，jitwxs 刷新页面，发现被踢出。</p><p><img src="https://img-blog.csdnimg.cn/20200531234209914.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="五、退出登录"><a href="#五、退出登录" class="headerlink" title="五、退出登录"></a>五、退出登录</h2><p>补充一下退出登录的内容，在之前，我们直接在 WebSecurityConfig 的 configure() 方法中，配置了：</p><div class="hljs"><pre><code class="hljs java">http.logout();</code></pre></div><p>这就是 Spring Security 的默认退出配置，Spring Security 在退出时候做了这样几件事：</p><ol><li>使当前的 session 失效</li><li>清除与当前用户有关的 remember-me 记录</li><li>清空当前的 SecurityContext</li><li>重定向到登录页</li></ol><p>Spring Security 默认的退出 Url 是 <code>/logout</code>，我们可以修改默认的退出 Url，例如修改为 <code>/signout</code>：</p><div class="hljs"><pre><code class="hljs java">http.logout()    .logoutUrl(<span class="hljs-string">"/signout"</span>);</code></pre></div><p>我们也可以配置当退出时清除浏览器的 Cookie，例如清除 名为 JSESSIONID 的 cookie：</p><div class="hljs"><pre><code class="hljs java">http.logout()    .logoutUrl(<span class="hljs-string">"/signout"</span>)    .deleteCookies(<span class="hljs-string">"JSESSIONID"</span>);</code></pre></div><p>我们也可以配置退出后处理的逻辑，方便做一些别的操作：</p><div class="hljs"><pre><code class="hljs java">http.logout()    .logoutUrl(<span class="hljs-string">"/signout"</span>)    .deleteCookies(<span class="hljs-string">"JSESSIONID"</span>)    .logoutSuccessHandler(logoutSuccessHandler);</code></pre></div><p>创建类 <code>DefaultLogoutSuccessHandler</code>：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomLogoutSuccessHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LogoutSuccessHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLogoutSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        String username = ((User) authentication.getPrincipal()).getUsername();        logger.info(<span class="hljs-string">"退出成功，用户名：&#123;&#125;"</span>,username);        <span class="hljs-comment">//重定向到登录页</span>        response.sendRedirect(<span class="hljs-string">"/login"</span>);    &#125;&#125;</code></pre></div><p>最后把它注入到 WebSecurityConfig 即可：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> CustomLogoutSuccessHandler logoutSuccessHandler;</code></pre></div><p>效果：</p><p><img src="https://img-blog.csdnimg.cn/2020053123365730.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="六、Session-共享"><a href="#六、Session-共享" class="headerlink" title="六、Session 共享"></a>六、Session 共享</h2><p>在最后补充下关于 Session 共享的知识点，一般情况下，一个程序为了保证稳定至少要部署两个，构成集群。那么就牵扯到了 Session 共享的问题，不然用户在 8080 登录成功后，后续访问了 8060 服务器，结果又提示没有登录。</p><p>这里就简单实现下 Session 共享，采用 Redis 来存储。</p><h3 id="6-1-配置-Redis"><a href="#6-1-配置-Redis" class="headerlink" title="6.1 配置 Redis"></a>6.1 配置 Redis</h3><p>为了方便起见，我直接使用 Docker 快速部署，如果你需要传统方式安装，可以参考文章<a href="https://www.jitwxs.cn/e331e26a.html" target="_blank" rel="noopener">《Redis 初探（1）——Redis 的安装》</a>。</p><div class="hljs"><pre><code class="hljs applescript">docker pull redisdocker <span class="hljs-built_in">run</span> <span class="hljs-comment">--name myredis -p 6379:6379 -d redis</span>docker exec -<span class="hljs-keyword">it</span> myredis redis-cli</code></pre></div><p>这里因为我ubutun连不上网，所以用的是redis客户端</p><h3 id="6-2-配置-Session-共享"><a href="#6-2-配置-Session-共享" class="headerlink" title="6.2 配置 Session 共享"></a>6.2 配置 Session 共享</h3><p>首先需要导入依赖，因为我们采用 Redis 方式实现，因此导入：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--redis相关依赖--&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>在 <code>application.xml</code> 中新增配置指定 redis 地址以及 session 的存储方式：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-comment">#redis相关配置</span><span class="hljs-string">spring.redis.host=localhost</span><span class="hljs-string">spring.redis.port=6379</span><span class="hljs-string">spring.session.store-type=redis</span></code></pre></div><p>然后为主类添加 <code>@EnableRedisHttpSession</code> 注解。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@EnableRedisHttpSession</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringSecuriity06Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(SpringSecuriity06Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><h3 id="6-3-运行程序"><a href="#6-3-运行程序" class="headerlink" title="6.3 运行程序"></a>6.3 运行程序</h3><p>这样就完成了基于 Redis 的 Session 共享，下面来测试下。首先修改 IDEA 配置来允许项目在多端口运行，勾选 <code>Allow running in parallel</code>(2018.2版本好像没有该选项，应该是取消勾选<code>Single instance only</code>)：</p><p><img src="https://img-blog.csdnimg.cn/20200531233713573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>运行程序，然后修改配置文件，将 <code>server.port</code> 更改为 8060，再次运行。这样项目就会分别在默认的 8080 端口和 8060 端口运行。</p><p><img src="https://img-blog.csdnimg.cn/20200531233941130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>先访问 <code>localhost:8080</code>，登录成功后，再访问 <code>localhost:8060</code>，发现无需登录。</p>]]></content>
    
    
    <categories>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(5)--权限控制</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-5-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-5-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>在第一篇中，我们说过，<strong>用户&lt;–&gt;角色&lt;–&gt;权限</strong>三层中，暂时不考虑权限，在这一篇，是时候把它完成了。</p><p>为了方便演示，这里的权限只是对角色赋予权限，也就是说同一个角色的用户，权限是一样的。当然了，你也可以精细化到为每一个用户设置权限，但是这不在本篇的探讨范围，有兴趣可以自己实验，原理都是一样的。</p><h2 id="一、数据准备"><a href="#一、数据准备" class="headerlink" title="一、数据准备"></a>一、数据准备</h2><h3 id="1-1-创建-sys-permission-表"><a href="#1-1-创建-sys-permission-表" class="headerlink" title="1.1 创建 sys_permission 表"></a>1.1 创建 sys_permission 表</h3><p>让我们先创建一张权限表，名为 <code>sys_permission</code>：</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`sys_permission`</span>(<span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,<span class="hljs-string">`url`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,<span class="hljs-string">`role_id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,<span class="hljs-string">`permission`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,PRIMARY <span class="hljs-keyword">KEY</span>(<span class="hljs-string">`id`</span>),<span class="hljs-keyword">KEY</span> <span class="hljs-string">`fk_roleId`</span>(<span class="hljs-string">`role_id`</span>),<span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-string">`fk_roleId`</span> <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span>(<span class="hljs-string">`role_id`</span>) <span class="hljs-keyword">REFERENCES</span> <span class="hljs-string">`sys_role`</span>(<span class="hljs-string">`id`</span>) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">CASCADE</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">CASCADE</span>)<span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">5</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4;</code></pre></div><p>内容就是两条数据，通过 <code>url</code> + <code>role_id</code> + <code>permission</code> 唯一标识了一个角色访问某一url时的权限，其中权限暂定为c、r、u、d，代表了增、删、改、查。</p><p><img src="https://www.jitwxs.cn/images/posts/20180515185020939.png" srcset="/img/loading.gif" alt="sys_permission 表数据"></p><h3 id="1-2-创建-Model、Mapper、Service"><a href="#1-2-创建-Model、Mapper、Service" class="headerlink" title="1.2 创建 Model、Mapper、Service"></a>1.2 创建 Model、Mapper、Service</h3><p>（1）Model</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysPermission</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String url;    <span class="hljs-keyword">private</span> Integer roleId;    <span class="hljs-keyword">private</span> String permission;    <span class="hljs-keyword">private</span> List permissions;    <span class="hljs-comment">//省略getter，setter</span>&#125;</code></pre></div><p>这里需要注意的时相比于数据库，多了一个 <code>permissions</code> 属性，该字段将 <code>permission</code> 按逗号分割为了 list。</p><p>（2）mapper</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysPermissionMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_permission WHERE role_id=#&#123;roleId&#125;"</span>)    List&lt;SysPermission&gt;listByRoleId(Integer roleId);&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysRoleMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_role WHERE id = #&#123;id&#125;"</span>)    <span class="hljs-function">SysRole <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_role WHERE name = #&#123;name&#125;"</span>)    <span class="hljs-function">SysRole <span class="hljs-title">selectByName</span><span class="hljs-params">(String name)</span></span>;&#125;</code></pre></div><p>（3）Service</p><p>SysPermissionService 中有一个方法，根据 roleId 获取所有的 <code>SysPermission</code>。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysPermissionService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysPermissionMapper permissionMapper;        <span class="hljs-comment">/**获取指定角色所有权限**/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;SysPermission&gt; <span class="hljs-title">listByRoleId</span><span class="hljs-params">(Integer roleId)</span></span>&#123;        <span class="hljs-keyword">return</span> permissionMapper.listByRoleId(roleId);    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysRoleService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysRoleMapper sysRoleMapper;        <span class="hljs-function"><span class="hljs-keyword">public</span> SysRole <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>&#123;        <span class="hljs-keyword">return</span> sysRoleMapper.selectById(id);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> SysRole <span class="hljs-title">selectByName</span><span class="hljs-params">(String name)</span></span>&#123;        <span class="hljs-keyword">return</span> sysRoleMapper.selectByName(name);    &#125;&#125;</code></pre></div><h3 id="1-3-修改接口"><a href="#1-3-修改接口" class="headerlink" title="1.3 修改接口"></a>1.3 修改接口</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;    <span class="hljs-comment">//...</span>    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/admin"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasPermission('/admin','r')"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">printAdminR</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"如果你看见这句话，说明你访问/admin路径具有r权限"</span>;    &#125;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/admin/c"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasPermission('/admin','c')"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">printAdminC</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"如果你看见这句话，说明你访问/admin路径具有c权限"</span>;    &#125;&#125;</code></pre></div><p>让我们修改下我们要访问的接口，<code>@PreAuthorize(&quot;hasPermission(&#39;/admin&#39;,&#39;r&#39;)&quot;)</code> 是关键，参数1指明了<strong>访问该接口需要的url</strong>，参数2指明了<strong>访问该接口需要的权限</strong>。</p><h2 id="二、PermissionEvaluator"><a href="#二、PermissionEvaluator" class="headerlink" title="二、PermissionEvaluator"></a>二、PermissionEvaluator</h2><p>我们需要自定义对 <code>hasPermission()</code> 方法的处理，就需要自定义 <code>PermissionEvaluator</code>，创建类 <code>CustomPermissionEvaluator</code>，实现 <code>PermissionEvaluator</code> 接口。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomPermissionEvaluator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PermissionEvaluator</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysPermissionService permissionService;    <span class="hljs-meta">@Autowired</span>    SysRoleService roleService;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPermission</span><span class="hljs-params">(Authentication authentication, Object targetUrl, Object targetPermission)</span> </span>&#123;        <span class="hljs-comment">//获得loadUserByUsername()方法的结果</span>        User user = (User) authentication.getPrincipal();        <span class="hljs-comment">//获得loadUserByUsername()中注入的角色</span>        Collection&lt;GrantedAuthority&gt; authorities = user.getAuthorities();        <span class="hljs-comment">//遍历用户所有角色</span>        <span class="hljs-keyword">for</span>(GrantedAuthority authority:authorities)&#123;            String roleName = authority.getAuthority();            Integer roleId = roleService.selectByName(roleName).getId();            <span class="hljs-comment">//得到角色所有的权限</span>            List&lt;SysPermission&gt; permissionList = permissionService.listByRoleId(roleId);            <span class="hljs-comment">//遍历permissionList</span>            <span class="hljs-keyword">for</span>(SysPermission sysPermission:permissionList)&#123;                <span class="hljs-comment">//获取权限集</span>                List permissions = sysPermission.getPermissions();                <span class="hljs-comment">//如果访问的url和权限用户符合的话，返回true</span>                <span class="hljs-keyword">if</span>(targetUrl.equals(sysPermission.getUrl()) &amp;&amp; permissions.contains(targetPermission))&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPermission</span><span class="hljs-params">(Authentication authentication, Serializable targetId, String targetType, Object permission)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><p>在 <code>hasPermission()</code> 方法中，参数 1 代表<strong>用户的权限身份</strong>，参数 2 参数 3 分别和 <code>@PreAuthorize(&quot;hasPermission(&#39;/admin&#39;,&#39;r&#39;)&quot;)</code> 中的参数对应，即<strong>访问 url 和权限</strong>。</p><p>思路如下：</p><ol><li>通过 <code>Authentication</code> 取出登录用户的所有 <code>Role</code></li><li>遍历每一个 <code>Role</code>，获取到每个<code>Role</code>的所有 <code>Permission</code></li><li>遍历每一个 <code>Permission</code>，只要有一个 <code>Permission</code> 的 <code>url</code> 和传入的url相同，且该 <code>Permission</code> 中包含传入的权限，返回 true</li><li>如果遍历都结束，还没有找到，返回false</li></ol><p>下面就是在 <code>WebSecurityConfig</code> 中注册 <code>CustomPermissionEvaluator</code>：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DefaultWebSecurityExpressionHandler <span class="hljs-title">webSecurityExpressionHandler</span><span class="hljs-params">()</span></span>&#123;        DefaultWebSecurityExpressionHandler handler = <span class="hljs-keyword">new</span> DefaultWebSecurityExpressionHandler();        handler.setPermissionEvaluator(<span class="hljs-keyword">new</span> CustomPermissionEvaluator());        <span class="hljs-keyword">return</span> handler;    &#125;&#125;</code></pre></div><h2 id="三、运行程序"><a href="#三、运行程序" class="headerlink" title="三、运行程序"></a>三、运行程序</h2><p>当我使用角色为 <code>ROLE_USER</code> 的用户仍然能访问，因为该用户访问 <code>/admin</code> 路径具有 <code>r</code> 权限：</p><p><img src="https://www.jitwxs.cn/images/posts/2018051519070954.png" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(4)--自定义表单登录</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%8D%95%E7%99%BB%E5%BD%95/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%8D%95%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="一、添加验证码"><a href="#一、添加验证码" class="headerlink" title="一、添加验证码"></a>一、添加验证码</h3><h4 id="1-1-验证码-Servlet"><a href="#1-1-验证码-Servlet" class="headerlink" title="1.1 验证码 Servlet"></a>1.1 验证码 Servlet</h4><p>验证码的 Servlet 代码，大家无需关心其内部实现，我也是百度直接捞了一个，直接复制即可。</p><div class="hljs"><pre><code class="hljs java">com.gavin.springsecurity04.common.VerifyServlet    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VerifyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123; <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">5051097528828603895L</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 验证码图片的宽度。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> width = <span class="hljs-number">100</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *  验证码图片的高度。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height = <span class="hljs-number">30</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 验证码字符个数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> codeCount = <span class="hljs-number">4</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 字体高度</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> fontHeight;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 干扰线数量</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> interLine = <span class="hljs-number">16</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 第一个字符的x轴值，因为后面的字符坐标依次递增，所以它们的x轴值是codeX的倍数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> codeX;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * codeY ,验证字符的y轴值，因为并行所以值一样</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> codeY;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * codeSequence 表示字符允许出现的序列值</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">char</span>[] codeSequence = &#123; <span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>, <span class="hljs-string">'H'</span>, <span class="hljs-string">'I'</span>, <span class="hljs-string">'J'</span>,            <span class="hljs-string">'K'</span>, <span class="hljs-string">'L'</span>, <span class="hljs-string">'M'</span>, <span class="hljs-string">'N'</span>, <span class="hljs-string">'O'</span>, <span class="hljs-string">'P'</span>, <span class="hljs-string">'Q'</span>, <span class="hljs-string">'R'</span>, <span class="hljs-string">'S'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">'U'</span>, <span class="hljs-string">'V'</span>, <span class="hljs-string">'W'</span>,            <span class="hljs-string">'X'</span>, <span class="hljs-string">'Y'</span>, <span class="hljs-string">'Z'</span>, <span class="hljs-string">'0'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'6'</span>, <span class="hljs-string">'7'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'9'</span> &#125;;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 初始化验证图片属性</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;        <span class="hljs-comment">// 从web.xml中获取初始信息</span>        <span class="hljs-comment">// 宽度</span>        String strWidth = <span class="hljs-keyword">this</span>.getInitParameter(<span class="hljs-string">"width"</span>);        <span class="hljs-comment">// 高度</span>        String strHeight = <span class="hljs-keyword">this</span>.getInitParameter(<span class="hljs-string">"height"</span>);        <span class="hljs-comment">// 字符个数</span>        String strCodeCount = <span class="hljs-keyword">this</span>.getInitParameter(<span class="hljs-string">"codeCount"</span>);        <span class="hljs-comment">// 将配置的信息转换成数值</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (strWidth != <span class="hljs-keyword">null</span> &amp;&amp; strWidth.length() != <span class="hljs-number">0</span>) &#123;                width = Integer.parseInt(strWidth);            &#125;            <span class="hljs-keyword">if</span> (strHeight != <span class="hljs-keyword">null</span> &amp;&amp; strHeight.length() != <span class="hljs-number">0</span>) &#123;                height = Integer.parseInt(strHeight);            &#125;            <span class="hljs-keyword">if</span> (strCodeCount != <span class="hljs-keyword">null</span> &amp;&amp; strCodeCount.length() != <span class="hljs-number">0</span>) &#123;                codeCount = Integer.parseInt(strCodeCount);            &#125;        &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-comment">//width-4 除去左右多余的位置，使验证码更加集中显示，减得越多越集中。</span>        <span class="hljs-comment">//codeCount+1     //等比分配显示的宽度，包括左右两边的空格</span>        codeX = (width-<span class="hljs-number">4</span>) / (codeCount+<span class="hljs-number">1</span>);        <span class="hljs-comment">//height - 10 集中显示验证码</span>        fontHeight = height - <span class="hljs-number">10</span>;        codeY = height - <span class="hljs-number">7</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ServletException</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> java.io.IOException</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, java.io.IOException </span>&#123;        <span class="hljs-comment">// 定义图像buffer</span>        BufferedImage buffImg = <span class="hljs-keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);        Graphics2D gd = buffImg.createGraphics();        <span class="hljs-comment">// 创建一个随机数生成器类</span>        Random random = <span class="hljs-keyword">new</span> Random();        <span class="hljs-comment">// 将图像填充为白色</span>        gd.setColor(Color.LIGHT_GRAY);        gd.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);        <span class="hljs-comment">// 创建字体，字体的大小应该根据图片的高度来定。</span>        Font font = <span class="hljs-keyword">new</span> Font(<span class="hljs-string">"Times New Roman"</span>, Font.PLAIN, fontHeight);        <span class="hljs-comment">// 设置字体。</span>        gd.setFont(font);        <span class="hljs-comment">// 画边框。</span>        gd.setColor(Color.BLACK);        gd.drawRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width - <span class="hljs-number">1</span>, height - <span class="hljs-number">1</span>);        <span class="hljs-comment">// 随机产生16条干扰线，使图象中的认证码不易被其它程序探测到。</span>        gd.setColor(Color.gray);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; interLine; i++) &#123;            <span class="hljs-keyword">int</span> x = random.nextInt(width);            <span class="hljs-keyword">int</span> y = random.nextInt(height);            <span class="hljs-keyword">int</span> xl = random.nextInt(<span class="hljs-number">12</span>);            <span class="hljs-keyword">int</span> yl = random.nextInt(<span class="hljs-number">12</span>);            gd.drawLine(x, y, x + xl, y + yl);        &#125;        <span class="hljs-comment">// randomCode用于保存随机产生的验证码，以便用户登录后进行验证。</span>        StringBuffer randomCode = <span class="hljs-keyword">new</span> StringBuffer();        <span class="hljs-keyword">int</span> red = <span class="hljs-number">0</span>, green = <span class="hljs-number">0</span>, blue = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 随机产生codeCount数字的验证码。</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; codeCount; i++) &#123;            <span class="hljs-comment">// 得到随机产生的验证码数字。</span>            String strRand = String.valueOf(codeSequence[random.nextInt(<span class="hljs-number">36</span>)]);            <span class="hljs-comment">// 产生随机的颜色分量来构造颜色值，这样输出的每位数字的颜色值都将不同。</span>            red = random.nextInt(<span class="hljs-number">255</span>);            green = random.nextInt(<span class="hljs-number">255</span>);            blue = random.nextInt(<span class="hljs-number">255</span>);            <span class="hljs-comment">// 用随机产生的颜色将验证码绘制到图像中。</span>            gd.setColor(<span class="hljs-keyword">new</span> Color(red,green,blue));            gd.drawString(strRand, (i + <span class="hljs-number">1</span>) * codeX, codeY);            <span class="hljs-comment">// 将产生的四个随机数组合在一起。</span>            randomCode.append(strRand);        &#125;        <span class="hljs-comment">// 将四位数字的验证码保存到Session中。</span>        HttpSession session = request.getSession();        session.setAttribute(<span class="hljs-string">"validateCode"</span>, randomCode.toString());        <span class="hljs-comment">// 禁止图像缓存。</span>        response.setHeader(<span class="hljs-string">"Pragma"</span>, <span class="hljs-string">"no-cache"</span>);        response.setHeader(<span class="hljs-string">"Cache-Control"</span>, <span class="hljs-string">"no-cache"</span>);        response.setDateHeader(<span class="hljs-string">"Expires"</span>, <span class="hljs-number">0</span>);        response.setContentType(<span class="hljs-string">"image/jpeg"</span>);        <span class="hljs-comment">// 将图像输出到Servlet输出流中。</span>        ServletOutputStream sos = response.getOutputStream();        ImageIO.write(buffImg, <span class="hljs-string">"jpeg"</span>, sos);        sos.close();    &#125;  &#125;</code></pre></div><p>然后在 Application 中注入该 Servlet：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringSecurity04Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(SpringSecurity04Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">indexServletRegistration</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//利用ServletRegistrationBean接口来使用servlet功能</span>        ServletRegistrationBean registration = <span class="hljs-keyword">new</span> ServletRegistrationBean(<span class="hljs-keyword">new</span> VerifyServlet());        registration.addUrlMappings(<span class="hljs-string">"/getVerifyCode"</span>);        <span class="hljs-keyword">return</span> registration;    &#125;&#125;</code></pre></div><h4 id="1-2-修改-login-html"><a href="#1-2-修改-login-html" class="headerlink" title="1.2 修改 login.html"></a>1.2 修改 login.html</h4><p>在原本的 login 页面基础上加上验证码字段：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>登陆<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>登陆<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"verifyCode"</span> <span class="hljs-attr">required</span>=<span class="hljs-string">"required"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"验证码"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"getVerifyCode"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"看不清，请点我"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"refresh(this)"</span> <span class="hljs-attr">onmouseover</span>=<span class="hljs-string">"mouseover(this)"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"remember-me"</span>/&gt;</span>自动登录<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>立即登陆<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">refresh</span>(<span class="hljs-params">obj</span>) </span>&#123; obj.src = <span class="hljs-string">"getVerifyCode?"</span> + <span class="hljs-built_in">Math</span>.random(); &#125;</span><span class="actionscript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mouseover</span><span class="hljs-params">(obj)</span> </span>&#123; obj.style.cursor = <span class="hljs-string">"pointer"</span>; &#125;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="1-3-添加匿名访问-Url"><a href="#1-3-添加匿名访问-Url" class="headerlink" title="1.3 添加匿名访问 Url"></a>1.3 添加匿名访问 Url</h4><p>不要忘记在 WebSecurityConfig 中允许该 Url 的匿名访问，不然没有登录是没有办法访问该 Url 的：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">//设置拦截忽略文件夹，可以对静态资源访问</span>    web.ignoring().antMatchers(<span class="hljs-string">"/css/**"</span>,<span class="hljs-string">"/js/**"</span>,<span class="hljs-string">"/css/**"</span>,<span class="hljs-string">"/getVerifyCode"</span>);&#125;</code></pre></div><p>效果如下：</p><p><img src="D:%5C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%5CBlog%5CMyBlog%5Csource_posts%5Cimage-20200523174552543.png" srcset="/img/loading.gif" alt="效果"></p><p>下面才算是这篇文章真正的部分。我们如何才能实现验证码验证呢，思考一下，应该有以下几种实现方式：</p><ol><li>登录表单提交前发送 AJAX 验证验证码</li><li>使用自定义过滤器(Filter)，在 Spring security 校验前验证验证码合法性</li><li>和用户名、密码一起发送到后台，在 Spring security 中进行验证</li></ol><h3 id="二、AJAX-验证"><a href="#二、AJAX-验证" class="headerlink" title="二、AJAX 验证"></a>二、AJAX 验证</h3><p>使用 AJAX 方式验证和我们 Spring Security 框架就没有任何关系了，其实就是表单提交前先发个 HTTP 请求验证验证码，本篇不再赘述。</p><h3 id="三、过滤器验证"><a href="#三、过滤器验证" class="headerlink" title="三、过滤器验证"></a>三、过滤器验证</h3><p>使用过滤器的思路是：<strong>在Spring Security 处理登录验证请求前，验证验证码，如果正确，放行；如果不正确，跳到异常</strong>。</p><h4 id="3-1-编写验证码过滤器"><a href="#3-1-编写验证码过滤器" class="headerlink" title="3.1 编写验证码过滤器"></a>3.1 编写验证码过滤器</h4><p>自定义一个过滤器，实现 <code>OncePerRequestFilter</code> （该 Filter 保证每次请求一定会过滤），在 <code>isProtectedUrl()</code> 方法中拦截了 POST 方式的 /login 请求。</p><p>在逻辑处理中从 request 中取出验证码，并进行验证，如果验证成功，放行；验证失败，手动生成异常。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VerifyFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OncePerRequestFilter</span> </span>&#123;    <span class="hljs-comment">/**获取路径信息**/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> PathMatcher PATH_MATCHER = <span class="hljs-keyword">new</span> AntPathMatcher();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-comment">//如果是POST请求，并且请求路径是/login，就去进行验证码校验</span>        <span class="hljs-keyword">if</span>(isProtectedUrl(httpServletRequest))&#123;            String verifyCode = httpServletRequest.getParameter(<span class="hljs-string">"verifyCode"</span>);            <span class="hljs-comment">//如果验证码错误，就抛出异常，否则正常执行</span>            <span class="hljs-keyword">if</span>(!validateVerify(verifyCode))&#123;                <span class="hljs-comment">//手动设置异常</span>                httpServletRequest.setAttribute(<span class="hljs-string">"SPRING_SECURITY_LAST_EXCEPTION"</span>,<span class="hljs-keyword">new</span> DisabledException(<span class="hljs-string">"验证码输入错误"</span>));                <span class="hljs-comment">//转发到错误url</span>       httpServletRequest.getRequestDispatcher(<span class="hljs-string">"/login/error"</span>).forward(httpServletRequest,httpServletResponse);            &#125;<span class="hljs-keyword">else</span> &#123;                filterChain.doFilter(httpServletRequest,httpServletResponse);            &#125;        &#125;<span class="hljs-keyword">else</span> &#123;            filterChain.doFilter(httpServletRequest,httpServletResponse);        &#125;    &#125;    <span class="hljs-comment">/**校验验证码**/</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validateVerify</span><span class="hljs-params">(String verifyCode)</span> </span>&#123;        <span class="hljs-comment">//获取当前线程绑定的request对象</span>        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = requestAttributes.getRequest();        <span class="hljs-comment">//下面这个validateCode是在servlet中存入session的名字</span>        String validateCode = ((String) request.getSession().getAttribute(<span class="hljs-string">"validateCode"</span>)).toLowerCase();        verifyCode = verifyCode.toLowerCase();        System.out.println(<span class="hljs-string">"验证码："</span>+validateCode+<span class="hljs-string">"用户输入："</span>+verifyCode);        <span class="hljs-keyword">return</span> validateCode.equals(verifyCode);    &#125;    <span class="hljs-comment">/**拦截/login的POST请求**/</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isProtectedUrl</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"POST"</span>.equals(request.getMethod()) &amp;&amp; PATH_MATCHER.match(<span class="hljs-string">"/login"</span>,request.getServletPath());    &#125;&#125;</code></pre></div><h4 id="3-2-注入过滤器"><a href="#3-2-注入过滤器" class="headerlink" title="3.2 注入过滤器"></a>3.2 注入过滤器</h4><p>修改 WebSecurityConfig 的 configure 方法，添加一个 <code>addFilterBefore()</code> ，具有两个参数，作用是在参数二之前执行参数一设置的过滤器。</p><p>Spring Security 对于用户名/密码登录方式是通过 <code>UsernamePasswordAuthenticationFilter</code> 处理的，我们在它之前执行验证码过滤器即可。</p><div class="hljs"><pre><code class="hljs java">.addFilterBefore(<span class="hljs-keyword">new</span> VerifyFilter(), UsernamePasswordAuthenticationFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span></code></pre></div><p>测试效果不理想，不推荐这种方式。</p><h3 id="四、Spring-Security-验证"><a href="#四、Spring-Security-验证" class="headerlink" title="四、Spring Security 验证"></a>四、Spring Security 验证</h3><p>使用过滤器就已经实现了验证码功能，但其实它和 AJAX 验证差别不大。</p><ul><li>AJAX 是在提交前发一个请求，请求返回成功就提交，否则不提交；</li><li>过滤器是先验证验证码，验证成功就让 Spring Security 验证用户名和密码；验证失败，则产生异常·。</li></ul><p>如果我们要做的需求是用户登录是需要多个验证字段，不单单是用户名和密码，那么使用过滤器会让逻辑变得复杂，这时候可以考虑自定义 Spring Security 的验证逻辑了…</p><h4 id="4-1-WebAuthenticationDetails"><a href="#4-1-WebAuthenticationDetails" class="headerlink" title="4.1 WebAuthenticationDetails"></a>4.1 WebAuthenticationDetails</h4><p>我们知道 Spring security 默认只会处理用户名和密码信息。这时候就要请出我们的主角——<code>WebAuthenticationDetails</code>。</p><blockquote><p><code>WebAuthenticationDetails</code>: 该类提供了获取用户登录时携带的额外信息的功能，默认提供了 remoteAddress 与 sessionId 信息。</p></blockquote><p>我们需要实现自定义的 <code>WebAuthenticationDetails</code>，并在其中加入我们的验证码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomWebAuthenticationDetails</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebAuthenticationDetails</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">6975601077710753878L</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String verifyCode;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Records the remote address and will also set the session Id if a session already</span><span class="hljs-comment">     * exists (it won't create one).</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request that the authentication request was received from</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomWebAuthenticationDetails</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;        <span class="hljs-keyword">super</span>(request);        verifyCode = request.getParameter(<span class="hljs-string">"verifyCode"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getVerifyCode</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.verifyCode;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        sb.append(<span class="hljs-keyword">super</span>.toString()).append(<span class="hljs-string">";VerifiCode:"</span>).append(<span class="hljs-keyword">this</span>.verifyCode);        <span class="hljs-keyword">return</span> sb.toString();    &#125;&#125;</code></pre></div><p>在这个方法中，我们将前台form表单中的verifyCode获取到，并通过get方法方便调用。</p><h4 id="4-2-AuthenticationDetailsSource"><a href="#4-2-AuthenticationDetailsSource" class="headerlink" title="4.2 AuthenticationDetailsSource"></a>4.2 AuthenticationDetailsSource</h4><p>自定义了<code>WebAuthenticationDetails</code>，我i们还需要将其放入 <code>AuthenticationDetailsSource</code> 中来替换原本的 <code>WebAuthenticationDetails</code> ，因此还得实现自定义 <code>AuthenticationDetailsSource</code> ：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>(<span class="hljs-string">"authenticationDetailsSource"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationDetailsSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationDetailsSource</span>&lt;<span class="hljs-title">HttpServletRequest</span>, <span class="hljs-title">WebAuthenticationDetails</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> WebAuthenticationDetails <span class="hljs-title">buildDetails</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CustomWebAuthenticationDetails(request);    &#125;&#125;</code></pre></div><p>该类是将原本的 <code>WebAuthenticationDetails</code> 替换为了我们的 <code>CustomWebAuthenticationDetails</code>。</p><p>接下来我们只需将 <code>CustomAuthenticationDetailsSource</code> 注入Spring Security中，替换掉默认的 <code>AuthenticationDetailsSource</code>。</p><p>通过修改 <code>WebSecurityConfig</code>将其注入，然后在config()中使用 <code>authenticationDetailsSource(authenticationDetailsSource)</code>方法来指定它。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>  AuthenticationDetailsSource&lt;HttpServletRequest, WebAuthenticationDetails&gt; authenticationDetailsSource;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;      http.authorizeRequests()      ....省略   .authenticationDetailsSource(authenticationDetailsSource)</code></pre></div><h4 id="4-3-AuthenticationProvider"><a href="#4-3-AuthenticationProvider" class="headerlink" title="4.3 AuthenticationProvider"></a>4.3 AuthenticationProvider</h4><p>至此我们通过自定义 <code>WebAuthenticationDetails</code> 和 <code>AuthenticationDetailsSource</code> 将验证码和用户名、密码一起带入了 Spring Security 中，下面我们需要将它取出来。</p><p>这里需要我们自定义 <code>AuthenticationProvider</code>，需要注意的是，<strong>如果是我们自己实现 <code>AuthenticationProvider</code>，那么我们就需要自己做密码校验了。</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationProvider</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> CustomUserDetailsService customUserDetailsService;    <span class="hljs-comment">/**用来验证用户身份**/</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        <span class="hljs-comment">//1.获取用户的用户名和密码</span>        String inputName = authentication.getName();        String inputPassword = authentication.getCredentials().toString();        CustomWebAuthenticationDetails details = (CustomWebAuthenticationDetails) authentication.getDetails();        String verifyCode = details.getVerifyCode();        <span class="hljs-keyword">if</span>(!validateVerify(verifyCode))&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisabledException(<span class="hljs-string">"验证码输入错误"</span>);        &#125;        <span class="hljs-comment">// userDetails为数据库中查询到的用户信息</span>        UserDetails userDetails = customUserDetailsService.loadUserByUsername(inputName);        <span class="hljs-comment">// 如果是自定义AuthenticationProvider，需要手动密码校验</span>        <span class="hljs-keyword">if</span>(!userDetails.getPassword().equals(inputPassword) || !userDetails.getUsername().equals(inputName))&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">"用户名或密码错误"</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(inputName,inputPassword,userDetails.getAuthorities());    &#125;    <span class="hljs-comment">/**验证码核对**/</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validateVerify</span><span class="hljs-params">(String verifiCode)</span> </span>&#123;        <span class="hljs-comment">//获取当前线程绑定的request对象</span>        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = requestAttributes.getRequest();        String validateCode = ((String) request.getSession().getAttribute(<span class="hljs-string">"validateCode"</span>)).toLowerCase();        verifiCode = verifiCode.toLowerCase();        System.out.println(<span class="hljs-string">"验证码："</span>+validateCode+<span class="hljs-string">";用户输入："</span>+verifiCode);        <span class="hljs-keyword">return</span> validateCode.equals(verifiCode);    &#125;    <span class="hljs-comment">/**判断当前的AuthenticationProvider是否支持对应的Authentication**/</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; authentication)</span> </span>&#123;        <span class="hljs-keyword">return</span> (UsernamePasswordAuthenticationToken<span class="hljs-class">.<span class="hljs-keyword">class</span></span><span class="hljs-class">                .<span class="hljs-title">isAssignableFrom</span>(<span class="hljs-title">authentication</span>))</span>;    &#125;&#125;</code></pre></div><p>最后在 <code>WebSecurityConfig</code> 中将其注入，并在 config 方法中通过 <code>auth.authenticationProvider()</code> 指定使用。</p><div class="hljs"><pre><code class="hljs java"> <span class="hljs-meta">@Autowired</span> CustomAuthenticationProvider customAuthenticationProvider; <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;     auth.authenticationProvider(customAuthenticationProvider); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(3)--异常处理</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>思考：为何登录失败自动跳转到/login?error，而且没有异常提示？</p><p><img src="https://img-blog.csdnimg.cn/20200531223128165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>因为首先 <code>/login?error</code> 是 Spring security 默认的失败 Url，其次<strong>如果你不手动处理这个异常，这个异常是不会被处理的</strong>。</p><h2 id="一、常见异常"><a href="#一、常见异常" class="headerlink" title="一、常见异常"></a>一、常见异常</h2><p>我们先来列举下一些 Spring Security 中常见的异常：</p><ul><li><code>UsernameNotFoundException</code>（用户不存在）</li><li><code>DisabledException</code>（用户已被禁用）</li><li><code>BadCredentialsException</code>（坏的凭据）</li><li><code>LockedException</code>（账户锁定）</li><li><code>AccountExpiredException</code> （账户过期）</li><li><code>CredentialsExpiredException</code>（证书过期）</li><li>…</li></ul><p>以上列出的这些异常都是 <code>AuthenticationException</code> 的子类，然后我们来看看 Spring security 如何处理 <code>AuthenticationException</code> 异常的。</p><h2 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h2><p>我们知道异常一般在过滤器中处理，在 <code>AbstractAuthenticationProcessingFilter</code> 中我们找到了对 <code>AuthenticationException</code> 的处理：</p><div class="hljs"><pre><code class="hljs jAVA">org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter#doFilter    <span class="hljs-keyword">try</span> &#123;authResult = attemptAuthentication(request, response);<span class="hljs-comment">//1.认证</span><span class="hljs-keyword">if</span> (authResult == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span>;&#125;sessionStrategy.onAuthentication(authResult, request, response); <span class="hljs-comment">//2.并发问题</span>&#125;<span class="hljs-keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;logger.error(<span class="hljs-string">"An internal error occurred while trying to authenticate the user."</span>,failed);unsuccessfulAuthentication(request, response, failed);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">catch</span> (AuthenticationException failed) &#123;unsuccessfulAuthentication(request, response, failed);<span class="hljs-comment">//3.认证失败</span><span class="hljs-keyword">return</span>;&#125;</code></pre></div><p>(1)，先是调用attemptAuthentication（）方法对请求参数进行提取</p><div class="hljs"><pre><code class="hljs java">org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter#attemptAuthentication<span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;<span class="hljs-keyword">if</span> (postOnly &amp;&amp; !request.getMethod().equals(<span class="hljs-string">"POST"</span>)) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">"Authentication method not supported: "</span> + request.getMethod());&#125;String username = obtainUsername(request);String password = obtainPassword(request);<span class="hljs-keyword">if</span> (username == <span class="hljs-keyword">null</span>) &#123;username = <span class="hljs-string">""</span>;&#125;<span class="hljs-keyword">if</span> (password == <span class="hljs-keyword">null</span>) &#123;password = <span class="hljs-string">""</span>;&#125;username = username.trim();UsernamePasswordAuthenticationToken authRequest = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(username, password);<span class="hljs-comment">// 设置“details”属性</span>setDetails(request, authRequest);<span class="hljs-comment">//认证</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);&#125;</code></pre></div><p>我们来看看<code>setDetails(request,authRequest)</code>做了些什么：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDetails</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">UsernamePasswordAuthenticationToken authRequest)</span> </span>&#123;authRequest.setDetails(authenticationDetailsSource.buildDetails(request));&#125;</code></pre></div><p>UsernamePasswordAuthenticationToken是Authentication的具体实现，所以这里实际上就是在设置details，至于details的值，则是通过authenticationDetailsSource来构建：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebAuthenticationDetailsSource</span> <span class="hljs-keyword">implements</span></span><span class="hljs-class"><span class="hljs-title">AuthenticationDetailsSource</span>&lt;<span class="hljs-title">HttpServletRequest</span>, <span class="hljs-title">WebAuthenticationDetails</span>&gt; </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> WebAuthenticationDetails <span class="hljs-title">buildDetails</span><span class="hljs-params">(HttpServletRequest context)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WebAuthenticationDetails(context);&#125;&#125;</code></pre></div><p>这里我们也就知道<code>buildDetails</code>方法返回的其实是一个<code>WebAuthenticationDetails</code>对象，而<code>WebAuthenticationDetails</code>对象默认有哪些属性呢？</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WebAuthenticationDetails</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<span class="hljs-keyword">this</span>.remoteAddress = request.getRemoteAddr();HttpSession session = request.getSession(<span class="hljs-keyword">false</span>);<span class="hljs-keyword">this</span>.sessionId = (session != <span class="hljs-keyword">null</span>) ? session.getId() : <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p>如果我们想保存更多关于Http请求的信息，可以通过自定义<code>WebAuthenticationDetails</code>来实现，同时<code>WebAuthenticationDetailsSource</code>也要一起重新定义。</p><p>接下来进入到<code>org.springframework.security.authentication.ProviderManager#authenticate</code>方法中：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;Class&lt;? extends Authentication&gt; toTest = authentication.getClass();AuthenticationException lastException = <span class="hljs-keyword">null</span>;AuthenticationException parentException = <span class="hljs-keyword">null</span>;Authentication result = <span class="hljs-keyword">null</span>;Authentication parentResult = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">boolean</span> debug = logger.isDebugEnabled();<span class="hljs-comment">//逐个遍历AuthenticationProvider，并调用他们的authenticate方法来做认证：</span><span class="hljs-keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;            <span class="hljs-comment">//首先要判断当前的AuthenticationProvider是否支持对应的Authentication</span><span class="hljs-keyword">if</span> (!provider.supports(toTest)) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (debug) &#123;logger.debug(<span class="hljs-string">"Authentication attempt using "</span>+ provider.getClass().getName());&#125;<span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//实际验证交给AuthenticationProvider来处理</span>result = provider.authenticate(authentication);<span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;copyDetails(authentication, result);<span class="hljs-keyword">break</span>;&#125;&#125;            <span class="hljs-comment">//如果验证过程中有异常，就会被捕获</span><span class="hljs-keyword">catch</span> (AccountStatusException | InternalAuthenticationServiceException e) &#123;prepareException(e, authentication);<span class="hljs-keyword">throw</span> e;&#125; <span class="hljs-keyword">catch</span> (AuthenticationException e) &#123;lastException = e;&#125;&#125;</code></pre></div><p>（2），调用 <code>attemptAuthentication</code>方法走完认证流程之后，回来之后，接下来就是调用 <code>sessionStrategy.onAuthentication</code>方法，这个方法就是用来处理 <code>session</code>的并发问题：</p><div class="hljs"><pre><code class="hljs java">org.springframework.security.web.authentication.session.ConcurrentSessionControlAuthenticationStrategy#onAuthentication<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthentication</span><span class="hljs-params">(Authentication authentication,</span></span><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<span class="hljs-comment">//1.获取当前用户的所有 session，该方法在调用时，传递两个参数，一个是当前用户的 authentication，</span><span class="hljs-comment">//另一个参数 false 表示不包含已经过期的 session（在用户登录成功后，会将用户的 sessionid 存起来，</span><span class="hljs-comment">//其中 key 是用户的主体（principal），value 则是该主体对应的 sessionid 组成的一个集合）。</span><span class="hljs-keyword">final</span> List&lt;SessionInformation&gt; sessions = sessionRegistry.getAllSessions(authentication.getPrincipal(), <span class="hljs-keyword">false</span>);<span class="hljs-comment">//接下来计算出当前用户已经有几个有效 session 了，同时获取允许的 session 并发数。</span><span class="hljs-keyword">int</span> sessionCount = sessions.size();<span class="hljs-keyword">int</span> allowedSessions = getMaximumSessionsForThisUser(authentication);<span class="hljs-comment">//如果当前 session 数（sessionCount）小于 session 并发数（allowedSessions），则不做任何处理</span><span class="hljs-keyword">if</span> (sessionCount &lt; allowedSessions) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//如果 allowedSessions 的值为 -1，表示对 session 数量不做任何限制。</span><span class="hljs-keyword">if</span> (allowedSessions == -<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (sessionCount == allowedSessions) &#123;HttpSession session = request.getSession(<span class="hljs-keyword">false</span>);<span class="hljs-keyword">if</span> (session != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 只有当这个请求与一个已经注册的会话相同时才允许它</span><span class="hljs-keyword">for</span> (SessionInformation si : sessions) &#123;<span class="hljs-keyword">if</span> (si.getSessionId().equals(session.getId())) &#123;<span class="hljs-keyword">return</span>;&#125;&#125;&#125;&#125;<span class="hljs-comment">//首先会有 exceptionIfMaximumExceeded 属性，这就是我们在 SecurityConfig 中配置的 maxSessionsPreventsLogin 的值，默认为 false，如果为 true，就直接抛出异常，禁止新的登录（参照微信），如果为 false，则对 sessions 按照请求时间进行排序，然后再使多余的 session 过期即可（参照QQ）。</span>allowableSessionsExceeded(sessions, allowedSessions, sessionRegistry);&#125;</code></pre></div><p>配置文件如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-comment">//1</span><span class="hljs-function">HttpSessionEventPub1isher <span class="hljs-title">httpSessionEventPub1isher</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HttpSessionEventPub1isher();&#125;<span class="hljs-comment">//关闭CRSF跨域</span>        http.csrf()                .disable()                .sessionManagement()                .maximumSessions(<span class="hljs-number">1</span>)                .maxSessionsPreventsLogin(<span class="hljs-keyword">true</span>);</code></pre></div><p>为什么要加这个Bean呢？因为在Spring Security中，它是通过监听session的销毁事件来及时清理session的记录的，用户从不同的浏览器登录后，都会有对应的session，当用户注销登录之后，session就会失效，但是默认的失效是通过调用<code>StandardSession#invalidate</code>方法来实现的，这一失效事件无法被Spring容器感知到，进而导致当用户注销登录之后，Spring Security没有及时清理会话信息表，以为用户还在线，进而导致用户无法重新登录进来。</p><p>为了解决这一问题，我们提供了一个HttpSessionEventPublisher，这个类实现了httpSessionListener接口，在该Bean中，可以将session创建以及销毁的事件及时感知到，并且调用Sprign中的事件机制将相关的创建和销毁事件发布出去，进而被Spring Security感知到。</p><p>(3)，当用户登录失败时，被异常捕获，转到 <code>unsuccessfulAuthentication()</code> 方法中，然后转交给了 <code>SimpleUrlAuthenticationFailureHandler</code> 类的 <code>onAuthenticationFailure()</code> 处理。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unsuccessfulAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;    SecurityContextHolder.clearContext();    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logger.isDebugEnabled()) &#123;        <span class="hljs-keyword">this</span>.logger.debug(<span class="hljs-string">"Authentication request failed: "</span> + failed.toString(), failed);        <span class="hljs-keyword">this</span>.logger.debug(<span class="hljs-string">"Updated SecurityContextHolder to contain null Authentication"</span>);        <span class="hljs-keyword">this</span>.logger.debug(<span class="hljs-string">"Delegating to authentication failure handler "</span> + <span class="hljs-keyword">this</span>.failureHandler);    &#125;    <span class="hljs-keyword">this</span>.rememberMeServices.loginFail(request, response);    <span class="hljs-keyword">this</span>.failureHandler.onAuthenticationFailure(request, response, failed);&#125;</code></pre></div><p>在 <code>onAuthenticationFailure()</code> 中，首先判断有没有设置 <code>defaultFailureUrl</code>。</p><ul><li>如果没有设置，直接返回 401 错误，即 <code>HttpStatus.UNAUTHORIZED</code> 的值。</li><li>如果设置了，首先执行 <code>saveException()</code> 方法。然后判断 <code>forwardToDestination</code> ，即是否是服务器跳转，默认使用重定向即客户端跳转。</li></ul><div class="hljs"><pre><code class="hljs java">org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler#onAuthenticationFailure<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">      HttpServletResponse response, AuthenticationException exception)</span></span><span class="hljs-function">      <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;       <span class="hljs-keyword">if</span> (defaultFailureUrl == <span class="hljs-keyword">null</span>) &#123;      logger.debug(<span class="hljs-string">"No failure URL set, sending 401 Unauthorized error"</span>);      response.sendError(HttpStatus.UNAUTHORIZED.value(),         HttpStatus.UNAUTHORIZED.getReasonPhrase());   &#125;   <span class="hljs-keyword">else</span> &#123;      saveException(request, exception);<span class="hljs-comment">//判断是转发还是重定向</span>  <span class="hljs-comment">//直接转发</span>      <span class="hljs-keyword">if</span> (forwardToDestination) &#123;         logger.debug(<span class="hljs-string">"Forwarding to "</span> + defaultFailureUrl);         request.getRequestDispatcher(defaultFailureUrl)               .forward(request, response);      &#125;      <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//重定向</span>         logger.debug(<span class="hljs-string">"Redirecting to "</span> + defaultFailureUrl);         redirectStrategy.sendRedirect(request, response, defaultFailureUrl);      &#125;   &#125;&#125;</code></pre></div><p>来到<code>org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler#saveException</code>方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveException</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">AuthenticationException exception)</span> </span>&#123;<span class="hljs-keyword">if</span> (forwardToDestination) &#123;request.setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION, exception);&#125;<span class="hljs-keyword">else</span> &#123;HttpSession session = request.getSession(<span class="hljs-keyword">false</span>);<span class="hljs-keyword">if</span> (session != <span class="hljs-keyword">null</span> || allowSessionCreation) &#123;request.getSession().setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION,exception);&#125;&#125;&#125;</code></pre></div><p>在 <code>saveException()</code> 方法中，首先判断<code>forwardToDestination</code>，如果使用服务器跳转则写入 Request，客户端跳转则写入 Session。写入名为 <code>SPRING_SECURITY_LAST_EXCEPTION</code> ，值为 <code>AuthenticationException</code>。</p><p>至此 Spring security 完成了异常处理，总结一下流程：</p><p>–&gt; AbstractAuthenticationProcessingFilter<code>.doFilter()</code></p><p>–&gt; AbstractAuthenticationProcessingFilter.<code>unsuccessfulAuthentication()</code></p><p>–&gt; SimpleUrlAuthenticationFailureHandler.<code>onAuthenticationFailure()</code></p><p>–&gt; SimpleUrlAuthenticationFailureHandler.<code>saveException()</code></p><h2 id="三、处理异常"><a href="#三、处理异常" class="headerlink" title="三、处理异常"></a>三、处理异常</h2><p>上面源码说了那么多，真正处理起来很简单，我们只需要指定错误的url，然后再该方法中对异常进行处理即可。</p><p>（1）指定错误url，<code>WebSecurityConfig</code> 中添加 <code>.failureUrl(&quot;/login/error&quot;)</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http.authorizeRequests()            .anyRequest().authenticated()            .and()            .formLogin().loginPage(<span class="hljs-string">"/login"</span>)            <span class="hljs-comment">//登录失败url</span>            .failureUrl(<span class="hljs-string">"/login/error"</span>)            <span class="hljs-comment">//登录成功url</span>            .defaultSuccessUrl(<span class="hljs-string">"/"</span>).permitAll()</code></pre></div><p>（2）在 Controller 中处理异常</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/login/error"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loginError</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;    response.setContentType(<span class="hljs-string">"text/html;charset=utf-8"</span>);    AuthenticationException exception =            (AuthenticationException)request.getSession().getAttribute(<span class="hljs-string">"SPRING_SECURITY_LAST_EXCEPTION"</span>);    <span class="hljs-keyword">try</span> &#123;        response.getWriter().write(exception.toString());    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre></div><p>我们首先获取了 session 中的 <code>SPRING_SECURITY_LAST_EXCEPTION</code> 。为了演示，我只是简单的将错误信息返回给了页面。运行程序，当我们输入错误密码时：</p><p><img src="https://img-blog.csdnimg.cn/20200531223348529.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>来到我们自己设置的错误页面，显示我们设置的错误信息。</p>]]></content>
    
    
    <categories>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(2)--自动登录</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-2-%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-2-%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一、修改-login-html"><a href="#一、修改-login-html" class="headerlink" title="一、修改 login.html"></a>一、修改 login.html</h2><p>在登录页添加自动登录的选项，注意自动登录字段的 name 属性必须是 <code>remember-me</code> ：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>欢迎来到登录页面<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"remember-me"</span>&gt;</span>记住我<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>立即登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="二、两种实现方式"><a href="#二、两种实现方式" class="headerlink" title="二、两种实现方式"></a>二、两种实现方式</h2><h3 id="2-1-Cookie-存储"><a href="#2-1-Cookie-存储" class="headerlink" title="2.1 Cookie 存储"></a>2.1 Cookie 存储</h3><p>这种方式十分简单，只要在 WebSecurityConfig 中的 configure() 方法添加一个 <code>rememberMe()</code> 即可,如下所示：</p><div class="hljs"><pre><code class="hljs java"> http.authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span><span class="hljs-comment">//                .antMatchers().permitAll()</span>                .anyRequest().authenticated()                .and()                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                .defaultSuccessUrl(<span class="hljs-string">"/"</span>).permitAll()                <span class="hljs-comment">// 自定义登录用户名和密码参数，默认为username和password</span><span class="hljs-comment">//                .usernameParameter("username")</span><span class="hljs-comment">//                .passwordParameter("password")</span>                .and()                <span class="hljs-comment">// 开启自动登录</span>                .rememberMe()                .and()                .logout()                .permitAll();        <span class="hljs-comment">//关闭CRSF跨域</span>        http.csrf().disable();    &#125;</code></pre></div><p>当我们登录时勾选自动登录时，会自动在 Cookie 中保存一个名为 <code>remember-me</code> 的cookie，默认有效期为2周，其值是一个加密字符串：</p><p><img src="https://www.jitwxs.cn/images/posts/20180509100451811.png" srcset="/img/loading.gif" alt="基于缓存的自动登录"></p><h3 id="2-2-数据库存储"><a href="#2-2-数据库存储" class="headerlink" title="2.2 数据库存储"></a>2.2 数据库存储</h3><p>使用 Cookie 存储虽然很方便，但是大家都知道 Cookie 毕竟是保存在客户端的，而且 Cookie 的值还与用户名、密码这些敏感数据相关，虽然加密了，但是将敏感信息存在客户端，毕竟不太安全。</p><p>Spring security 还提供了另一种相对更安全的实现机制：<strong>在客户端的 Cookie 中，仅保存一个无意义的加密串（与用户名、密码等敏感数据无关），然后在数据库中保存该加密串-用户信息的对应关系，自动登录时，用 Cookie 中的加密串，到数据库中验证，如果通过，自动登录才算通过。</strong></p><h4 id="2-2-1-基本原理"><a href="#2-2-1-基本原理" class="headerlink" title="2.2.1 基本原理"></a>2.2.1 基本原理</h4><p>当浏览器发起表单登录请求时，当通过 <code>UsernamePasswordAuthenticationFilter</code> 认证成功后，会经过 <code>RememberMeService</code>，在其中有个 <code>TokenRepository</code>，它会生成一个 token，首先将 token 写入到浏览器的 Cookie 中，然后将 token、认证成功的用户名写入到数据库中。</p><p>当浏览器下次请求时，会经过 <code>RememberMeAuthenticationFilter</code>，它会读取 Cookie 中的 token，交给 RememberMeService 从数据库中查询记录。如果存在记录，会读取用户名并去调用 <code>UserDetailsService</code>，获取用户信息，并将用户信息放入Spring Security 中，实现自动登录。</p><p><img src="https://www.jitwxs.cn/images/posts/20181202143630639.png" srcset="/img/loading.gif" alt="实现原理"></p><p>RememberMeAuthenticationFilter 在整个过滤器链中是比较靠后的位置，也就是说在传统登录方式都无法登录的情况下才会使用自动登录。</p><p><img src="https://www.jitwxs.cn/images/posts/20181202144420871.png" srcset="/img/loading.gif" alt="spring security过滤器链"></p><h4 id="2-2-2-代码实现"><a href="#2-2-2-代码实现" class="headerlink" title="2.2.2 代码实现"></a>2.2.2 代码实现</h4><p>首先需要创建一张表来存储 token 信息：</p><div class="hljs"><pre><code class="hljs SQL"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`persistent_logins`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`persistent_logins`</span>(<span class="hljs-string">`username`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<span class="hljs-string">`series`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    <span class="hljs-string">`token`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    <span class="hljs-string">`last_used`</span> <span class="hljs-built_in">timestamp</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span>,    PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`series`</span>))<span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4;</code></pre></div><p>在 WebSecurityConfig 中注入 <code>dataSource</code> ，创建一个 <code>PersistentTokenRepository</code> 的Bean：</p><div class="hljs"><pre><code class="hljs java">    <span class="hljs-meta">@Autowired</span>    DataSource dataSource;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersistentTokenRepository <span class="hljs-title">persistentTokenRepository</span><span class="hljs-params">()</span></span>&#123;        JdbcTokenRepositoryImpl tokenRepository = <span class="hljs-keyword">new</span> JdbcTokenRepositoryImpl();        tokenRepository.setDataSource(dataSource);                <span class="hljs-comment">//如果token表不存在，使用下面语句可以初始化该表，若存在，则需要注释掉这条语句，否则会报错</span><span class="hljs-comment">//        tokenRepository.setCreateTableOnStartup(true);</span>        <span class="hljs-keyword">return</span> tokenRepository;    &#125;</code></pre></div><p>在 <code>configure()</code> 中按如下所示配置自动登录：</p><div class="hljs"><pre><code class="hljs java"> <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span><span class="hljs-comment">//                .antMatchers().permitAll()</span>                .anyRequest().authenticated()                .and()                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                .defaultSuccessUrl(<span class="hljs-string">"/"</span>).permitAll()                .and()                <span class="hljs-comment">// 开启自动登录</span>                .rememberMe()                .tokenRepository(persistentTokenRepository())                <span class="hljs-comment">//有效时间(单位；s)</span>                .tokenValiditySeconds(<span class="hljs-number">60</span>)                .userDetailsService(userDetailsService)                .and()                .logout()                .permitAll();        <span class="hljs-comment">//关闭CRSF跨域</span>        http.csrf().disable();    &#125;</code></pre></div><h2 id="三、运行程序"><a href="#三、运行程序" class="headerlink" title="三、运行程序"></a>三、运行程序</h2><p>勾选自动登录后，Cookie 和数据库中均存储了 token 信息：</p><p><img src="https://www.jitwxs.cn/images/posts/20180509102031410.png" srcset="/img/loading.gif" alt="效果"></p>]]></content>
    
    
    <categories>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(1)--基础入门</title>
    <link href="/2020/05/29/SpringBoot%E9%9B%86%E6%88%90Spring-Security-1-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <url>/2020/05/29/SpringBoot%E9%9B%86%E6%88%90Spring-Security-1-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一、导入依赖"><a href="#一、导入依赖" class="headerlink" title="一、导入依赖"></a>一、导入依赖</h1><p>导入 <code>spring-boot-starter-security</code> 依赖，在 SpringBoot 2.0 环境下默认使用的是 5.0 版本。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-comment">&lt;!--注意，这里必须要指定版本，MySQL5用的驱动url是com.mysql.jdbc.Driver，</span><span class="hljs-comment">      MySQL6以后用的是com.mysql.cj.jdbc.Driver。版本不匹配便会报驱动类已过时的错误。--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.15<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h1 id="二、创建数据库"><a href="#二、创建数据库" class="headerlink" title="二、创建数据库"></a>二、创建数据库</h1><p>一般权限控制有三层，即：<code>用户</code>&lt;–&gt;<code>角色</code>&lt;–&gt;<code>权限</code>，用户与角色是多对多，角色和权限也是多对多。这里我们先暂时不考虑权限，只考虑<code>用户</code>&lt;–&gt;<code>角色</code>。</p><div class="hljs"><pre><code class="hljs mysql">-- 创建用户表 sys_user： --DROP TABLE IF EXISTS &#96;sys_user&#96;;CREATE TABLE &#96;sys_user&#96;(&#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,&#96;name&#96; varchar(255) NOT NULL,&#96;password&#96; varchar(255) NOT NULL,    PRIMARY KEY (&#96;id&#96;))ENGINE&#x3D;InnoDB DEFAULT CHARSET &#x3D; utf8;-- 创建权限表 sys_role： --DROP TABLE IF EXISTS &#96;sys_role&#96;;CREATE TABLE &#96;sys_role&#96;(&#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,    &#96;name&#96; varchar(255) NOT NULL,    PRIMARY KEY (&#96;id&#96;))ENGINE&#x3D;InnoDB DEFAULT CHARSET &#x3D; utf8;-- 创建用户-角色表 sys_user_role：（外键这里有点困惑，先标记下） --DROP TABLE IF EXISTS &#96;sys_user_role&#96;;CREATE TABLE &#96;sys_user_role&#96;(&#96;user_id&#96; int(11) NOT NULL ,    &#96;role_id&#96; int(11) NOT NULL,    PRIMARY KEY (&#96;user_id&#96;,&#96;role_id&#96;),    KEY &#96;fk_role_id&#96; (&#96;role_id&#96;),    CONSTRAINT &#96;fk_role_id&#96; FOREIGN KEY (&#96;role_id&#96;) REFERENCES &#96;sys_role&#96; (&#96;id&#96;) ON DELETE CASCADE ON UPDATE CASCADE,    CONSTRAINT &#96;fk_user_id&#96; FOREIGN KEY (&#96;user_id&#96;) REFERENCES &#96;sys_user&#96; (&#96;id&#96;) ON DELETE CASCADE ON UPDATE CASCADE)ENGINE&#x3D;InnoDB DEFAULT CHARSET &#x3D; utf8;-- 添加数据：（注意：传值的时候里面是单引号，如：&#39;1&#39;） --INSERT INTO &#96;sys_role&#96; VALUES (&#39;1&#39;, &#39;ROLE_ADMIN&#39;);INSERT INTO &#96;sys_role&#96; VALUES (&#39;2&#39;, &#39;ROLE_USER&#39;);INSERT INTO &#96;sys_user&#96; VALUES (&#39;1&#39;, &#39;admin&#39;, &#39;123&#39;);INSERT INTO &#96;sys_user&#96; VALUES (&#39;2&#39;, &#39;jitwxs&#39;, &#39;123&#39;);INSERT INTO &#96;sys_user_role&#96; VALUES (&#39;1&#39;, &#39;1&#39;);INSERT INTO &#96;sys_user_role&#96; VALUES (&#39;2&#39;, &#39;2&#39;);</code></pre></div><p>注意：权限格式为 <code>ROLE_XXX</code>，是 Spring Security 的规定。</p><h1 id="三、准备页面"><a href="#三、准备页面" class="headerlink" title="三、准备页面"></a>三、准备页面</h1><p>因为是示例程序，页面越简单越好，只用于登录的 <code>login.html</code> 以及用于登录成功后的 <code>home.html</code>，将其放置在 <code>resources/static</code> 目录下：</p><p>(1)login.html</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>欢迎来到登录页面<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>立即登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>注意：用户的登录认证是由 Spring Security 进行处理的，请求路径默认为 <code>/login</code>，用户名字段默认为 <code>username</code>，密码字段默认为 <code>password</code> 。</p><p>(2)home.html</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>欢迎回家<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>登录成功<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/admin"</span>&gt;</span>检测是否具有ROLE_ADMIN角色<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/user"</span>&gt;</span>检测是否具有ROLE_USER角色<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"window.location.href='/logout'"</span>&gt;</span>退出登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h1 id="四、配置-application-properties"><a href="#四、配置-application-properties" class="headerlink" title="四、配置 application.properties"></a>四、配置 application.properties</h1><p>在配置文件中配置下数据库连接：</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">root</span><span class="hljs-comment">#JDBC连接MySQL6 （com.mysql.cj.jdbc.Driver）， 需要指定时区serverTimezone，否则会报错</span><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/spring_security?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><span class="hljs-meta">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><span class="hljs-comment">#开启下划线转驼峰命令法</span><span class="hljs-meta">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="hljs-string">true</span></code></pre></div><h1 id="五、创建Model实体、Mapper、Service-和-Controller"><a href="#五、创建Model实体、Mapper、Service-和-Controller" class="headerlink" title="五、创建Model实体、Mapper、Service 和 Controller"></a>五、创建Model实体、Mapper、Service 和 Controller</h1><h2 id="5-1-Model"><a href="#5-1-Model" class="headerlink" title="5.1 Model"></a>5.1 Model</h2><p>(1)SysUser</p><div class="hljs"><pre><code class="hljs java">com.gavin.springsecuriity01.Model.SysUser    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysUser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-comment">//这里必须是name，与数据库对应，否则运行会报错</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-comment">// 省略getter/setter</span>&#125;</code></pre></div><p>(2)SysRole</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysRole</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-comment">// 省略getter/setter</span>&#125;</code></pre></div><p>(3)SysUserRole</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysUserRole</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-keyword">private</span> Integer userId;    <span class="hljs-keyword">private</span> Integer roleId;        <span class="hljs-comment">// 省略getter/setter</span>&#125;</code></pre></div><h2 id="5-2-Mapper"><a href="#5-2-Mapper" class="headerlink" title="5.2 Mapper"></a>5.2 Mapper</h2><p>(1)SysUserMapper</p><div class="hljs"><pre><code class="hljs java">com.gavin.springsecuriity01.Mapper.SysUserMapper<span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysUserMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_user WHERE id = #&#123;id&#125;"</span>)    <span class="hljs-function">SysUser <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_user WHERE name = #&#123;name&#125;"</span>)    <span class="hljs-function">SysUser <span class="hljs-title">selectByName</span><span class="hljs-params">(String name)</span></span>;&#125;</code></pre></div><p>(2)SysRoleMapper</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysRoleMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_role WHERE id = #&#123;id&#125;"</span>)    <span class="hljs-function">SysRole <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>;&#125;</code></pre></div><p>(3)SysUserRoleMapper</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysUserRoleMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_user_role WHERE user_id = #&#123;id&#125;"</span>)    <span class="hljs-function">List&lt;SysUserRole&gt; <span class="hljs-title">listByUserId</span><span class="hljs-params">(Integer userId)</span></span>; &#125;</code></pre></div><h2 id="5-3-Service"><a href="#5-3-Service" class="headerlink" title="5.3 Service"></a>5.3 Service</h2><p>(1)SysUserService</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysUserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysUserMapper sysUserMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> SysUser <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>&#123;        <span class="hljs-keyword">return</span> sysUserMapper.selectById(id);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> SysUser <span class="hljs-title">selectByName</span><span class="hljs-params">(String name)</span></span>&#123;        <span class="hljs-keyword">return</span> sysUserMapper.selectByName(name);    &#125;&#125;</code></pre></div><p>(2)SysRoleService</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysRoleService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysRoleMapper sysRoleMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> SysRole <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>&#123;        <span class="hljs-keyword">return</span> sysRoleMapper.selectById(id);    &#125;&#125;</code></pre></div><p>(3)SysUserRoleService</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysUserRoleService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysUserRoleMapper sysUserRoleMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;SysUserRole&gt; <span class="hljs-title">listByUserId</span><span class="hljs-params">(Integer userId)</span></span>&#123;        <span class="hljs-keyword">return</span> sysUserRoleMapper.listByUserId(userId);    &#125;&#125;</code></pre></div><h2 id="5-4-Controller"><a href="#5-4-Controller" class="headerlink" title="5.4 Controller"></a>5.4 Controller</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(LoginController<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">showHome</span><span class="hljs-params">()</span></span>&#123;        String name = SecurityContextHolder.getContext().getAuthentication().getName();        logger.info(<span class="hljs-string">"当前登录用户："</span>+name);        <span class="hljs-keyword">return</span> <span class="hljs-string">"home.html"</span>;    &#125;        <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/login"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">showLogin</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"login.html"</span>;    &#125;        <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/admin"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasRole('ROLE_ADMIN')"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">printAdmin</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"如果你看见这句话，说明你有ROLE_ADMIN角色"</span>;    &#125;        <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasRole('ROLE_USER')"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">printUser</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"如果你看见这句话，说明你有ROLE_USER角色"</span>;    &#125;&#125;</code></pre></div><ul><li>如代码所示，获取当前登录用户：<code>SecurityContextHolder.getContext().getAuthentication()</code></li><li><code>@PreAuthorize</code> 用于判断用户是否有指定权限，没有就不能访问</li></ul><h1 id="六、配置-SpringSecurity"><a href="#六、配置-SpringSecurity" class="headerlink" title="六、配置 SpringSecurity"></a>六、配置 SpringSecurity</h1><h2 id="6-1-UserDetailsService"><a href="#6-1-UserDetailsService" class="headerlink" title="6.1 UserDetailsService"></a>6.1 UserDetailsService</h2><p>首先我们需要自定义 <code>UserDetailsService</code> ，将用户信息和权限注入进来。</p><p>我们需要重写 <code>loadUserByUsername</code> 方法，参数是用户输入的用户名。返回值是<code>UserDetails</code>，这是一个接口，一般使用它的子类<code>org.springframework.security.core.userdetails.User</code>，它有三个参数，分别是用户名、密码和权限集。</p><blockquote><p>实际情况下，大多将 DAO 中的 User 类继承 <code>org.springframework.security.core.userdetails.User</code> 返回。</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>(<span class="hljs-string">"userDetailsService"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomUserDetailsService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysUserService sysUserService;        <span class="hljs-meta">@Autowired</span>    SysRoleService sysRoleService;        <span class="hljs-meta">@Autowired</span>    SysUserRoleService sysUserRoleService;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;        Collection&lt;GrantedAuthority&gt; authorities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();                <span class="hljs-comment">//从数据库中取出用户信息</span>        SysUser user = sysUserService.selectByName(username);                <span class="hljs-comment">//判断用户是否存在</span>        <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">"用户名不存在！！"</span>);        &#125;                <span class="hljs-comment">//如果用户存在，就添加权限给他</span>        List&lt;SysUserRole&gt; userRoles = sysUserRoleService.listByUserId(user.getId());        <span class="hljs-keyword">for</span>(SysUserRole userRole:userRoles)&#123;            SysRole role = sysRoleService.selectById(userRole.getRoleId());            authorities.add(<span class="hljs-keyword">new</span> SimpleGrantedAuthority(role.getName()));        &#125;        <span class="hljs-comment">//返回UserDetails的实现类</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(user.getName(),user.getPassword(),authorities);    &#125;&#125;</code></pre></div><h1 id="6-2-WebSecurityConfig"><a href="#6-2-WebSecurityConfig" class="headerlink" title="6.2 WebSecurityConfig"></a>6.2 WebSecurityConfig</h1><p>该类是 Spring Security 的配置类，该类的三个注解分别是标识该类是配置类、开启 Security 服务、开启全局 Securtiy 注解。</p><p>首先将我们自定义的 <code>userDetailsService</code> 注入进来，在 <code>configure()</code> 方法中使用 <code>auth.userDetailsService()</code> 方法替换掉默认的 userDetailsService。</p><p>这里我们还指定了密码的加密方式（5.0 版本强制要求设置），因为我们数据库是明文存储的，所以明文返回即可，如下所示：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="hljs-keyword">true</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    CustomUserDetailsService userDetailsService;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth.userDetailsService(userDetailsService).passwordEncoder(<span class="hljs-keyword">new</span> PasswordEncoder() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">encode</span><span class="hljs-params">(CharSequence rawPassword)</span> </span>&#123;                <span class="hljs-keyword">return</span> rawPassword.toString();            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(CharSequence rawPassword, String encodedPassword)</span> </span>&#123;                <span class="hljs-keyword">return</span> encodedPassword.equals(rawPassword.toString());            &#125;        &#125;);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//设置拦截忽略文件夹，可以对静态资源访问</span>        web.ignoring().antMatchers(<span class="hljs-string">"/css/**"</span>,<span class="hljs-string">"/js/**"</span>,<span class="hljs-string">"/css/**"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span><span class="hljs-comment">//                .antMatchers().permitAll()</span>                .anyRequest().authenticated()                .and()                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                .defaultSuccessUrl(<span class="hljs-string">"/"</span>).permitAll()                <span class="hljs-comment">// 自定义登录用户名和密码参数，默认为username和password</span><span class="hljs-comment">//                .usernameParameter("username")</span><span class="hljs-comment">//                .passwordParameter("password")</span>                .and()                .logout().permitAll();        <span class="hljs-comment">//关闭CRSF跨域</span>        http.csrf().disable();    &#125;&#125;</code></pre></div><h1 id="七、运行程序"><a href="#七、运行程序" class="headerlink" title="七、运行程序"></a>七、运行程序</h1><blockquote><p>ROLE_ADMIN 账户：用户名 <strong>admin</strong>，密码 <strong>123</strong><br>ROLE_USER 账户：用户名 <strong>jitwxs</strong>，密码 <strong>123</strong></p></blockquote><p>注：本系列文章来源于<a href="https://www.jitwxs.cn/categories/安全框架/Spring-Security/" target="_blank" rel="noopener">https://www.jitwxs.cn/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/Spring-Security/</a></p>]]></content>
    
    
    <categories>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
