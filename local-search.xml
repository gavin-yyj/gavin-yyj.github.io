<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>11. Redis--一致性Hash算法</title>
    <link href="/2020/06/06/11-Redis-%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95/"/>
    <url>/2020/06/06/11-Redis-%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Redis集群的使用"><a href="#一、Redis集群的使用" class="headerlink" title="一、Redis集群的使用"></a>一、Redis集群的使用</h1><p>我们在使用Redis的时候，为了保证Redis的高可用，提高Redis的读写性能，最简单的方式我们会做主从复制，组成Master-Master或者Master-Slave的形式，或者搭建Redis集群，进行数据的读写分离，类似于数据库的主从复制和读写分离。如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20200606181116231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>同样类似于数据库，当单表数据大于500W的时候需要对其进行分库分表，当数据量很大的时候（标准可能不一样，要看Redis服务器容量）我们同样可以对Redis进行类似的操作，就是分库分表。 </p><p>假设，我们有一个社交网站，需要使用Redis存储图片资源，存储的格式为键值对，key值为图片名称，value为该图片所在文件服务器的路径，我们需要根据文件名查找该文件所在文件服务器上的路径，数据量大概有2000W左右，按照我们约定的规则进行分库，规则就是随机分配，我们可以部署8台缓存服务器，每台服务器大概含有500W条数据，并且进行主从复制，示意图如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606181138961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>由于规则是随机的，所有我们的一条数据都有可能存储在任何一组Redis中，例如上图我们用户查找一张名称为”a.png”的图片，由于规则是随机的，我们不确定具体是在哪一个Redis服务器上的，因此我们需要进行1、2、3、4，4次查询才能够查询到（也就是遍历了所有的Redis服务器），这显然不是我们想要的结果，有了解过的小伙伴可能会想到，随机的规则不行，可以使用类似于数据库中的分库分表规则：按照Hash值、取模、按照类别、按照某一个字段值等等常见的规则就可以出来了！好，按照我们的主题，我们就使用Hash的方式。</p><h1 id="二、为Redis集群使用Hash"><a href="#二、为Redis集群使用Hash" class="headerlink" title="二、为Redis集群使用Hash"></a>二、为Redis集群使用Hash</h1><p><img src="https://img-blog.csdnimg.cn/20200606181214521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>上图中，假设我们查找的是”a.png”，由于有4台服务器（排除从库），因此公式为hash(a.png) % 4 = 2 ，可知定位到了第2号服务器，这样的话就不会遍历所有的服务器，大大提升了性能！</p><h1 id="三、使用Hash的问题"><a href="#三、使用Hash的问题" class="headerlink" title="三、使用Hash的问题"></a>三、使用Hash的问题</h1><p>上述的方式虽然提升了性能，我们不再需要对整个Redis服务器进行遍历！但是，使用上述Hash算法进行缓存时，会出现一些缺陷，主要体现在服务器数量变动的时候，所有缓存的位置都要发生改变！</p><p>试想一下，如果4台缓存服务器已经不能满足我们的缓存需求，那么我们应该怎么做呢？很简单，多增加几台缓存服务器不就行了！假设：我们增加了一台缓存服务器，那么缓存服务器的数量就由4台变成了5台。那么原本hash(a.png) % 4 = 2 的公式就变成了hash(a.png) % 5 = ？ ， 可想而知这个结果肯定不是2的，这种情况带来的结果就是当服务器数量变动时，所有缓存的位置都要发生改变！换句话说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端数据库请求数据（还记得上一篇的《缓存雪崩》吗？）！</p><p>同样的，假设4台缓存中突然有一台缓存服务器出现了故障，无法进行缓存，那么我们则需要将故障机器移除，但是如果移除了一台缓存服务器，那么缓存服务器数量从4台变为3台，也是会出现上述的问题！</p><p>所以，我们应该想办法不让这种情况发生，但是由于上述Hash算法本身的缘故，使用取模法进行缓存时，这种情况是无法避免的，为了解决这些问题，Hash一致性算法（一致性Hash算法）诞生了！</p><h1 id="四、一致性Hash算法的神秘面纱"><a href="#四、一致性Hash算法的神秘面纱" class="headerlink" title="四、一致性Hash算法的神秘面纱"></a>四、一致性Hash算法的神秘面纱</h1><p>一致性Hash算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性Hash算法是对232取模，什么意思呢？简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-232-1（即哈希值是一个32位无符号整形），整个哈希环如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606181226458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到232-1，也就是说0点左侧的第一个点代表232-1， 0和232-1在零点中方向重合，我们把这个由232个点组成的圆环称为Hash环。</p><p>下一步将各个服务器使用Hash进行一个哈希，具体可以选择<strong>服务器的IP或主机名</strong>作为<strong>关键字</strong>进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606181241661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！</p><p>例如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606181254463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>根据一致性Hash算法，数据A会被定位到Node A上，B被定位到Node B上，C被定位到Node C上，D被定位到Node D上。</p><h1 id="五、一致性Hash算法的容错性和可扩展性"><a href="#五、一致性Hash算法的容错性和可扩展性" class="headerlink" title="五、一致性Hash算法的容错性和可扩展性"></a>五、一致性Hash算法的容错性和可扩展性</h1><p>现假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。<strong>一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响</strong>，如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20200606181306101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>下面考虑另外一种情况，如果在系统中增加一台服务器Node X，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200606181318529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X ！一般的，在一致性Hash算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。</p><p>综上所述，一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="六、Hash环的数据倾斜问题"><a href="#六、Hash环的数据倾斜问题" class="headerlink" title="六、Hash环的数据倾斜问题"></a>六、Hash环的数据倾斜问题</h1><p>一致性Hash算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器，其环分布如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606181330666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器IP或主机名的后面增加编号来实现。</p><p>例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：</p><p><img src="https://img-blog.csdnimg.cn/20200606181342261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p><h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><p>上文中，我们一步步分析了什么是一致性Hash算法，主要是考虑到分布式系统每个节点都有可能失效，并且新的节点很可能动态的增加进来的情况，如何保证当系统的节点数目发生变化的时候，我们的系统仍然能够对外提供良好的服务，这是值得考虑的！</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0. Redis--引导</title>
    <link href="/2020/06/06/0-Redis-%E5%BC%95%E5%AF%BC/"/>
    <url>/2020/06/06/0-Redis-%E5%BC%95%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Redis简介"><a href="#一、Redis简介" class="headerlink" title="一、Redis简介"></a>一、Redis简介</h1><p>Redis是一个开源的<strong>内存中</strong>的数据结构存储系统，它可以用作：<strong>数据库</strong>、<strong>缓存</strong>和<strong>消息中间件</strong>。</p><p>它支持多种类型的数据结构，如字符串（String），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）与范围查询，Bitmaps，Hyperloglogs 和地理空间（Geospatial）索引半径查询。其中常见的数据结构类型有：<strong>String</strong>、<strong>List</strong>、<strong>Set</strong>、<strong>Hash</strong>、<strong>ZSet</strong>这5种。</p><p>Redis 内置了复制（Replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（Transactions） 和不同级别的磁盘持久化（Persistence），并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（High Availability）。</p><p>Redis也提供了持久化的选项，这些选项可以让用户将自己的数据保存到磁盘上面进行存储。根据实际情况，可以每隔一定时间将数据集导出到磁盘（快照），或者追加到命令日志中（AOF只追加文件），他会在执行写命令时，将被执行的写命令复制到硬盘里面。您也可以关闭持久化功能，将Redis作为一个高效的网络的缓存数据功能使用。</p><p>Redis不使用表，他的数据库不会预定义或者强制去要求用户对Redis存储的不同数据进行关联。</p><p>数据库的工作模式按存储方式可分为：硬盘数据库和内存数据库。Redis 将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度极快。</p><h1 id="二、Redis和其他缓存数据库的区别"><a href="#二、Redis和其他缓存数据库的区别" class="headerlink" title="二、Redis和其他缓存数据库的区别"></a>二、Redis和其他缓存数据库的区别</h1><h2 id="1-1-Redis-与其他-key-value-缓存产品相比有以下三个特点："><a href="#1-1-Redis-与其他-key-value-缓存产品相比有以下三个特点：" class="headerlink" title="1.1 Redis 与其他 key - value 缓存产品相比有以下三个特点："></a>1.1 Redis 与其他 key - value 缓存产品相比有以下三个特点：</h2><p>（1）Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</p><p>（2）Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</p><p>（3）Redis支持数据的备份，即master-slave模式的数据备份。</p><h2 id="1-2-Redis和Memcached的区别"><a href="#1-2-Redis和Memcached的区别" class="headerlink" title="1.2 Redis和Memcached的区别"></a>1.2 Redis和Memcached的区别</h2><p>Redis常被拿来和高性能键值缓存服务器Memcached进行对比：这两者都可以用来存储键值对，彼此的性能也相差无几，但是Redis相对支持更多的数据类型，除了支持键值对之外，还支持list，set，zset，hash等数据结构的存储，而Memcached只能存储普通的字符串键。</p><p>Memcached用户只能通过APPEND的方式将数据添加到已有的字符串的末尾，并将这个字符串当做列表来使用。但是在删除这些元素的时候，Memcached采用的是通过黑名单的方式来隐藏列表里的元素，从而避免了对元素的读取、更新、删除等操作。相反的Redis的List和Set允许用户直接添加和删除元素。</p><h2 id="1-3-Redis和其他数据库的区别"><a href="#1-3-Redis和其他数据库的区别" class="headerlink" title="1.3 Redis和其他数据库的区别"></a>1.3 Redis和其他数据库的区别</h2><p><img src="https://img-blog.csdnimg.cn/20200606171008448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="三、Redis为什么这么快"><a href="#三、Redis为什么这么快" class="headerlink" title="三、Redis为什么这么快"></a>三、Redis为什么这么快</h1><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p><p>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p><p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p><p>4、使用多路I/O复用模型，非阻塞IO；</p><p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p><p>以上几点都比较好理解，下边我们针对多路 I/O 复用模型进行简单的探讨：</p><p>（1）多路 I/O 复用模型</p><p>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p><p><strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong>采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p><h1 id="四、为什么Redis是单线程的"><a href="#四、为什么Redis是单线程的" class="headerlink" title="四、为什么Redis是单线程的"></a>四、为什么Redis是单线程的</h1><p>我们首先要明白，上边的种种分析，都是为了营造一个Redis很快的氛围！官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。</p><p>但是，我们使用单线程的方式是无法发挥多核CPU 性能，不过我们可以通过在单机开多个Redis 实例来完善！</p><p><strong>警告</strong>：这里我们一直在强调的单线程，只是在处理我们的网络请求的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！</p><h1 id="五、扩展"><a href="#五、扩展" class="headerlink" title="五、扩展"></a>五、扩展</h1><p>以下也是你应该知道的几种模型：</p><p>1、单进程多线程模型：MySQL、Memcached、Oracle（Windows版本）；</p><p>2、多进程模型：Oracle（Linux版本）；</p><p>3、Nginx有两类进程，一类称为Master进程(相当于管理进程)，另一类称为Worker进程（实际工作进程）。启动方式有两种：</p><p>（1）单进程启动：此时系统中仅有一个进程，该进程既充当Master进程的角色，也充当Worker进程的角色。</p><p>（2）多进程启动：此时系统有且仅有一个Master进程，至少有一个Worker进程工作。</p><p>（3）Master进程主要进行一些全局性的初始化工作和管理Worker的工作；事件处理是在Worker中进行的。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10. Redis--如何优化缓存架构</title>
    <link href="/2020/06/06/10-Redis-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84/"/>
    <url>/2020/06/06/10-Redis-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="一、为什么要用缓存集群"><a href="#一、为什么要用缓存集群" class="headerlink" title="一、为什么要用缓存集群"></a>一、为什么要用缓存集群</h1><p>啥叫热 Key 和大 Value 呢?简单来说，热 Key，就是你的缓存集群中的某个 Key 瞬间被数万甚至十万的并发请求打爆。</p><p>大 Value，就是你的某个 Key 对应的 Value 可能有 GB 级的大小，导致查询 Value 的时候出现网络相关的故障问题。</p><p>先来看看下面的一幅图：</p><p><img src="https://img-blog.csdnimg.cn/20200606162958479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>简单来说，假设你手头有个系统，他本身是集群部署的，然后后面有一套缓存集群，这个集群不管你用 Redis Cluster，还是Memcached，或者是公司自研缓存集群，都可以。</p><p>那么，这套系统用缓存集群干什么呢?很简单，在缓存里放一些平时不怎么变动的数据，然后用户在查询大量的平时不怎么变动的数据的时候，不就可以直接从缓存里走了吗?</p><p>缓存集群的并发能力是很强的，而且读缓存的性能是很高的。举个例子，假设你每秒有 2 万请求，但是其中 90% 都是读请求，那么每秒 1.8 万请求都是在读一些不太变化的数据，而不是写数据。</p><p>那此时你把数据都放在数据库里，然后每秒发送 2 万请求到数据库上读写数据，你觉得合适吗?</p><p>当然不太合适了，如果你要用数据库承载每秒 2 万请求的话，那么不好意思，你很可能就得搞分库分表 + 读写分离。</p><p>比如你得分 3 个主库，承载每秒 2000 的写入请求，然后每个主库挂 3 个从库，一共 9 个从库承载每秒 1.8 万的读请求。</p><p>这样的话，你可能就需要一共是 12 台高配置的数据库服务器，这是很耗费钱的，成本非常高，而且很不合适。</p><p>所以，此时你完全就可以把平时不太变化的数据放在缓存集群里，缓存集群可以采用 2 主 2 从，<strong>主节点用来写入缓存</strong>，<strong>从节点用来读缓存。</strong></p><p>以缓存集群的性能，2 个从节点完全可以用来承载每秒 1.8 万的大量读了，然后 3 个数据库主库就是承载每秒 2000 的写请求和少量其他读请求就可以了。</p><p>大家看看下面的图，你耗费的机器瞬间变成了 4 台缓存机器 + 3 台数据库机器 = 7 台机器，是不是比之前的 12 台机器减少了很大的资源开销?</p><p>没错，缓存其实在系统架构里是非常重要的组成部分。很多时候，对于那些很少变化但是大量高并发读的数据，通过<strong>缓存集群</strong>来抗高并发读，是非常合适的。</p><p><img src="https://img-blog.csdnimg.cn/20200606163024316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>这里所有的机器数量、并发请求量都是一个示例，大家主要是体会一下这个意思就好，其目的主要是给一些不太熟悉缓存相关技术的同学一点背景性的阐述，让这些同学能够理解在系统里用缓存集群承载读请求是什么意思。</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="二、20-万用户同时访问一个热点缓存的问题"><a href="#二、20-万用户同时访问一个热点缓存的问题" class="headerlink" title="二、20 万用户同时访问一个热点缓存的问题"></a>二、20 万用户同时访问一个热点缓存的问题</h1><p>好了，背景是已经给大家解释清楚了，那么现在就可以给大家说说今天重点要讨论的问题：热点缓存。</p><p>我们来做一个假设，你现在有 10 个缓存节点来抗大量的读请求。正常情况下，读请求应该是均匀的落在 10 个缓存节点上的，对吧!</p><p>这 10 个缓存节点，每秒承载 1 万请求是差不多的。然后我们再做一个假设，你一个节点承载 2 万请求是极限，所以一般你就限制一个节点正常承载 1 万请求就 OK 了，稍微留一点 Buffer 出来。</p><p>好，所谓的热点缓存问题是什么意思呢?很简单，就是突然因为莫名的原因，出现大量的用户访问同一条缓存数据。</p><p>举个例子，某个明星突然宣布跟某某结婚，这个时候是不是会引发可能短时间内每秒都是数十万的用户去查看这个明星跟某某结婚的那条新闻?</p><p>那么假设那条新闻就是一个缓存，然后对应就是一个缓存 Key，就存在一台缓存机器上，此时瞬时假设有 20 万请求奔向那一台机器上的一个 Key。</p><p>此时会如何?我们看看下面的图，来体会一下这种绝望的感受：</p><p><img src="https://img-blog.csdnimg.cn/20200606163209327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>这个时候很明显了，我们刚才假设的是一个缓存 Slave 节点最多每秒就是 2 万的请求，当然实际缓存单机承载 5 万~10 万读请求也是可能的，我们这里就是一个假设。</p><p>结果此时，每秒突然奔过来 20 万请求到这台机器上，会怎么样?很简单，上面图里那台被 20 万请求指向的缓存机器会过度操劳而宕机的。</p><p>那么如果缓存集群开始出现机器的宕机，此时会如何?接着，读请求发现读不到数据，会从数据库里提取原始数据，然后放入剩余的其他缓存机器里去。</p><p>但是接踵而来的每秒 20 万请求，会再次压垮其他的缓存机器。以此类推，最终导致缓存集群全盘崩溃，引发系统整体宕机。</p><p>咱们看看下面的图，再感受一下这个恐怖的现场：</p><p><img src="https://img-blog.csdnimg.cn/20200606163226832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="三、基于流式计算技术的缓存热点自动发现"><a href="#三、基于流式计算技术的缓存热点自动发现" class="headerlink" title="三、基于流式计算技术的缓存热点自动发现"></a>三、基于流式计算技术的缓存热点自动发现</h1><p>其实这里关键的一点，就是对于这种热点缓存，你的系统需要能够在热点缓存突然发生的时候，直接发现他，然后瞬间立马实现毫秒级的自动负载均衡。</p><p>那么我们就先来说说，你如何自动发现热点缓存问题?首先你要知道，一般出现缓存热点的时候，你的每秒并发肯定是很高的，可能每秒都几十万甚至上百万的请求量过来，这都是有可能的。</p><p>所以，此时完全可以基于大数据领域的流式计算技术来进行实时数据访问次数的统计，比如 Storm、Spark Streaming、Flink，这些技术都是可以的。</p><p>然后一旦在实时数据访问次数统计的过程中，比如发现一秒之内，某条数据突然访问次数超过了 1000，就直接立马把这条数据判定为是热点数据，可以将这个发现出来的热点数据写入比如 Zookeeper 中。</p><p>当然，你的系统如何判定热点数据，可以根据自己的业务还有经验值来就可以了。</p><p>大家看看下面这张图，看看整个流程是如何进行的：</p><p><img src="https://img-blog.csdnimg.cn/20200606163237932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>当然肯定有人会问，那你的流式计算系统在进行数据访问次数统计的时候，会不会也存在说单台机器被请求每秒几十万次的问题呢?</p><p>答案是否，因为流式计算技术，尤其是 Storm 这种系统，他可以做到同一条数据的请求过来，先分散在很多机器里进行本地计算，最后再汇总局部计算结果到一台机器进行全局汇总。</p><p>所以几十万请求可以先分散在比如 100 台机器上，每台机器统计了这条数据的几千次请求。</p><p>然后 100 条局部计算好的结果汇总到一台机器做全局计算即可，所以基于流式计算技术来进行统计是不会有热点问题的。</p><p><img src="https://img-blog.csdnimg.cn/2020060616325139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="四、热点缓存自动加载为-JVM-本地缓存"><a href="#四、热点缓存自动加载为-JVM-本地缓存" class="headerlink" title="四、热点缓存自动加载为 JVM 本地缓存"></a>四、热点缓存自动加载为 JVM 本地缓存</h1><p>我们自己的系统可以对 Zookeeper 指定的热点缓存对应的 Znode 进行监听，如果有变化他立马就可以感知到了。</p><p>此时系统层就可以立马把相关的缓存数据从数据库加载出来，然后直接放在自己系统内部的本地缓存里即可。</p><p>这个本地缓存，你用 Ehcache、Hashmap，其实都可以，一切都看自己的业务需求，主要说的就是将缓存集群里的集中式缓存，直接变成每个系统自己本地实现缓存即可，每个系统自己本地是无法缓存过多数据的。</p><p>因为一般这种普通系统单实例部署机器可能就一个 4 核 8G 的机器，留给本地缓存的空间是很少的，所以用来放这种热点数据的本地缓存是最合适的，刚刚好。</p><p>假设你的系统层集群部署了 100 台机器，那么好了，此时你 100 台机器瞬间在本地都会有一份热点缓存的副本。</p><p>然后接下来对热点缓存的读操作，直接系统本地缓存读出来就给返回了，不用再走缓存集群了。</p><p>这样的话，也不可能允许每秒 20 万的读请求到达缓存机器的一台机器上读一个热点缓存了，而是变成 100 台机器每台机器承载数千请求，那么那数千请求就直接从机器本地缓存返回数据了，这是没有问题的。</p><p>我们再来画一幅图，一起来看看这个过程：</p><p><img src="https://img-blog.csdnimg.cn/20200606163305719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="五、限流熔断保护"><a href="#五、限流熔断保护" class="headerlink" title="五、限流熔断保护"></a>五、限流熔断保护</h1><p>除此之外，在每个系统内部，还应该专门加一个对热点数据访问的限流熔断保护措施。</p><p>每个系统实例内部，都可以加一个熔断保护机制，假设缓存集群最多每秒承载4万读请求，那么你一共有 100 个系统实例。</p><p>你自己就该限制好，每个系统实例每秒最多请求缓存集群读操作不超过 400 次，一超过就可以熔断掉，不让请求缓存集群，直接返回一个空白信息，然后用户稍后会自行再次重新刷新页面之类的。</p><p>通过系统层自己直接加限流熔断保护措施，可以很好的保护后面的缓存集群、数据库集群之类的不要被打死，我们来看看下面的图：</p><p><img src="https://img-blog.csdnimg.cn/20200606163320488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9. Redis--Redis缓存问题</title>
    <link href="/2020/06/06/9-Redis-Redis%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/"/>
    <url>/2020/06/06/9-Redis-Redis%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><blockquote><p>咳咳，这一节内容应该早就放上博客的，一直忘记了，在写上一篇<a href="https://www.jitwxs.cn/dc21b1d2.html" target="_blank" rel="noopener">《详解布隆过滤器》</a>时，谈到缓存问题，一看博客中竟然没有写过相关的，实在是不该，特此补上。</p></blockquote><p>Redis 所存在的缓存问题也是大部分缓存所存在的问题，因此本文不单单特指于 Redis。这些问题包括<strong>缓存穿透、缓存雪崩、缓存击穿、缓存预热</strong>等等，相关文章网络上已经数不胜数了，说实话本文和它们没啥不同之处，只是为了记录，所以对于了解过的人基本就是废话了，谨慎阅读哦。</p><h2 id="二、缓存穿透"><a href="#二、缓存穿透" class="headerlink" title="二、缓存穿透"></a>二、缓存穿透</h2><p><strong>问题描述：</strong></p><p><code>缓存穿透</code>是指<strong>查询一个一定不存在的数据</strong>，这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p><p><strong>解决方案：</strong></p><p>有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用<code>布隆过滤器</code>，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被 这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</p><p>另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。</p><p><img src="https://img-blog.csdnimg.cn/20200606160601704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="三、缓存雪崩"><a href="#三、缓存雪崩" class="headerlink" title="三、缓存雪崩"></a>三、缓存雪崩</h2><p><strong>问题描述：</strong></p><p><code>缓存雪崩</code>是指在我们<strong>设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效</strong>，请求全部转发到DB，DB瞬时压力过重雪崩。</p><p>缓存正常从Redis中获取，示意图如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606164835761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>缓存失效瞬间示意图如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606164842618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>解决方案：</strong></p><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者<strong>考虑用加锁或者队列的方式保证缓存的单线程（进程）写</strong>，从而避免失效时大量的并发请求落到底层存储系统上。</p><p>还可以将缓存失效时间分散开，比如我们可以<strong>在原有的失效时间基础上增加一个随机值</strong>，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><h2 id="四、缓存击穿"><a href="#四、缓存击穿" class="headerlink" title="四、缓存击穿"></a>四、缓存击穿</h2><p><strong>问题描述：</strong></p><p>对于一些设置了过期时间的 key，如果这些 key 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个<strong>和缓存雪崩的区别在于这里针对某一 key 缓存，而缓存雪崩则是很多 key</strong>。</p><p>缓存在某个时间点过期的时候，恰好在这个时间点对这个 key 有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮。</p><p><strong>解决方案：</strong></p><p>业界比较常用的做法，是使用互斥锁(mutex)。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去 load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的 <code>SETNX</code> 或者 Memcache 的 ADD）去 set 一个 mutex key，当操作返回成功时，再进行 load db 的操作并回设缓存；否则，就重试整个 get 缓存的方法。</p><h2 id="五、缓存预热"><a href="#五、缓存预热" class="headerlink" title="五、缓存预热"></a>五、缓存预热</h2><p><strong>问题描述：</strong></p><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p><p><strong>解决方案：</strong></p><ol><li>直接写个缓存刷新页面，上线时手工操作下；</li><li>数据量不大，可以在项目启动的时候自动进行加载；</li><li>定时刷新缓存；</li></ol><h2 id="六、缓存更新"><a href="#六、缓存更新" class="headerlink" title="六、缓存更新"></a>六、缓存更新</h2><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p><p>（1）定时去清理过期的缓存；</p><p>（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</p><p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p><h2 id="七、缓存降级"><a href="#七、缓存降级" class="headerlink" title="七、缓存降级"></a>七、缓存降级</h2><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p><p><strong>降级的最终目的是保证核心服务可用</strong>，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。 </p><p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p><p>（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p><p>（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p><p>（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</p><p>（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8. Redis--Redis的实际应用</title>
    <link href="/2020/06/06/8-Redis-Redis%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
    <url>/2020/06/06/8-Redis-Redis%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>在<a href="https://www.jitwxs.cn/5108d6b6.html" target="_blank" rel="noopener">《Redis初探（7）——Jedis操纵集群》</a>中，我们已经学会了搭建 Redis 集群，以及使用策略模式，在xml文件中灵活切换单机版和集群版。</p><p>本章将演示在宜立方商城项目中使用 Redis，项目地址：<a href="https://github.com/jitwxs/e3mall" target="_blank" rel="noopener">e3mall</a>。</p><h2 id="一、功能需求"><a href="#一、功能需求" class="headerlink" title="一、功能需求"></a>一、功能需求</h2><p>商城首页访问量巨大，因为首页的大轮播图是从数据库查询获取的，<strong>每次访问都要查询一次数据库</strong>，数据库压力巨大，亟需缓存。</p><p><img src="https://img-blog.csdnimg.cn/20200606160145616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="二、功能实现"><a href="#二、功能实现" class="headerlink" title="二、功能实现"></a>二、功能实现</h2><p>实现之前首先思考 Redis 是要加在 Service 层还是 Web 层。理论上来说都可以，但是加在 Web 层的话，其他 Web 去调用 Service 还是得去查数据库，因此我们加在 Service 层。</p><p>其次思考使用什么数据类型，我们使用<strong>哈希类型</strong>，field 为类别的 id，value 为对应查询的查询内容。</p><h3 id="2-1-配置文件-cfg-properties"><a href="#2-1-配置文件-cfg-properties" class="headerlink" title="2.1 配置文件 cfg.properties"></a>2.1 配置文件 cfg.properties</h3><p>首先在配置文件中加入 Redis 相关的信息，最后一项 <code>redis.CONTENT_KEY</code> 为我们首页轮播图缓存的 key 值：</p><div class="hljs"><pre><code class="hljs ini">COPY#Redis单机<span class="hljs-attr">redis.standalone.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.standalone.port</span>=<span class="hljs-number">6379</span><span class="hljs-comment">#Redis集群</span><span class="hljs-attr">redis.cluster.01.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.01.port</span>=<span class="hljs-number">7001</span><span class="hljs-attr">redis.cluster.02.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.02.port</span>=<span class="hljs-number">7002</span><span class="hljs-attr">redis.cluster.03.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.03.port</span>=<span class="hljs-number">7003</span><span class="hljs-attr">redis.cluster.04.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.04.port</span>=<span class="hljs-number">7004</span><span class="hljs-attr">redis.cluster.05.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.05.port</span>=<span class="hljs-number">7005</span><span class="hljs-attr">redis.cluster.06.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.06.port</span>=<span class="hljs-number">7006</span><span class="hljs-comment">#Redis key相关</span><span class="hljs-comment">#用于存放tb_content表的缓存（哈希类型）</span><span class="hljs-attr">redis.CONTENT_KEY</span>=CONTENT_KEY</code></pre></div><h3 id="2-2-Spring-中-Redis-配置"><a href="#2-2-Spring-中-Redis-配置" class="headerlink" title="2.2 Spring 中 Redis 配置"></a>2.2 Spring 中 Redis 配置</h3><p>这里的代码在上一节已经说过了，因为我们是开发环境，使用单机版即可。</p><div class="hljs"><pre><code class="hljs xml">COPY<span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context</span></span><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 注意：单机和集群同时只能放开一个 --&gt;</span>    <span class="hljs-comment">&lt;!-- 加载配置文件 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:cfg.properties"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 配置Redis单机 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jedisClientPool"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"jit.wxs.common.jedis.JedisClientPool"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"jedisPool"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"jedisPool"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jedisPool"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.JedisPool"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.standalone.host&#125;"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.standalone.port&#125;"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置Redis集群 --&gt;</span>    <span class="hljs-comment">&lt;!--&lt;bean id="jedisClientCluster" class="jit.wxs.common.jedis.JedisClientCluster"&gt;--&gt;</span>        <span class="hljs-comment">&lt;!--&lt;property name="jedisCluster" ref="jedisCluster"/&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--&lt;bean id="jedisCluster" class="redis.clients.jedis.JedisCluster"&gt;--&gt;</span>        <span class="hljs-comment">&lt;!--&lt;constructor-arg&gt;--&gt;</span>            <span class="hljs-comment">&lt;!--&lt;set&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;bean class="redis.clients.jedis.HostAndPort"&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="host" value="$&#123;redis.cluster.01.host&#125;"/&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="port" value="$&#123;redis.cluster.01.port&#125;"/&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;bean class="redis.clients.jedis.HostAndPort"&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="host" value="$&#123;redis.cluster.02.host&#125;"/&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="port" value="$&#123;redis.cluster.02.port&#125;"/&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;bean class="redis.clients.jedis.HostAndPort"&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="host" value="$&#123;redis.cluster.03.host&#125;"/&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="port" value="$&#123;redis.cluster.03.port&#125;"/&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;bean class="redis.clients.jedis.HostAndPort"&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="host" value="$&#123;redis.cluster.04.host&#125;"/&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="port" value="$&#123;redis.cluster.04.port&#125;"/&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;bean class="redis.clients.jedis.HostAndPort"&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="host" value="$&#123;redis.cluster.05.host&#125;"/&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="port" value="$&#123;redis.cluster.05.port&#125;"/&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;bean class="redis.clients.jedis.HostAndPort"&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="host" value="$&#123;redis.cluster.06.host&#125;"/&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="port" value="$&#123;redis.cluster.06.port&#125;"/&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span>            <span class="hljs-comment">&lt;!--&lt;/set&gt;--&gt;</span>        <span class="hljs-comment">&lt;!--&lt;/constructor-arg&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><h3 id="2-3-Service-层代码"><a href="#2-3-Service-层代码" class="headerlink" title="2.3 Service 层代码"></a>2.3 Service 层代码</h3><p>首先我们注入了 <code>JedisClient</code>，然后从配置文件取到了 key 的名字 <code>CONTENT_KEY</code>。</p><p>在 <code>listByCategoryId()</code> 方法中，我们先查询 Redis 中是否有存在的 field，如果有，直接返回；如果没有，先查询数据库，然后存入缓存。</p><p>为了<strong>保证缓存的同步</strong>，在添加和删除方法中，我直接删除掉了相应 field 的缓存，这样当执行查询方法时，会重新保存缓存。</p><p>需要注意的是，<strong>Redis 的正常/异常与否，不应当影响程序的正常运行</strong>。因为即使没有 Redis 程序也是可以正常运行的，因此我们在 Redis 操作的地方，需要 <code>try-catch</code>，在 catch 中可以打印日志信息等操作，我这里只是简单的输出在控制台。</p><blockquote><p>注：JedisClient 接口和其单机/集群实现类代码省略，需要请看上一节。</p></blockquote><div class="hljs"><pre><code class="hljs java">COPY<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TbContentServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceImpl</span>&lt;<span class="hljs-title">TbContentMapper</span>, <span class="hljs-title">TbContent</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">TbContentService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> TbContentMapper contentMapper;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> JedisClient jedisClient;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;redis.CONTENT_KEY&#125;"</span>)    <span class="hljs-keyword">private</span> String CONTENT_KEY;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除CONTENT_KEY中指定field</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteContentKeyFromRedis</span><span class="hljs-params">(Long cid)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            jedisClient.hdel(CONTENT_KEY, cid + <span class="hljs-string">""</span>);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;TbContent&gt; <span class="hljs-title">listByCategoryId</span><span class="hljs-params">(Long cid)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 如果缓存存在的话，直接从缓存中取</span>            String json = jedisClient.hget(CONTENT_KEY, cid + <span class="hljs-string">""</span>);            <span class="hljs-keyword">if</span>(StringUtils.isNotBlank(json)) &#123;                <span class="hljs-keyword">return</span> JsonUtils.jsonToList(json, TbContent<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        List&lt;TbContent&gt; contents = contentMapper.selectList(<span class="hljs-keyword">new</span> EntityWrapper&lt;TbContent&gt;() .eq(<span class="hljs-string">"category_id"</span>, cid));        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 加入缓存</span>            jedisClient.hset(CONTENT_KEY, cid+<span class="hljs-string">""</span>, JsonUtils.objectToJson(contents));        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> contents;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addContent</span><span class="hljs-params">(TbContent tbContent)</span> </span>&#123;        <span class="hljs-comment">// 更新缓存</span>        deleteContentKeyFromRedis(tbContent.getCategoryId());        tbContent.setCreated(<span class="hljs-keyword">new</span> Date());        tbContent.setUpdated(<span class="hljs-keyword">new</span> Date());                contentMapper.insert(tbContent);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteById</span><span class="hljs-params">(Long id)</span> </span>&#123;        <span class="hljs-keyword">if</span>(id == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 更新缓存</span>        TbContent tbContent = contentMapper.selectById(id);        deleteContentKeyFromRedis(tbContent.getCategoryId());        contentMapper.deleteById(id);    &#125;&#125;</code></pre></div><h3 id="2-4-Web-层代码"><a href="#2-4-Web-层代码" class="headerlink" title="2.4 Web 层代码"></a>2.4 Web 层代码</h3><p>我们设首页轮播图的 id 为 <code>ad1Id</code>，直接调用 <code>tbContentService.listByCategoryId(ad1Id)</code> 即可。</p><div class="hljs"><pre><code class="hljs java">COPY<span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageController</span> </span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;ad1.id&#125;"</span>)    <span class="hljs-keyword">private</span> Long ad1Id;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> TbContentService tbContentService;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/index"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">showIndex</span><span class="hljs-params">(Model model)</span> </span>&#123;        <span class="hljs-comment">// 得到首页大轮播图的List</span>        List&lt;TbContent&gt; ad1List = tbContentService.listByCategoryId(ad1Id);        model.addAttribute(<span class="hljs-string">"ad1List"</span>, ad1List);        <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;    &#125;&#125;</code></pre></div><h2 id="三、验证"><a href="#三、验证" class="headerlink" title="三、验证"></a>三、验证</h2><p>服务器启动单机版 Redis，当我们刷新首页的时候，就会将缓存保存到了 Redis 中。</p><p>Key 为 <code>CONTENT_KEY</code>，field 目前只有一个，即首页轮播图，其值为89，value 为转换为 json 的数据：</p><p><img src="https://img-blog.csdnimg.cn/2020060616020848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>当我在后台为首页添加一个轮播图后，该 Field 被删除掉了（这里之所以连 key 也被删掉了，是因为该 key 中只有一个field，因此唯一的 field 被删掉了，key 也就删掉了）：</p><div class="hljs"><pre><code class="hljs shell">COPY127.0.0.1:6379&gt; keys *(empty list or set)</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200606160231372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>重新刷新首页，正确显示三张：</p><p><img src="https://img-blog.csdnimg.cn/2020060616025755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>再次查看 Redis：</p><p><img src="https://img-blog.csdnimg.cn/20200606160316730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7. Redis--Redis操纵集群</title>
    <link href="/2020/06/06/7-Redis-Redis%E6%93%8D%E7%BA%B5%E9%9B%86%E7%BE%A4/"/>
    <url>/2020/06/06/7-Redis-Redis%E6%93%8D%E7%BA%B5%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<p>在<a href="https://www.jitwxs.cn/baef2507.html" target="_blank" rel="noopener">《Redis 初探（2）——Jedis 的使用》</a>中，我们已经学会了Jedis操纵单机Redis的简单使用，本章将继续深入，介绍Jedis对集群的操纵。</p><h2 id="一、Jedis-连接单机"><a href="#一、Jedis-连接单机" class="headerlink" title="一、Jedis 连接单机"></a>一、Jedis 连接单机</h2><p>在开始介绍 Jedis 连接集群之前，先简单回顾下连接单机的使用。</p><h3 id="1-1-简单使用"><a href="#1-1-简单使用" class="headerlink" title="1.1 简单使用"></a>1.1 简单使用</h3><div class="hljs"><pre><code class="hljs java">COPY<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJedis</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 1.获得连接对象。参数为redis所在的服务器地址及端口号</span>    Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">6379</span>);    <span class="hljs-comment">// 2.获得数据</span>    String age = jedis.get(<span class="hljs-string">"age"</span>);    System.out.println(age);    jedis.close();&#125;</code></pre></div><h3 id="1-2-使用连接池"><a href="#1-2-使用连接池" class="headerlink" title="1.2 使用连接池"></a>1.2 使用连接池</h3><div class="hljs"><pre><code class="hljs java">COPY<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJedisPool</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//1. 创建Jedis连接池配置（包含许多配置，这里只配置了3个）</span>    JedisPoolConfig poolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();    <span class="hljs-comment">// 设置最小和最大闲置个数</span>    poolConfig.setMinIdle(<span class="hljs-number">5</span>);    poolConfig.setMaxIdle(<span class="hljs-number">10</span>);    <span class="hljs-comment">// 设置连接池最大个数</span>    poolConfig.setMaxTotal(<span class="hljs-number">30</span>);    <span class="hljs-comment">//2. 创建Jedis连接池</span>    JedisPool pool = <span class="hljs-keyword">new</span> JedisPool(poolConfig,<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">6379</span>);    <span class="hljs-comment">//3. 从连接池中获取Jedis对象</span>    Jedis jedis = pool.getResource();    <span class="hljs-comment">//4.操纵数据</span>    jedis.set(<span class="hljs-string">"sex"</span>, <span class="hljs-string">"male"</span>);    System.out.println(jedis.get(<span class="hljs-string">"sex"</span>));    <span class="hljs-comment">//5.关闭资源</span>    jedis.close();    pool.close();&#125;</code></pre></div><h2 id="二、Jedis-连接集群"><a href="#二、Jedis-连接集群" class="headerlink" title="二、Jedis 连接集群"></a>二、Jedis 连接集群</h2><p>Jedis 连接集群也是十分简单，首先创建一个 <code>HostAndPort</code> 的集合，里面存放着集群中的每一个节点，然后创建 <code>JedisCluster</code> 对象，直接操纵该对象即可。</p><p><code>JedisCluster</code> 在项目中<strong>单例存在</strong>即可。第三步的关闭可省略（因为单例存在，如果关掉了，即整个项目要结束了）。</p><div class="hljs"><pre><code class="hljs java">COPY<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJedisCluster</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">// 1.创建一个JedisCluster对象。第一个参数nodes是一个set类型，set中包含若干个HostAndPort对象</span>    Set&lt;HostAndPort&gt; nodes = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    nodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">7001</span>));    nodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">7002</span>));    nodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">7003</span>));    nodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">7004</span>));    nodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">7005</span>));    nodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">7006</span>));    JedisCluster cluster = <span class="hljs-keyword">new</span> JedisCluster(nodes);    <span class="hljs-comment">// 2.直接使用JedisCluster对象操作redis，单例存在即可。</span>    cluster.set(<span class="hljs-string">"test"</span>, <span class="hljs-string">"123"</span>);    System.out.println(cluster.get(<span class="hljs-string">"test"</span>));    <span class="hljs-comment">// 3.关闭JedisCluster对象。</span>    cluster.close();&#125;</code></pre></div><h2 id="三、Jedis-的实际应用"><a href="#三、Jedis-的实际应用" class="headerlink" title="三、Jedis 的实际应用"></a>三、Jedis 的实际应用</h2><p>在实际项目中，测试环境一般使用单机版，生产环境使用集群版。为了避免代码的不必要改动，我们使用<code>策略模式</code>，<code>面向接口开发</code>。</p><h3 id="3-1-JedisClient-接口"><a href="#3-1-JedisClient-接口" class="headerlink" title="3.1 JedisClient 接口"></a>3.1 JedisClient 接口</h3><p>定义一个 <code>JedisClient</code> 的接口，里面封装了常用的一些方法，主要是对 <code>String</code> 类型和 <code>Hash</code> 类型的操作，可以根据实际情况进行修改。</p><div class="hljs"><pre><code class="hljs java">COPYimport java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">JedisClient</span> </span>&#123;    <span class="hljs-function">String <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span></span>;    <span class="hljs-function">String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span></span>;    <span class="hljs-function">Boolean <span class="hljs-title">exists</span><span class="hljs-params">(String key)</span></span>;    <span class="hljs-function">Long <span class="hljs-title">expire</span><span class="hljs-params">(String key, <span class="hljs-keyword">int</span> seconds)</span></span>;    <span class="hljs-function">Long <span class="hljs-title">ttl</span><span class="hljs-params">(String key)</span></span>;    <span class="hljs-function">Long <span class="hljs-title">incr</span><span class="hljs-params">(String key)</span></span>;    <span class="hljs-function">Long <span class="hljs-title">hset</span><span class="hljs-params">(String key, String field, String value)</span></span>;    <span class="hljs-function">String <span class="hljs-title">hget</span><span class="hljs-params">(String key, String field)</span></span>;    <span class="hljs-function">Long <span class="hljs-title">hdel</span><span class="hljs-params">(String key, String... field)</span></span>;    <span class="hljs-function">Boolean <span class="hljs-title">hexists</span><span class="hljs-params">(String key, String field)</span></span>;    <span class="hljs-function">List&lt;String&gt; <span class="hljs-title">hvals</span><span class="hljs-params">(String key)</span></span>;    <span class="hljs-function">Long <span class="hljs-title">del</span><span class="hljs-params">(String key)</span></span>;&#125;</code></pre></div><h3 id="3-2-单机实现类"><a href="#3-2-单机实现类" class="headerlink" title="3.2 单机实现类"></a>3.2 单机实现类</h3><div class="hljs"><pre><code class="hljs java">COPYimport java.util.List;<span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<span class="hljs-keyword">import</span> redis.clients.jedis.JedisPool;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisClientPool</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">JedisClient</span> </span>&#123;        <span class="hljs-keyword">private</span> JedisPool jedisPool;    <span class="hljs-function"><span class="hljs-keyword">public</span> JedisPool <span class="hljs-title">getJedisPool</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisPool;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setJedisPool</span><span class="hljs-params">(JedisPool jedisPool)</span> </span>&#123;        <span class="hljs-keyword">this</span>.jedisPool = jedisPool;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        String result = jedis.set(key, value);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        String result = jedis.get(key);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">exists</span><span class="hljs-params">(String key)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Boolean result = jedis.exists(key);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">expire</span><span class="hljs-params">(String key, <span class="hljs-keyword">int</span> seconds)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Long result = jedis.expire(key, seconds);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">ttl</span><span class="hljs-params">(String key)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Long result = jedis.ttl(key);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">incr</span><span class="hljs-params">(String key)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Long result = jedis.incr(key);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">hset</span><span class="hljs-params">(String key, String field, String value)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Long result = jedis.hset(key, field, value);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hget</span><span class="hljs-params">(String key, String field)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        String result = jedis.hget(key, field);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">hdel</span><span class="hljs-params">(String key, String... field)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Long result = jedis.hdel(key, field);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">hexists</span><span class="hljs-params">(String key, String field)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Boolean result = jedis.hexists(key, field);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">hvals</span><span class="hljs-params">(String key)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        List&lt;String&gt; result = jedis.hvals(key);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">del</span><span class="hljs-params">(String key)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Long result = jedis.del(key);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre></div><h3 id="3-3-集群实现类"><a href="#3-3-集群实现类" class="headerlink" title="3.3 集群实现类"></a>3.3 集群实现类</h3><div class="hljs"><pre><code class="hljs java">COPYimport java.util.List;<span class="hljs-keyword">import</span> redis.clients.jedis.JedisCluster;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisClientCluster</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">JedisClient</span> </span>&#123;        <span class="hljs-keyword">private</span> JedisCluster jedisCluster;        <span class="hljs-function"><span class="hljs-keyword">public</span> JedisCluster <span class="hljs-title">getJedisCluster</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setJedisCluster</span><span class="hljs-params">(JedisCluster jedisCluster)</span> </span>&#123;        <span class="hljs-keyword">this</span>.jedisCluster = jedisCluster;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.set(key, value);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.get(key);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">exists</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.exists(key);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">expire</span><span class="hljs-params">(String key, <span class="hljs-keyword">int</span> seconds)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.expire(key, seconds);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">ttl</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.ttl(key);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">incr</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.incr(key);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">hset</span><span class="hljs-params">(String key, String field, String value)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.hset(key, field, value);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hget</span><span class="hljs-params">(String key, String field)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.hget(key, field);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">hdel</span><span class="hljs-params">(String key, String... field)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.hdel(key, field);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">hexists</span><span class="hljs-params">(String key, String field)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.hexists(key, field);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">hvals</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.hvals(key);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">del</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.del(key);    &#125;&#125;</code></pre></div><h3 id="3-4-实战演示"><a href="#3-4-实战演示" class="headerlink" title="3.4 实战演示"></a>3.4 实战演示</h3><p>（1）首先准备一个配置文件 <code>cfg.properties</code>，在配置文件中加入关于 redis 的信息：</p><div class="hljs"><pre><code class="hljs ini">COPY# redis单机<span class="hljs-attr">redis.standalone.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.standalone.port</span>=<span class="hljs-number">6379</span><span class="hljs-comment">#redis集群</span><span class="hljs-attr">redis.cluster.01.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.01.port</span>=<span class="hljs-number">7001</span><span class="hljs-attr">redis.cluster.02.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.02.port</span>=<span class="hljs-number">7002</span><span class="hljs-attr">redis.cluster.03.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.03.port</span>=<span class="hljs-number">7003</span><span class="hljs-attr">redis.cluster.04.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.04.port</span>=<span class="hljs-number">7004</span><span class="hljs-attr">redis.cluster.05.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.05.port</span>=<span class="hljs-number">7005</span><span class="hljs-attr">redis.cluster.06.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.06.port</span>=<span class="hljs-number">7006</span></code></pre></div><p>（2）准备 Spring 关于 redis 的配置文件 <code>applicationContext-redis.xml</code>：</p><p>需要注意的是，单机和集群同时<strong>只能放开一个，另一个必须注释掉</strong>。因为我们取Bean是取接口，即 <code>JedisClient</code>，这两个都是 <code>JedisClient</code> 的实现类。</p><div class="hljs"><pre><code class="hljs xml">COPY<span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="hljs-tag"><span class="hljs-string">    http://www.springframework.org/schema/context</span></span><span class="hljs-tag"><span class="hljs-string">    http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 注意：单机和集群同时只能放开一个 --&gt;</span>    <span class="hljs-comment">&lt;!-- 加载配置文件 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:cfg.properties"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 配置Redis单机 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jedisClientPool"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"jit.wxs.common.jedis.JedisClientPool"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"jedisPool"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"jedisPool"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jedisPool"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.JedisPool"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.standalone.host&#125;"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.standalone.port&#125;"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置Redis集群 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jedisClientCluster"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"jit.wxs.common.jedis.JedisClientCluster"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"jedisCluster"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"jedisCluster"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jedisCluster"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.JedisCluster"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.HostAndPort"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.01.host&#125;"</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.01.port&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.HostAndPort"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.02.host&#125;"</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.02.port&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.HostAndPort"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.03.host&#125;"</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.03.port&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.HostAndPort"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.04.host&#125;"</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.04.port&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.HostAndPort"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.05.host&#125;"</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.05.port&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.HostAndPort"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.06.host&#125;"</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.06.port&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>（3）编写测试方法</p><div class="hljs"><pre><code class="hljs java">COPY<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    ApplicationContext ac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:applicationContext-redis.xml"</span>);    JedisClient jedisClient = ac.getBean(JedisClient<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    jedisClient.set(<span class="hljs-string">"author"</span>, <span class="hljs-string">"jitwxs"</span>);    String result = jedisClient.get(<span class="hljs-string">"author"</span>);    System.out.println(result);&#125;</code></pre></div><p>因为我们是面向接口开发，因此当我们切换单机和集群时，这段代码不需要任何修改，只需要修改配置文件即可。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6. Redis--Redis集群</title>
    <link href="/2020/06/06/6-Redis-Redis%E9%9B%86%E7%BE%A4/"/>
    <url>/2020/06/06/6-Redis-Redis%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<p>之前我们所学习的都是 Redis 的单机版，我们知道 Redis 之所以读取速度快是因为它是<strong>存储在内存</strong>中的。内存的容量是有限的，单台 Redis 会碰到性能瓶颈，这就需要使用 <code>Redis集群（Redis-cluster）</code>。</p><h2 id="一、集群原理"><a href="#一、集群原理" class="headerlink" title="一、集群原理"></a>一、集群原理</h2><h3 id="1-1-集群架构"><a href="#1-1-集群架构" class="headerlink" title="1.1 集群架构"></a>1.1 集群架构</h3><p><img src="https://img-blog.csdnimg.cn/20200606125039833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>如上图所示，每一个蓝色圆圈就是一个 Redis 节点，这些节点组成了一个 <code>Redis集群（Redis-cluster）</code>。节点之间使用 <code>Ping——Pong</code> 机制进行互联，其内部用二进制协议优化传输速度和带宽。</p><p>Redis客户端和节点<strong>直接连接</strong>即可，无需中间件，一台客户端连接一个节点即可，Client 访问时直接访问任意一个Redis节点即可。</p><h3 id="1-2-负载均衡"><a href="#1-2-负载均衡" class="headerlink" title="1.2 负载均衡"></a>1.2 负载均衡</h3><p>当我们搭建了集群后，其是如何实现负载均衡的呢？</p><p>Redis 集群中内置了 <strong>16384</strong> 个<code>哈希槽（slot）</code>，它会把所有的物理节点都映射到<strong>[0,16383]</strong>的slot上。</p><p>当我们需要在Redis集群中放置了个 key-value 时，Redis 先对 key 使用 <code>crc16</code> 算法得出一个结果，然后将结果<strong>对16384取余</strong>，这样<strong>每一个 key 都会对应一个编号在0 ~16383的 哈希槽</strong>。</p><p>Redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。例如我们有三个节点，其每个节点哈希槽范围为：0 ~ 5000，5001 ~ 10000，10001~ 16383。</p><p><img src="https://img-blog.csdnimg.cn/20200606130442462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>当我们存储一个名为 Hello1 的 key 时，其通过 <code>crc16</code> 算法计算出的结果为1500，Redis 集群就会将这个 key 放在对应1500的<code>哈希槽</code>中，又因为哈希槽0~ 5000被映射到了 Server1，则 Hello1 就被放置在了 Server1。</p><p><img src="https://img-blog.csdnimg.cn/2020060613054833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="1-3-容错机制"><a href="#1-3-容错机制" class="headerlink" title="1.3 容错机制"></a>1.3 容错机制</h3><p>通过上面的负载均衡的原理，知道其实<strong>每一台</strong> Redis 客户端保存的<strong>内容都是不一样</strong>的，那么当Redis集群中<strong>任意一个节点挂掉</strong>（连接失败）时，<strong>整个集群就挂了</strong>。</p><p>为了实现 Redis 的高可用，需要<strong>为每一个节点添加备用机</strong>，即<code>主备机制</code>。</p><p>一般集群都有集群管理工具，但是 Redis 集群没有，它是通过<code>投票机制</code>来实现的。</p><p>以下图为例简单说一下投票机制：</p><ol><li>当黄色节点发现无法 ping 通红色节点，它就觉得红色节点可能挂掉了，于是它会<strong>发起投票</strong>。</li><li>其他节点会尝试去 ping 红色节点，只要有<strong>超过半数</strong>的节点无法 ping 通红色节点，就<strong>判定红色节点挂掉</strong>（即使它实际上可能并没有挂掉）。</li><li>当红色节点被判定挂掉后，会<strong>启动该节点的备用机</strong>。如果该节点不存在备用机，或备用机也挂掉，那么<strong>整个Redis集群就挂掉了</strong>。</li></ol><p><img src="https://www.jitwxs.cn/images/posts/20180408222553762.png" srcset="/img/loading.gif" alt="img"></p><h2 id="二、搭建集群"><a href="#二、搭建集群" class="headerlink" title="二、搭建集群"></a>二、搭建集群</h2><blockquote><p>说明：在实际项目中，搭建集群都是搞运维的负责的，如果是专门的研发人员，其实可以不用知道如何搭建集群。</p></blockquote><p>Redis 集群为了实现容错机制，<strong>最少需要三个节点</strong>（一个出错，另外两个投票），又因为<strong>每个节点至少要有一台备份机</strong>，因此一个<strong>最简单的 Redis 集群需要6个 Redis 客户端</strong>。</p><p>这里只是演示一下，使用<code>伪集群</code>，即6台 Redis 搭建在一台 Linux 上，仅使用端口号进行区分，设端口号范围为7001 ~ 7006。</p><h3 id="2-1-准备原始-Redis"><a href="#2-1-准备原始-Redis" class="headerlink" title="2.1 准备原始 Redis"></a>2.1 准备原始 Redis</h3><blockquote><p>注：<a href="https://www.jitwxs.cn/e331e26a.html" target="_blank" rel="noopener">《Redis 初探（1）——Redis 的安装》</a>这篇文章中源码和安装后的文件是在同一文件夹下，本篇文章不使用这种方法。</p></blockquote><p>准备一个 Redis 安装包，将源码解压到当前文件夹：</p><div class="hljs"><pre><code class="hljs shell">COPYwxs@ubuntu:~$ lsDesktop  redis-4.0.8.tar.gzwxs@ubuntu:~$ tar zxvf redis-4.0.8.tar.gz</code></pre></div><p>进入解压后文件夹，执行 make 编译：</p><div class="hljs"><pre><code class="hljs shell">COPYwxs@ubuntu:~$ cd redis-4.0.8/wxs@ubuntu:~/redis-4.0.8$ make</code></pre></div><blockquote><p>注：所有源码安装需要自行编译的都需要 gcc、g++ 等相关软件支持</p></blockquote><p>将其安装到<code>/usr/local/redis</code>目录下：</p><div class="hljs"><pre><code class="hljs shell">COPYwxs@ubuntu:~/redis-4.0.8$ sudo make install PREFIX=/usr/local/redis</code></pre></div><p>该目录下只有一个 bin 目录，存放 redis 的可执行文件，我们从源码包中拷贝一份 redis 配置文件过来：</p><div class="hljs"><pre><code class="hljs shell">COPYwxs@ubuntu:/usr/local/redis$ lsbinwxs@ubuntu:/usr/local/redis$ sudo cp ~/redis-4.0.8/redis.conf .wxs@ubuntu:/usr/local/redis$ lsbin  redis.conf</code></pre></div><p>编辑该配置文件：</p><p>（1）修改 bind 端口号为 <code>0.0.0.0</code>，使其支持远程访问。</p><p><img src="https://img-blog.csdnimg.cn/20200606135013850.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>（2）开启后端模式。</p><p><img src="https://img-blog.csdnimg.cn/20200606135225299.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>（3）设置日志文件位置</p><p><img src="https://img-blog.csdnimg.cn/20200606135249116.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>（4）开启 AOF 持久化</p><p><img src="https://img-blog.csdnimg.cn/20200606135308180.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="2-2-准备-Redis-集群客户端"><a href="#2-2-准备-Redis-集群客户端" class="headerlink" title="2.2 准备 Redis 集群客户端"></a>2.2 准备 Redis 集群客户端</h3><p><strong>注意：\</strong>用来做集群的客户端*<em>必须是干净的客户端*</em>，像备份文件 <code>dump.rdb</code>、<code>appendonly.aof</code> 等应当先删除掉，避免不必要的错误。</p><p>在 <code>/usr/local</code> 中创建 <code>redis-cluster</code> 文件夹，拷贝六份原始 Redis：</p><div class="hljs"><pre><code class="hljs shell">COPYwxs@ubuntu:/usr/local/redis-cluster$ sudo cp -r ../redis redis01wxs@ubuntu:/usr/local/redis-cluster$ sudo cp -r ../redis redis02wxs@ubuntu:/usr/local/redis-cluster$ sudo cp -r ../redis redis03wxs@ubuntu:/usr/local/redis-cluster$ sudo cp -r ../redis redis04wxs@ubuntu:/usr/local/redis-cluster$ sudo cp -r ../redis redis05wxs@ubuntu:/usr/local/redis-cluster$ sudo cp -r ../redis redis06wxs@ubuntu:/usr/local/redis-cluster$ lsredis01  redis02  redis03  redis04  redis05  redis06</code></pre></div><p>以 redis01 为例，编辑其 <code>redis.conf</code> 文件：</p><p>（1）修改端口号为 7001</p><p><img src="https://img-blog.csdnimg.cn/20200606135324484.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>（2）修改 pidfile</p><p><img src="https://img-blog.csdnimg.cn/20200606135353518.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>（3）开启集群开关</p><p><img src="https://img-blog.csdnimg.cn/20200606135404621.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>依次修改其他客户端，端口号范围从7001 ~ 7006。</p><p>编写一个启动这些客户端的批处理 <code>startup.sh</code>：</p><div class="hljs"><pre><code class="hljs bash">COPYcd redis01/binsudo ./redis-server ../redis.conf<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis02/binsudo ./redis-server ../redis.conf<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis03/binsudo ./redis-server ../redis.conf<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis04/binsudo ./redis-server ../redis.conf<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis05/binsudo ./redis-server ../redis.conf<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis06/binsudo ./redis-server ../redis.conf<span class="hljs-built_in">cd</span> ../../</code></pre></div><p>执行脚本，启动成功：</p><p><img src="https://img-blog.csdnimg.cn/20200606135422369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>编写一个关闭这些客户端的批处理 <code>shutdown.sh</code>：</p><div class="hljs"><pre><code class="hljs bash">COPYcd redis01/binsudo ./redis-cli -p 7001 shutdown<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis02/binsudo ./redis-cli -p 7002 shutdown<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis03/binsudo ./redis-cli -p 7003 shutdown<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis04/binsudo ./redis-cli -p 7004 shutdown<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis05/binsudo ./redis-cli -p 7005 shutdown<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis06/binsudo ./redis-cli -p 7006 shutdown<span class="hljs-built_in">cd</span> ../../</code></pre></div><p>执行脚本，关闭成功：</p><p><img src="https://img-blog.csdnimg.cn/20200606135446595.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>目录结构如下：</p><div class="hljs"><pre><code class="hljs shell">COPYwxs@ubuntu:/usr/local/redis-cluster$ lsredis01  redis02  redis03  redis04  redis05  redis06  shutdown.sh  startup.sh</code></pre></div><h3 id="2-3-搭建集群"><a href="#2-3-搭建集群" class="headerlink" title="2.3 搭建集群"></a>2.3 搭建集群</h3><p>从 redis 源码的 src 目录中拷贝 <code>redis-trib.rb</code> 过来：</p><div class="hljs"><pre><code class="hljs shell">COPYwxs@ubuntu:/usr/local/redis-cluster$ sudo cp ~/redis-4.0.8/src/redis-trib.rb .wxs@ubuntu:/usr/local/redis-cluster$ lsredis01  redis03  redis05  redis-trib.rb  startup.shredis02  redis04  redis06  shutdown.sh</code></pre></div><p>因为这是一个 <code>shell</code> 文件，需要安装 shell 和 shell 包管理器：</p><div class="hljs"><pre><code class="hljs shell">COPYwxs@ubuntu:/usr/local/redis-cluster$ sudo apt-get install shell shellgems</code></pre></div><p>安装 shell 关于 Redis 的库,可以执行 <code>gem install redis</code> 或者<a href="https://shellgems.org/gems/redis/versions/" target="_blank" rel="noopener">前往官网</a>下载安装包后安装。</p><div class="hljs"><pre><code class="hljs shell">COPYwxs@ubuntu:/usr/local/redis-cluster$ sudo gem install redisFetching: redis-4.0.1.gem (100%)Successfully installed redis-4.0.1Parsing documentation for redis-4.0.1Installing ri documentation for redis-4.0.1Done installing documentation for redis after 0 seconds1 gem installed</code></pre></div><p>执行 <code>redis-trib.rb</code> 时需要附带参数，格式如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606135501801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>先启动所有客户端，然后执行脚本：</p><div class="hljs"><pre><code class="hljs shell">COPYwxs@ubuntu:/usr/local/redis-cluster$ ./startup.sh wxs@ubuntu:/usr/local/redis-cluster$ ./redis-trib.rb create --replicas 1 192.168.30.155:7001 192.168.30.155:7002 192.168.30.155:7003 192.168.30.155:7004 192.168.30.155:7005  192.168.30.155:7006</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200606135527930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>创建成功：</p><p><img src="https://img-blog.csdnimg.cn/20200606135550905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>最后说两句：</p><ol><li>如果你不是伪集群，真的在服务器上搭建了集群，即 <code>真集群</code>，那么只需要在任意一台上执行 <code>redis-trib.rb</code> 即可。</li><li>在真集群的情况下，除了在配置文件中要 <code>bind 0.0.0.0</code> 以外，还要注意关闭防火墙，不然无法搭建。</li><li>如果关闭所有 redis 客户端后，想要重新开启集群，在客户端都启动后，进入任意客户端执行<code>cluster nodes</code>即可。</li><li>如果想要重新生成集群，需要删除每个 Redis 中生成的持久化文件。</li></ol><h2 id="三、使用-redis-cli-连接集群"><a href="#三、使用-redis-cli-连接集群" class="headerlink" title="三、使用 redis-cli 连接集群"></a>三、使用 redis-cli 连接集群</h2><p>使用任意一个 <code>redis-cli</code>（以redis01的为例），使用 <code>-h</code> 指定ip地址（默认连接127.0.0.1），使用 <code>-p</code> 参数指定端口号（默认连接原始的端口为6379的 redis），使用 <code>-c</code> 参数指定是集群（不加会导致无法将 key 放入对应的客户端中）。</p><div class="hljs"><pre><code class="hljs shell">COPYwxs@ubuntu:/usr/local/redis-cluster$ ./redis01/bin/redis-cli -h 192.168.30.155 -p 7001 -c</code></pre></div><p>当我在7001中添加了一个 <code>name jitwxs</code> 后，它计算出 key 的哈希槽为5798，这个范围在7002中，因此这个 key 被移动到了7002中，并且当前连接重定向到了7002。</p><p><img src="https://img-blog.csdnimg.cn/20200606135606467.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs shell">COPY192.168.30.155:7002&gt; keys *1) "name"192.168.30.155:7001&gt; keys *(empty list or set)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5. Redis--Redis的持久化</title>
    <link href="/2020/06/06/5-Redis-Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/2020/06/06/5-Redis-Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>Redis 的高性能是由其将所有数据都存储在了内存中，需要使用时直接从内存调用即可。为了使 Redis 在重启之后仍然能保证数据不丢失，需要将数据从内存同步到内存中，这一过程就是<code>持久化</code>。</p><p>Redis 支持两种持久化方式，一种是 <code>RDB方式</code>，一种是 <code>AOF方式</code>。可以单独使用其中一种或将两种结合使用。</p><ul><li>RDB (默认) 在<strong>指定的时间间隔</strong>内将内存中的数据快照写入磁盘。</li><li>AOF 以<strong>日志</strong>的形式记录服务器处理的<strong>每一个写操作</strong>，在Redis服务器启动之初会读取该文件来重新构建数据库，以保证启动后数据库中的数据是完整的。</li></ul><h2 id="一、RDB"><a href="#一、RDB" class="headerlink" title="一、RDB"></a>一、RDB</h2><h3 id="1-1-实现步骤"><a href="#1-1-实现步骤" class="headerlink" title="1.1 实现步骤"></a>1.1 实现步骤</h3><ol><li>Redis 执行 <code>fork</code> 命令创建子进程。</li><li>父进程继续处理 client 请求，子进程负责将内存内容写入到临时文件。由于 OS 的写时复制机制父子进程会共享相同的物理页面，当父进程处理写请求时OS会为父进程要修改的页面创建副本，而不是写共享的页面。所以子进程的地址空间内的数据是 fork 时刻整个数据库的一个<strong>快照</strong>。</li><li>当子进程将快照写入临时文件完毕后，用临时文件替换原来的快照文件，然后子进程退出。</li></ol><p>需要注意的是，每次 RDB 都是将<strong>内存数据完整写入到磁盘一次</strong>，并<strong>不是增量的只同步脏数据</strong>。如果数据量大的话，而且写操作比较多，必然会引起大量的磁盘IO操作，可能会严重影响性能。</p><h3 id="1-2-优势"><a href="#1-2-优势" class="headerlink" title="1.2 优势"></a>1.2 优势</h3><ol><li>一旦采用该方式，那么你的整个 Redis 数据库将<strong>只包含一个文件</strong>，这样非常<strong>方便备份</strong>。</li><li>方便备份，我们可以很容易的将一个一个 RDB 文件移动到其他的存储介质上。</li><li>RDB 在恢复大数据集时的速度比 AOF 的<strong>恢复速度要快</strong>。</li><li>RDB 可以<strong>最大化 Redis 的性能</strong>（父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 IO 操作）。</li></ol><h3 id="1-3-劣势"><a href="#1-3-劣势" class="headerlink" title="1.3 劣势"></a>1.3 劣势</h3><ol><li>如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么 RDB 将不是一个很好的选择。 因为系统一旦在定时持久化之前发生宕机， 你就可能会<strong>丢失这之间的数据</strong>。</li><li>因为 RDB 是通过 fork 子进程来协助完成持久化工作的，因此当数据集较大时，会<strong>影响服务器性能</strong>。</li></ol><h3 id="1-4-RDB-配置"><a href="#1-4-RDB-配置" class="headerlink" title="1.4 RDB 配置"></a>1.4 RDB 配置</h3><p>在 <code>redis.conf</code> 中可以配置和RDF相关的信息：</p><p>(1) 配置 RDB 文件位置</p><p><img src="https://img-blog.csdnimg.cn/20200606122136837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>(2) 配置 RDB 保存时机</p><p><img src="https://img-blog.csdnimg.cn/20200606122206950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="二、AOF"><a href="#二、AOF" class="headerlink" title="二、AOF"></a>二、AOF</h2><p>采用 AOF 方式，Redis 会将每一个收到的写命令都通过 <code>write</code> 函数写入到 AOF 文件中。当 Redis 重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。</p><p>AOF 的方式也同时带来了另一个问题：<strong>持久化文件会变的越来越大</strong>。例如我们调用 <code>incr num</code> 命令100次，文件中必须保存全部的100条命令，其实有99条都是多余的，因为要恢复数据库的状态其实文件中保存一条 <code>set num 100</code> 就够了。</p><h3 id="2-1-实现步骤"><a href="#2-1-实现步骤" class="headerlink" title="2.1 实现步骤"></a>2.1 实现步骤</h3><ol><li>Redis调用<code>fork</code>命令创建子进程。</li><li>子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令。</li><li>父进程继续处理client请求，除了把写命令写入到原来的AOF文件中，同时缓存新收到的写命令。</li><li>子进程把快照内容写入到临时文件后，子进程发信号通知父进程，然后父进程把缓存的写命令也写入到临时文件。</li><li>父进程使用临时文件替换老的AOF文件，并重命名，后面收到的写命令也开始往新的AOF文件中追加。</li></ol><p>需要注意的是，重写AOF文件的操作并没有读取旧的AOF文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的AOF文件，这点和快照有点类似。</p><h3 id="2-2-优势"><a href="#2-2-优势" class="headerlink" title="2.2 优势"></a>2.2 优势</h3><ol><li>AOF 提供的三种同步策略，使得数据安全性更高。</li><li>因为 AOF 对日志文件的写入操作采用的是<code>append 模式</code>，因此在写入过程中即使出现宕机现象，也不会破坏日志文件已经存在的内容。</li><li>如果 AOF 日志文件过大，Redis可以自动启用 <code>rewrite 机制</code>，使 Redis 以 append 模式不断的将修改数据写入到老的磁盘文件中，同时 Redis 还会创建一个新的文件用于记录此期间有哪些命令被执行。因此在进行 rewrite 切换时可以更好的保证数据安全性。</li></ol><h3 id="2-3-劣势"><a href="#2-3-劣势" class="headerlink" title="2.3 劣势"></a>2.3 劣势</h3><ol><li>对于相同数量的数据集而言，AOF 文件通常要大于 RDB 文件。</li><li>根据同步策略的不同，AOF 在运行效率上往往会慢于 RDB。</li></ol><h3 id="2-4-AOF-配置"><a href="#2-4-AOF-配置" class="headerlink" title="2.4 AOF 配置"></a>2.4 AOF 配置</h3><p>AOF 默认是关闭的，修改配置文件 <code>redis.conf</code> 来打开 AOF：</p><p><img src="https://img-blog.csdnimg.cn/20200606122949195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>AOF 具有三种同步策略，在配置文件 <code>redis.conf</code> 中进行配置：</p><p><img src="https://img-blog.csdnimg.cn/20200606123020516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>除了满足同步策略来自动同步外，可以手动同步，执行命令 <code>bgrewriteaof</code> 即可。</p><p>下面演示下 AOF 恢复：</p><div class="hljs"><pre><code class="hljs elixir">wxs<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:/usr/local/redis/src</span><span class="hljs-variable">$ </span>./redis-cli <span class="hljs-number">127.0</span>.0.<span class="hljs-number">1:6379</span>&gt; keys *(empty list <span class="hljs-keyword">or</span> set)<span class="hljs-number">127.0</span>.0.<span class="hljs-number">1:6379</span>&gt; set name jitwxs <span class="hljs-comment">#设置一个key</span>OK<span class="hljs-number">127.0</span>.0.<span class="hljs-number">1:6379</span>&gt; flushdb <span class="hljs-comment">#清空数据库</span>OK<span class="hljs-number">127.0</span>.0.<span class="hljs-number">1:6379</span>&gt; exitwxs<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:/usr/local/redis/src</span><span class="hljs-variable">$ </span>ps auxc | grep rediswxs        <span class="hljs-number">5974</span>  0.<span class="hljs-number">1</span>  0.<span class="hljs-number">4</span>  <span class="hljs-number">51828</span>  <span class="hljs-number">8368</span> ?        Ssl  <span class="hljs-number">21:23</span>   0<span class="hljs-symbol">:</span>00 redis-serverwxs<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:/usr/local/redis/src</span><span class="hljs-variable">$ </span>kill <span class="hljs-number">5974</span> <span class="hljs-comment">#停止服务</span>wxs<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:/usr/local/redis/src</span><span class="hljs-variable">$ </span>vim ../redis_dbfile/appendonly.aof <span class="hljs-comment">#修改AOF文件并删除掉最后一行的flushdb命令</span>wxs<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:/usr/local/redis/src</span><span class="hljs-variable">$ </span>./redis-server ../redis.conf <span class="hljs-comment">#重新启动服务，数据被恢复</span>wxs<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:/usr/local/redis/src</span><span class="hljs-variable">$ </span>./redis-cli <span class="hljs-number">127.0</span>.0.<span class="hljs-number">1:6379</span>&gt; keys *<span class="hljs-number">1</span>) <span class="hljs-string">"name"</span></code></pre></div><blockquote><p>注：这里只是说明Redis持久化配置相关的内容，实际配置由于本人使用的是Docker容器生成的Redis，所以有些地方跟上述不一致，所以仅仅作为参考，后续会更新完善。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4. Redis--Redis的特性</title>
    <link href="/2020/06/06/4-Redis-Redis%E7%9A%84%E7%89%B9%E6%80%A7/"/>
    <url>/2020/06/06/4-Redis-Redis%E7%9A%84%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="一、多数据库"><a href="#一、多数据库" class="headerlink" title="一、多数据库"></a>一、多数据库</h2><p>每一个 Redis 实例可以包括多个数据库，客户端可以指定连接某个 Redis 实例的某个数据库。一个Redis实例最多可以提供 <strong>16</strong> 个数据库，下标从 0 到 15，客户端<strong>默认连接第 0 号数据库</strong>。</p><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>选择第 n 号数据库</td><td>select n</td></tr><tr><td>将当前库的 key 转移到第 n 号数据库</td><td>move key n</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/20200606100035439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>这里补充下之前没有提到的 Redis 服务器的一些命令：</p><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>测试连接状态是否可用</td><td>ping</td></tr><tr><td>命令行中打印内容</td><td>echo xxx</td></tr><tr><td>返回当前数据库中 key 的数目</td><td>dbsize</td></tr><tr><td>获取服务器的信息和统计</td><td>info</td></tr><tr><td>删除当前选择数据库中所有key</td><td>flushdb</td></tr><tr><td>删除所有数据库中所有key</td><td>flushall</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-symbol">wxs@</span>ubuntu:/usr/local/redis/src$ ./redis-cli<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; select <span class="hljs-number">1</span> #进入<span class="hljs-number">1</span>号数据库OK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">1</span>]&gt; ping #检查连接状态PONG<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">1</span>]&gt; dbsize #获取当前数据库key数目(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">1</span>]&gt; flushdb #清空当前数据库OK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">1</span>]&gt; keys *(empty list <span class="hljs-keyword">or</span> <span class="hljs-keyword">set</span>)<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">1</span>]&gt; flushall #清空所有数据库OK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">1</span>]&gt; select <span class="hljs-number">0</span>OK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; keys *(empty list <span class="hljs-keyword">or</span> <span class="hljs-keyword">set</span>)</code></pre></div><h2 id="二、消息订阅与发布"><a href="#二、消息订阅与发布" class="headerlink" title="二、消息订阅与发布"></a>二、消息订阅与发布</h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。Redis 客户端可以订阅<strong>任意数量</strong>的频道。</p><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>订阅频道</td><td>subscribe cctv</td></tr><tr><td>批量订阅频道</td><td>psubscribe cctv*</td></tr><tr><td>在指定频道中发送消息publish cctv “hello”</td><td></td></tr></tbody></table><p>实现消息的订阅和发布至少需要两个终端，我们在终端1中订阅 cctv 这个频道的消息：</p><p><img src="https://img-blog.csdnimg.cn/20200606103425153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>在终端2中向 cctv 这个频道发布消息：从上面的图可以看到，推送的消息已经被订阅者收到。</p><p><img src="https://img-blog.csdnimg.cn/20200606103500275.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>我们也可以以一种正则的形式订阅多个频道，比如 cctv 下面有多个频道，例如 cctv-1、cctv-2 等等，我们只需订阅这个即可：</p><div class="hljs"><pre><code class="hljs nginx"><span class="hljs-attribute">psubscribe</span> cctv*</code></pre></div><h2 id="三、事务"><a href="#三、事务" class="headerlink" title="三、事务"></a>三、事务</h2><p>Redis 和其他数据库一样，也支持事务功能，但是 Redis 的数据库<strong>并不是一种真正的事务</strong>，它其实<strong>更像是一种批处理</strong>。</p><p>传统数据库意义上的事务，是将多条 SQL 语句作为一个整体，如果其中任何一条语句执行失败，那么这些语句都不会被执行。但是Redis的事务，<strong>如果有某一条命令执行失败，其后的命令仍然会执行</strong>。</p><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>开启事务(类似：begin transaction)</td><td>multi</td></tr><tr><td>提交事务（类似：commit）</td><td>exec</td></tr><tr><td>事务回滚（类似：rollback）</td><td>discard</td></tr></tbody></table><div class="hljs"><pre><code class="hljs accesslog">wxs@ubuntu:/usr/local/redis/src$ ./redis-cli <span class="hljs-number">127.0.0.1:6379</span>&gt; set num <span class="hljs-number">1</span>OK<span class="hljs-number">127.0.0.1:6379</span>&gt; set name jitwxsOK<span class="hljs-number">127.0.0.1:6379</span>&gt; multi #开启事务OK<span class="hljs-number">127.0.0.1:6379</span>&gt; incr numQUEUED<span class="hljs-number">127.0.0.1:6379</span>&gt; incr nameQUEUED<span class="hljs-number">127.0.0.1:6379</span>&gt; set age <span class="hljs-number">20</span>QUEUED<span class="hljs-number">127.0.0.1:6379</span>&gt; exec #执行事务<span class="hljs-number">1</span>) (integer) <span class="hljs-number">2</span><span class="hljs-number">2</span>) (error) ERR value is not an integer or out of range #命令报错<span class="hljs-number">3</span>) OK #前面命令出错后这条命令仍然执行了<span class="hljs-number">127.0.0.1:6379</span>&gt; get num<span class="hljs-string">"2"</span><span class="hljs-number">127.0.0.1:6379</span>&gt; get name<span class="hljs-string">"jitwxs"</span><span class="hljs-number">127.0.0.1:6379</span>&gt; get age #该命令的确执行了<span class="hljs-string">"20"</span><span class="hljs-number">127.0.0.1:6379</span>&gt;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. Redis--Redis的数据类型</title>
    <link href="/2020/06/05/3-Redis-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2020/06/05/3-Redis-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>Redis支持以下五种数据结构：</p><ul><li>String类型</li><li>List类型</li><li>Set类型</li><li>SortedSet类型</li><li>Hash类型</li></ul><table><thead><tr><th>存储极限</th><th>大小</th></tr></thead><tbody><tr><td>String类型的value大小</td><td>512M</td></tr><tr><td>Hash类型key的键值对大小</td><td>4294967295</td></tr><tr><td>List类型的key个数</td><td>4294967295</td></tr><tr><td>Set/SortedSet类型的key个数</td><td>4294967295</td></tr></tbody></table><h2 id="一、String（字符串）类型"><a href="#一、String（字符串）类型" class="headerlink" title="一、String（字符串）类型"></a>一、String（字符串）类型</h2><p>在前面两章中，我们存储的都是 String 类型。该类型增加和删除一个键值对十分简单，如下：</p><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>获取值</td><td>get key</td></tr><tr><td>添加一个键值对</td><td>set key value</td></tr><tr><td>获取并重置一个键值对</td><td>getset key value</td></tr><tr><td>删除一个键值对</td><td>del key</td></tr></tbody></table><p>字符串也可以进行数值操作（Redis内部自动将value转换为数值型），方法如下：</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>incr key</td><td>值加1</td></tr><tr><td>decr key</td><td>值减1</td></tr><tr><td>incrby key n</td><td>值加n</td></tr><tr><td>decrby key n</td><td>值减n</td></tr></tbody></table><p>如果key值不存在，当做0处理，如果value值无法转换为整型时，会返回错误信息：</p><p><img src="https://img-blog.csdnimg.cn/20200605223023304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>介绍一下字符串拼接方法，如下：</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>append key</td><td>拼接字符串</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/2020060522335293.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="二、Hash（散列）类型"><a href="#二、Hash（散列）类型" class="headerlink" title="二、Hash（散列）类型"></a>二、Hash（散列）类型</h2><p>散列，即 Hash，Redis 中的 Hash 类型可以看成<strong>Map集合</strong>。Hash 类型的<strong>每一个 key 的 value 对应于一个 Map，该Map包含多个键值对的数据</strong>，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200605231035860.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="2-1-赋值"><a href="#2-1-赋值" class="headerlink" title="2.1 赋值"></a>2.1 赋值</h3><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>hset key field value</td><td>为指定key设置一个键值对</td></tr><tr><td>hmset key field value[field2 value2…]</td><td>为指定key设置多个键值对</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/2020060523171942.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="2-2-取值"><a href="#2-2-取值" class="headerlink" title="2.2 取值"></a>2.2 取值</h3><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>hget key field</td><td>返回指定 key 中 field 的值</td></tr><tr><td>hmget key filed[field2…]</td><td>返回指定 key 中多个 field 的值</td></tr><tr><td>hgetall key</td><td>返回指定 key 中所有 field-value</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/2020060523191135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="2-3-删除"><a href="#2-3-删除" class="headerlink" title="2.3 删除"></a>2.3 删除</h3><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>hdel key field[field2…]</td><td>删除指定 key 一个或多个 field</td></tr><tr><td>del key</td><td>清空 Hash</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/20200605232227429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="2-4-扩展命令"><a href="#2-4-扩展命令" class="headerlink" title="2.4 扩展命令"></a>2.4 扩展命令</h3><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>hexists key field</td><td>判断指定 key 中 field 是否存在</td></tr><tr><td>hlen key</td><td>返回指定 key 中 field 的数量</td></tr><tr><td>hkeys key</td><td>获取指定 key 中所有的 field</td></tr><tr><td>hvals key</td><td>获取指定 key 中所有的 value</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hmset myHash name yyj age <span class="hljs-number">20</span> sex maleOK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hexists myHash name(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hexists myHash unknown(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">0</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hlen myHash(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hkeys myHash<span class="hljs-number">1</span>) <span class="hljs-string">"name"</span><span class="hljs-number">2</span>) <span class="hljs-string">"age"</span><span class="hljs-number">3</span>) <span class="hljs-string">"sex"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hvals myHash<span class="hljs-number">1</span>) <span class="hljs-string">"yyj"</span><span class="hljs-number">2</span>) <span class="hljs-string">"20"</span><span class="hljs-number">3</span>) <span class="hljs-string">"male"</span></code></pre></div><h2 id="三、List-类型"><a href="#三、List-类型" class="headerlink" title="三、List 类型"></a>三、List 类型</h2><p>Redis 的 List 类型有点像 Java 中的 LinkList，内部实现是一个<code>双向链表</code>，双向链表的知识点参考文章：<a href="https://www.jitwxs.cn/abd3f641.html" target="_blank" rel="noopener">《数据结构 第二章 线性表》</a>。</p><h3 id="3-1-添加"><a href="#3-1-添加" class="headerlink" title="3.1 添加"></a>3.1 添加</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>从左端添加多个value</td><td>lpush key value[value2…]</td></tr><tr><td>从右端添加多个value</td><td>rpush key value[value2…]</td></tr></tbody></table><p><strong>注：</strong> 如果 key 不存在会先创建 key，然后添加。</p><p><img src="https://img-blog.csdnimg.cn/20200605233016372.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="3-2-查看"><a href="#3-2-查看" class="headerlink" title="3.2 查看"></a>3.2 查看</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>获取 list 从 start 到 end 的值</td><td>lrange key start end</td></tr><tr><td>获取 list 中元素数量</td><td>llen key</td></tr></tbody></table><p>因为 List 内部是一个双向链表，因此链表<strong>首元素下标为0，尾元素下标为-1</strong>，因此查看所有元素即：<code>lrange key 0 -1</code>。</p><p><img src="https://img-blog.csdnimg.cn/20200605233241255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="3-3-删除"><a href="#3-3-删除" class="headerlink" title="3.3 删除"></a>3.3 删除</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>返回并弹出左端元素</td><td>lpop key</td></tr><tr><td>返回并弹出右端元素</td><td>rpop key</td></tr></tbody></table><p><strong>注：</strong> 如果 key 不存在，返回nil。</p><p><img src="https://img-blog.csdnimg.cn/20200605233444391.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="3-4-扩展命令"><a href="#3-4-扩展命令" class="headerlink" title="3.4 扩展命令"></a>3.4 扩展命令</h3><h4 id="3-4-1-添加前检查-key-的存在性"><a href="#3-4-1-添加前检查-key-的存在性" class="headerlink" title="3.4.1 添加前检查 key 的存在性"></a>3.4.1 添加前检查 key 的存在性</h4><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>从左端添加多个 value</td><td>lpushx key value[value2…]</td></tr><tr><td>从右端添加多个 value</td><td>rpushx key value[value2…]</td></tr></tbody></table><p>这两个方法加了 <code>x</code> 的和之前不加 <code>x</code> 的不同之处是：如果 key 不存在，将<strong>不进行插入</strong>。</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; del myList(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lpushx myList a b c(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">0</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span>(empty list <span class="hljs-keyword">or</span> <span class="hljs-keyword">set</span>)</code></pre></div><h4 id="3-4-2-根据-value-删除"><a href="#3-4-2-根据-value-删除" class="headerlink" title="3.4.2 根据 value 删除"></a>3.4.2 根据 value 删除</h4><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>删除 count 个值为 value 的元素</td><td>lrem key count value</td></tr></tbody></table><p>若 count &gt; 0，则从左到右删除：</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush myList <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">6</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"2"</span><span class="hljs-number">3</span>) <span class="hljs-string">"1"</span><span class="hljs-number">4</span>) <span class="hljs-string">"3"</span><span class="hljs-number">5</span>) <span class="hljs-string">"5"</span><span class="hljs-number">6</span>) <span class="hljs-string">"1"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrem myList <span class="hljs-number">2</span> <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">2</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"2"</span><span class="hljs-number">2</span>) <span class="hljs-string">"3"</span><span class="hljs-number">3</span>) <span class="hljs-string">"5"</span><span class="hljs-number">4</span>) <span class="hljs-string">"1"</span></code></pre></div><p>若 count &lt; 0，则从右向左删除：</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush myList <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">6</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"2"</span><span class="hljs-number">3</span>) <span class="hljs-string">"1"</span><span class="hljs-number">4</span>) <span class="hljs-string">"3"</span><span class="hljs-number">5</span>) <span class="hljs-string">"5"</span><span class="hljs-number">6</span>) <span class="hljs-string">"1"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrem myList <span class="hljs-number">-2</span> <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">2</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"2"</span><span class="hljs-number">3</span>) <span class="hljs-string">"3"</span><span class="hljs-number">4</span>) <span class="hljs-string">"5"</span></code></pre></div><p>若 count = 0，删除所有：</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush myList <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">6</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"2"</span><span class="hljs-number">3</span>) <span class="hljs-string">"1"</span><span class="hljs-number">4</span>) <span class="hljs-string">"3"</span><span class="hljs-number">5</span>) <span class="hljs-string">"5"</span><span class="hljs-number">6</span>) <span class="hljs-string">"1"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrem myList <span class="hljs-number">0</span> <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"2"</span><span class="hljs-number">2</span>) <span class="hljs-string">"3"</span><span class="hljs-number">3</span>) <span class="hljs-string">"5"</span></code></pre></div><h4 id="3-4-3-根据下标设置-value"><a href="#3-4-3-根据下标设置-value" class="headerlink" title="3.4.3 根据下标设置 value"></a>3.4.3 根据下标设置 value</h4><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>设置下标为 index 的元素值。0代表最左边元素，-1代表最右边元素，下标不存在时抛出异常。</td><td>lset key index value</td></tr></tbody></table><div class="hljs"><pre><code class="hljs tcl"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush myList <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>(integer) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">lset</span> myList <span class="hljs-number">1</span> <span class="hljs-number">5</span>OK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">lrange</span> myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"5"</span><span class="hljs-number">3</span>) <span class="hljs-string">"3"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">lset</span> myList <span class="hljs-number">3</span> <span class="hljs-number">5</span>(<span class="hljs-keyword">error</span>) ERR index out of range</code></pre></div><h4 id="3-4-4-相对于某元素插入-value"><a href="#3-4-4-相对于某元素插入-value" class="headerlink" title="3.4.4 相对于某元素插入 value"></a>3.4.4 相对于某元素插入 value</h4><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>在 pivot 元素前插入value</td><td>linsert key before pivot value</td></tr><tr><td>在 pivot 元素后插入value</td><td>linsert key after pivot value</td></tr></tbody></table><p>注：如果 pivot 不存在，不插入。</p><div class="hljs"><pre><code class="hljs tcl"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush myList <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>(integer) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">linsert</span> myList before <span class="hljs-number">2</span> a(integer) <span class="hljs-number">4</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">linsert</span> myList <span class="hljs-keyword">after</span> <span class="hljs-number">2</span> b(integer) <span class="hljs-number">5</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">lrange</span> myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"a"</span><span class="hljs-number">3</span>) <span class="hljs-string">"2"</span><span class="hljs-number">4</span>) <span class="hljs-string">"b"</span><span class="hljs-number">5</span>) <span class="hljs-string">"3"</span></code></pre></div><h4 id="3-4-5-将链表-A-右边元素移出并添加到链表B-左边"><a href="#3-4-5-将链表-A-右边元素移出并添加到链表B-左边" class="headerlink" title="3.4.5 将链表 A 右边元素移出并添加到链表B 左边"></a>3.4.5 将链表 A 右边元素移出并添加到链表B 左边</h4><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>将链表 A 右边元素移出并添加到链表 B 左边</td><td>rpoplpush listA listB</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush myListA <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush myListB a b c(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpoplpush myListA myListB<span class="hljs-string">"3"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myListA <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"2"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myListB <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"3"</span><span class="hljs-number">2</span>) <span class="hljs-string">"a"</span><span class="hljs-number">3</span>) <span class="hljs-string">"b"</span><span class="hljs-number">4</span>) <span class="hljs-string">"c"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpoplpush myListA myListA<span class="hljs-string">"2"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myListA <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"2"</span><span class="hljs-number">2</span>) <span class="hljs-string">"1"</span></code></pre></div><h2 id="四、Set-类型"><a href="#四、Set-类型" class="headerlink" title="四、Set 类型"></a>四、Set 类型</h2><p>Redis 的 Set 类型和 Java 中的 Set 类型一样，它具有两个重要的特点：<code>无序性</code>和<code>唯一性</code>，具体不再赘述。</p><h3 id="4-1-基本操作"><a href="#4-1-基本操作" class="headerlink" title="4.1 基本操作"></a>4.1 基本操作</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>向 set 中添加成员，如果成员已存在，不再添加</td><td>sadd key member[member2…]</td></tr><tr><td>向 set 中删除成员，如果不存在，也不会报错</td><td>srem key member[member2…]</td></tr><tr><td>获取 set 中所有成员</td><td>smembers key</td></tr><tr><td>判断指定成员是否存在于 set 中</td><td>sismember key member</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sadd mySet <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; smembers mySet<span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"2"</span><span class="hljs-number">3</span>) <span class="hljs-string">"3"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; srem mySet <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">2</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; smembers mySet<span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sismember mySet <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sismember mySet <span class="hljs-number">2</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">0</span></code></pre></div><h3 id="4-2-集合操作"><a href="#4-2-集合操作" class="headerlink" title="4.2 集合操作"></a>4.2 集合操作</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>集合的差集</td><td>sdiff key1 key2[key3…]</td></tr><tr><td>集合的交集</td><td>sinter key1 key2[key3…]</td></tr><tr><td>集合的并集</td><td>sunion key1 key2[key3…]</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sadd mySet1 a b c <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">4</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sadd mySet2 <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> b(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">4</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sdiff mySet1 mySet2<span class="hljs-number">1</span>) <span class="hljs-string">"a"</span><span class="hljs-number">2</span>) <span class="hljs-string">"c"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sdiff mySet2 mySet1<span class="hljs-number">1</span>) <span class="hljs-string">"2"</span><span class="hljs-number">2</span>) <span class="hljs-string">"3"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sinter mySet1 mySet2<span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"b"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sunion mySet1 mySet2<span class="hljs-number">1</span>) <span class="hljs-string">"c"</span><span class="hljs-number">2</span>) <span class="hljs-string">"1"</span><span class="hljs-number">3</span>) <span class="hljs-string">"b"</span><span class="hljs-number">4</span>) <span class="hljs-string">"2"</span><span class="hljs-number">5</span>) <span class="hljs-string">"a"</span><span class="hljs-number">6</span>) <span class="hljs-string">"3"</span></code></pre></div><h3 id="4-3-扩展命令"><a href="#4-3-扩展命令" class="headerlink" title="4.3 扩展命令"></a>4.3 扩展命令</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>求 set 中成员数量</td><td>scard key</td></tr><tr><td>随机返回一个成员</td><td>srandmember key</td></tr><tr><td>将多个集合的差集存储在 desc 中</td><td>sdiffstore desc key1 key2[key3…]</td></tr><tr><td>将多个集合的交集存储在 desc 中</td><td>sinterstore desc key1 key2[key3…]</td></tr><tr><td>将多个集合的并集存储在 desc 中</td><td>sunionstore desc key1 key2[key3…]</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; smembers mySet1<span class="hljs-number">1</span>) <span class="hljs-string">"a"</span><span class="hljs-number">2</span>) <span class="hljs-string">"c"</span><span class="hljs-number">3</span>) <span class="hljs-string">"1"</span><span class="hljs-number">4</span>) <span class="hljs-string">"b"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; smembers mySet2<span class="hljs-number">1</span>) <span class="hljs-string">"3"</span><span class="hljs-number">2</span>) <span class="hljs-string">"b"</span><span class="hljs-number">3</span>) <span class="hljs-string">"2"</span><span class="hljs-number">4</span>) <span class="hljs-string">"1"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; scard mySet1(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">4</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; srandmember mySet1<span class="hljs-string">"c"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sdiffstore mySet3 mySet1 mySet2(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">2</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; smembers mySet3<span class="hljs-number">1</span>) <span class="hljs-string">"a"</span><span class="hljs-number">2</span>) <span class="hljs-string">"c"</span></code></pre></div><h2 id="五、SortedSet-类型"><a href="#五、SortedSet-类型" class="headerlink" title="五、SortedSet 类型"></a>五、SortedSet 类型</h2><p>SortedSet 和 Set 的区别是，SortedSet 中每一个成员都有一个 <code>score（分数）</code>与之关联，Redis 通过 score 来为集合中的元素进行排序（默认为升序）。</p><h3 id="5-1-添加-获取元素"><a href="#5-1-添加-获取元素" class="headerlink" title="5.1 添加/获取元素"></a>5.1 添加/获取元素</h3><table><thead><tr><th align="left">含义</th><th>方法</th></tr></thead><tbody><tr><td align="left">添加成员。如果成员存在，会用新的 score 替代原有的 score，返回值是新加入到集合中的成员个数</td><td>zadd key score member[score2 member2… ]</td></tr><tr><td align="left">获取指定成员的 score</td><td>zscore key member</td></tr><tr><td align="left">获取 key 中成员个数</td><td>scard key</td></tr><tr><td align="left">获取集合中下标从 start 到 end 的成员，[withscores]表明返回的成员包含其 score</td><td>zrange key start end[withscores]</td></tr><tr><td align="left">上面方法的反转</td><td>zrevrange key start end[withscores]</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zadd mySort <span class="hljs-number">82</span> wangnima <span class="hljs-number">100</span> cat <span class="hljs-number">33</span> dog <span class="hljs-number">43</span> jitwxs <span class="hljs-number">80</span> zhouyang <span class="hljs-number">60</span> liuchang(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">6</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zscore mySort jitwxs<span class="hljs-string">"100"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zcard mySort(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">6</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"dog"</span><span class="hljs-number">2</span>) <span class="hljs-string">"liuchang"</span><span class="hljs-number">3</span>) <span class="hljs-string">"zhouyang"</span><span class="hljs-number">4</span>) <span class="hljs-string">"wangnima"</span><span class="hljs-number">5</span>) <span class="hljs-string">"cat"</span><span class="hljs-number">6</span>) <span class="hljs-string">"jitwxs"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span> withscores <span class="hljs-number">1</span>) <span class="hljs-string">"dog"</span> <span class="hljs-number">2</span>) <span class="hljs-string">"33"</span> <span class="hljs-number">3</span>) <span class="hljs-string">"liuchang"</span> <span class="hljs-number">4</span>) <span class="hljs-string">"60"</span> <span class="hljs-number">5</span>) <span class="hljs-string">"zhouyang"</span> <span class="hljs-number">6</span>) <span class="hljs-string">"80"</span> <span class="hljs-number">7</span>) <span class="hljs-string">"wangnima"</span> <span class="hljs-number">8</span>) <span class="hljs-string">"82"</span> <span class="hljs-number">9</span>) <span class="hljs-string">"cat"</span><span class="hljs-number">10</span>) <span class="hljs-string">"100"</span><span class="hljs-number">11</span>) <span class="hljs-string">"jitwxs"</span><span class="hljs-number">12</span>) <span class="hljs-string">"100"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrevrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span> withscores <span class="hljs-number">1</span>) <span class="hljs-string">"jitwxs"</span> <span class="hljs-number">2</span>) <span class="hljs-string">"100"</span> <span class="hljs-number">3</span>) <span class="hljs-string">"cat"</span> <span class="hljs-number">4</span>) <span class="hljs-string">"100"</span> <span class="hljs-number">5</span>) <span class="hljs-string">"wangnima"</span> <span class="hljs-number">6</span>) <span class="hljs-string">"82"</span> <span class="hljs-number">7</span>) <span class="hljs-string">"zhouyang"</span> <span class="hljs-number">8</span>) <span class="hljs-string">"80"</span> <span class="hljs-number">9</span>) <span class="hljs-string">"liuchang"</span><span class="hljs-number">10</span>) <span class="hljs-string">"60"</span><span class="hljs-number">11</span>) <span class="hljs-string">"dog"</span><span class="hljs-number">12</span>) <span class="hljs-string">"33"</span></code></pre></div><h3 id="5-2-删除元素"><a href="#5-2-删除元素" class="headerlink" title="5.2 删除元素"></a>5.2 删除元素</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>删除成员</td><td>zrem key member[member2…]</td></tr><tr><td>按照下标范围删除成员</td><td>zremrangebyrank key start stop</td></tr><tr><td>按照 score 范围删除成员</td><td>zremrangebyscore key min max</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrem mySort wangnima(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zcard mySort(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">5</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"dog"</span><span class="hljs-number">2</span>) <span class="hljs-string">"liuchang"</span><span class="hljs-number">3</span>) <span class="hljs-string">"zhouyang"</span><span class="hljs-number">4</span>) <span class="hljs-string">"cat"</span><span class="hljs-number">5</span>) <span class="hljs-string">"jitwxs"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zremrangebyrank mySort <span class="hljs-number">0</span> <span class="hljs-number">2</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"cat"</span><span class="hljs-number">2</span>) <span class="hljs-string">"jitwxs"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span> withscores <span class="hljs-number">1</span>) <span class="hljs-string">"dog"</span> <span class="hljs-number">2</span>) <span class="hljs-string">"33"</span> <span class="hljs-number">3</span>) <span class="hljs-string">"jitwxs"</span> <span class="hljs-number">4</span>) <span class="hljs-string">"43"</span> <span class="hljs-number">5</span>) <span class="hljs-string">"liuchang"</span> <span class="hljs-number">6</span>) <span class="hljs-string">"60"</span> <span class="hljs-number">7</span>) <span class="hljs-string">"zhouyang"</span> <span class="hljs-number">8</span>) <span class="hljs-string">"80"</span> <span class="hljs-number">9</span>) <span class="hljs-string">"wangnima"</span><span class="hljs-number">10</span>) <span class="hljs-string">"82"</span><span class="hljs-number">11</span>) <span class="hljs-string">"cat"</span><span class="hljs-number">12</span>) <span class="hljs-string">"100"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zremrangebyscore mySort <span class="hljs-number">50</span> <span class="hljs-number">85</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span> withscores<span class="hljs-number">1</span>) <span class="hljs-string">"dog"</span><span class="hljs-number">2</span>) <span class="hljs-string">"33"</span><span class="hljs-number">3</span>) <span class="hljs-string">"jitwxs"</span><span class="hljs-number">4</span>) <span class="hljs-string">"43"</span><span class="hljs-number">5</span>) <span class="hljs-string">"cat"</span><span class="hljs-number">6</span>) <span class="hljs-string">"100"</span></code></pre></div><h3 id="5-3-扩展方法"><a href="#5-3-扩展方法" class="headerlink" title="5.3 扩展方法"></a>5.3 扩展方法</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>返回 score 在[min,max]的成员并按照 score 排序。[withscores]：显示 score；[limit offset count]：从 offst 开始返回 count 个成员</td><td>zrangebyscore key min max[withscores] [limit offset count]</td></tr><tr><td>设置指定成员增加的分数，返回值是修改后的分数</td><td>zincrby key increment member</td></tr><tr><td>获取分树在[min,max]的成员数量</td><td>zcount key min max</td></tr><tr><td>返回成员在集合中的排名（升序）</td><td>zrank key member</td></tr><tr><td>返回成员在集合中的排名（降序）</td><td>zrevrank key member</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span> withscores <span class="hljs-number">1</span>) <span class="hljs-string">"dog"</span> <span class="hljs-number">2</span>) <span class="hljs-string">"33"</span> <span class="hljs-number">3</span>) <span class="hljs-string">"jitwxs"</span> <span class="hljs-number">4</span>) <span class="hljs-string">"43"</span> <span class="hljs-number">5</span>) <span class="hljs-string">"liuchang"</span> <span class="hljs-number">6</span>) <span class="hljs-string">"60"</span> <span class="hljs-number">7</span>) <span class="hljs-string">"zhouyang"</span> <span class="hljs-number">8</span>) <span class="hljs-string">"80"</span> <span class="hljs-number">9</span>) <span class="hljs-string">"wangnima"</span><span class="hljs-number">10</span>) <span class="hljs-string">"82"</span><span class="hljs-number">11</span>) <span class="hljs-string">"cat"</span><span class="hljs-number">12</span>) <span class="hljs-string">"100"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrangebyscore mySort <span class="hljs-number">30</span> <span class="hljs-number">86</span> limit <span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-number">1</span>) <span class="hljs-string">"liuchang"</span><span class="hljs-number">2</span>) <span class="hljs-string">"zhouyang"</span><span class="hljs-number">3</span>) <span class="hljs-string">"wangnima"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zcount mySort <span class="hljs-number">0</span> <span class="hljs-number">60</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zincrby mySort <span class="hljs-number">17</span> jitwxs<span class="hljs-string">"60"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrank mySort jitwxs(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrevrank mySort jitwxs(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">4</span></code></pre></div><h2 id="六、key-的通用命令"><a href="#六、key-的通用命令" class="headerlink" title="六、key 的通用命令"></a>六、key 的通用命令</h2><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>获取所有于 pattern 匹配的 key。*：任意一个或多个字符，？：任意一个字符</td><td>keys pattern</td></tr><tr><td>删除指定 key</td><td>del key[key2…]</td></tr><tr><td>判断 key 是否存在</td><td>exists key</td></tr><tr><td>为 key 重命名</td><td>rename key newKey</td></tr><tr><td>设置过期时间（单位s）</td><td>expire key</td></tr><tr><td>获取key 剩余的过期时间（单位s）。若没有设置过期时间，返回-1；超时不存在返回-2</td><td>ttl key</td></tr><tr><td>获取 key 类型，key 不存在返回none</td><td>type key</td></tr></tbody></table><p>注：如果你设置了一个 key 的过期时间，如果又不想让它过期，可以执行命令 <code>persist key</code>。</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; keys * <span class="hljs-number">1</span>) <span class="hljs-string">"unknown"</span> <span class="hljs-number">2</span>) <span class="hljs-string">"mySet2"</span> <span class="hljs-number">3</span>) <span class="hljs-string">"float_num"</span> <span class="hljs-number">4</span>) <span class="hljs-string">"myListB"</span> <span class="hljs-number">5</span>) <span class="hljs-string">"mySet3"</span> <span class="hljs-number">6</span>) <span class="hljs-string">"userName"</span> <span class="hljs-number">7</span>) <span class="hljs-string">"myListA"</span> <span class="hljs-number">8</span>) <span class="hljs-string">"int_num"</span> <span class="hljs-number">9</span>) <span class="hljs-string">"mySort"</span><span class="hljs-number">10</span>) <span class="hljs-string">"mySet1"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; del unknown(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; type myListAlist<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rename myListA myListOK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; exists myListA(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">0</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; ttl mySort(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">-1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; expire mySort <span class="hljs-number">30</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; ttl mySort(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">-2</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; keys *<span class="hljs-number">1</span>) <span class="hljs-string">"mySet2"</span><span class="hljs-number">2</span>) <span class="hljs-string">"myList"</span><span class="hljs-number">3</span>) <span class="hljs-string">"float_num"</span><span class="hljs-number">4</span>) <span class="hljs-string">"myListB"</span><span class="hljs-number">5</span>) <span class="hljs-string">"mySet3"</span><span class="hljs-number">6</span>) <span class="hljs-string">"userName"</span><span class="hljs-number">7</span>) <span class="hljs-string">"int_num"</span><span class="hljs-number">8</span>) <span class="hljs-string">"mySet1"</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. Redis--Jedis的使用</title>
    <link href="/2020/06/05/2-Redis-Jedis%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/06/05/2-Redis-Jedis%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>在Linux中开启redis服务，并传入一个变量username，赋值为yyj：<br><img src="https://img-blog.csdnimg.cn/20200605211103310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="第一个Jedis程序"><a href="#第一个Jedis程序" class="headerlink" title="第一个Jedis程序"></a>第一个Jedis程序</h1><h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><div class="hljs"><pre><code class="hljs java">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;redis.clients&lt;/groupId&gt;        &lt;artifactId&gt;jedis&lt;/artifactId&gt;        &lt;version&gt;2.9.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;commons-pool&lt;/groupId&gt;        &lt;artifactId&gt;commons-pool&lt;/artifactId&gt;        &lt;version&gt;1.5.4&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;        &lt;artifactId&gt;hamcrest-all&lt;/artifactId&gt;        &lt;version&gt;1.3&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre></div><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//1.获得连接对象，参数为redis所在的服务器地址及端口号</span>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">"192.168.75.130"</span>, <span class="hljs-number">6379</span>);        <span class="hljs-comment">//2.获得数据</span>        String username = jedis.get(<span class="hljs-string">"username"</span>);        System.out.println(username);        jedis.close();    &#125;&#125;</code></pre></div><p>这里的redis服务器地址查找方式：</p><div class="hljs"><pre><code class="hljs java">yyj<span class="hljs-meta">@yyj</span>-virtual-machine:~$ ifconfig -a</code></pre></div><p>这样我们通过运行Redis的主机IP地址和Redis的端口号，然后就可以直接get到username的值了。</p><h1 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h1><p>Jedis和数据库连接库一样，都有连接池，即JedisPool，通过简单的配置即可直接从连接池中取Jedis对象。<br>测试代码如下：</p><div class="hljs"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//1.创建Jedis连接池配置</span>        JedisPoolConfig jedisPoolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();        <span class="hljs-comment">//设置最小和最大闲置个数</span>        jedisPoolConfig.setMaxIdle(<span class="hljs-number">5</span>);        jedisPoolConfig.setMaxIdle(<span class="hljs-number">10</span>);        <span class="hljs-comment">//设置连接池最大个数</span>        jedisPoolConfig.setMaxTotal(<span class="hljs-number">30</span>);        <span class="hljs-comment">//2. 创建Jedis连接池</span>        JedisPool jedisPool = <span class="hljs-keyword">new</span> JedisPool(jedisPoolConfig, <span class="hljs-string">"192.168.75.130"</span>, <span class="hljs-number">6379</span>);        <span class="hljs-comment">//3.从连接池中获取Jedis对象</span>        Jedis jedis = jedisPool.getResource();        <span class="hljs-comment">//4.操纵数据</span>        jedis.set(<span class="hljs-string">"age"</span>,<span class="hljs-string">"20"</span>);        System.out.println(jedis.get(<span class="hljs-string">"age"</span>));        <span class="hljs-comment">//5.关闭资源</span>        jedis.close();        jedisPool.close();    &#125;&#125;</code></pre></div><h1 id="封装成工具类"><a href="#封装成工具类" class="headerlink" title="封装成工具类"></a>封装成工具类</h1><p>将上面的Redis连接池封装成一个工具类，其他地方的代码直接调用工具类来执行即可。<br>首先在src下的resource目录下新建一个配置文件redis.properties，把一些配置信息存储在配置文件中：</p><div class="hljs"><pre><code class="hljs java">#Redis连接信息redis.ip = <span class="hljs-number">192.168</span><span class="hljs-number">.75</span><span class="hljs-number">.130</span>redis.port = <span class="hljs-number">6379</span>#Redis配置信息redis.minIdle = <span class="hljs-number">5</span>redis.maxIdle = <span class="hljs-number">30</span>redis.maxTotal = <span class="hljs-number">30</span></code></pre></div><p>新建 JedisUtils.java：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisUtils</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool jedisPool = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">/** 获取连接 **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title">getJedis</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(jedisPool == <span class="hljs-keyword">null</span>)&#123;            initJedisPool();        &#125;        <span class="hljs-keyword">return</span> jedisPool.getResource();    &#125;        <span class="hljs-comment">/** 关闭连接 **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeJedis</span><span class="hljs-params">(Jedis jedis)</span> </span>&#123;        jedis.close();    &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initJedisPool</span><span class="hljs-params">()</span> </span>&#123;        InputStream in = JedisUtils.class.getClassLoader().getResourceAsStream("redis.properties");        Properties properties = <span class="hljs-keyword">new</span> Properties();        <span class="hljs-keyword">try</span> &#123;            properties.load(in);            JedisPoolConfig poolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();            poolConfig.setMinIdle(Integer.parseInt(properties.getProperty(<span class="hljs-string">"redis.minIdle"</span>)));            poolConfig.setMaxIdle(Integer.parseInt(properties.getProperty(<span class="hljs-string">"redis.maxIdle"</span>)));            poolConfig.setMaxTotal(Integer.parseInt(properties.getProperty(<span class="hljs-string">"redis.maxTotal"</span>)));            jedisPool = <span class="hljs-keyword">new</span> JedisPool(                    poolConfig,                    properties.getProperty(<span class="hljs-string">"redis.ip"</span>),                    Integer.parseInt(properties.getProperty(<span class="hljs-string">"redis.port"</span>)));        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            System.out.println(<span class="hljs-string">"载入配置文件错误"</span>);            e.printStackTrace();        &#125;    &#125;&#125;</code></pre></div><p>测试代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;    Jedis jedis = JedisUtils.getJedis();    System.out.println(jedis.get(<span class="hljs-string">"age"</span>));    JedisUtils.closeJedis(jedis);&#125;</code></pre></div><p>目录结构如下：<br><img src="https://img-blog.csdnimg.cn/2020060522103795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. Redis--安装Redis</title>
    <link href="/2020/06/05/1-Redis-%E5%AE%89%E8%A3%85Redis/"/>
    <url>/2020/06/05/1-Redis-%E5%AE%89%E8%A3%85Redis/</url>
    
    <content type="html"><![CDATA[<h2 id="1-1-什么是-Redis"><a href="#1-1-什么是-Redis" class="headerlink" title="1.1 什么是 Redis"></a>1.1 什么是 Redis</h2><p>Redis 是使用 C 语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，Redis 支持以下五种数据类型：</p><ul><li>String 类型</li><li>List 类型</li><li>Set 类型</li><li>SortedSet 类型</li><li>Hash类型</li></ul><h2 id="1-2-Redis-应用场景"><a href="#1-2-Redis-应用场景" class="headerlink" title="1.2 Redis 应用场景"></a>1.2 Redis 应用场景</h2><ul><li>缓存</li><li>分布式集群架构中session分离</li><li>任务队列</li><li>…</li></ul><h2 id="1-3-安装-Redis"><a href="#1-3-安装-Redis" class="headerlink" title="1.3 安装 Redis"></a>1.3 安装 Redis</h2><p>这里我是基于Docker安装Redis</p><ol><li><p>先搜索Redis镜像</p><div class="hljs"><pre><code><pre><code class="hljs linux">yyj@yyj-virtual-machine:~$ docker search redis</code></pre></div></code></pre><p><img src="https://img-blog.csdnimg.cn/20200605201628811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li><li><p>拉取镜像</p> <div class="hljs"><pre><code class="hljs java">sudo docker pull redis:tag</code></pre></div><p><code>:tag</code>是可选的，tag表示软件的版本，默认是latest。</p><h2 id="1-4-根据镜像启动redis"><a href="#1-4-根据镜像启动redis" class="headerlink" title="1.4 根据镜像启动redis"></a>1.4 根据镜像启动redis</h2></li></ol><p><img src="https://img-blog.csdnimg.cn/20200605202515325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="!\[在这里插入图片描述\](https://img-blog.csdnimg.cn/20200605202139539.png?x-oss-process=image/watermark,type_ZmFuZ3"><br>其中 Port 表示redis的端口号，PID 表示改进程的 pid 号，下方光标不停的闪动，此时 redis 就已经启动了。<br>新开一个窗口，运行redis-cli<br><img src="https://img-blog.csdnimg.cn/20200605202656380.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>测试效果：<br><img src="https://img-blog.csdnimg.cn/20200605202757404.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>Tips:如果我们要连接远程Redis，可以加参数： <code>-h IP地址</code><br>如果要指定端口，可以加参数：<code>-p 端口号</code></p></blockquote><h2 id="1-5-后端模式"><a href="#1-5-后端模式" class="headerlink" title="1.5 后端模式"></a>1.5 后端模式</h2><p>如果觉得开多个窗口麻烦，可以设置Redis启动模式为后端启动即可，仅仅只需要在运行redis的时候加上<code>-d</code>。<br><img src="https://img-blog.csdnimg.cn/20200605203644657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="1-6-退出Redis"><a href="#1-6-退出Redis" class="headerlink" title="1.6 退出Redis"></a>1.6 退出Redis</h2><p><img src="https://img-blog.csdnimg.cn/20200605203404108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>数据库，Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13.Netty--使用UDP广播事件</title>
    <link href="/2020/06/03/13-Netty-%E4%BD%BF%E7%94%A8UDP%E5%B9%BF%E6%92%AD%E4%BA%8B%E4%BB%B6/"/>
    <url>/2020/06/03/13-Netty-%E4%BD%BF%E7%94%A8UDP%E5%B9%BF%E6%92%AD%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>UDP概述</li><li>一个广播应用程序示例</li></ul></blockquote><h1 id="UDP的基础知识"><a href="#UDP的基础知识" class="headerlink" title="UDP的基础知识"></a>UDP的基础知识</h1><p>面向连接的传输（如TCP）管理了两个网络端点之间的连接的建立，在连接的生命周期内的有序和可靠的消息传输，以及最后连接的有序终止。<br>类似于UDP这样的无连接协议中，并没有持久化连接这样的概念，并且每个消息（一个UDP数据报）都是一个单独的传输单元。</p><h1 id="UDP广播"><a href="#UDP广播" class="headerlink" title="UDP广播"></a>UDP广播</h1><p>UDP提供了向多个接收者发送消息的额外传输模式：<br>多播：传播到一个预定义的主机组<br>广播：传输到网络上的所有主机</p><h1 id="UDP示例应用程序"><a href="#UDP示例应用程序" class="headerlink" title="UDP示例应用程序"></a>UDP示例应用程序</h1><p>发布/订阅模式:一个生产者或者服务发布事件，而多个客户端进行订阅以接收它们。<br><img src="https://img-blog.csdnimg.cn/20200603212624678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>所有的在该UDP端口上监听的事件监视器都将会接收到广播消息。</p><h1 id="消息POJO：LogEvent"><a href="#消息POJO：LogEvent" class="headerlink" title="消息POJO：LogEvent"></a>消息POJO：LogEvent</h1><p>在消息处理应用程序中，数据通常由POJO表示，除了实际上的消息内容，其还可以包含配置或处理信息，在这个应用程序中，我们将会把消息作为事件处理，并且由于该数据来自于日志文件，所以我们称它为LogEvent。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogEvent</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> SEPARATOR = (<span class="hljs-keyword">byte</span>) <span class="hljs-string">':'</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> InetSocketAddress source;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String logfile;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String msg;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> received;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LogEvent</span><span class="hljs-params">(String logfile, String msg)</span> </span>&#123; <span class="hljs-comment">// 用于传出消息的构造函数</span>        <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, -<span class="hljs-number">1</span>, logfile, msg);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LogEvent</span><span class="hljs-params">(InetSocketAddress source, <span class="hljs-keyword">long</span> received, String logfile, String msg)</span> </span>&#123; <span class="hljs-comment">// 用于 传入消息的构造函数</span>        <span class="hljs-keyword">this</span>.source = source;        <span class="hljs-keyword">this</span>.logfile = logfile;        <span class="hljs-keyword">this</span>.msg = msg;        <span class="hljs-keyword">this</span>.received = received;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> InetSocketAddress <span class="hljs-title">getSource</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 返回发送LogEvent 的源的InetSocketAddress</span>        <span class="hljs-keyword">return</span> source;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLogfile</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 返回所发送的LogEvent 的日志文件的名称</span>        <span class="hljs-keyword">return</span> logfile;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMsg</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 返回消息内容</span>        <span class="hljs-keyword">return</span> msg;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getReceivedTimestamp</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 返回接收LogEvent的时间</span>        <span class="hljs-keyword">return</span> received;    &#125;&#125;</code></pre></div><p>定义好了消息组件，接下来便可以实现该应用程序的广播逻辑了。</p><h1 id="编写广播者"><a href="#编写广播者" class="headerlink" title="编写广播者"></a>编写广播者</h1><p>Netty提供了大量的类来支持UDP应用程序的编写<br><img src="https://img-blog.csdnimg.cn/20200603213229555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Netty 的DatagramPacket 是一个简单的消息容器，DatagramChannel 实现用它来和远程节点通信。它包含了接收者（和可选的发送者）的地址以及消息的有效负载本身。<br>下图展示了正在广播的3个日志条目，每个都将通过一个专门的DatagramPacket进行广播：<br><img src="https://img-blog.csdnimg.cn/20200603213320917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>下图呈现了该LogEventBroadcaster的ChannelPipeline的一个高级别视图，展示了LogEvent消息是如何流经它的。<br><img src="https://img-blog.csdnimg.cn/20200603213516499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>所有的将要被传输的数据都被封装在了LogEvent消息中，LogEventBroadcaster将把这些写入到Channel中，并通过ChannelPipeline发送它们，在那里他们将会被转换（编码）为DatagramPacket消息，最后，它们都将通过UDP被广播，并由远程节点（监视器）所捕获。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogEventEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageEncoder</span>&lt;<span class="hljs-title">LogEvent</span>&gt;</span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> InetSocketAddress remoteAddress;     <span class="hljs-comment">//LogEventEncoder创建了即将被发送到指定的InetSocketAddress的DatagramPacket消息</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LogEventEncoder</span><span class="hljs-params">(InetSocketAddress remoteAddress)</span></span>&#123;        <span class="hljs-keyword">this</span>.remoteAddress = remoteAddress;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                          LogEvent logEvent, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">byte</span>[] file = logEvent.getLogfile().getBytes(CharsetUtil.UTF_8);        <span class="hljs-keyword">byte</span>[] msg = logEvent.getMsg().getBytes(CharsetUtil.UTF_8);        ByteBuf buf = channelHandlerContext.alloc().buffer(file.length + msg.length + <span class="hljs-number">1</span>);        <span class="hljs-comment">//将文件名写入到ByteBuf中</span>        buf.writeBytes(file);        <span class="hljs-comment">//添加一个SEPARATOR</span>        buf.writeByte(LogEvent.SEPARATOR);        <span class="hljs-comment">//将日志消息写入ByteBuf中</span>        buf.writeBytes(msg);        <span class="hljs-comment">//将一个拥有数据和目的地地址的新DatagramPacket添加到出站的消息列表中</span>        out.add(<span class="hljs-keyword">new</span> io.netty.channel.socket.DatagramPacket(buf,remoteAddress));    &#125;&#125;</code></pre></div><p>在LogEventEncoder被实现之后，我们已经准备好了引导该服务器，其包括设置各种各样的ChannelOption，以及在ChannelPipeline中安装所需要的ChannelHandler。这将通过主类LogEventBroadcaster完成。如下代码所示。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogEventBroadcaster</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventLoopGroup group;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Bootstrap bootstrap;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> File file;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LogEventBroadcaster</span><span class="hljs-params">(InetSocketAddress address, File file)</span></span>&#123;        group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        bootstrap = <span class="hljs-keyword">new</span> Bootstrap();        <span class="hljs-comment">//引导该NioDatagramChannel（无连接）</span>        bootstrap.group(group).channel(NioDatagramChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                //设置<span class="hljs-title">SO_BROADCAST</span>套接字选项</span><span class="hljs-class">                .<span class="hljs-title">option</span>(<span class="hljs-title">ChannelOption</span>.<span class="hljs-title">SO_BROADCAST</span>,<span class="hljs-title">true</span>)</span><span class="hljs-class">                .<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">LogEventEncoder</span>(<span class="hljs-title">address</span>))</span>;        <span class="hljs-keyword">this</span>.file = file;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        <span class="hljs-comment">//绑定Channel</span>        Channel ch = bootstrap.bind(<span class="hljs-number">0</span>).sync().channel();        <span class="hljs-keyword">long</span> pointer = <span class="hljs-number">0</span>;        <span class="hljs-comment">//启动主处理循环</span>        <span class="hljs-keyword">for</span> (;;)&#123;            <span class="hljs-keyword">long</span> len = file.length();            <span class="hljs-keyword">if</span> (len &lt; pointer)&#123;                <span class="hljs-comment">//file was reset</span>                <span class="hljs-comment">//如果有必要，将文件指针设置到该文件的最后一个字符</span>                pointer = len;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len &gt; pointer)&#123;                <span class="hljs-comment">//Content was added</span>                RandomAccessFile raf = <span class="hljs-keyword">new</span> RandomAccessFile(file,<span class="hljs-string">"r"</span>);                <span class="hljs-comment">//设置当前的文件指针，以确保没有任何的旧日志被发送</span>                raf.seek(pointer);                String line;                <span class="hljs-keyword">while</span>((line = raf.readLine()) != <span class="hljs-keyword">null</span>)&#123;                    <span class="hljs-comment">//对于每条日志条目。，写入一个LogEvent到Channel中</span>                    ch.writeAndFlush(<span class="hljs-keyword">new</span> LogEvent(<span class="hljs-keyword">null</span>,-<span class="hljs-number">1</span>,file.getAbsolutePath(),line));                &#125;                <span class="hljs-comment">//存储其在文件中的当前位置</span>                pointer = raf.getFilePointer();                raf.close();            &#125;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//休眠1秒，如果被中断，则退出循环，否则重新处理它</span>                Thread.sleep(<span class="hljs-number">1000</span>);            &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;                Thread.interrupted();                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>&#123;        group.shutdownGracefully();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        <span class="hljs-keyword">if</span> (args.length != <span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();        &#125;        LogEventBroadcaster broadcaster = <span class="hljs-keyword">new</span> LogEventBroadcaster(                <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"255.255.255.255"</span>,Integer.parseInt(args[<span class="hljs-number">0</span>])),<span class="hljs-keyword">new</span> File(args[<span class="hljs-number">1</span>]));        <span class="hljs-keyword">try</span> &#123;            broadcaster.run();        &#125;<span class="hljs-keyword">finally</span> &#123;            broadcaster.stop();        &#125;    &#125;&#125;</code></pre></div><p>6、编写监视器</p><p>目标是将netcat替换为一个更加完整的事件消费者，我们称之为LogEventMonitor。这个程序将：</p><p>（1）接收有LogEventBroadcaster广播的UDP DatagramPacket</p><p>（2）将它们解码为LogEvent消息</p><p>（3）将LogEvent消息写到System.out</p><p>和之前一样，该逻辑由一组自定义的ChannelHandler实现——对于我们的解码器来说，我们将扩展MessageToMessageDecoder。下图描绘LogEventMonitor的ChannelPipeline，并且展示了LogEvnet是如何流经它的。<br><img src="https://img-blog.csdnimg.cn/20200603214313967.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>ChannelPipeline中的第一个解码器LogEventDecoder负责传入的DatagramPacket解码为LogEvent消息（一个用于转换入站数据的任何Netty应用程序的典型设置）</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogEventDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageDecoder</span>&lt;<span class="hljs-title">DatagramPacket</span>&gt;</span>&#123;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                          DatagramPacket datagramPacket, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//获取对DatagramPacket中的数据的引用</span>        ByteBuf data = datagramPacket.content();        <span class="hljs-comment">//获取该SEPARATOR的索引</span>        <span class="hljs-keyword">int</span> idx = data.indexOf(<span class="hljs-number">0</span>,data.readableBytes(),LogEvent.SEPARATOR);        <span class="hljs-comment">//提取文件名</span>        String fileName = data.slice(<span class="hljs-number">0</span>,idx).toString(CharsetUtil.UTF_8);        <span class="hljs-comment">//提取日志消息</span>        String logMsg = data.slice(idx + <span class="hljs-number">1</span>,data.readableBytes()).toString(CharsetUtil.UTF_8);        <span class="hljs-comment">//构建一个新的LogEvent对象，并且将它添加到列表中</span>        LogEvent event = <span class="hljs-keyword">new</span> LogEvent(datagramPacket.sender(),System.currentTimeMillis(),fileName,logMsg);        out.add(event);    &#125;&#125;</code></pre></div><p>第二个ChannelHandler的工作是对第一个ChannelHandler所创建的LogEvent消息执行一些处理。在这个场景下，它只是简单地将它们写到System.out。在真实世界的应用程序中，你可能需要聚合来源于不同日志文件的事件，或者将它们发布到数据库中。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogEventHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">LogEvent</span>&gt;</span>&#123;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//当异常发生时，打印栈跟踪信息，并关闭对应的Channel</span>        cause.printStackTrace();        ctx.close();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                                LogEvent event)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//创建StringBuilder，并且构建输出的字符串</span>        StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();        builder.append(event.getReceived());        builder.append(<span class="hljs-string">" ["</span>);        builder.append(event.getSource().toString());        builder.append(<span class="hljs-string">"] ["</span>);        builder.append(event.getLogfile());        builder.append(<span class="hljs-string">"] : "</span>);        builder.append(event.getMsg());        <span class="hljs-comment">//打印LogEvent的数据</span>        System.out.println(builder.toString());    &#125;&#125;</code></pre></div><p>LogEventHandler将以一种简单易读的格式打印LogEvent消息，现在我们需要将我们的LogEventDecoder和LogEventHandler安装到ChannelPipeline中。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogEventMonitor</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventLoopGroup group;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Bootstrap bootstrap;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LogEventMonitor</span><span class="hljs-params">(InetSocketAddress address)</span></span>&#123;        group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        bootstrap = <span class="hljs-keyword">new</span> Bootstrap();        bootstrap.group(group)                .channel(NioDatagramChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                .<span class="hljs-title">option</span>(<span class="hljs-title">ChannelOption</span>.<span class="hljs-title">SO_BROADCAST</span>,<span class="hljs-title">true</span>)</span><span class="hljs-class">                .<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt;() </span>&#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel channel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        ChannelPipeline pipeline = channel.pipeline();                        pipeline.addLast(<span class="hljs-keyword">new</span> LogEventDecoder());                        pipeline.addLast(<span class="hljs-keyword">new</span> LogEventHandler());                    &#125;                &#125;).localAddress(address);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Channel <span class="hljs-title">bind</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> bootstrap.bind().syncUninterruptibly().channel();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>&#123;        group.shutdownGracefully();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        <span class="hljs-keyword">if</span> (args.length != <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Usage:LoEventMonitor &lt;port&gt;"</span>);        &#125;        LogEventMonitor monitor = <span class="hljs-keyword">new</span> LogEventMonitor(<span class="hljs-keyword">new</span> InetSocketAddress(Integer.parseInt(args[<span class="hljs-number">0</span>])));        <span class="hljs-keyword">try</span> &#123;            Channel channel = monitor.bind();            System.out.println(<span class="hljs-string">"LogEventMonitor running"</span>);            channel.closeFuture().sync();        &#125;<span class="hljs-keyword">finally</span> &#123;            monitor.stop();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12.Netty--WebSocket</title>
    <link href="/2020/06/03/12-Netty-WebSocket/"/>
    <url>/2020/06/03/12-Netty-WebSocket/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>实时Web的概念</li><li>WebSocket协议</li><li>使用Netty构建一个基于WebSocket的聊天室服务器</li></ul></blockquote><h1 id="WebSocket简介"><a href="#WebSocket简介" class="headerlink" title="WebSocket简介"></a>WebSocket简介</h1><p>WebSocket协议是完全重新设计的协议，旨在为Web上的双向数据传输问题提供一个切实可行的解决方案，使得客户端与服务器之间可以在任意时刻传输消息。</p><h1 id="我们的WebSocket示例应用程序"><a href="#我们的WebSocket示例应用程序" class="headerlink" title="我们的WebSocket示例应用程序"></a>我们的WebSocket示例应用程序</h1><p><img src="https://img-blog.csdnimg.cn/20200603155650935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="添加WebSocket支持"><a href="#添加WebSocket支持" class="headerlink" title="添加WebSocket支持"></a>添加WebSocket支持</h1><p><img src="https://img-blog.csdnimg.cn/20200603155948230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="处理HTTP请求"><a href="#处理HTTP请求" class="headerlink" title="处理HTTP请求"></a>处理HTTP请求</h2><p>首先我们需要实现处理HTTP请求的组件，这个组件将提供用于访问聊天室并显示由连接的客户端发送的消息的网页。channelRead0()方法的实现是如何转发任何目标URI为/ws的请求的。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpRequestHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">FullHttpRequest</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String wsUri;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> File INDEX;    <span class="hljs-keyword">static</span> &#123;        URL location = HttpRequestHandler<span class="hljs-class">.<span class="hljs-keyword">class</span></span><span class="hljs-class">            .<span class="hljs-title">getProtectionDomain</span>()</span><span class="hljs-class">            .<span class="hljs-title">getCodeSource</span>().<span class="hljs-title">getLocation</span>()</span>;        <span class="hljs-keyword">try</span> &#123;            String path = location.toURI() + <span class="hljs-string">"index.html"</span>;            path = !path.contains(<span class="hljs-string">"file:"</span>) ? path : path.substring(<span class="hljs-number">5</span>);            INDEX = <span class="hljs-keyword">new</span> File(path);        &#125; <span class="hljs-keyword">catch</span> (URISyntaxException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Unable to locate index.html"</span>, e);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpRequestHandler</span><span class="hljs-params">(String wsUri)</span> </span>&#123;        <span class="hljs-keyword">this</span>.wsUri = wsUri;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,FullHttpRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 如果请求了WebSocket协议升级，则增加引用计数（调用retain()方法），并将它传递给下一个 ChannelInboundHandler</span>        <span class="hljs-keyword">if</span> (wsUri.equalsIgnoreCase(request.getUri())) &#123;            ctx.fireChannelRead(request.retain());         &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 处理100 Continue请求以符合HTTP1.1 规范</span>            <span class="hljs-keyword">if</span> (HttpHeaders.is100ContinueExpected(request)) &#123;                 send100Continue(ctx);            &#125;            <span class="hljs-comment">// 读取index.html</span>            RandomAccessFile file = <span class="hljs-keyword">new</span> RandomAccessFile(INDEX, <span class="hljs-string">"r"</span>);             HttpResponse response = <span class="hljs-keyword">new</span> DefaultHttpResponse(            request.getProtocolVersion(), HttpResponseStatus.OK);            response.headers().set(HttpHeaders.Names.CONTENT_TYPE,<span class="hljs-string">"text/plain; charset=UTF-8"</span>);            <span class="hljs-keyword">boolean</span> keepAlive = HttpHeaders.isKeepAlive(request);            <span class="hljs-keyword">if</span> (keepAlive) &#123;                response.headers().set(HttpHeaders.Names.CONTENT_LENGTH, file.length());                response.headers().set( HttpHeaders.Names.CONNECTION,HttpHeaders.Values.KEEP_ALIVE);            &#125;            <span class="hljs-comment">// 将HttpResponse写到客户端</span>            ctx.write(response);             <span class="hljs-keyword">if</span> (ctx.pipeline().get(SslHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>== <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 将index.html写到客户端</span>                ctx.write(<span class="hljs-keyword">new</span> DefaultFileRegion(file.getChannel(), <span class="hljs-number">0</span>, file.length()));             &#125; <span class="hljs-keyword">else</span> &#123;                ctx.write(<span class="hljs-keyword">new</span> ChunkedNioFile(file.getChannel()));            &#125;            <span class="hljs-comment">// 写LastHttpContent并冲刷至客户端</span>            ChannelFuture future = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);             <span class="hljs-comment">// 如果没有请求keep-alive，则在写操作完成后关闭Channel</span>            <span class="hljs-keyword">if</span> (!keepAlive) &#123;                 future.addListener(ChannelFutureListener.CLOSE);            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send100Continue</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;        FullHttpResponse response = <span class="hljs-keyword">new</span> DefaultFullHttpResponse(        HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE);        ctx.writeAndFlush(response);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre></div><p>如果该HTTP请求指向了地址为/ws的URI，那么HttpRequestHandler将调用FullHttpRequest对象上的retain()方法，并通过调用fireChannelRead(msg)方法将它转发给下一个ChannelInboundHandler。之所以需要调用retain()方法，是因为调用channelRead()方法完成之后，它将调用FullHttpRequest对象上的release()方法来释放它的资源。</p><h2 id="处理WebSocket帧"><a href="#处理WebSocket帧" class="headerlink" title="处理WebSocket帧"></a>处理WebSocket帧</h2><p><img src="https://img-blog.csdnimg.cn/20200603203324279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>TextWebSocketFrame是我们唯一真正需要处理的帧类型。Netty提供了WebSocketServerProtocolHandler来处理其他类型的帧。<br>下面代码展示了我们用于处理TextWebSocketFrame的ChannelInboundHandler，其还将在它的ChannelGroup中跟踪所有活动的WebSocket连接。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextWebSocketFrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">TextWebSocketFrame</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelGroup group;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TextWebSocketFrameHandler</span><span class="hljs-params">(ChannelGroup group)</span> </span>&#123;        <span class="hljs-keyword">this</span>.group = group;    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 重写userEventTriggered()方法以处理自定义事件</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 如果该事件表示握手成功，则从该Channelipeline中移除HttpRequestHandler，因为将不会接收到任何HTTP 消息了</span>        <span class="hljs-keyword">if</span> (evt == WebSocketServerProtocolHandler.ServerHandshakeStateEvent.HANDSHAKE_COMPLETE) &#123;            ctx.pipeline().remove(HttpRequestHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            <span class="hljs-comment">// 通知所有已经连接的WebSocket 客户端新的客户端已经连接上了</span>            group.writeAndFlush(<span class="hljs-keyword">new</span> TextWebSocketFrame(<span class="hljs-string">"Client "</span> + ctx.channel() + <span class="hljs-string">" joined"</span>));            <span class="hljs-comment">// 将新的WebSocket Channel添加到ChannelGroup 中，以便它可以接收到所有的消息</span>            group.add(ctx.channel());        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">super</span>.userEventTriggered(ctx, evt);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,TextWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">// 增加消息的引用计数，并将它写到ChannelGroup 中所有已经连接的客户端</span>        group.writeAndFlush(msg.retain());     &#125;&#125;</code></pre></div><p>和之前一样，对于retain()方法的调用是必需的，因为当channelRead0()方法返回时，TextWebSocketFrame 的引用计数将会被减少。由于所有的操作都是异步的，因此，writeAndFlush()方法可能会在channelRead0()方法返回之后完成，而且它绝对不能访问一个已经失效的引用。</p><h2 id="初始化ChannelPipeline"><a href="#初始化ChannelPipeline" class="headerlink" title="初始化ChannelPipeline"></a>初始化ChannelPipeline</h2><p>为了将ChannelHandler安装到ChannelPipeline中，需要扩展ChannelInitializer，并实现initChannel()方法。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatServerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelGroup group;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ChatServerInitializer</span><span class="hljs-params">(ChannelGroup group)</span> </span>&#123;        <span class="hljs-keyword">this</span>.group = group;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//将所有有需要的ChannelHandler添加到ChannelPipeline中</span>        ChannelPipeline pipeline = ch.pipeline();        pipeline.addLast(<span class="hljs-keyword">new</span> HttpServerCodec());        pipeline.addLast(<span class="hljs-keyword">new</span> ChunkedWriteHandler());        pipeline.addLast(<span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">64</span> * <span class="hljs-number">1024</span>));        pipeline.addLast(<span class="hljs-keyword">new</span> HttpRequestHandler(<span class="hljs-string">"/ws"</span>));        pipeline.addLast(<span class="hljs-keyword">new</span> WebSocketServerProtocolHandler(<span class="hljs-string">"/ws"</span>));        pipeline.addLast(<span class="hljs-keyword">new</span> TextWebSocketFrameHandler(group));    &#125;&#125;</code></pre></div><p>下面是基于WebSocket聊天服务器的ChannelHandler及各自的职责：<br><img src="https://img-blog.csdnimg.cn/20200603204803165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Netty的WebSocketServerProtocolHandler处理了所有委托管理的WebSocket帧类型以及升级握手本身，如果握手成功，那么所需的ChannelHandler将会被添加到ChannelPipeline中，而那些不再需要的ChannelHandler则将会被移除。<br>WebSocket 协议升级之前的ChannelPipeline：<br><img src="https://img-blog.csdnimg.cn/20200603205148885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>WebSocket 协议升级完成之后的ChannelPipeline：<br><img src="https://img-blog.csdnimg.cn/20200603205201947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h2><p>由ChatServer类来引导服务器，并安装ChatServerInitializer的代码。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatServer</span> </span>&#123;<span class="hljs-comment">//创建DefaultChannelGroup，其将保存所有已经连接的WebSocketChannel</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelGroup channelGroup =            <span class="hljs-keyword">new</span> DefaultChannelGroup(ImmediateEventExecutor.INSTANCE);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();    <span class="hljs-keyword">private</span> Channel channel;    <span class="hljs-comment">//引导服务器</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">start</span><span class="hljs-params">(InetSocketAddress address)</span> </span>&#123;        ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();        bootstrap.group(group)                .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                .<span class="hljs-title">childHandler</span>(<span class="hljs-title">createInitializer</span>(<span class="hljs-title">channelGroup</span>))</span>;        ChannelFuture future = bootstrap.bind(address);        future.syncUninterruptibly();        channel = future.channel();        <span class="hljs-keyword">return</span> future;    &#125;    <span class="hljs-comment">//创建ChatServerInitializer</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> ChannelInitializer&lt;Channel&gt; <span class="hljs-title">createInitializer</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            ChannelGroup group)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ChatServerInitializer(group);    &#125;    <span class="hljs-comment">//处理服务器关闭，并释放所有的资源</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>) &#123;            channel.close();        &#125;        channelGroup.close();        group.shutdownGracefully();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">if</span> (args.length != <span class="hljs-number">1</span>) &#123;            System.err.println(<span class="hljs-string">"Please give port as argument"</span>);            System.exit(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">int</span> port = Integer.parseInt(args[<span class="hljs-number">0</span>]);        <span class="hljs-keyword">final</span> ChatServer endpoint = <span class="hljs-keyword">new</span> ChatServer();        ChannelFuture future = endpoint.start(                <span class="hljs-keyword">new</span> InetSocketAddress(port));        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                endpoint.destroy();            &#125;        &#125;);        future.channel().closeFuture().syncUninterruptibly();    &#125;&#125;</code></pre></div><h1 id="测试该应用程序"><a href="#测试该应用程序" class="headerlink" title="测试该应用程序"></a>测试该应用程序</h1><p>略</p><h2 id="如何进行加密"><a href="#如何进行加密" class="headerlink" title="如何进行加密"></a>如何进行加密</h2><p>为ChannelPipeline加密：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//扩展ChatServerInitializer来加密</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecureChatServerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChatServerInitializer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SslContext context;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SecureChatServerInitializer</span><span class="hljs-params">(ChannelGroup group, SslContext context)</span> </span>&#123;        <span class="hljs-keyword">super</span>(group);        <span class="hljs-keyword">this</span>.context = context;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">super</span>.initChannel(ch);        <span class="hljs-comment">//调用父类的initChannel()方法</span>        SSLEng.ine engine = context.newEngine(ch.alloc());        engine.setUseClientMode(<span class="hljs-keyword">false</span>);        <span class="hljs-comment">//将SslHandler添加到ChannelPipeline中</span>        ch.pipeline().addFirst(<span class="hljs-keyword">new</span> SslHandler(engine));    &#125;&#125;</code></pre></div><p>最后一步是调整ChatServer以使用SecureChatServerInitializer，以便在ChannelPipeline中安装SslHandler。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecureChatServer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChatServer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SslContext context;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SecureChatServer</span><span class="hljs-params">(SslContext context)</span> </span>&#123;        <span class="hljs-keyword">this</span>.context = context;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> ChannelInitializer&lt;Channel&gt; <span class="hljs-title">createInitializer</span><span class="hljs-params">(ChannelGroup group)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SecureChatServerInitializer(group, context); <span class="hljs-comment">// 返回之前创建的SecureChatServerInitializer 以启用加密</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">if</span> (args.length != <span class="hljs-number">1</span>) &#123;            System.err.println(<span class="hljs-string">"Please give port as argument"</span>);            System.exit(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">int</span> port = Integer.parseInt(args[<span class="hljs-number">0</span>]);        SelfSignedCertificate cert = <span class="hljs-keyword">new</span> SelfSignedCertificate();        SslContext context = SslContext.newServerContext(cert.certificate(), cert.privateKey());        <span class="hljs-keyword">final</span> SecureChatServer endpoint = <span class="hljs-keyword">new</span> SecureChatServer(context);        ChannelFuture future = endpoint.start(<span class="hljs-keyword">new</span> InetSocketAddress(port));        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                endpoint.destroy();            &#125;        &#125;);        future.channel().closeFuture().syncUninterruptibly();    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11.Netty--预置的ChannelHandler和编解码器</title>
    <link href="/2020/06/03/11-Netty-%E9%A2%84%E7%BD%AE%E7%9A%84ChannelHandler%E5%92%8C%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/"/>
    <url>/2020/06/03/11-Netty-%E9%A2%84%E7%BD%AE%E7%9A%84ChannelHandler%E5%92%8C%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>通过SSL/TLS保护Netty应用程序；</li><li>构建基于Netty的HTTP/HTTPS应用程序</li><li>处理空闲的连接和超时</li><li>解码基于分隔符的协议和基于长度的协议</li><li>写大型数据</li><li>Netty为许多通用协议提供了编解码器和处理器，几乎可以开箱即用。</li></ul></blockquote><h1 id="通过SSL-TLS保护Netty应用程序"><a href="#通过SSL-TLS保护Netty应用程序" class="headerlink" title="通过SSL/TLS保护Netty应用程序"></a>通过SSL/TLS保护Netty应用程序</h1><p>为了支持SSL/TLS，Java提供了javax.net.ssl包，它的SSLContext和SSLEngine类使得实现解密和加密相当简单直接。Netty通过一个名为SslHandler的ChannelHandler实现利用了这个API，其中SslHandler在内部使用了SSLEngine来完成实际的工作。<br>下图是通过SslHandler进行解密和加密的数据流。<br><img src="https://img-blog.csdnimg.cn/20200603120939780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Netty还提供了使用OpenSSL工具包的SSLEngine实现，该类提供了比JDK提供的SSLEngine具有更好的性能。<br>下面的代码展示了如何使用ChannelInitializer来将SslHandler添加到ChannelPipeline中。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SslChannelInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt;</span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SslContext context; <span class="hljs-comment">// 传入要使用的SslContext</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> startTls; <span class="hljs-comment">// 如果设置为true，第一个写入的消息将不会被加密（客户端应该设置为true）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SslChannelInitializer</span><span class="hljs-params">(SslContext context,<span class="hljs-keyword">boolean</span> startTls)</span> </span>&#123;        <span class="hljs-keyword">this</span>.context = context;        <span class="hljs-keyword">this</span>.startTls = startTls;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 对于每个SslHandler实例，都使用Channel的ByteBufAllocator从SslContext获取一个新的SSLEngine</span>        SSLEngine engine = context.newEngine(ch.alloc());        <span class="hljs-comment">// 将SslHandler 作为第一个ChannelHandler 添加到ChannelPipeline 中</span>        ch.pipeline().addFirst(<span class="hljs-string">"ssl"</span>,<span class="hljs-keyword">new</span> SslHandler(engine, startTls));    &#125;&#125;</code></pre></div><p>在大多数情况下，SslHandler将是ChannelPipeline中的第一个ChannelHandler，这确保了只有在所有其他的ChannelHandler将他们的逻辑应用到数据之后，才会进行加密。<br>SslHandler提供的一些方法：<br><img src="https://img-blog.csdnimg.cn/20200603121820849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="构建基于Netty的HTTP-HTTPS应用程序"><a href="#构建基于Netty的HTTP-HTTPS应用程序" class="headerlink" title="构建基于Netty的HTTP/HTTPS应用程序"></a>构建基于Netty的HTTP/HTTPS应用程序</h1><h2 id="HTTP解码器、编码器和编解码器"><a href="#HTTP解码器、编码器和编解码器" class="headerlink" title="HTTP解码器、编码器和编解码器"></a>HTTP解码器、编码器和编解码器</h2><p>HTTP是基于请求/响应模式的：客户端向服务器发送一个HTTP请求，然后服务器将会返回一个HTTP响应。<br>下图分别展示了生产和消费HTTP请求和HTTP响应的方法：<br>HTTP 请求的组成部分：<br><img src="https://img-blog.csdnimg.cn/20200603122819791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="HTTP 请求的组成部分"><br>HTTP 响应的组成部分：<br><img src="https://img-blog.csdnimg.cn/20200603122907848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>下面的代码展示了将HTTP支持添加到你的应用程序，几乎只需要将正确的ChannelHandler添加到ChannelPipeline中。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpPipelineInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> client;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpPipelineInitializer</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> client)</span> </span>&#123;        <span class="hljs-keyword">this</span>.client = client;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        <span class="hljs-keyword">if</span> (client) &#123;         <span class="hljs-comment">// 如果是客户端，则添加HttpResponseDecoder来处理来自服务器的响应</span>            pipeline.addLast(<span class="hljs-string">"decoder"</span>, <span class="hljs-keyword">new</span> HttpResponseDecoder());            <span class="hljs-comment">//如果是客户端，则添加HttpRequestEncoder来向服务器发送请求</span>            pipeline.addLast(<span class="hljs-string">"encoder"</span>, <span class="hljs-keyword">new</span> HttpRequestEncoder());        &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//如果是服务器，则添加HttpRequestDecoder来接收来自客户端的请求</span>            pipeline.addLast(<span class="hljs-string">"decoder"</span>, <span class="hljs-keyword">new</span> HttpRequestDecoder());            <span class="hljs-comment">//如果是服务器，则添加HttpResponseEncoder以向客户端发送响应</span>            pipeline.addLast(<span class="hljs-string">"encoder"</span>, <span class="hljs-keyword">new</span> HttpResponseEncoder());        &#125;    &#125;&#125;</code></pre></div><h2 id="聚合HTTP消息"><a href="#聚合HTTP消息" class="headerlink" title="聚合HTTP消息"></a>聚合HTTP消息</h2><p>由于HTTP 的请求和响应可能由许多部分组成，因此你需要聚合它们以形成完整的消息。为了消除这项繁琐的任务，Netty 提供了一个聚合器，它可以将多个消息部分合并为FullHttpRequest 或者FullHttpResponse 消息。<br>引入这种自动聚合机制只不过是向ChannelPipeline中添加另外一个ChannelHandler罢了。<br>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 自动聚合HTTP 的消息片段</span><span class="hljs-comment">*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpAggregatorInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isClient;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpAggregatorInitializer</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isClient)</span> </span>&#123;        <span class="hljs-keyword">this</span>.isClient = isClient;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        <span class="hljs-keyword">if</span> (isClient) &#123;            pipeline.addLast(<span class="hljs-string">"codec"</span>, <span class="hljs-keyword">new</span> HttpClientCodec());        &#125; <span class="hljs-keyword">else</span> &#123;            pipeline.addLast(<span class="hljs-string">"codec"</span>, <span class="hljs-keyword">new</span> HttpServerCodec());        &#125;        <span class="hljs-comment">//将最大的消息大小为512KB的HttpObjectAggregator添加到ChannelPipeline</span>        pipeline.addLast(<span class="hljs-string">"aggregator"</span>,<span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">512</span> * <span class="hljs-number">1024</span>));    &#125;&#125;</code></pre></div><h2 id="HTTP压缩"><a href="#HTTP压缩" class="headerlink" title="HTTP压缩"></a>HTTP压缩</h2><p>Netty 为压缩和解压缩提供了ChannelHandler 实现，它们同时支持gzip 和deflate 编码。<br>客户端可以通过提供以下头部信息来指示服务器它所支持的压缩格式：</p><div class="hljs"><pre><code class="hljs markup">GET &#x2F;encrypted-area HTTP&#x2F;1.1Host: www.example.comAccept-Encoding: gzip, deflate</code></pre></div><p>注意：服务器不需要压缩它所发送的数据<br>下面代码展示了自动压缩HTTP消息</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 自动压缩HTTP 消息</span><span class="hljs-comment">*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpCompressionInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isClient;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpCompressionInitializer</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isClient)</span> </span>&#123;        <span class="hljs-keyword">this</span>.isClient = isClient;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        <span class="hljs-keyword">if</span> (isClient) &#123;            pipeline.addLast(<span class="hljs-string">"codec"</span>, <span class="hljs-keyword">new</span> HttpClientCodec());            <span class="hljs-comment">// 如果是客户端，则添加HttpContentDecompressor 以处理来自服务器的压缩内容.</span>            pipeline.addLast(<span class="hljs-string">"decompressor"</span>,<span class="hljs-keyword">new</span> HttpContentDecompressor());        &#125; <span class="hljs-keyword">else</span> &#123;            pipeline.addLast(<span class="hljs-string">"codec"</span>, <span class="hljs-keyword">new</span> HttpServerCodec());            <span class="hljs-comment">// 如果是服务器，则添加HttpContentCompressor来压缩数据（如果客户端支持它）</span>            pipeline.addLast(<span class="hljs-string">"compressor"</span>,<span class="hljs-keyword">new</span> HttpContentCompressor());        &#125;    &#125;&#125;</code></pre></div><h2 id="使用HTTPS"><a href="#使用HTTPS" class="headerlink" title="使用HTTPS"></a>使用HTTPS</h2><p>启用HTTPS只需要将SslHandler添加到ChannelPipeline的ChannelHandler组合中。<br>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpsCodecInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SslContext context;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isClient;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpsCodecInitializer</span><span class="hljs-params">(SslContext context, <span class="hljs-keyword">boolean</span> isClient)</span> </span>&#123;        <span class="hljs-keyword">this</span>.context = context;        <span class="hljs-keyword">this</span>.isClient = isClient;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        SSLEngine engine = context.newEngine(ch.alloc());        <span class="hljs-comment">//将SslHandler添加到ChannelPipeline中以使用HTTPS</span>        pipeline.addFirst(<span class="hljs-string">"ssl"</span>, <span class="hljs-keyword">new</span> SslHandler(engine));        <span class="hljs-comment">//如果是客户端，则添加HttpClientCodec</span>        <span class="hljs-keyword">if</span> (isClient) &#123;            pipeline.addLast(<span class="hljs-string">"codec"</span>, <span class="hljs-keyword">new</span> HttpClientCodec());        <span class="hljs-comment">//如果是服务器，则添加HttpServerCodec</span>        &#125; <span class="hljs-keyword">else</span> &#123;            pipeline.addLast(<span class="hljs-string">"codec"</span>, <span class="hljs-keyword">new</span> HttpServerCodec());        &#125;    &#125;&#125;</code></pre></div><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket为网页和远程服务器之间的双向通信提供了一种替代HTTP轮询的方案。<br>如果想要在应用程序中添加对于WebSocket的支持，只需要将适当的客户端或者服务器WebSocketChannelHandler添加到ChannelPipeline中，这个类将处理由WebSocket定义的称为帧的特殊消息类型。<br>WebSocket协议如下：<br><img src="https://img-blog.csdnimg.cn/2020060313363214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>WebSocketFrame可以被归类于数据帧或者控制帧，主要类型如下：<br><img src="https://img-blog.csdnimg.cn/20200603133805130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在服务器端支持WebSocket的代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketServerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt;</span>&#123;    <span class="hljs-meta">@Override</span>        ch.pipeline().addLast(        <span class="hljs-keyword">new</span> HttpServerCodec(),        <span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">65536</span>), <span class="hljs-comment">// 为握手提供聚合的HttpRequest</span>        <span class="hljs-keyword">new</span> WebSocketServerProtocolHandler(<span class="hljs-string">"/websocket"</span>), <span class="hljs-comment">// 如果被请求的端点是"/websocket"，则处理该升级握手</span>        <span class="hljs-keyword">new</span> TextFrameHandler(), <span class="hljs-comment">// TextFrameHandler 处理TextWebSocketFrame</span>        <span class="hljs-keyword">new</span> BinaryFrameHandler(),        <span class="hljs-keyword">new</span> ContinuationFrameHandler());    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextFrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">TextWebSocketFrame</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,TextWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Handle text frame</span>        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryFrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">BinaryWebSocketFrame</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,BinaryWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Handle binary frame</span>        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContinuationFrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ContinuationWebSocketFrame</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,ContinuationWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Handle continuation frame</span>        &#125;    &#125;&#125;</code></pre></div><p>想要为WebSocket添加安全性，只需要将SslHandler作为第一个ChannelHandler添加到ChannelPipeline中。</p><h1 id="空闲的连接和超时"><a href="#空闲的连接和超时" class="headerlink" title="空闲的连接和超时"></a>空闲的连接和超时</h1><p>检测空闲连接以及超时连接对于及时释放资源来说是至关重要的，Netty特地为它提供了几个ChannelHandler实现。<br><img src="https://img-blog.csdnimg.cn/20200603142124762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>下列代码展示了当我们通常的发送心跳消息到远程节点的方法时，如果在60s内没有接收或者发送任何的数据，我们将如何得到通知；如果没有响应，则连接会被关闭。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdleStateHandlerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        <span class="hljs-comment">// IdleStateHandler 将在被触发时发送一个IdleStateEvent 事件</span>        pipeline.addLast(<span class="hljs-keyword">new</span> IdleStateHandler(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS));        <span class="hljs-comment">//将一个HeartbeatHandler添加到ChannelPipeline中</span>        pipeline.addLast(<span class="hljs-keyword">new</span> HeartbeatHandler());    &#125;    <span class="hljs-comment">//实现userEventTriggered()方法以发送心跳消息</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeartbeatHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-comment">//发送到远程节点的心跳消息</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ByteBuf HEARTBEAT_SEQUENCE =Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(<span class="hljs-string">"HEARTBEAT"</span>, CharsetUtil.ISO_8859_1));        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx,Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-keyword">if</span> (evt <span class="hljs-keyword">instanceof</span> IdleStateEvent) &#123;             <span class="hljs-comment">// 发送心跳消息，并在发送失败时关闭该连接</span>                ctx.writeAndFlush(HEARTBEAT_SEQUENCE.duplicate())                    .addListener(ChannelFutureListener.CLOSE_ON_FAILURE);            &#125; <span class="hljs-keyword">else</span> &#123;             <span class="hljs-comment">// 不是IdleStateEvent事件，所以将它传递给下一个ChannelInboundHandler</span>                <span class="hljs-keyword">super</span>.userEventTriggered(ctx, evt);            &#125;        &#125;    &#125;&#125;</code></pre></div><p>上面这个示例演示了如何使用IdleStateHandler来测试远程节点是否仍然还活着，并且在它失活时通过关闭连接来释放资源。<br>如果连接超过60s没有接收或者发送任何的数据，那么IdleStateHandler将会使用一个IdleStateEvent事件来调用fireUserEventTriggered()方法。HeartbeatHandler实现了userEventTriggered()方法，如果这个方法检测到IdleSstateEvent事件，它将会发送心跳消息，并且添加一个将在发送操作失败时关闭该连接的ChannelFutureListener。</p><h1 id="解码基于分隔符的协议和基于长度的协议"><a href="#解码基于分隔符的协议和基于长度的协议" class="headerlink" title="解码基于分隔符的协议和基于长度的协议"></a>解码基于分隔符的协议和基于长度的协议</h1><h2 id="基于分隔符的协议"><a href="#基于分隔符的协议" class="headerlink" title="基于分隔符的协议"></a>基于分隔符的协议</h2><p>基于分隔符的（delimited）消息协议使用定义的字符来标记的消息或者消息段（通常被称为帧）的开头或者结尾。由RFC文档正式定义的许多协议（如SMTP、POP3、IMAP以及Telnet）都是这样的。<br><img src="https://img-blog.csdnimg.cn/20200603143648459.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>下图展示了当帧由行尾序列\r\n分割时是如何被处理的：<br><img src="https://img-blog.csdnimg.cn/20200603143900748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LineBasedHandlerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        <span class="hljs-comment">//该LineBasedFrameDecoder将提取的帧转发给下一个ChannelInboundHandler</span>        pipeline.addLast(<span class="hljs-keyword">new</span> LineBasedFrameDecoder(<span class="hljs-number">64</span> * <span class="hljs-number">1024</span>));        <span class="hljs-comment">//添加FrameHandler来接收帧</span>        pipeline.addLast(<span class="hljs-keyword">new</span> FrameHandler());    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-comment">//传入了单个帧的内容</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Do something with the data extracted from the frame</span>        &#125;    &#125;&#125;</code></pre></div><p>作为示例，我们将使用下面的协议规范：<br>1.传入数据流是一系列的帧，每个帧都由换行符（\n）分隔；<br>2.每个帧都由一系列的元素组成，每个元素都由单个空格字符分隔；<br>3.一个帧的内容代表一个命令，定义为一个命令名称后跟着数目可变的参数。<br>我们用于这个协议的自定义解码器将定义以下类：<br>1.Cmd—将帧（命令）的内容存储在ByteBuf 中，一个ByteBuf 用于名称，另一个用于参数；<br>2.CmdDecoder—从被重写了的decode()方法中获取一行字符串，并从它的内容构建一个Cmd 的实例；<br>3.CmdHandler —从CmdDecoder 获取解码的Cmd 对象，并对它进行一些处理；<br>4.CmdHandlerInitializer —为了简便起见，我们将会把前面的这些类定义为专门的ChannelInitializer 的嵌套类，其将会把这些ChannelInboundHandler 安装到ChannelPipeline 中。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CmdHandlerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> SPACE = (<span class="hljs-keyword">byte</span>)<span class="hljs-string">' '</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        pipeline.addLast(<span class="hljs-keyword">new</span> CmdDecoder(<span class="hljs-number">64</span> * <span class="hljs-number">1024</span>)); <span class="hljs-comment">// 添加CmdDecoder 以提取Cmd 对象，并将它转发给下一个ChannelInboundHandler</span>        pipeline.addLast(<span class="hljs-keyword">new</span> CmdHandler()); <span class="hljs-comment">// 添加CmdHandler 以接收和处理Cmd 对象</span>    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cmd</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ByteBuf name;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ByteBuf args;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cmd</span><span class="hljs-params">(ByteBuf name, ByteBuf args)</span> </span>&#123;            <span class="hljs-keyword">this</span>.name = name;            <span class="hljs-keyword">this</span>.args = args;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> name;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title">args</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> args;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CmdDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LineBasedFrameDecoder</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CmdDecoder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxLength)</span> </span>&#123;            <span class="hljs-keyword">super</span>(maxLength);        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf buffer)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//从ByteBuf中提取由行尾符序列分割的帧</span>            ByteBuf frame = (ByteBuf) <span class="hljs-keyword">super</span>.decode(ctx, buffer);            <span class="hljs-keyword">if</span> (frame == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            <span class="hljs-comment">// 查找第一个空格字符的索引。前面是命令名称，接着是参数</span>            <span class="hljs-keyword">int</span> index = frame.indexOf(frame.readerIndex(),frame.writerIndex(), SPACE);            <span class="hljs-comment">// 使用包含有命令名称和参数的切片创建新的Cmd 对象</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Cmd(frame.slice(frame.readerIndex(), index),frame.slice(index + <span class="hljs-number">1</span>, frame.writerIndex()));        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CmdHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">Cmd</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, Cmd msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Do something with the command(获取Cmd对象进一步操作)</span>        &#125;    &#125;&#125;</code></pre></div><h2 id="基于长度的协议"><a href="#基于长度的协议" class="headerlink" title="基于长度的协议"></a>基于长度的协议</h2><p><img src="https://img-blog.csdnimg.cn/20200603144720346.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200603144751918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>如果遇到被编码到消息头部的帧大小不是固定值的协议，为了处理这种变长帧，可以使用LengthFieldBasedFrameDecoder，它将从头部字段确定帧长，然后从数据流中提取指定的字节数。<br><img src="https://img-blog.csdnimg.cn/20200603145131132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LengthBasedInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        pipeline.addLast(<span class="hljs-keyword">new</span> LengthFieldBasedFrameDecoder(<span class="hljs-number">64</span> * <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>));        pipeline.addLast(<span class="hljs-keyword">new</span> FrameHandler());    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Do something with the frame</span>        &#125;    &#125;&#125;</code></pre></div><h1 id="写大型数据"><a href="#写大型数据" class="headerlink" title="写大型数据"></a>写大型数据</h1><p>由于写操作是非阻塞的，所在存在内存耗尽的风险，因此在写大型数据时，需要准备好处理到远程节点的连接是慢速连接的情况，这种情况会导致内存释放的延迟。<br>下面代码展示了如何通过从FileInputStream创建一个DefaultRegion，并将其写入Channel，从而利用零拷贝特性来传输一个文件的内容。</p><div class="hljs"><pre><code class="hljs java">FileInputStream in = <span class="hljs-keyword">new</span> FileInputStream(file);<span class="hljs-comment">// 以该文件的完整长度创建一个新的DefaultFileRegion</span>FileRegion region = <span class="hljs-keyword">new</span> DefaultFileRegion(in.getChannel(), <span class="hljs-number">0</span>, file.length());<span class="hljs-comment">// 发送该DefaultFileRegion，并注册一个ChannelFutureListener</span>channel.writeAndFlush(region).addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">if</span> (!future.isSuccess()) &#123;            Throwable cause = future.cause(); <span class="hljs-comment">// 处理失败</span>            <span class="hljs-comment">// Do something</span>        &#125;    &#125;&#125;);</code></pre></div><p>这个示例只适用于文件内容的直接传输，不包括应用程序对数据的任何处理。在需要将数据从文件系统复制到用户内存中时，可以使用ChunkedWriteHandler，它支持异步写大型数据流，而又不会导致大量的内存消耗。<br><img src="https://img-blog.csdnimg.cn/20200603150611949.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>下面代码展示了ChunkedStream的用法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChunkedWriteHandlerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> File file;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SslContext sslCtx;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ChunkedWriteHandlerInitializer</span><span class="hljs-params">(File file, SslContext sslCtx)</span> </span>&#123;        <span class="hljs-keyword">this</span>.file = file;        <span class="hljs-keyword">this</span>.sslCtx = sslCtx;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        <span class="hljs-comment">//将SslHandler添加到ChannelPipeline中</span>        pipeline.addLast(<span class="hljs-keyword">new</span> SslHandler(sslCtx.newEngine(ch.alloc());        <span class="hljs-comment">//添加ChunkedWritHandler以处理作为ChunkedInput传入的数据</span>        pipeline.addLast(<span class="hljs-keyword">new</span> ChunkedWriteHandler());        <span class="hljs-comment">// 一旦连接建立，WriteStreamHandler就开始写文件数据</span>        pipeline.addLast(<span class="hljs-keyword">new</span> WriteStreamHandler());     &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteStreamHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-comment">//当连接建立时，channelActive()方法将使用ChunkedInput写文件数据</span>        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span><span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-keyword">super</span>.channelActive(ctx);            ctx.writeAndFlush(<span class="hljs-keyword">new</span> ChunkedStream(<span class="hljs-keyword">new</span> FileInputStream(file)));        &#125;    &#125;&#125;</code></pre></div><h1 id="序列化数据"><a href="#序列化数据" class="headerlink" title="序列化数据"></a>序列化数据</h1><h2 id="JDK序列化"><a href="#JDK序列化" class="headerlink" title="JDK序列化"></a>JDK序列化</h2><p><img src="https://img-blog.csdnimg.cn/20200603151321484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="JBoss-Marshalling序列化"><a href="#JBoss-Marshalling序列化" class="headerlink" title="JBoss Marshalling序列化"></a>JBoss Marshalling序列化</h2><p><img src="https://img-blog.csdnimg.cn/20200603151359976.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>下面代码展示了如何使用MarshallingDecoder和MarshallingEncoder：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MarshallingInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MarshallerProvider marshallerProvider;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UnmarshallerProvider unmarshallerProvider;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MarshallingInitializer</span><span class="hljs-params">(UnmarshallerProvider unmarshallerProvider,MarshallerProvider marshallerProvider)</span> </span>&#123;        <span class="hljs-keyword">this</span>.marshallerProvider = marshallerProvider;        <span class="hljs-keyword">this</span>.unmarshallerProvider = unmarshallerProvider;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel channel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = channel.pipeline();        <span class="hljs-comment">//添加MarshallingDecoder以将ByteBuf转换为POJO</span>        pipeline.addLast(<span class="hljs-keyword">new</span> MarshallingDecoder(unmarshallerProvider));        <span class="hljs-comment">//添加MarshallingEncoder以将POJO转换为ByteBuf</span>        pipeline.addLast(<span class="hljs-keyword">new</span> MarshallingEncoder(marshallerProvider));        <span class="hljs-comment">// 添加ObjectHandler，以处理普通的实现了Serializable 接口的POJO</span>        pipeline.addLast(<span class="hljs-keyword">new</span> ObjectHandler());     &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">Serializable</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext,Serializable serializable)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Do something</span>        &#125;    &#125;&#125;</code></pre></div><h2 id="Protocol-Buffers序列化"><a href="#Protocol-Buffers序列化" class="headerlink" title="Protocol Buffers序列化"></a>Protocol Buffers序列化</h2><p>Protocol Buffers 以一种紧凑而高效的方式对结构化的数据进行编码以及解码。它具有许多的编程语言绑定，使得它很适合跨语言的项目。(由Google公司开发的、现在已经开源的数据交换格式。)<br><img src="https://img-blog.csdnimg.cn/20200603151801160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProtoBufInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MessageLite lite;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProtoBufInitializer</span><span class="hljs-params">(MessageLite lite)</span> </span>&#123;        <span class="hljs-keyword">this</span>.lite = lite;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        pipeline.addLast(<span class="hljs-keyword">new</span> ProtobufVarint32FrameDecoder());        pipeline.addLast(<span class="hljs-keyword">new</span> ProtobufEncoder()); ①        pipeline.addLast(<span class="hljs-keyword">new</span> ProtobufDecoder(lite));        pipeline.addLast(<span class="hljs-keyword">new</span> ObjectHandler());    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Do something with the object</span>        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10.Netty--编解码器框架</title>
    <link href="/2020/06/02/10-Netty-%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E6%A1%86%E6%9E%B6/"/>
    <url>/2020/06/02/10-Netty-%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>解码器、编码器以及编解码器的概述</li><li>Netty的编解码器类</li></ul></blockquote><h2 id="什么是编解码器"><a href="#什么是编解码器" class="headerlink" title="什么是编解码器"></a>什么是编解码器</h2><ul><li><p>编码器是将消息转换为适合于传输的格式（最有可能的就是字节流）；</p></li><li><p>解码器则是将网络字节流换回应用程序的消息格式；</p></li><li><p>编码器操作出站数据，解码器处理入站数据；</p></li></ul><h2 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h2><ul><li><p>将字节码解码为消息———ByteToMessageDecoder和ReplayingDecoder；</p></li><li><p>将一种消息类型解码为另一种———MessageToMessagedecoder</p></li></ul><p>因为解码器是负责将入站数据从一种格式转换到另一种格式，所以Netty的解码器实现了ChannelInboundHandler。</p><p>每当需要为ChannelPipeline中的下一个ChannelInboundHanler转换入站数据时会用到解码器，可以将多个解码器链接在一起，以实现任意复杂的转换逻辑。</p><h3 id="抽象类ByteToMessageDecoder"><a href="#抽象类ByteToMessageDecoder" class="headerlink" title="抽象类ByteToMessageDecoder"></a>抽象类ByteToMessageDecoder</h3><p>由于你不可能知道远程节点是否会一次性地发送一个完整的消息，所以这个类会对入站数据进行缓冲，直到它准备好处理。</p><p>ByteToMessageDecoder方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>decode(ChannelHandlerContext ctx,ByteBuf in,List<Objext> out)</td><td>decode()方法被调用时将会传入一个包含了传入数据的ByteBuf，以及一个用来添加解码消息的List，对这个方法的调用将会重复进行，直到确定没有新的元素被添加到该List，或者该ByteBuf中没有更多可读取的字节时为止。然后，如果该List不为空，那么它的内容将会被传递给ChannelPipeline中的下一个ChannelInboundHandler。</td></tr><tr><td>decodeLast(ChannelHandlerContext ctx,ByteBuf in,Lists<Object>out)</td><td>默认实现只是简单地调用了decode()方法，当Channel的状态变为非活动时，这个方法将会被调用一次，可以重写该方法来提供特殊的处理，比如用来产生一个LastHttpContent消息</td></tr></tbody></table><p>示例：假设你接收了一个包含简单int的字节流，每个int都需要被单独处理，在这种情况下，你需要从入站ByteBuf中读取每个int，并将它传递给ChannelPipeline中的下一个ChannelInboundHandler。为了解码这个字节流，你要扩展ByteToMessageDecoder类。</p><p><img src="https://img-blog.csdnimg.cn/20200603100430311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToIntegerDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in,</span></span><span class="hljs-function"><span class="hljs-params">        List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//检查是否至少有 4 字节可读（一个 int 的字节长度）</span>        <span class="hljs-keyword">if</span> (in.readableBytes() &gt;= <span class="hljs-number">4</span>) &#123;            <span class="hljs-comment">//从入站 ByteBuf 中读取一个 int，并将其添加到解码消息的 List 中</span>            out.add(in.readInt());        &#125;    &#125;&#125;</code></pre></div><h3 id="抽象类ReplayingDecoder"><a href="#抽象类ReplayingDecoder" class="headerlink" title="抽象类ReplayingDecoder"></a>抽象类ReplayingDecoder</h3><p>ReplayingDecoder扩展了ByteToMessageDecoder类，不必调用readableBytes()方法。它通过使用一个自定义的ByteBuf也就是ReplayingDecoderByteBuf来实现，包装传入的ByteBuf实现了这一点，readableBytes()方法将在内部执行。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToIntegerDecoder2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReplayingDecoder</span>&lt;<span class="hljs-title">Void</span>&gt; </span>&#123; <span class="hljs-comment">// 扩展ReplayingDecoder&lt;Void&gt;以将字节解码为消息</span>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 传入的ByteBuf 是ReplayingDecoderByteBuf</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in,List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;     <span class="hljs-comment">//从入站ByteBuf中读取一个int，并将其添加</span>        out.add(in.readInt());    &#125;&#125;</code></pre></div><p>如果没有足够的字节可用，这个readInt()方法的实现将会抛出一个Error（实际上是Signal），其将在基类中被捕获并处理，当有更多的数据可供读取时，该decode()方法将会被再次调用。<br>这里有一个简单的准则：如果使用ByteToMessageDecoder 不会引入太多的复杂性，那么请使用它；否则，请使用ReplayingDecoder。</p><h2 id="抽象类MessageToMessageDecoder"><a href="#抽象类MessageToMessageDecoder" class="headerlink" title="抽象类MessageToMessageDecoder"></a>抽象类MessageToMessageDecoder</h2><p>这里我们将编写一个IntegerToStringDecoder解码器来扩展MessageToMessageDecoder<Integer>,尖括号里面的参数代表了输入参数的类型。<br><img src="https://img-blog.csdnimg.cn/20200603102908817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerToStringDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageDecoder</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        out.add(String.valueOf(msg));    &#125;&#125;</code></pre></div><h2 id="TooLongFrameException类"><a href="#TooLongFrameException类" class="headerlink" title="TooLongFrameException类"></a>TooLongFrameException类</h2><p>Netty提供了TooLongFrameException类，其将由解码器在帧超出指定的大小限制时抛出。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SafeByteToMessageDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_FRAME_SIZE = <span class="hljs-number">1024</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in,</span></span><span class="hljs-function"><span class="hljs-params">        List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">int</span> readable = in.readableBytes();        <span class="hljs-keyword">if</span> (readable &gt; MAX_FRAME_SIZE) &#123; <span class="hljs-comment">// 检查缓冲区中是否有超过MAX_FRAME_SIZE个字节</span>            in.skipBytes(readable); <span class="hljs-comment">// 跳过所有的可读字节，抛出TooLongFrameException 并通知ChannelHandler</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TooLongFrameException(<span class="hljs-string">"Frame too big!"</span>);        &#125;        <span class="hljs-comment">// do something</span>        ...    &#125;&#125;</code></pre></div><h1 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h1><p>编码器实现了ChannelOutBoundHandler，并将出站数据从一种格式转换为另一种格式。Netty提供了一组类，用于帮助你编写具有以下功能的编码器：<br>将消息编码为字节；<br>将消息编码为另一种格式的消息；</p><h2 id="抽象类MessageToByteEncoder"><a href="#抽象类MessageToByteEncoder" class="headerlink" title="抽象类MessageToByteEncoder"></a>抽象类MessageToByteEncoder</h2><p><img src="https://img-blog.csdnimg.cn/20200603103905581.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>这个类只有一个方法，而解码器有两个，这是因为解码器通常需要在Channel关闭之后产生最后一个消息，因此也就有了decodeLast()方法，但是编码器就没必要在连接被关闭后仍产生消息了。<br>示例：接收一个Short类型的实例作为消息，将它编码为Short的原子类型，并将它写入ByteBuf中，其将随后被转发给ChannelPipeline中的下一个ChannelOutboundHandler，每个传出的Short值都将会被占用ByteBuf中的2字节。<br><img src="https://img-blog.csdnimg.cn/20200603104641304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShortToByteEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">Short</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Short msg, ByteBuf out)</span><span class="hljs-keyword">throws</span> Exception </span>&#123;        out.writeShort(msg);    &#125;&#125;</code></pre></div><h2 id="抽象类MessageToMessageEncoder"><a href="#抽象类MessageToMessageEncoder" class="headerlink" title="抽象类MessageToMessageEncoder"></a>抽象类MessageToMessageEncoder</h2><p>示例：使用IntegerToStringEncoder扩展了MessageToMessageEncoder，设计如图所示：<br><img src="https://img-blog.csdnimg.cn/20200603105140614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerToStringEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageEncoder</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        out.add(String.valueOf(msg));    &#125;&#125;</code></pre></div><h1 id="抽象的编解码器类"><a href="#抽象的编解码器类" class="headerlink" title="抽象的编解码器类"></a>抽象的编解码器类</h1><h2 id="抽象类ByteToMessageCodec"><a href="#抽象类ByteToMessageCodec" class="headerlink" title="抽象类ByteToMessageCodec"></a>抽象类ByteToMessageCodec</h2><p>应用场景：我们需要将字节解码为某种形式的消息，随后再次对它进行编码。<br><img src="https://img-blog.csdnimg.cn/20200603110056715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="抽象类MessageToMessageCodec"><a href="#抽象类MessageToMessageCodec" class="headerlink" title="抽象类MessageToMessageCodec"></a>抽象类MessageToMessageCodec</h2><p><img src="https://img-blog.csdnimg.cn/20200603111222346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>下面代码展示了Web浏览器与服务器之间的双向通信可能的实现方式：我们的WebSocketConvertHandler在参数化MessageToMessageCodec时将使用INBOUN_IN类型的WebSocketFrame，以及OUTBOUND_IN类型的MyWebSocketFrame，后者是WebSocketConvertHandler本身的一个静态嵌套类。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketConvertHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageCodec</span>&lt;<span class="hljs-title">WebSocketFrame</span>, <span class="hljs-title">WebSocketConvertHandler</span>.<span class="hljs-title">MyWebSocketFrame</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 将MyWebSocketFrame 编码为指定的WebSocketFrame 子类型</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, WebSocketConvertHandler.MyWebSocketFrame msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ByteBuf payload = msg.getData().duplicate().retain();        <span class="hljs-keyword">switch</span> (msg.getType()) &#123; <span class="hljs-comment">// 实例化一个指定子类型的WebSocketFrame</span>            <span class="hljs-keyword">case</span> BINARY:                out.add(<span class="hljs-keyword">new</span> BinaryWebSocketFrame(payload));                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> TEXT:                out.add(<span class="hljs-keyword">new</span> TextWebSocketFrame(payload));                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> CLOSE:                out.add(<span class="hljs-keyword">new</span> CloseWebSocketFrame(<span class="hljs-keyword">true</span>, <span class="hljs-number">0</span>, payload));                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> CONTINUATION:                out.add(<span class="hljs-keyword">new</span> ContinuationWebSocketFrame(payload));                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> PONG:                out.add(<span class="hljs-keyword">new</span> PongWebSocketFrame(payload));                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> PING:                out.add(<span class="hljs-keyword">new</span> PingWebSocketFrame(payload));                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(                        <span class="hljs-string">"Unsupported websocket msg "</span> + msg);        &#125;    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 将WebSocketFrame 解码为MyWebSocketFrame，并设置FrameType</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, WebSocketFrame msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ByteBuf payload = msg.content().duplicate().retain();        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> BinaryWebSocketFrame) &#123;            out.add(<span class="hljs-keyword">new</span> MyWebSocketFrame(                    MyWebSocketFrame.FrameType.BINARY, payload));        &#125; <span class="hljs-keyword">else</span>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> CloseWebSocketFrame) &#123;            out.add(<span class="hljs-keyword">new</span> MyWebSocketFrame (                    MyWebSocketFrame.FrameType.CLOSE, payload));        &#125; <span class="hljs-keyword">else</span>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> PingWebSocketFrame) &#123;            out.add(<span class="hljs-keyword">new</span> MyWebSocketFrame (                    MyWebSocketFrame.FrameType.PING, payload));        &#125; <span class="hljs-keyword">else</span>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> PongWebSocketFrame) &#123;            out.add(<span class="hljs-keyword">new</span> MyWebSocketFrame (                    MyWebSocketFrame.FrameType.PONG, payload));        &#125; <span class="hljs-keyword">else</span>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> TextWebSocketFrame) &#123;            out.add(<span class="hljs-keyword">new</span> MyWebSocketFrame (                    MyWebSocketFrame.FrameType.TEXT, payload));        &#125; <span class="hljs-keyword">else</span>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> ContinuationWebSocketFrame) &#123;            out.add(<span class="hljs-keyword">new</span> MyWebSocketFrame (                    MyWebSocketFrame.FrameType.CONTINUATION, payload));        &#125; <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(                    <span class="hljs-string">"Unsupported websocket msg "</span> + msg);        &#125;    &#125;    <span class="hljs-comment">//声明WebSocketConvertHandler所使用的OUTBOUND_IN类型</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebSocketFrame</span> </span>&#123;    <span class="hljs-comment">//定义拥有被包装的有效负载的WebSocketFrame的类型</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> FrameType &#123;            BINARY,            CLOSE,            PING,            PONG,            TEXT,            CONTINUATION        &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> FrameType type;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ByteBuf data;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyWebSocketFrame</span><span class="hljs-params">(FrameType type, ByteBuf data)</span> </span>&#123;            <span class="hljs-keyword">this</span>.type = type;            <span class="hljs-keyword">this</span>.data = data;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> FrameType <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> type;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> data;        &#125;    &#125;&#125;</code></pre></div><h2 id="CombinedChannelDuplexHandler类"><a href="#CombinedChannelDuplexHandler类" class="headerlink" title="CombinedChannelDuplexHandler类"></a>CombinedChannelDuplexHandler类</h2><p>结合一个解码器和编码器可能会对可重用性造成影响。但是，有一种方法既能够避免这种惩罚，又不会牺牲将一个解码器和一个编码器作为一个单独的单元部署所带来的便利性。CombinedChannelDuplexHandler 提供了这个解决方案，其声明为：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CombinedChannelDuplexHandler</span> &lt;<span class="hljs-title">I</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandler</span>,<span class="hljs-title">O</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelOutboundHandler</span>&gt;</span></code></pre></div><p>首先看看ByteToCharDecoder类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteToCharDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in,</span></span><span class="hljs-function"><span class="hljs-params">        List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">while</span> (in.readableBytes() &gt;= <span class="hljs-number">2</span>) &#123;            out.add(in.readChar());        &#125;    &#125;&#125;</code></pre></div><p>这里的decode()方法一次将从ByteBuf中提取2字节，并将它们作为char写入到List中，其将会被自动装箱为Character对象。<br>再来看看CharToByteEncoder类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CharToByteEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">Character</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Character msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        out.writeChar(msg);    &#125;&#125;</code></pre></div><p>既然我们有了编码器和解码器，我们可以将它们结合起来构建一个编解码器：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//通过该编码器和解码器实现参数化CombinnedByteCharCodec</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CombinedByteCharCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CombinedChannelDuplexHandler</span>&lt;<span class="hljs-title">ByteToCharDecoder</span>, <span class="hljs-title">CharToByteEncoder</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CombinedByteCharCodec</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//将委托实例传递给父类</span>        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> ByteToCharDecoder(), <span class="hljs-keyword">new</span> CharToByteEncoder());    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.Netty--单元测试</title>
    <link href="/2020/06/02/9-Netty-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <url>/2020/06/02/9-Netty-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>单元测试</li><li>EmbeddedChannel概述</li><li>使用EmbeddedChannel测试ChannelHandler</li></ul></blockquote><p>单元测试的标准：不仅能够证明你的实现是正确的，而且还要能够很容易地隔离那些因修改代码而突然出现的问题。</p><p>因为正在被测试的代码模块或者单元将在它正常的运行环境之外被执行，所以还需要一个框架或者脚手架以便在其中运行它（这里我们选择的是JUnit4）。</p><h2 id="EmbeddedChannel概述"><a href="#EmbeddedChannel概述" class="headerlink" title="EmbeddedChannel概述"></a>EmbeddedChannel概述</h2><p>我们的业务逻辑是通过将ChannelPipeline中的ChannelHandler实现链接在一起来完成的，每个ChannelHandler都将处理一个明确定义的任务或者是步骤。</p><p>Netty提供了EmbeddedChannel，用于测试ChannelHandler，其原理就是将入站数据或者出站数据写入EmbeddedChannel中，然后检查是否有任何东西到达了ChannelPipeline的尾端，以这种方式便可以确定消息是否已经被编译或者被解码过了，以及是否触发了任何的ChannelHandler动作。</p><p>EmbeddedChannel方法：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>writeInbound(Object…msgs)</td><td>将入站消息写入到EmbeddedChannel中，如果可以通过readInbound()方法从EmbeddedChannel中读取数据，则返回true</td></tr><tr><td>readInbound()</td><td>从EmbeddedChannel中读取一个入站消息，任何返回的消息都经过了整个ChannelPipeline，如果没有数据则返回null</td></tr><tr><td>writeOutbound(…)</td><td>将出站消息写入到EmbeddedChannel中，如果可以通过readOutbound()方法从EmbeddedChannel中读取数据，则返回true</td></tr><tr><td>readOutbound(…)</td><td>从EmbeddedChannel中读取一个出站消息，任何返回的消息都经过了整个ChannelPipeline，如果没有数据则返回null</td></tr><tr><td>finish()</td><td>结束EmbeddedChannel，如果里面有任何类型的可读数据都会返回true，它也会调用Channel的close方法</td></tr></tbody></table><p>EmbeededChannel的处理过程如图所示：</p><p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2399198972,3683808923&fm=15&gp=0.jpg" srcset="/img/loading.gif" alt="img"></p><h2 id="使用EmbeededChannel测试ChannelHandler"><a href="#使用EmbeededChannel测试ChannelHandler" class="headerlink" title="使用EmbeededChannel测试ChannelHandler"></a>使用EmbeededChannel测试ChannelHandler</h2><h3 id="JUnit断言"><a href="#JUnit断言" class="headerlink" title="JUnit断言"></a>JUnit断言</h3><p>org.junit.Assert类提供了很多用于测试的静态方法，失败的断言将导致一个异常被抛出，并将终止当前正在执行的测试。</p><h3 id="测试入站消息"><a href="#测试入站消息" class="headerlink" title="测试入站消息"></a>测试入站消息</h3><p>接下来实现一个简单的ByteToMessageDecoder，给定足够的数据，然后这个解码器将产生固定大小的帧，如果没有足够的数据可供的读取，它将等待下一个数据块的到来，并将再次检查是否能够产生一个新的帧。</p><p>我们代码是这个解码器产生固定为3个字节大小的帧，它可能会需要多个事件来提供足够的字节数来产生一个帧，最终每个帧都会被传递给ChannelPipeline中的下一个ChannelHandler。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FixedLengthFrameDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> frameLength;    <span class="hljs-comment">//指定要生成的帧的长度</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FixedLengthFrameDecoder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> frameLength)</span> </span>&#123;        <span class="hljs-keyword">if</span> (frameLength &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(                <span class="hljs-string">"frameLength must be a positive integer: "</span> + frameLength);        &#125;        <span class="hljs-keyword">this</span>.frameLength = frameLength;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in,</span></span><span class="hljs-function"><span class="hljs-params">        List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//检查是否有足够的字节可以被读取，以生成下一个帧</span>        <span class="hljs-keyword">while</span> (in.readableBytes() &gt;= frameLength) &#123;            <span class="hljs-comment">//从 ByteBuf 中读取一个新帧</span>            ByteBuf buf = in.readBytes(frameLength);            <span class="hljs-comment">//将该帧添加到已被解码的消息列表中</span>            out.add(buf);        &#125;    &#125;&#125;</code></pre></div><p>现在创建一个单元测试：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FixedLengthFrameDecoderTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>                           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFramesDecoded</span><span class="hljs-params">()</span></span>&#123;        ByteBuf buffer = Unpooled.buffer();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;            buffer.writeByte(i);        &#125;        ByteBuf duplicate = buffer.duplicate();        <span class="hljs-comment">//创建一个EmbeddedChannel，并添加一个FixedLengthFramesDecoded，将其以3字节的帧长度被测试</span>        EmbeddedChannel embeddedChannel = <span class="hljs-keyword">new</span> EmbeddedChannel(<span class="hljs-keyword">new</span> FixedLengthFrameDecoder(<span class="hljs-number">3</span>));        <span class="hljs-comment">//将数据写入EmbeddedChannel</span>        Assert.assertTrue(embeddedChannel.writeInbound(duplicate.retain()));        <span class="hljs-comment">//标记Channel为已完成的状态</span>        Assert.assertTrue(embeddedChannel.finish());                <span class="hljs-comment">//读取所生成的消息，并且验证是否有3帧，其中每帧都为3字节</span>        ByteBuf read = (ByteBuf) embeddedChannel.readInbound();        Assert.assertEquals(buffer.readSlice(<span class="hljs-number">3</span>),read);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; read.capacity(); i++) &#123;            System.out.println(read.getByte(i));        &#125;        read.release();        read = (ByteBuf)embeddedChannel.readInbound();        Assert.assertEquals(buffer.readSlice(<span class="hljs-number">3</span>),read);        read.release();        read = embeddedChannel.readInbound();        Assert.assertEquals(buffer.readSlice(<span class="hljs-number">3</span>),read);        read.release();        Assert.assertNull(embeddedChannel.readInbound());        buffer.release();    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFramesDecoded2</span><span class="hljs-params">()</span></span>&#123;        ByteBuf buffer = Unpooled.buffer();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;            buffer.writeByte(i);        &#125;        ByteBuf duplicate = buffer.duplicate();        EmbeddedChannel embeddedChannel = <span class="hljs-keyword">new</span> EmbeddedChannel(<span class="hljs-keyword">new</span> FixedLengthFrameDecoder(<span class="hljs-number">3</span>));        <span class="hljs-comment">//返回false，因为没有一个完整的可供读取的帧</span>        Assert.assertFalse(embeddedChannel.writeInbound(buffer.readBytes(<span class="hljs-number">2</span>)));        Assert.assertTrue(embeddedChannel.writeInbound(buffer.readBytes(<span class="hljs-number">7</span>)));        Assert.assertTrue(embeddedChannel.finish());        <span class="hljs-comment">//读取所生成的消息，并且验证是否有3帧，其中每帧都为3字节</span>        ByteBuf read = (ByteBuf) embeddedChannel.readInbound();        Assert.assertEquals(buffer.readSlice(<span class="hljs-number">3</span>),read);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; read.capacity(); i++) &#123;            System.out.println(read.getByte(i));        &#125;        read.release();        read = (ByteBuf)embeddedChannel.readInbound();        Assert.assertEquals(buffer.readSlice(<span class="hljs-number">3</span>),read);        read.release();        read = embeddedChannel.readInbound();        Assert.assertEquals(buffer.readSlice(<span class="hljs-number">3</span>),read);        read.release();        Assert.assertNull(embeddedChannel.readInbound());        buffer.release();    &#125;&#125;</code></pre></div><h3 id="测试出站消息"><a href="#测试出站消息" class="headerlink" title="测试出站消息"></a>测试出站消息</h3><p>利用EmbeddedChannel来测试一个编码器形式的ChannelOutboundHandler，这里我们只是简单的将负数转换为绝对值。</p><p>步骤：</p><ul><li>持有AbsIntegerEncoder的EmbeddedChannel将会以4字节的负整数的形式写出站数据；</li><li>编码器将从传入的ByteBuf中读取每个负整数，并将会调用Math.abs()方法来获取其绝对值；</li><li>编码器将会把每个负整数的绝对值写到ChannelPipeline中</li></ul><p>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbsIntegerEncoder</span> <span class="hljs-keyword">extends</span></span><span class="hljs-class">    <span class="hljs-title">MessageToMessageEncoder</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">        ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//检查是否有足够的字节用来编码</span>        <span class="hljs-keyword">while</span> (in.readableBytes() &gt;= <span class="hljs-number">4</span>) &#123;            <span class="hljs-comment">//从输入的 ByteBuf中读取下一个整数，并且计算其绝对值</span>            <span class="hljs-keyword">int</span> value = Math.abs(in.readInt());            <span class="hljs-comment">//将该整数写入到编码消息的 List 中</span>            out.add(value);        &#125;    &#125;&#125;</code></pre></div><p>使用了EmbeddedChannel来测试代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbsIntegerEncoderTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testEncoded</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//创建一个ByteBuf，并且写入9个负整数</span>        ByteBuf buf = Unpooled.buffer();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            buf.writeInt(i * -<span class="hljs-number">1</span>);        &#125;        <span class="hljs-comment">//创建一个EmbeddedChannel，并安装一个要测试的AbsIntegerEncoder</span>        EmbeddedChannel channel = <span class="hljs-keyword">new</span> EmbeddedChannel(<span class="hljs-keyword">new</span> AbsIntegerEncoder());        <span class="hljs-comment">//写入ByteBuf,并断言调用readOutbound()方法将会产生数据</span>        assertTrue(channel.writeOutbound(buf));        <span class="hljs-comment">//将该Channel标记为已完成状态</span>        assertTrue(channel.finish());        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            assertEquals(i,channel.readOutbound());        &#125;        assertNull(channel.readOutbound());    &#125;&#125;</code></pre></div><h2 id="测试异常处理"><a href="#测试异常处理" class="headerlink" title="测试异常处理"></a>测试异常处理</h2><p>示例：如果所读取的字节数超出了某个特定的限制，我们将会抛出一个TooLongFrameException，这是一种经常用来防范资源被耗尽的方法。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrameChunkDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxFrameSize;    <span class="hljs-comment">//指定将要产生的帧的最大允许大小</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FrameChunkDecoder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxFrameSize)</span> </span>&#123;        <span class="hljs-keyword">this</span>.maxFrameSize = maxFrameSize;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in,</span></span><span class="hljs-function"><span class="hljs-params">        List&lt;Object&gt; out)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">int</span> readableBytes = in.readableBytes();        <span class="hljs-keyword">if</span> (readableBytes &gt; maxFrameSize) &#123;            <span class="hljs-comment">// discard the bytes</span>            <span class="hljs-comment">//如果该帧太大，则丢弃它并抛出一个 TooLongFrameException……</span>            in.clear();            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TooLongFrameException();        &#125;        <span class="hljs-comment">//……否则，从 ByteBuf 中读取一个新的帧</span>        ByteBuf buf = in.readBytes(readableBytes);        <span class="hljs-comment">//将该帧添加到解码 读取一个新的帧消息的 List 中</span>        out.add(buf);    &#125;&#125;</code></pre></div><p>然后使用EmbeddedChannel来测试之前的代码是否正确：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrameChunkDecoderTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFramesDecoded</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//创建一个ByteBuf,并向它写入9字节</span>        ByteBuf buf = Unpooled.buffer();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;            buf.writeByte(i);        &#125;        ByteBuf input = buf.duplicate();        <span class="hljs-comment">//创建一个EmbeddedChannel，并向其安装一个帧大小为3字节的FrameChunkDecoder</span>        EmbeddedChannel channel = <span class="hljs-keyword">new</span> EmbeddedChannel(<span class="hljs-keyword">new</span> FrameChunkDecoder(<span class="hljs-number">3</span>));        <span class="hljs-comment">//向它写入2字节，并断言它们将会产生一个新帧</span>        assertTrue(channel.writeInbound(<span class="hljs-number">2</span>));        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//写入4字节大小的帧，并捕获预期的TooLongFrameException</span>            channel.writeInbound(input.readBytes(<span class="hljs-number">4</span>));            <span class="hljs-comment">//如果上面没有捕获，那么就会到达这个断言，并且测试失败</span>            fail();        &#125;<span class="hljs-keyword">catch</span> (TooLongFrameException e)&#123;            <span class="hljs-comment">//</span>        &#125;        <span class="hljs-comment">//因为之前的异常拦截里面没有做任何处理，所以程序可以继续执行，写入剩余的2字节，并断言将会产生一个有效帧</span>        assertTrue(channel.writeInbound(input.readBytes(<span class="hljs-number">3</span>)));        <span class="hljs-comment">//将该Channel标记为已完成状态</span>        assertTrue(channel.finish());        <span class="hljs-comment">//读取产生的消息，并且验证值</span>        ByteBuf read = (ByteBuf) channel.readInbound();        assertEquals(buf.readSlice(<span class="hljs-number">2</span>),read);        read.release();        read = (ByteBuf)channel.readInbound();        assertEquals(buf.skipBytes(<span class="hljs-number">4</span>).readSlice(<span class="hljs-number">3</span>),read);        read.release();        buf.release();    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.Netty--引导</title>
    <link href="/2020/06/02/8-Netty-%E5%BC%95%E5%AF%BC/"/>
    <url>/2020/06/02/8-Netty-%E5%BC%95%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>引导客户端和服务器</li><li>从Channel内引导客户端</li><li>添加ChannelHandler</li><li>使用ChannelOption和属性</li></ul></blockquote><h2 id="Bootstrap类"><a href="#Bootstrap类" class="headerlink" title="Bootstrap类"></a>Bootstrap类</h2><p>引导类的层次结构：</p><p><img src="https://img-blog.csdnimg.cn/20200602152558618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>服务器致力于使用一个父Channel来接收来自客户端的连接，并创建子Channel以用于它们之间的通信；而客户端一般只需要一个单独的、没有父Channel的Channel来用于所有的网络交互。</p><p>首先聊聊为什么引导类是Cloneable的？</p><p>当我们需要创建多个具有类似配置或者完全相同配置的Channel的时候，可以通过在一个已经配置完成的引导类实例上调用clone（）方法来返回另一个可以立即使用的引导类实例。</p><p>这种方式只会创建引导类实例的EventLoopGroup的一个浅拷贝，被浅拷贝的EventLoopGroup将在所有克隆的Channel实例之间共享。</p><h2 id="引导客户端和无连接协议"><a href="#引导客户端和无连接协议" class="headerlink" title="引导客户端和无连接协议"></a>引导客户端和无连接协议</h2><p>Bootstrap类被用于客户端或者使用了无连接协议的应用程序中，主要方法有如下：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>group</td><td>设置 EventLoopGroup 用于处理所有的 Channel 的事件</td></tr><tr><td>channel channelFactory</td><td>channel() 指定 Channel 的实现类。如果类没有提供一个默认的构造函数,你可以调用 channelFactory() 来指定一个工厂类被 bind() 调用。</td></tr><tr><td>localAddress</td><td>指定Channel应该绑定到本地地址 。如果不提供,将由操作系统创建一个随机的。或者,您可以使用 bind() 或 connect()指定localAddress</td></tr><tr><td>option</td><td>设置 ChannelOption，其将被应用到新创建 Channel 的 ChannelConfig。这些选项将被 bind 或 connect 设置在Channel,这取决于哪个被首先调用。这个方法在创建Channel后没有影响。所支持 ChannelOption 取决于使用的Channel类型</td></tr><tr><td>attr</td><td>指定新创建的Channel属性值，这些属性值通过 bind 或 connect 设置在Channel,这取决于哪个被首先调用。这个方法在创建Channel后没有影响。所支持 ChannelOption 取决于使用的Channel类型</td></tr><tr><td>handler</td><td>设置添加到 ChannelPipeline 中的 ChannelHandler 接收事件通知。</td></tr><tr><td>clone</td><td>创建一个当前 Bootstrap的克隆拥有原来相同的设置。</td></tr><tr><td>remoteAddress</td><td>设置远程地址。此外,您可以通过 connect() 指定</td></tr><tr><td>connect</td><td>连接到远端，返回一个 ChannelFuture, 用于通知连接操作完成</td></tr><tr><td>bind</td><td>将通道绑定并返回一个 ChannelFuture,用于通知绑定操作完成后,必须调用 Channel.connect() 来建立连接。</td></tr></tbody></table><h3 id="引导客户端"><a href="#引导客户端" class="headerlink" title="引导客户端"></a>引导客户端</h3><p>引导过程如下图所示：</p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1591084964998&di=f47186a7d9c0c972d4a0146152c6db5d&imgtype=0&src=http%3A%2F%2Fww1.sinaimg.cn%2Flarge%2F66bbf30bly1g35jn06modj20rq0i6gp3.jpg" srcset="/img/loading.gif" alt="img"></p><p>引导一个客户端代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BootstrapClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;        BootstrapClient client = <span class="hljs-keyword">new</span> BootstrapClient();        client.bootstrap();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 代码清单 8-1 引导一个客户端</span><span class="hljs-comment">     * */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bootstrap</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//设置 EventLoopGroup，提供用于处理 Channel 事件的 EventLoop</span>        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-comment">//创建一个Bootstrap类的实例以创建和连接新的客户端Channel</span>        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();        bootstrap.group(group)            <span class="hljs-comment">//指定要使用的Channel 实现</span>            .channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">            //设置用于 <span class="hljs-title">Channel</span> 事件和数据的<span class="hljs-title">ChannelInboundHandler</span></span><span class="hljs-class">            .<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt;() </span>&#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">                    ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                    ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    System.out.println(<span class="hljs-string">"Received data"</span>);                &#125;                &#125;);        <span class="hljs-comment">//连接到远程主机</span>        ChannelFuture future = bootstrap.connect(            <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"www.manning.com"</span>, <span class="hljs-number">80</span>));        future.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span></span><span class="hljs-function">                <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-keyword">if</span> (channelFuture.isSuccess()) &#123;                    System.out.println(<span class="hljs-string">"Connection established"</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    System.err.println(<span class="hljs-string">"Connection attempt failed"</span>);                    channelFuture.cause().printStackTrace();                &#125;            &#125;        &#125;);    &#125;&#125;</code></pre></div><h3 id="Channel和EventLoopGroup的兼容性"><a href="#Channel和EventLoopGroup的兼容性" class="headerlink" title="Channel和EventLoopGroup的兼容性"></a>Channel和EventLoopGroup的兼容性</h3><p>在引导的过程中，在调用bind（）或者connect（）方法之前，必须调用一下方法来设置所需的组件：</p><ul><li>group()</li><li>channel()或者channelFactory()</li><li>handler()</li></ul><p>如果不这样做，则将会导致IllegalStateException，尤其是handler（）方法，因为它需要配置好的ChannelPipeline。</p><h2 id="引导服务器"><a href="#引导服务器" class="headerlink" title="引导服务器"></a>引导服务器</h2><h3 id="ServerBootstrap类"><a href="#ServerBootstrap类" class="headerlink" title="ServerBootstrap类"></a>ServerBootstrap类</h3><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>group</td><td>设置ServerBootstrap要用的EventLoopGroup，这个 EventLoopGroup 提供 ServerChannel 的 I/O 处理并且接收 Channel</td></tr><tr><td>channel channelFactory</td><td>channel() 指定 Channel 的实现类。如果Channel没有提供一个默认的构造函数,你可以提供一个 ChannelFactory。</td></tr><tr><td>localAddress</td><td>指定 ServerChannel 应该绑定到的本地地址。如果不提供,将由操作系统创建一个随机的。或者,您可以使用 bind() 或 connect()指定localAddress</td></tr><tr><td>option</td><td>指定一个 ChannelOption 来用于新创建的 ServerChannel 的 ChannelConfig 。这些选项将被设置在Channel的 bind() 或 connect(),这取决于谁首先被调用。在此调用这些方法之后设置或更改 ChannelOption 是无效的。</td></tr><tr><td>childOption</td><td>当Channel已被接受，指定一个 ChannelOption 应用于 Channel 的 ChannelConfig。</td></tr><tr><td>attr</td><td>指定 ServerChannel 的属性。这些属性可以被子Channel的 bind() 设置。当调用 bind() 之后，修改它们不会生效。</td></tr><tr><td>childAttr</td><td>应用属性到接收到的子Channel上。后续调用没有效果。</td></tr><tr><td>handler</td><td>设置添加到 ServerChannel 的 ChannelPipeline 中的 ChannelHandler。</td></tr><tr><td>childHandler</td><td>设置添加到接收到的 Channel 的 ChannelPipeline 中的 ChannelHandler。handler() 和 childHandler()之间的区别是前者是接收和处理ServerChannel，同时 childHandler() 添加处理器用于处理和接收 Channel。后者代表一个套接字绑定到一个远端。</td></tr><tr><td>clone</td><td>克隆 ServerBootstrap 用于连接到不同的远端，通过设置相同的原始 ServerBoostrap。</td></tr><tr><td>bind</td><td>绑定 ServerChannel 并且返回一个 ChannelFuture,用于通知连接操作完成了（结果可以是成功或者失败）</td></tr></tbody></table><h3 id="引导服务器-1"><a href="#引导服务器-1" class="headerlink" title="引导服务器"></a>引导服务器</h3><p>ServerBootstrap类比Bootstrap类多了一些childXXX()方法，这是因为ServerChannel的实现负责创建子Channel，这些子Channel代表了已被接受的连接，用这些方法来简化将设置应用到已被接受的子Channel的ChannelConfig的任务。</p><p>下图展示了ServerBootstrap在bind（）方法被调用时创建了一个ServerChannel，并且该ServerChannel管理了多个子Channel。</p><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1542357931,1822191383&fm=15&gp=0.jpg" srcset="/img/loading.gif" alt="img"></p><p>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bootstrap</span><span class="hljs-params">()</span> </span>&#123;        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-comment">//创建 Server Bootstrap</span>        ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();        <span class="hljs-comment">//设置 EventLoopGroup，其提供了用于处理 Channel 事件的EventLoop</span>        bootstrap.group(group)            <span class="hljs-comment">//指定要使用的 Channel 实现</span>            .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">            //设置用于处理已被接受的子 <span class="hljs-title">Channel</span> 的<span class="hljs-title">I</span>/<span class="hljs-title">O</span>及数据的 <span class="hljs-title">ChannelInboundHandler</span></span><span class="hljs-class">            .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt;() </span>&#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                    ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    System.out.println(<span class="hljs-string">"Received data"</span>);                &#125;            &#125;);        <span class="hljs-comment">//通过配置好的 ServerBootstrap 的实例绑定该 Channel</span>        ChannelFuture future = bootstrap.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));        future.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span></span><span class="hljs-function">                <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-keyword">if</span> (channelFuture.isSuccess()) &#123;                    System.out.println(<span class="hljs-string">"Server bound"</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    System.err.println(<span class="hljs-string">"Bind attempt failed"</span>);                    channelFuture.cause().printStackTrace();                &#125;            &#125;        &#125;);    &#125;</code></pre></div><h2 id="从Channel引导客户端"><a href="#从Channel引导客户端" class="headerlink" title="从Channel引导客户端"></a>从Channel引导客户端</h2><p>在实际项目开发中有时需要从已经被接受的子Channel中引导一个客户端Channel，我们可以创建一个新的Bootstrap实例，但是这样会产生额外的线程，以及在已被接受的子Channel和客户端Channel之间交换数据时带来的上下文切换。</p><p>一个更好的解决方案是：通过将已被接受的子Channel的EventLoop传递给Bootstrap的group（）方法来共享该EventLoop。</p><p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=2705103063,4189013526&fm=26&gp=0.jpg" srcset="/img/loading.gif" alt="img"></p><p>代码实现如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bootstrap</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//创建 ServerBootstrap 以创建 ServerSocketChannel，并绑定它</span>        ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();        <span class="hljs-comment">//设置 EventLoopGroup，其将提供用以处理 Channel 事件的 EventLoop</span>        bootstrap.group(<span class="hljs-keyword">new</span> NioEventLoopGroup(), <span class="hljs-keyword">new</span> NioEventLoopGroup())            <span class="hljs-comment">//指定要使用的 Channel 实现</span>            .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">            //设置用于处理已被接受的子 <span class="hljs-title">Channel</span> 的 <span class="hljs-title">I</span>/<span class="hljs-title">O</span> 和数据的 <span class="hljs-title">ChannelInboundHandler</span></span><span class="hljs-class">            .<span class="hljs-title">childHandler</span>(</span><span class="hljs-class">                <span class="hljs-title">new</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt;() </span>&#123;                    ChannelFuture connectFuture;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span></span><span class="hljs-function">                        <span class="hljs-keyword">throws</span> Exception </span>&#123;                        <span class="hljs-comment">//创建一个 Bootstrap 类的实例以连接到远程主机</span>                        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();                        <span class="hljs-comment">//指定 Channel 的实现</span>                        bootstrap.channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">handler</span>(</span><span class="hljs-class">                            //为入站 <span class="hljs-title">I</span>/<span class="hljs-title">O</span> 设置 <span class="hljs-title">ChannelInboundHandler</span></span><span class="hljs-class">                            <span class="hljs-title">new</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt;() </span>&#123;                                <span class="hljs-meta">@Override</span>                                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">                                    ChannelHandlerContext ctx, ByteBuf in)</span></span><span class="hljs-function">                                    <span class="hljs-keyword">throws</span> Exception </span>&#123;                                    System.out.println(<span class="hljs-string">"Received data"</span>);                                &#125;                            &#125;);                        <span class="hljs-comment">//使用与分配给已被接受的子Channel相同的EventLoop</span>                        bootstrap.group(ctx.channel().eventLoop());                        connectFuture = bootstrap.connect(                            <span class="hljs-comment">//连接到远程节点</span>                            <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"www.manning.com"</span>, <span class="hljs-number">80</span>));                    &#125;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">                        ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                            ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        <span class="hljs-keyword">if</span> (connectFuture.isDone()) &#123;                            <span class="hljs-comment">//当连接完成时，执行一些数据操作（如代理）</span>                            <span class="hljs-comment">// do something with the data</span>                        &#125;                    &#125;                &#125;);        <span class="hljs-comment">//通过配置好的 ServerBootstrap 绑定该 ServerSocketChannel</span>        ChannelFuture future = bootstrap.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));        future.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span></span><span class="hljs-function">                <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-keyword">if</span> (channelFuture.isSuccess()) &#123;                    System.out.println(<span class="hljs-string">"Server bound"</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    System.err.println(<span class="hljs-string">"Bind attempt failed"</span>);                    channelFuture.cause().printStackTrace();                &#125;            &#125;        &#125;);    &#125;</code></pre></div><p>编写Netty应用程序的一个一般原则：尽可能地重用EventLoop，以减少线程创建所带来的开销。</p><h2 id="在引导过程中添加多个ChannelHandler"><a href="#在引导过程中添加多个ChannelHandler" class="headerlink" title="在引导过程中添加多个ChannelHandler"></a>在引导过程中添加多个ChannelHandler</h2><p>之前的代码中，我们调用handler（）或者childHandler（）方法来添加单个的ChannelHandler。Netty提供了一个特殊的ChannelInboundHandlerAdapter（）子类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Channel</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span></span></code></pre></div><p>通过它的<code>protected abstract void initChannel(C ch) throws Exception</code>方法来讲多个ChannelHandler添加到一个ChannelPipeLine中的简便方法。你只需要简单的向Bootstrap或ServerBootstrap的实例提供你的ChannelInitializer实现即可，在该方法返回之后，ChannelInitializer的实例将会从ChannelPipeline中移除它自己。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bootstrap</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">//创建 ServerBootstrap 以创建和绑定新的 Channel</span>        ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();        <span class="hljs-comment">//设置 EventLoopGroup，其将提供用以处理 Channel 事件的 EventLoop</span>        bootstrap.group(<span class="hljs-keyword">new</span> NioEventLoopGroup(), <span class="hljs-keyword">new</span> NioEventLoopGroup())            <span class="hljs-comment">//指定 Channel 的实现</span>            .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">            //注册一个 <span class="hljs-title">ChannelInitializerImpl</span> 的实例来设置 <span class="hljs-title">ChannelPipeline</span></span><span class="hljs-class">            .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializerImpl</span>())</span>;        <span class="hljs-comment">//绑定到地址</span>        ChannelFuture future = bootstrap.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));        future.sync();    &#125;    <span class="hljs-comment">//用以设置 ChannelPipeline 的自定义 ChannelInitializerImpl 实现</span>    <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChannelInitializerImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-comment">//将所需的 ChannelHandler 添加到 ChannelPipeline</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            ChannelPipeline pipeline = ch.pipeline();            pipeline.addLast(<span class="hljs-keyword">new</span> HttpClientCodec());            pipeline.addLast(<span class="hljs-keyword">new</span> HttpObjectAggregator(Integer.MAX_VALUE));        &#125;    &#125;</code></pre></div><p>如果你的应用程序使用了多个ChannelHandler，自己定义一个ChannelInitializer的实现来将它们安装到ChannelPipeline中即可。</p><h2 id="使用Netty的ChannelOption和属性"><a href="#使用Netty的ChannelOption和属性" class="headerlink" title="使用Netty的ChannelOption和属性"></a>使用Netty的ChannelOption和属性</h2><p>在每个Channel创建时都手动配置它很麻烦，这时我们可以通过option()方法来讲ChannelOption应用到引导，我们提供的值将会被自动应用到引导所创建的所有Channel。</p><p>Netty提供了AttributeMap抽象以及AttributeKey等工具来实现任何类型的数据项与客户端和服务器Channel之间安全地关联。</p><p>下面代码展示了如何使用ChannelOption来配置Channel，以及如何使用属性来存储整型值。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bootstrap</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//创建一个 AttributeKey 以标识该属性</span>        <span class="hljs-keyword">final</span> AttributeKey&lt;Integer&gt; id = AttributeKey.newInstance(<span class="hljs-string">"ID"</span>);        <span class="hljs-comment">//创建一个 Bootstrap 类的实例以创建客户端 Channel 并连接它们</span>        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();        <span class="hljs-comment">//设置 EventLoopGroup，其提供了用于处理 Channel 事件的 EventLoop</span>        bootstrap.group(<span class="hljs-keyword">new</span> NioEventLoopGroup())            <span class="hljs-comment">//指定 Channel 的实现</span>            .channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">            .<span class="hljs-title">handler</span>(</span><span class="hljs-class">                //设置用以处理 <span class="hljs-title">Channel</span> 的 <span class="hljs-title">I</span>/<span class="hljs-title">O</span> 以及数据的 <span class="hljs-title">ChannelInboundHandler</span></span><span class="hljs-class">                <span class="hljs-title">new</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt;() </span>&#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRegistered</span><span class="hljs-params">(ChannelHandlerContext ctx)</span></span><span class="hljs-function">                        <span class="hljs-keyword">throws</span> Exception </span>&#123;                        <span class="hljs-comment">//使用 AttributeKey 检索属性以及它的值</span>                        Integer idValue = ctx.channel().attr(id).get();                        <span class="hljs-comment">// do something with the idValue</span>                    &#125;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">                        ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                        ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        System.out.println(<span class="hljs-string">"Received data"</span>);                    &#125;                &#125;            );        <span class="hljs-comment">//设置 ChannelOption，其将在 connect()或者bind()方法被调用时被设置到已经创建的 Channel 上</span>        bootstrap.option(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)            .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">5000</span>);        <span class="hljs-comment">//存储该 id 属性</span>        bootstrap.attr(id, <span class="hljs-number">123456</span>);        <span class="hljs-comment">//使用配置好的 Bootstrap 实例连接到远程主机</span>        ChannelFuture future = bootstrap.connect(            <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"www.manning.com"</span>, <span class="hljs-number">80</span>));        future.syncUninterruptibly();    &#125;</code></pre></div><h2 id="引导DatagramChannel"><a href="#引导DatagramChannel" class="headerlink" title="引导DatagramChannel"></a>引导DatagramChannel</h2><p>前面提到的都是基于TCP协议的SocketChannel，但是Bootstrap类也可以被用于无连接的协议，Netty提供了各种DatagramChannel的实现，唯一区别就是，不再调用connect()方法，而是只调用bind()方法，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bootstrap</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//创建一个 Bootstrap 的实例以创建和绑定新的数据报 Channel</span>        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();        <span class="hljs-comment">//设置 EventLoopGroup，其提供了用以处理 Channel 事件的 EventLoop</span>        bootstrap.group(<span class="hljs-keyword">new</span> OioEventLoopGroup()).channel(            <span class="hljs-comment">//指定 Channel 的实现</span>            OioDatagramChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">handler</span>(</span><span class="hljs-class">            //设置用以处理 <span class="hljs-title">Channel</span> 的 <span class="hljs-title">I</span>/<span class="hljs-title">O</span> 以及数据的 <span class="hljs-title">ChannelInboundHandler</span></span><span class="hljs-class">            <span class="hljs-title">new</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">DatagramPacket</span>&gt;() </span>&#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,</span></span><span class="hljs-function"><span class="hljs-params">                    DatagramPacket msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    <span class="hljs-comment">// Do something with the packet</span>                &#125;            &#125;        );        <span class="hljs-comment">//调用 bind() 方法，因为该协议是无连接的</span>        ChannelFuture future = bootstrap.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">0</span>));        future.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span></span><span class="hljs-function">               <span class="hljs-keyword">throws</span> Exception </span>&#123;               <span class="hljs-keyword">if</span> (channelFuture.isSuccess()) &#123;                   System.out.println(<span class="hljs-string">"Channel bound"</span>);               &#125; <span class="hljs-keyword">else</span> &#123;                   System.err.println(<span class="hljs-string">"Bind attempt failed"</span>);                   channelFuture.cause().printStackTrace();               &#125;            &#125;        &#125;);    &#125;</code></pre></div><h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><p><strong>最重要的是关闭EventLoopGroup</strong>，通过调用EventLoopGroup.shutdownGracefully()方法。这个调用将返回一个 Future 用来通知关闭完成。注意,shutdownGracefully()也是一个异步操作,所以你需要阻塞,直到它完成或注册一个侦听器直到返回的 Future 来通知完成。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bootstrap</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//创建处理 I/O 的EventLoopGroup</span>        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-comment">//创建一个 Bootstrap 类的实例并配置它</span>        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();        bootstrap.group(group)             .channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">        //...</span><span class="hljs-class">             .<span class="hljs-title">handler</span>(</span><span class="hljs-class">                <span class="hljs-title">new</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt;() </span>&#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">                            ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                            ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        System.out.println(<span class="hljs-string">"Received data"</span>);                    &#125;                &#125;             );        bootstrap.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"www.manning.com"</span>, <span class="hljs-number">80</span>)).syncUninterruptibly();        <span class="hljs-comment">//,,,</span>        <span class="hljs-comment">//shutdownGracefully()方法将释放所有的资源，并且关闭所有的当前正在使用中的 Channel</span>        Future&lt;?&gt; future = group.shutdownGracefully();        <span class="hljs-comment">// block until the group has shutdown</span>        future.syncUninterruptibly();    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.Netty--EventLoop和线程模型</title>
    <link href="/2020/06/01/7-Netty-EventLoop%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/06/01/7-Netty-EventLoop%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>线程模型概述</li><li>事件循环的概念和实现</li><li>任务调度</li><li>实现细节</li></ul></blockquote><h2 id="线程模型概述"><a href="#线程模型概述" class="headerlink" title="线程模型概述"></a>线程模型概述</h2><p>基本的线程池化模式可以描述为：</p><ul><li><p>从池的空闲列表中选择一个Thread，并且指派它去运行一个已提交的任务（一个Runnable的实现）；</p></li><li><p>当任务完成时，将该Thread返回给该列表，使其可被重用。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200602154938594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>（1）要执行的任务；</p><p>（2）任务递交给了线程池；</p><p>（3）从线程池中拉取一个可用的Thread，并执行任务，当任务完成时，将该Thread返回给空闲列表，使其可被重用</p><h2 id="EventLoop接口"><a href="#EventLoop接口" class="headerlink" title="EventLoop接口"></a>EventLoop接口</h2><p>EventLoop是协同设计的一部分，采用了两个基本的API：并发和网络编程。</p><p><img src="https://img-blog.csdnimg.cn/20200602155018734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>一个EventLoop将由一个永远都不会改变的Thread驱动，同时任务（Runnable或者Callable）可以直接提交给EventLoop实现，以立即执行或者调度执行。根据配置和可用核心不同，可能会创建多个EventLoop实例用以优化资源的使用，并且单个EventLoop可能会被指派用于服务多个Channel。</p><h3 id="Netty4中的I-O和事件处理"><a href="#Netty4中的I-O和事件处理" class="headerlink" title="Netty4中的I/O和事件处理"></a>Netty4中的I/O和事件处理</h3><p>所有的I/O操作和事件都由已经被分配给了EventLoop的那个Thread来处理。</p><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>常见的用例是：发送心跳消息到远程节点，以检查连接是否还活着。</p><h3 id="JDK的任务调度API"><a href="#JDK的任务调度API" class="headerlink" title="JDK的任务调度API"></a>JDK的任务调度API</h3><p>java.util.concurrent.Executors类的工厂方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>newScheduledThreadPool(int corePoolSize)<br /><br />newScheduledThreadPool(int corePoolSize,<br />ThreadFactory threadFactory)</td><td>创建一个ScheduledThreadExecutorService，用于调度命令在指定延迟之后运行或者周期性地执行。它使用corePoolSize参数来计算线程数</td></tr><tr><td>newSingleThreadScheduledExecutor（）<br /><br />newSingleThreadScheduledExecutor(ThreadFactory threadFactory)</td><td>创建一个ScheduledThreadExecutorService，用于调度命令在指定延迟之后运行或者周期性地执行。它使用一个线程来执行被调度的任务。</td></tr></tbody></table><p>下面代码展示了如何使用ScheduledExecutorService来在60s的延迟之后执行一个任务：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//创建一个其线程池具有 10 个线程的ScheduledExecutorService</span>        ScheduledExecutorService executor =                Executors.newScheduledThreadPool(<span class="hljs-number">10</span>);        ScheduledFuture&lt;?&gt; future = executor.schedule(            <span class="hljs-comment">//创建一个 Runnable，以供调度稍后执行</span>            <span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-comment">//该任务要打印的消息</span>                System.out.println(<span class="hljs-string">"Now it is 60 seconds later"</span>);            &#125;        <span class="hljs-comment">//调度任务在从现在开始的 60 秒之后执行</span>        &#125;, <span class="hljs-number">60</span>, TimeUnit.SECONDS);        <span class="hljs-comment">//...</span>        <span class="hljs-comment">//一旦调度任务执行完成，就关闭 ScheduledExecutorService 以释放资源</span>        executor.shutdown();    &#125;</code></pre></div><p>高负载下性能上不佳</p><h3 id="使用EventLoop调度任务"><a href="#使用EventLoop调度任务" class="headerlink" title="使用EventLoop调度任务"></a>使用EventLoop调度任务</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleViaEventLoop</span><span class="hljs-params">()</span> </span>&#123;     Channel ch = CHANNEL_FROM_SOMEWHERE; <span class="hljs-comment">// get reference from somewhere</span>     ScheduledFuture&lt;?&gt; future = ch.eventLoop().schedule(         <span class="hljs-comment">//创建一个 Runnable以供调度稍后执行</span>         <span class="hljs-keyword">new</span> Runnable() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;             <span class="hljs-comment">//要执行的代码</span>             System.out.println(<span class="hljs-string">"60 seconds later"</span>);         &#125;         <span class="hljs-comment">//调度任务在从现在开始的 60 秒之后执行</span>     &#125;, <span class="hljs-number">60</span>, TimeUnit.SECONDS); &#125;</code></pre></div><p>如果要调度任务以每隔60s执行一次，则使用ScheduleAtFixedRate()方法。</p><p>要想取消或者检查（被调度任务的）执行状态，可以使用每隔异步操作所返回的ScheduledFuture。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancelingTaskUsingScheduledFuture</span><span class="hljs-params">()</span></span>&#123;       Channel ch = CHANNEL_FROM_SOMEWHERE; <span class="hljs-comment">// get reference from somewhere</span>       <span class="hljs-comment">//...</span>       <span class="hljs-comment">//调度任务，并获得所返回的ScheduledFuture</span>       ScheduledFuture&lt;?&gt; future = ch.eventLoop().scheduleAtFixedRate(               <span class="hljs-keyword">new</span> Runnable() &#123;                   <span class="hljs-meta">@Override</span>                   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                       System.out.println(<span class="hljs-string">"Run every 60 seconds"</span>);                   &#125;               &#125;, <span class="hljs-number">60</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS);       <span class="hljs-comment">// Some other code that runs...</span>       <span class="hljs-keyword">boolean</span> mayInterruptIfRunning = <span class="hljs-keyword">false</span>;       <span class="hljs-comment">//取消该任务，防止它再次运行</span>       future.cancel(mayInterruptIfRunning);   &#125;</code></pre></div><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h3><p>Netty线程模型的卓越性能取决于对于当前执行的Thread的身份的确定（通过调用EventLoop的inEventLoop（Thread）方法实现），也就是说，确定它是否是分配给当前Channel以及它的EventLoop的那一个线程。</p><p>如果当前调用线程正是支撑EventLoop的线程，那么所提交的代码块将会被直接执行，否则，EventLoop将调度该任务以便稍后执行，并将它放入到内部队列中，当EventLoop下次处理它的事件时，它会执行队列中的那些任务/事件。</p><p>注意：每个EventLoop都有他自己的任务队列，独立于任何其他的EventLoop。</p><p><img src="https://img-blog.csdnimg.cn/20200602155127463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="EventLoop-线程的分配"><a href="#EventLoop-线程的分配" class="headerlink" title="EventLoop/线程的分配"></a>EventLoop/线程的分配</h3><h4 id="异步传输"><a href="#异步传输" class="headerlink" title="异步传输"></a>异步传输</h4><p>异步传输实现只使用了少量的EventLoop（以及和它们相关联的Thread），而且在当前的线程模型中，它们可能会被多个Channel所共享。这使得可以通过尽可能少的Thread来支撑大量的Channel，而不是每个Channel分配一个Thread。</p><p><img src="https://img-blog.csdnimg.cn/20200602155138107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>EventLoopGroup负责为每个新创建的Channel分配一个EventLoop，并且相同的Event Loop可能会被分配给多个Channel。</p><p>一旦一个Channel被分配给要给EventLoop，它将在它的整个生命周期中都使用整个EventLoop（以及相关联的Thread）。</p><h4 id="阻塞传输"><a href="#阻塞传输" class="headerlink" title="阻塞传输"></a>阻塞传输</h4><p>每个Channel都将会被分配给一个EventLoop（以及它的Thread）</p><p><img src="https://img-blog.csdnimg.cn/2020060215514520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.Netty--ChannelHandler和ChannelPipeline</title>
    <link href="/2020/05/31/6-Netty-ChannelHandler%E5%92%8CChannelPipeline/"/>
    <url>/2020/05/31/6-Netty-ChannelHandler%E5%92%8CChannelPipeline/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>ChannelHandler和ChannelPipeline</li><li>检测资源泄漏</li><li>异常处理</li></ul></blockquote><h2 id="ChannelHandler家族"><a href="#ChannelHandler家族" class="headerlink" title="ChannelHandler家族"></a>ChannelHandler家族</h2><h3 id="Channel的生命周期"><a href="#Channel的生命周期" class="headerlink" title="Channel的生命周期"></a>Channel的生命周期</h3><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>ChannelUnregistered</td><td>Channel已经被创建，但还未注册到EventLoop</td></tr><tr><td>ChannelRegistered</td><td>Channel已经被注册到了EventLoop</td></tr><tr><td>ChannelActive</td><td>Channel处于活动状态（已连接到远程节点），可以接收和发送数据了</td></tr><tr><td>ChannelInactive</td><td>Channel没有连接到远程节点</td></tr></tbody></table><p>Channel的正常生命周期如下图所示，当这些状态发生改变时，将会生成对应的事件，这些事件将会被转发给ChannelPipeline中的ChannelHandler，其可以随后对它们做出响应。</p><p><img src="https://img-blog.csdnimg.cn/20200601160759198.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="ChannelHandler的生命周期"><a href="#ChannelHandler的生命周期" class="headerlink" title="ChannelHandler的生命周期"></a>ChannelHandler的生命周期</h3><p>ChannelHandler的生命周期方法主要有下面几种，这些方法都有一个ChannelHandlerContext参数，在ChannelHandler被添加到ChannelPipeline中或者从ChannelPipeline中移除时都会调用这些操作。</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>handlerAdded</td><td>当把ChannelHandler添加到ChannelPipeline中时被调用</td></tr><tr><td>handlerRemoved</td><td>当从ChannelPineline中移除ChannelHandler时被调用</td></tr><tr><td>exceptionCaught</td><td>当处理过程中在ChannelPipeline中有错误产生时被调用</td></tr></tbody></table><p>Netty定义了两个重要的ChannelHandler子接口：</p><ul><li>ChannelInboundHandler：处理入站数据以及各种状态变化；</li><li>ChannelOutboundHandler：处理出站数据并且允许拦截所有的操作；</li></ul><h3 id="ChannelInboundHandler接口"><a href="#ChannelInboundHandler接口" class="headerlink" title="ChannelInboundHandler接口"></a>ChannelInboundHandler接口</h3><p>下面这些是ChannelInboundHandler的生命周期方法，将会在数据被接收时或者与其对应的Channel状态发生改变时被调用。</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>ChannelUnregistered</td><td>当Channel从它的EventLoop注销并且无法处理任何I/O时被调用</td></tr><tr><td>ChannelRegistered</td><td>当Channel已经注册到它的EventLoop，并且能够处理I/O时被调用</td></tr><tr><td>ChannelActive</td><td>当Channel处于活动状态（已连接到远程节点）时被调用</td></tr><tr><td>ChannelInactive</td><td>当Channel离开活动状态并且不再连接它的远程节点时被调用</td></tr><tr><td>ChannelReadComplete</td><td>当Channel上的一个读操作完成时被调用</td></tr><tr><td>ChannelRead</td><td>当从Channel读取数据时被调用</td></tr><tr><td>ChannelWritabilityChanged</td><td>当Channel的可写状态发生改变时被调用</td></tr><tr><td>userEventTriggered</td><td>当调用ChannelInboundHandler.fireUserEventTriggered()方法时被调用</td></tr></tbody></table><p>当某个ChannelInboundHandler的实现重写了channelRead（）方法时，它将负责显示地释放与池化的ByteBuf实例相关的内存。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;        <span class="hljs-comment">//丢弃已接收的消息</span>        ReferenceCountUtil.release(msg);    &#125;&#125;</code></pre></div><p>不过我们一般使用SimpleChannelInboundHandler来自动释放资源。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleDiscardHandler</span></span><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,</span></span><span class="hljs-function"><span class="hljs-params">        Object msg)</span> </span>&#123;        <span class="hljs-comment">//不需要任何显式的资源释放</span>        <span class="hljs-comment">// No need to do anything special</span>    &#125;&#125;</code></pre></div><p>由于使用SimpleChannelInboundHandler会自动释放资源，所以不能存储指向任何消息的引用供将来使用。</p><h3 id="ChannelOutboundHandler接口"><a href="#ChannelOutboundHandler接口" class="headerlink" title="ChannelOutboundHandler接口"></a>ChannelOutboundHandler接口</h3><p>用来处理出站操作，它的方法将被Channel、ChannelPipeline以及ChannelHandlerContext调用。</p><p>ChannelOutboundHandler的一个强大的功能就是可以按需推迟操作或者事件，比如到远程节点的写入被暂停了，你可以推迟冲刷操作并在稍后继续。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ChannelOutboundHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelHandler</span> </span>&#123;<span class="hljs-comment">//当请求将Channel绑定到本地地址时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bind</span><span class="hljs-params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-comment">//当请求将Channel连接到远程节点时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            ChannelHandlerContext ctx, SocketAddress remoteAddress,</span></span><span class="hljs-function"><span class="hljs-params">            SocketAddress localAddress, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-comment">//当请求将Channel从远程节点断开时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">disconnect</span><span class="hljs-params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-comment">//当请求关闭Channel时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-comment">//当请求将Channel从它的EventLoop注销时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deregister</span><span class="hljs-params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-comment">//当请求从Channel读取更多的数据时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-comment">//当请求通过Channel将数据写到远程节点时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-comment">//当请求通过Channel将入队数据冲刷到远程节点时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception</span>;&#125;</code></pre></div><p>ChannelOutboundHandler中的大部分方法都需要一个ChannelPromise参数，以便在操作完成时得到通知。ChannelPromise是ChannelFuture的一个子类，其定义了一些可写的方法，如setSuccess（）和setFailure（），从而使ChannelFuture不可变。</p><h3 id="ChannelHandler适配器"><a href="#ChannelHandler适配器" class="headerlink" title="ChannelHandler适配器"></a>ChannelHandler适配器</h3><p>我们可以使用ChannelInboundHandlerAdapter和ChannelOutboundHandlerAdapter类作为自己的ChannelHandler的起始点。这两个适配器分别提供了ChannelInboundHandler和ChannelOutboundHandler的基本实现，通过扩展抽象类ChannelHandlerAdapter，他们获得了ChannelHandler的方法。生成的类的层次结构如下图</p><p><img src="https://img-blog.csdnimg.cn/20200601160813550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200601160827702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>在ChannelInboundHandlerAdapter和ChannelOutboundHandlerAdapter中所提供的方法体调用了其相关联的ChannelHandlerContext上的等效方法，从而将事件转发到了ChannelPipeline中的下一个ChannelHandler中。</p><h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><p>每当通过调用ChannelInboundHandler.channelRead()或者ChannelOutboundHandler.write()方法来处理数据时，你都需要确保没有任何的资源泄露。</p><p>Netty提供了4种泄漏检测级别，分别如下：</p><ul><li><p>DISABLED——禁用泄露检测</p></li><li><p>SIMPLE——使用1%的默认采样率检测并报告任何发现的泄露</p></li><li><p>ADVANCED——使用默认的采样率，报告所发现的任何的泄露以及对应的消息被访问的位置</p></li><li><p>PARANOID——类似于ADVANCED，但是其将会对每次访问都进行采样，这对性能将会有很大的影响，应该只在调试阶段使用</p></li></ul><p>泄露检测级别可以通过将下面的Java系统属性设置为表中的一个值来定义：</p><div class="hljs"><pre><code class="hljs java">java -Dio.netty.leakDetectionLevel = ADVANCED</code></pre></div><p>消费入站可以通过SimpleChannelInboundHandler类来实现，在消息被channelRead0()方法消费之后自动释放消息。</p><p>如果是出站消息，丢弃并释放资源的代码参考如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardOutboundHandler</span></span><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelOutboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx,</span></span><span class="hljs-function"><span class="hljs-params">        Object msg, ChannelPromise promise)</span> </span>&#123;        <span class="hljs-comment">//通过使用 ReferenceCountUtil.realse(...)方法释放资源</span>        ReferenceCountUtil.release(msg);        <span class="hljs-comment">//通知 ChannelPromise数据已经被处理了</span>        promise.setSuccess();    &#125;&#125;</code></pre></div><p>这里要注意的是，我们不仅要释放资源，同时也要通知ChannelPromise，否则可能会出现ChannelFutureListener收不到某个消息已经被处理的通知。</p><h2 id="ChannelPipeline接口"><a href="#ChannelPipeline接口" class="headerlink" title="ChannelPipeline接口"></a>ChannelPipeline接口</h2><p>每个新建的Channel都会被分配一个新的ChannelPipeline，Channel既不能附加另一个ChannelPipeline，也不能分离当前的。</p><p>根据事件的起源，事件将会被ChannelInboundHandler或者ChannelOutboundHandler处理，随后通过调用ChannelHandlerContext的实现，它将被转发给同一超类型的下一个ChannelHandler。</p><p>ChannelHandlerContext的作用就是使得ChannelHandler能够和它的ChannelPipeline以及其他的ChannelHandler交互。</p><p>下图是一个典型的同时具有入站和出站ChannelHandler的ChannelPipeline的布局：</p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1590999092320&di=27fc68aadc3a9af02ab63d0231dcb6d5&imgtype=0&src=http%3A%2F%2Fimg3.imgtn.bdimg.com%2Fit%2Fu%3D1589654393%2C4151543914%26fm%3D214%26gp%3D0.jpg" srcset="/img/loading.gif" alt="img"></p><p>Netty总是将ChannelPipeline的入站口作为头部，而将出站口作为尾部，在ChannelPipeline传播事件时，它会测试ChannelPipeline中下一个ChannelHandler的类型是否和事件的运动方向相匹配，如果不匹配就跳过，直到找到和该事件所期望的方向相匹配的为止。</p><h3 id="修改ChannelPipeline"><a href="#修改ChannelPipeline" class="headerlink" title="修改ChannelPipeline"></a>修改ChannelPipeline</h3><p>通过调用ChannelPipeline上的相关方法，ChannelHandler可以添加、删除或者替换其他的ChannelHandler，从而实时地修改ChannelPipeline的布局。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">modifyPipeline</span><span class="hljs-params">()</span> </span>&#123;        ChannelPipeline pipeline = CHANNEL_PIPELINE_FROM_SOMEWHERE; <span class="hljs-comment">// get reference to pipeline;</span>        <span class="hljs-comment">//创建一个 FirstHandler 的实例</span>        FirstHandler firstHandler = <span class="hljs-keyword">new</span> FirstHandler();        <span class="hljs-comment">//将该实例作为"handler1"添加到ChannelPipeline 中</span>        pipeline.addLast(<span class="hljs-string">"handler1"</span>, firstHandler);        <span class="hljs-comment">//将一个 SecondHandler的实例作为"handler2"添加到 ChannelPipeline的第一个槽中。这意味着它将被放置在已有的"handler1"之前</span>        pipeline.addFirst(<span class="hljs-string">"handler2"</span>, <span class="hljs-keyword">new</span> SecondHandler());        <span class="hljs-comment">//将一个 ThirdHandler 的实例作为"handler3"添加到 ChannelPipeline 的最后一个槽中</span>        pipeline.addLast(<span class="hljs-string">"handler3"</span>, <span class="hljs-keyword">new</span> ThirdHandler());        <span class="hljs-comment">//...</span>        <span class="hljs-comment">//通过名称移除"handler3"</span>        pipeline.remove(<span class="hljs-string">"handler3"</span>);        <span class="hljs-comment">//通过引用移除FirstHandler（它是唯一的，所以不需要它的名称）</span>        pipeline.remove(firstHandler);        <span class="hljs-comment">//将 SecondHandler("handler2")替换为 FourthHandler:"handler4"</span>        pipeline.replace(<span class="hljs-string">"handler2"</span>, <span class="hljs-string">"handler4"</span>, <span class="hljs-keyword">new</span> FourthHandler());    &#125;</code></pre></div><p>通常ChannelPipeline中的每个ChannelHandler都是通过它的EventLoop（I/O线程）来处理传递给它的事件的。</p><h3 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h3><ul><li>ChannelPipeline保存了与Channel相关联的ChannelHandler；</li></ul><ul><li>ChannelPipeline可以根据需要、通过添加或者删除ChannelHandler来动态修改；</li></ul><ul><li>ChannelPipeline有着丰富的API用以被调用、以响应入站和出站事件。</li></ul><h2 id="ChannelHandlerContext接口"><a href="#ChannelHandlerContext接口" class="headerlink" title="ChannelHandlerContext接口"></a>ChannelHandlerContext接口</h2><p>前面也提到了，ChannelHandlerContext代表了ChannelHandler和ChannelPipeline之间的关联，ChannelHandlerContext的主要功能就是管理它所关联的ChannelHandler和在同一个ChannelPipeline中的其他ChannelHandler之间的交互。</p><p>ChannelHandlerContext本身很多方法在Channel和ChannelPipeline中也存在，但是如果调用Channel或者ChannelPipeline上的这些方法，它们将沿着整个ChannelPipeline进行传播，而调用位于ChannelHandlerContext上的这些方法，则将从当前所关联的ChannelHandler开始，并且只会传播给位于该ChannelPipeline中的下一个能够处理该事件的ChannelHandler因此它会产生更短的事件流，性能会得到提高。</p><p>另外，ChannelHandlerContext和ChannelHandler之间的关联（绑定）是永远不会改变的，所以缓存对它的引用是安全的。</p><h3 id="使用ChannelHandlerContext"><a href="#使用ChannelHandlerContext" class="headerlink" title="使用ChannelHandlerContext"></a>使用ChannelHandlerContext</h3><p>Channel、ChannelPipeline、ChannelHandler以及ChannelHandlerContext之间的关系如下图：</p><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=777592249,3155125613&fm=15&gp=0.jpg" srcset="/img/loading.gif" alt="img"></p><p>为什么想要从channelPipeline中的某个特定点开始传播事件呢？</p><ul><li><p>为了减少将事件经传对它不感兴趣的ChannelHandler所带来的开销；</p></li><li><p>为了避免将事件传经那些可能会对它感兴趣的ChannelHandler。</p></li></ul><p>如果想调用从某个特定的ChannelHandler开始的处理过程，必须获取到在（ChannelPipeline）该ChannelHandler之前的ChannelHandler所关联的ChannelHandlerContext，这个ChannelHandlerContext将调用和它所关联的ChannelHandler之后的ChannelHandler。</p><p>通过ChannelHandlerContext触发的操作的事件流如下图所示：</p><p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=770095752,3504408543&fm=15&gp=0.jpg" srcset="/img/loading.gif" alt="img"></p><h3 id="ChannelHandler和ChannelHandlerContext的高级用法"><a href="#ChannelHandler和ChannelHandlerContext的高级用法" class="headerlink" title="ChannelHandler和ChannelHandlerContext的高级用法"></a>ChannelHandler和ChannelHandlerContext的高级用法</h3><p>通过调用ChannelHandlerContext上的pipeline()方法来获得被封闭的ChannelPipeline的引用，这使得运行时得以操作ChannelPipeline的ChannelHandler。如可以通过将ChannelHandler添加到ChannelPipeline中来实现动态的协议切换；还可以缓存ChannelHandlerContext的引用以供后面使用。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelHandlerAdapter</span> </span>&#123;    <span class="hljs-keyword">private</span> ChannelHandlerContext ctx;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;        <span class="hljs-comment">//存储到 ChannelHandlerContext的引用以供稍后使用</span>        <span class="hljs-keyword">this</span>.ctx = ctx;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(String msg)</span> </span>&#123;        <span class="hljs-comment">//使用之前存储的到 ChannelHandlerContext的引用来发送消息</span>        ctx.writeAndFlush(msg);    &#125;&#125;</code></pre></div><p>因为一个ChannelHandler可以从属于多个ChannelPipeline，所以也可以绑定多个ChannelHandlerContext实例，但是ChannelHandler必须使用@Sharable注解，并且ChannelHandler必须是线程安全的。</p><p>看个错误示例：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Sharable</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsharableHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;        <span class="hljs-comment">//将 count 字段的值加 1</span>        count++;        <span class="hljs-comment">//记录方法调用，并转发给下一个ChannelHandler</span>        System.out.println(<span class="hljs-string">"inboundBufferUpdated(...) called the "</span>                + count + <span class="hljs-string">" time"</span>);        ctx.fireChannelRead(msg);    &#125;&#125;</code></pre></div><p>为什么要共享一个ChannelHandler？</p><p>主要是用于收集跨越多个Channel的统计信息。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="处理入站异常"><a href="#处理入站异常" class="headerlink" title="处理入站异常"></a>处理入站异常</h3><p>要想处理入站异常，需要在自己的ChannelInboundHandler实现中重写exceptionCaught（）方法。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InboundExceptionHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx,</span></span><span class="hljs-function"><span class="hljs-params">        Throwable cause)</span> </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre></div><ul><li>ChannelHandler.exceptionCaught()的默认实现是简单地将当前异常转发给ChannelPipeline中的下一个ChannelHandler；</li><li>如果异常到达了ChannelPipeline的尾端，它将会被记录为未被处理；</li><li>要想自定义处理逻辑，需要重写exceptionCaught（）方法，然后决定是否需要将异常传播出去。</li></ul><h3 id="处理出站异常"><a href="#处理出站异常" class="headerlink" title="处理出站异常"></a>处理出站异常</h3><p>用于处理出站操作中的正常完成以及异常完成的选项，都基于以下的通知机制：</p><ul><li>每个出站操作都将返回一个ChannelFuture。注册到ChannelFuture的ChannelFutureListener将在操作完成时被通知该操作是成功了还是失败了；</li><li>几乎所有的ChannelOutboundHandler上的方法都会传入一个ChannelPromise的实例，作为ChannelFuture的子类，ChannelPromise也可以被分配用于异步通知的监听器。</li></ul><p>添加ChannelFutureListener到ChannelFuture的代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addingChannelFutureListener</span><span class="hljs-params">()</span></span>&#123;        Channel channel = CHANNEL_FROM_SOMEWHERE; <span class="hljs-comment">// get reference to pipeline;</span>        ByteBuf someMessage = SOME_MSG_FROM_SOMEWHERE; <span class="hljs-comment">// get reference to pipeline;</span>        <span class="hljs-comment">//...</span>        io.netty.channel.ChannelFuture future = channel.write(someMessage);        future.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(io.netty.channel.ChannelFuture f)</span> </span>&#123;                <span class="hljs-keyword">if</span> (!f.isSuccess()) &#123;                    f.cause().printStackTrace();                    f.channel().close();                &#125;            &#125;        &#125;);    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.Netty--ByteBuf</title>
    <link href="/2020/05/31/5-Netty-ByteBuf/"/>
    <url>/2020/05/31/5-Netty-ByteBuf/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>ByteBuf：Netty的数据容器</li><li>API的详细信息</li><li>用例</li><li>内存分配</li></ul></blockquote><h2 id="ByteBuf的API"><a href="#ByteBuf的API" class="headerlink" title="ByteBuf的API"></a>ByteBuf的API</h2><p>Java NIO虽然提供了ByteBuffer作为字节容器，但是其使用过于复杂和繁琐，因此用ByteBuf来代替ByteBuffer。</p><p>优点：</p><ul><li>可以被用户自定义的缓冲区类型扩展</li><li>通过内置的复合缓冲区类型实现了透明的零拷贝</li><li>容量可以按需增长</li><li>在读和写这两种模式之间切换不需要调用ByteBuffer的flip（）方法；</li><li>读和写使用了不同的索引；</li><li>支持方法的链式调用</li><li>支持引用计数</li><li>支持<a href="https://blog.csdn.net/syviah/article/details/46550161" target="_blank" rel="noopener">池化</a></li></ul><h2 id="ByteBuf类"><a href="#ByteBuf类" class="headerlink" title="ByteBuf类"></a>ByteBuf类</h2><h3 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h3><p>ByteBuf维护了两个不同的索引：一个用于读取，一个用于写入。当你从ByteBuf读取时，它的readIndex将会被递增已经被读取的字节数，同样，当你写入ByteBuf时，它的writerIndex也会被递增。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy84MTk2OTQxLTIyYjg2MzlkMGY0Njg0MDAucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="img"></p><h3 id="ByteBuf的使用模式"><a href="#ByteBuf的使用模式" class="headerlink" title="ByteBuf的使用模式"></a>ByteBuf的使用模式</h3><h4 id="堆缓冲区"><a href="#堆缓冲区" class="headerlink" title="堆缓冲区"></a>堆缓冲区</h4><p>将数据存储在JVM的堆空间中，这种模式被称为支撑数组，它能在没有使用<a href="https://blog.csdn.net/syviah/article/details/46550161" target="_blank" rel="noopener">池化</a>的情况下提供快速的分配和释放。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapBuffer</span><span class="hljs-params">()</span> </span>&#123;        ByteBuf heapBuf = BYTE_BUF_FROM_SOMEWHERE; <span class="hljs-comment">//get reference form somewhere</span>        <span class="hljs-comment">//检查 ByteBuf 是否有一个支撑数组</span>        <span class="hljs-keyword">if</span> (heapBuf.hasArray()) &#123;            <span class="hljs-comment">//如果有，则获取对该数组的引用</span>            <span class="hljs-keyword">byte</span>[] array = heapBuf.array();            <span class="hljs-comment">//计算第一个字节的偏移量</span>            <span class="hljs-keyword">int</span> offset = heapBuf.arrayOffset() + heapBuf.readerIndex();            <span class="hljs-comment">//获得可读字节数</span>            <span class="hljs-keyword">int</span> length = heapBuf.readableBytes();            <span class="hljs-comment">//使用数组、偏移量和长度作为参数调用你的方法</span>            handleArray(array, offset, length);        &#125;    &#125;</code></pre></div><h4 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h4><p>直接缓冲区时另一种ByteBuf模式，它的内容将驻留在常规的会被垃圾回收的堆之外，相对于堆缓冲区，它的分配和释放都较为昂贵，另外因为数据不是在堆上，所以还要进行一次复制。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">directBuffer</span><span class="hljs-params">()</span> </span>&#123;        ByteBuf directBuf = BYTE_BUF_FROM_SOMEWHERE; <span class="hljs-comment">//get reference form somewhere</span>        <span class="hljs-comment">//检查 ByteBuf 是否由数组支撑。如果不是，则这是一个直接缓冲区</span>        <span class="hljs-keyword">if</span> (!directBuf.hasArray()) &#123;            <span class="hljs-comment">//获取可读字节数</span>            <span class="hljs-keyword">int</span> length = directBuf.readableBytes();            <span class="hljs-comment">//分配一个新的数组来保存具有该长度的字节数据</span>            <span class="hljs-keyword">byte</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length];            <span class="hljs-comment">//将字节复制到该数组</span>            directBuf.getBytes(directBuf.readerIndex(), array);            <span class="hljs-comment">//使用数组、偏移量和长度作为参数调用你的方法</span>            handleArray(array, <span class="hljs-number">0</span>, length);        &#125;    &#125;</code></pre></div><h4 id="复合缓冲区"><a href="#复合缓冲区" class="headerlink" title="复合缓冲区"></a>复合缓冲区</h4><p>Netty通过一个ByteBuf子类CompositeByteBuf来提供一个将多个缓冲区表示为单个合并缓冲区的虚拟表示。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">byteBufComposite</span><span class="hljs-params">()</span> </span>&#123;        CompositeByteBuf messageBuf = Unpooled.compositeBuffer();        ByteBuf headerBuf = BYTE_BUF_FROM_SOMEWHERE; <span class="hljs-comment">// can be backing or direct</span>        ByteBuf bodyBuf = BYTE_BUF_FROM_SOMEWHERE;   <span class="hljs-comment">// can be backing or direct</span>        <span class="hljs-comment">//将 ByteBuf 实例追加到 CompositeByteBuf</span>        messageBuf.addComponents(headerBuf, bodyBuf);        <span class="hljs-comment">//...</span>        <span class="hljs-comment">//删除位于索引位置为 0（第一个组件）的 ByteBuf</span>        messageBuf.removeComponent(<span class="hljs-number">0</span>); <span class="hljs-comment">// remove the header</span>        <span class="hljs-comment">//循环遍历所有的 ByteBuf 实例</span>        <span class="hljs-keyword">for</span> (ByteBuf buf : messageBuf) &#123;            System.out.println(buf.toString());        &#125;    &#125;</code></pre></div><p>CompositeByteBuf可能不支持访问其支撑数组，因此访问CompositeByteBuf中的数据类似于访问直接缓冲区，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">byteBufCompositeArray</span><span class="hljs-params">()</span> </span>&#123;        CompositeByteBuf compBuf = Unpooled.compositeBuffer();        <span class="hljs-comment">//获得可读字节数</span>        <span class="hljs-keyword">int</span> length = compBuf.readableBytes();        <span class="hljs-comment">//分配一个具有可读字节数长度的新数组</span>        <span class="hljs-keyword">byte</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length];        <span class="hljs-comment">//将字节读到该数组中</span>        compBuf.getBytes(compBuf.readerIndex(), array);        <span class="hljs-comment">//使用偏移量和长度作为参数使用该数组</span>        handleArray(array, <span class="hljs-number">0</span>, array.length);    &#125;</code></pre></div><h2 id="字节级操作"><a href="#字节级操作" class="headerlink" title="字节级操作"></a>字节级操作</h2><h3 id="随机访问索引"><a href="#随机访问索引" class="headerlink" title="随机访问索引"></a>随机访问索引</h3><p>ByteBuf的索引也是从零开始的，访问数据的代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">byteBufRelativeAccess</span><span class="hljs-params">()</span> </span>&#123;        ByteBuf buffer = BYTE_BUF_FROM_SOMEWHERE; <span class="hljs-comment">//get reference form somewhere</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; buffer.capacity(); i++) &#123;            <span class="hljs-keyword">byte</span> b = buffer.getByte(i);            System.out.println((<span class="hljs-keyword">char</span>) b);        &#125;    &#125;</code></pre></div><h3 id="顺序访问索引"><a href="#顺序访问索引" class="headerlink" title="顺序访问索引"></a>顺序访问索引</h3><p>ByteBuf被读索引和写索引划分为了三个区域：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczAuYmRzdGF0aWMuY29tLzcwY0Z1SFNoX1ExWW54R2twb1dLMUhGNmhoeS9pdC91PTI2NDQwMjEyMDgsMzczMDkyNDY5OCZmbT0xNSZncD0wLmpwZw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="img"></p><h3 id="可丢弃字节"><a href="#可丢弃字节" class="headerlink" title="可丢弃字节"></a>可丢弃字节</h3><p>可丢弃字节的分段包含了已经被读过的字节。通过调用discardReadBytes()方法，可以丢弃它们并回收空间，变成可写字节，但是不建议频繁调用discardReadBytes()方法，因为可读字节必须被移动到缓冲区的开始位置。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy84MTk2OTQxLTY2MjFjZGQ2MjQwNzdkODcucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="img"></p><h3 id="可读字节"><a href="#可读字节" class="headerlink" title="可读字节"></a>可读字节</h3><p>存储了实际数据，任何名称以read 或者skip 开头的操作都将检索或者跳过位于当前readerIndex 的数据，并且将它增加已读字节数。</p><h3 id="可写字节"><a href="#可写字节" class="headerlink" title="可写字节"></a>可写字节</h3><p>拥未定义内容的、写入就绪的内存区域，任何名称以write开头的操作都将从当前的writerIndex处开始写数据，并将它增加已经写入的字节数。</p><h3 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h3><p>通过调用markReaderIndex()、markWriterIndex()、resetWriterIndex()和resetReaderIndex()来标记和重置ByteBuf 的readerIndex 和writerIndex。可以通过调用clear()方法来将readerIndex 和writerIndex 都设置为0，但是这并不会清除内存中的内容。</p><p>clear（）方法调用前：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy84MTk2OTQxLTZlMzMxM2E5NTA4NmRkMDgucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="img"></p><p>clear（）方法调用后：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy84MTk2OTQxLTYxNDdhYmM0M2MwNTYwZTYucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="img"></p><h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><ul><li><p>boolean process(byte value) 检查输入值是否是正在查找的值</p></li><li><p>forEachByte(ByteBufProcessor.FIND_NUL) 和以NULL结尾的内容的Flash套接字集成</p></li></ul><h3 id="派生缓冲区"><a href="#派生缓冲区" class="headerlink" title="派生缓冲区"></a>派生缓冲区</h3><p>1.duplicate()；<br> 2.slice()；<br> 3.slice(int, int)；<br> 4.Unpooled.unmodifiableBuffer(…)；<br> 5.order(ByteOrder)；<br> 6.readSlice(int)。</p><p>以上这些方法都将返回一个新的ByteBuf实例，它具有自己的读索引、写索引和标记索引，其内部存储和JDK的ByteBuffer一样也是共享的，因此如果修改了它的内容，那么同时也就修改了其对应的源实例。</p><p>如果需要一个现有缓冲区的真实副本，使用copy()或者copy(int,int)方法。</p><p>下面代码展示了如何使用slice(int,int)方法来操作ByteBuf的一个分段：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">byteBufSlice</span><span class="hljs-params">()</span> </span>&#123;      Charset utf8 = Charset.forName(<span class="hljs-string">"UTF-8"</span>);      <span class="hljs-comment">//创建一个用于保存给定字符串的字节的 ByteBuf</span>      ByteBuf buf = Unpooled.copiedBuffer(<span class="hljs-string">"Netty in Action rocks!"</span>, utf8);      <span class="hljs-comment">//创建该 ByteBuf 从索引 0 开始到索引 15 结束的一个新切片</span>      ByteBuf sliced = buf.slice(<span class="hljs-number">0</span>, <span class="hljs-number">15</span>);      <span class="hljs-comment">//将打印“Netty in Action”</span>      System.out.println(sliced.toString(utf8));      <span class="hljs-comment">//更新索引 0 处的字节</span>      buf.setByte(<span class="hljs-number">0</span>, (<span class="hljs-keyword">byte</span>)<span class="hljs-string">'J'</span>);      <span class="hljs-comment">//将会成功，因为数据是共享的，对其中一个所做的更改对另外一个也是可见的</span>      <span class="hljs-keyword">assert</span> buf.getByte(<span class="hljs-number">0</span>) == sliced.getByte(<span class="hljs-number">0</span>);  &#125;</code></pre></div><p>如果有可能，建议使用slice()方法来避免复制内存的开销。</p><h3 id="读-写操作"><a href="#读-写操作" class="headerlink" title="读/写操作"></a>读/写操作</h3><p>有两种类别的读/写操作：</p><ul><li><p>get()和set()操作，从给定的索引开始，并且保持索引不变；</p></li><li><p>read()和write()操作，从给定的索引开始，并且会根据已经访问过的字节数对索引进行调整。</p></li></ul><p>测试代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">byteBufSetGet</span><span class="hljs-params">()</span> </span>&#123;        Charset utf8 = Charset.forName(<span class="hljs-string">"UTF-8"</span>);        <span class="hljs-comment">//创建一个新的 ByteBuf以保存给定字符串的字节</span>        ByteBuf buf = Unpooled.copiedBuffer(<span class="hljs-string">"Netty in Action rocks!"</span>, utf8);        <span class="hljs-comment">//打印第一个字符'N'</span>        System.out.println((<span class="hljs-keyword">char</span>)buf.getByte(<span class="hljs-number">0</span>));        <span class="hljs-comment">//存储当前的 readerIndex 和 writerIndex</span>        <span class="hljs-keyword">int</span> readerIndex = buf.readerIndex();        <span class="hljs-keyword">int</span> writerIndex = buf.writerIndex();        <span class="hljs-comment">//将索引 0 处的字 节更新为字符'B'</span>        buf.setByte(<span class="hljs-number">0</span>, (<span class="hljs-keyword">byte</span>)<span class="hljs-string">'B'</span>);        <span class="hljs-comment">//打印第一个字符，现在是'B'</span>        System.out.println((<span class="hljs-keyword">char</span>)buf.getByte(<span class="hljs-number">0</span>));        <span class="hljs-comment">//将会成功，因为这些操作并不会修改相应的索引</span>        <span class="hljs-keyword">assert</span> readerIndex == buf.readerIndex();        <span class="hljs-keyword">assert</span> writerIndex == buf.writerIndex();    &#125;</code></pre></div><h2 id="ByteBufHolder接口"><a href="#ByteBufHolder接口" class="headerlink" title="ByteBufHolder接口"></a>ByteBufHolder接口</h2><p>Netty提供了ByteBufHolder来提供高级特性的支持，如存储各种属性值（HTTP响应中字节的内容，状态码，cookie等），缓冲区池化等。</p><p>ByteBufHolder只有几种用于访问底层数据和引用计数的方法：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>content()</td><td>返回由这个ByteBufHolder所持有的ByteBuf</td></tr><tr><td>copy()</td><td>返回这个ByteBufHolder的一个深拷贝，包括一个其所包含的ByteBuf 的非共享拷贝</td></tr><tr><td>duplicate()</td><td>返回这个ByteBufHolder 的一个浅拷贝，包括一个其所包含的ByteBuf 的共享拷贝</td></tr></tbody></table><h2 id="ByteBuf-分配"><a href="#ByteBuf-分配" class="headerlink" title="ByteBuf 分配"></a>ByteBuf 分配</h2><h3 id="按需分配：ByteBufAllocator-接口"><a href="#按需分配：ByteBufAllocator-接口" class="headerlink" title="按需分配：ByteBufAllocator 接口"></a>按需分配：ByteBufAllocator 接口</h3><p>Netty 通过<code>ByteBufAllocator</code>接口 实现了（ByteBuf 的）<a href="https://blog.csdn.net/syviah/article/details/46550161" target="_blank" rel="noopener">池化</a> ，它可以用来分配我们所描述过的任意类型的ByteBuf实例。</p><p>Netty提供了两种ByteBufAllocator 的实现： <code>PooledByteBufAllocator</code>和<code>UnpooledByteBufAllocator</code>。前者池化了ByteBuf的实例以提高性能并最大限度地减少内存碎片(一种称为jemalloc的已被大量现代操作系统所采用的高效方法来分配内存).后者的实现不池化ByteBuf实例，并且在每次它被调用时都会返回一个新的实例。</p><h3 id="Unpooled缓冲区"><a href="#Unpooled缓冲区" class="headerlink" title="Unpooled缓冲区"></a>Unpooled缓冲区</h3><p>提供静态的辅助方法来创建未池化的ByteBuf实例：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>buffer()<br/>buffer(int initialCapacity)<br/>buffer(int initialCapacity, int maxCapacity)</td><td>返回一个未池化的基于堆内存存储的ByteBuf</td></tr><tr><td>directBuffer()<br/>directBuffer(int initialCapacity)<br/>directBuffer(int initialCapacity, int maxCapacity)</td><td>返回一个未池化的基于直接内存存储的ByteBuf</td></tr><tr><td>wrappedBuffer()</td><td>返回一个包装了给定数据的ByteBuf</td></tr><tr><td>copiedBuffer()</td><td>返回一个复制了给定数据的ByteBuf</td></tr></tbody></table><h3 id="ByteBufUtil-类"><a href="#ByteBufUtil-类" class="headerlink" title="ByteBufUtil 类"></a>ByteBufUtil 类</h3><p>提供了用于操作ByteBuf的静态的辅助方法，有两个非常有用的方法：</p><ul><li>hexdump() 以十六进制的表示形式打印ByteBuf 的内容</li><li>equals(ByteBuf, ByteBuf) 它被用来判断两个ByteBuf实例的相等性</li></ul><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>引用计数是一种通过在某个对象所持有的资源不再被其他对象引用时释放该对象所持有的资源来优化内存使用和性能的技术。</p><p>引用计数对于池化实现（如PooledByteBufAllocator）来说是至关重要的，它降低了内存分配的开销。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">referenceCounting</span><span class="hljs-params">()</span></span>&#123;     Channel channel = CHANNEL_FROM_SOMEWHERE; <span class="hljs-comment">//get reference form somewhere</span>     <span class="hljs-comment">//从 Channel 获取ByteBufAllocator</span>     ByteBufAllocator allocator = channel.alloc();     <span class="hljs-comment">//...</span>     <span class="hljs-comment">//从 ByteBufAllocator分配一个 ByteBuf</span>     ByteBuf buffer = allocator.directBuffer();     <span class="hljs-comment">//检查引用计数是否为预期的 1</span>     <span class="hljs-keyword">assert</span> buffer.refCnt() == <span class="hljs-number">1</span>;     <span class="hljs-comment">//...</span> &#125;</code></pre></div><p>释放引用计数的对象：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseReferenceCountedObject</span><span class="hljs-params">()</span></span>&#123;      ByteBuf buffer = BYTE_BUF_FROM_SOMEWHERE; <span class="hljs-comment">//get reference form somewhere</span>      <span class="hljs-comment">//减少到该对象的活动引用。当减少到 0 时，该对象被释放，并且该方法返回 true</span>      <span class="hljs-keyword">boolean</span> released = buffer.release();      <span class="hljs-comment">//...</span>  &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.Netty--传输</title>
    <link href="/2020/05/31/4-Netty-%E4%BC%A0%E8%BE%93/"/>
    <url>/2020/05/31/4-Netty-%E4%BC%A0%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>OIO：阻塞传输</li><li>NIO：异步传输</li><li>Local：JVM内部的异步通信</li><li>Embedded：测试你的ChannelHandler</li></ul></blockquote><h2 id="案例研究：传输迁移"><a href="#案例研究：传输迁移" class="headerlink" title="案例研究：传输迁移"></a>案例研究：传输迁移</h2><h3 id="不通过Netty使用OIO和NIO"><a href="#不通过Netty使用OIO和NIO" class="headerlink" title="不通过Netty使用OIO和NIO"></a>不通过Netty使用OIO和NIO</h3><p>未使用Netty的阻塞网络编程代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlainOioServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//将服务器绑定到指定端口</span>        ServerSocket socket = <span class="hljs-keyword">new</span> ServerSocket(port);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span>(;;)&#123;                <span class="hljs-comment">//接收连接</span>                <span class="hljs-keyword">final</span> Socket clientSocket = socket.accept();                System.out.println(<span class="hljs-string">"Accepted connection from "</span>+ clientSocket);                <span class="hljs-comment">//创建一个新的线程来处理该连接</span>                <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                        OutputStream out;                        <span class="hljs-keyword">try</span> &#123;                            out = clientSocket.getOutputStream();                            out.write(<span class="hljs-string">"Hi!\r\n"</span>.getBytes(CharsetUtil.UTF_8));                            <span class="hljs-comment">//关闭连接</span>                            clientSocket.close();                        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                            e.printStackTrace();                        &#125;                        <span class="hljs-keyword">finally</span> &#123;                            <span class="hljs-keyword">try</span> &#123;                                clientSocket.close();                            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                                                            &#125;                        &#125;                    &#125;                &#125;).start();<span class="hljs-comment">//启动线程</span>            &#125;        &#125;        <span class="hljs-keyword">catch</span> (IOException e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre></div><p>未使用Netty的异步网络编程代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlainNioServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        ServerSocketChannel serverChannel = ServerSocketChannel.open();        serverChannel.configureBlocking(<span class="hljs-keyword">false</span>);        ServerSocket serverSocket = serverChannel.socket();        InetSocketAddress address = <span class="hljs-keyword">new</span> InetSocketAddress(port);        <span class="hljs-comment">//将服务器绑定到选定的端口</span>        serverSocket.bind(address);        <span class="hljs-comment">//打开Selector来处理Channel</span>        Selector selector = Selector.open();        <span class="hljs-comment">//将ServerSocket注册到Selector来接收连接</span>        serverChannel.register(selector, SelectionKey.OP_ACCEPT);        <span class="hljs-keyword">final</span> ByteBuffer msg = ByteBuffer.wrap(<span class="hljs-string">"Hi!\r\n"</span>.getBytes());        <span class="hljs-comment">//等待需要处理的新事件，阻塞将一直持续到下一个传入事件</span>        <span class="hljs-keyword">for</span> (;;)&#123;            <span class="hljs-keyword">try</span> &#123;                selector.select();            &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;                e.printStackTrace();                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-comment">//获取所有接收事件的SelectorKey实例</span>            Set&lt;SelectionKey&gt; readKeys = selector.selectedKeys();            Iterator&lt;SelectionKey&gt; iterator = readKeys.iterator();            <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;                SelectionKey key = iterator.next();                iterator.remove();                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">//检测事件是否是一个新的并且已经就绪可以被接收的连接</span>                    <span class="hljs-keyword">if</span>(key.isAcceptable())&#123;                        ServerSocketChannel server = (ServerSocketChannel) key.channel();                        SocketChannel client = server.accept();                        client.configureBlocking(<span class="hljs-keyword">false</span>);                        <span class="hljs-comment">//接收客户端，并将它注册到选择器</span>                        client.register(selector,SelectionKey.OP_WRITE |                                 SelectionKey.OP_READ,msg.duplicate());                        System.out.println(<span class="hljs-string">"Accepted connection from "</span> + client);                    &#125;                    <span class="hljs-comment">//检查套接字是否已经准备好写数据</span>                    <span class="hljs-keyword">if</span>(key.isWritable())&#123;                        SocketChannel client = (SocketChannel) key.channel();                        ByteBuffer buffer = (ByteBuffer) key.attachment();                        <span class="hljs-keyword">while</span>(buffer.hasRemaining())&#123;                            <span class="hljs-comment">//将数据写到已连接的客户端</span>                            <span class="hljs-keyword">if</span>(client.write(buffer) == <span class="hljs-number">0</span>)&#123;                                <span class="hljs-keyword">break</span>;                            &#125;                        &#125;                        <span class="hljs-comment">//关闭连接</span>                        client.close();                    &#125;                &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;                    key.cancel();                    <span class="hljs-keyword">try</span> &#123;                        key.channel().close();                    &#125;<span class="hljs-keyword">catch</span> (IOException ex)&#123;                                            &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="通过Netty使用OIO和NIO"><a href="#通过Netty使用OIO和NIO" class="headerlink" title="通过Netty使用OIO和NIO"></a>通过Netty使用OIO和NIO</h3><p>使用Netty的阻塞网络处理代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyOioServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">final</span> ByteBuf buf = Unpooled.unreleasableBuffer(                Unpooled.copiedBuffer(<span class="hljs-string">"Hi!\r\n"</span>, CharsetUtil.UTF_8));        OioEventLoopGroup group = <span class="hljs-keyword">new</span> OioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建ServerBootstrap</span>            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();            b.group(group)                    <span class="hljs-comment">//使用OioEventLoopGroup以允许阻塞模式</span>                    .channel(OioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                    .<span class="hljs-title">localAddress</span>(<span class="hljs-title">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-title">port</span>))</span><span class="hljs-class">                    //指定<span class="hljs-title">ChannelInitializer</span>，对于每个已接收的连接都调用它</span><span class="hljs-class">                    .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            <span class="hljs-comment">//添加一个ChannelInboundHandlerAdapter以拦截和处理事件</span>                            socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;                                <span class="hljs-meta">@Override</span>                                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span></span>&#123;                                    <span class="hljs-comment">//将消息写到客户端，并添加ChannelFutureListener，以便消息一被写完就关闭连接</span>                                    ctx.writeAndFlush(buf.duplicate()).addListener(ChannelFutureListener.CLOSE);                                &#125;                            &#125;);                        &#125;                    &#125;);            ChannelFuture f = b.bind().sync();            f.channel().closeFuture().sync();        &#125;<span class="hljs-keyword">finally</span> &#123;            group.shutdownGracefully().sync();        &#125;            &#125;&#125;</code></pre></div><p>非阻塞的Netty版本</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyNioServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">final</span> ByteBuf buf = Unpooled.unreleasableBuffer(                Unpooled.copiedBuffer(<span class="hljs-string">"Hi!\r\n"</span>, CharsetUtil.UTF_8));        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<span class="hljs-comment">//</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建ServerBootstrap</span>            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();            b.group(group)                    <span class="hljs-comment">//使用OioEventLoopGroup以允许阻塞模式</span>                    .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)//</span><span class="hljs-class">                    .<span class="hljs-title">localAddress</span>(<span class="hljs-title">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-title">port</span>))</span><span class="hljs-class">                    //指定<span class="hljs-title">ChannelInitializer</span>，对于每个已接收的连接都调用它</span><span class="hljs-class">                    .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            <span class="hljs-comment">//添加一个ChannelInboundHandlerAdapter以拦截和处理事件</span>                            socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;                                <span class="hljs-meta">@Override</span>                                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span></span>&#123;                                    <span class="hljs-comment">//将消息写到客户端，并添加ChannelFutureListener，以便消息一被写完就关闭连接</span>                                    ctx.writeAndFlush(buf.duplicate()).addListener(ChannelFutureListener.CLOSE);                                &#125;                            &#125;);                        &#125;                    &#125;);            ChannelFuture f = b.bind().sync();            f.channel().closeFuture().sync();        &#125;<span class="hljs-keyword">finally</span> &#123;            group.shutdownGracefully().sync();        &#125;    &#125;&#125;</code></pre></div><p>我们发现使用Netty框架，从阻塞传输切换到非阻塞传输代码要做的更改非常小。</p><h2 id="传输API"><a href="#传输API" class="headerlink" title="传输API"></a>传输API</h2><p>传输API 的核心就是Channel接口，它被用于所有的I/O操作，其层次结构如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200531232951464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>如图所示，每个Channel都将会被分配一个ChannelPipeline和ChannelConfig，ChannelConfig包含了该Channel的所有配置设置，并且支持热更新。</p><p>ChannelPipeline持有所有将应用于入站和出站数据以及事件的ChannelHandler实例，这些ChannelHandler实现了应用程序用于处理状态变化以及数据处理的逻辑。</p><p>ChannelHandler的典型用途包括：</p><ul><li>将数据从一种格式转换为另一种格式：</li><li>提供异常的通知；</li><li>提供Channel变为活动的或者非活动的通知；</li><li>提供当Channel注册到EventLoop或者从EventLoop注销时的通知；</li><li>提供有关用户自定义事件的通知。</li></ul><p>channel的方法：</p><table><thead><tr><th align="center">方法名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">eventLoop</td><td align="left">返回分配给Channel的EventLoop</td></tr><tr><td align="center">pipeline</td><td align="left">返回分配给Channel的ChannelPipeline</td></tr><tr><td align="center">isActive</td><td align="left">如果Channel是活动的，则返回true</td></tr><tr><td align="center">localAddress</td><td align="left">返回本地的SocketAddress</td></tr><tr><td align="center">remoteAddress</td><td align="left">返回远程的SocketAddress</td></tr><tr><td align="center">write</td><td align="left">将数据写到远程节点，这个数据将被传递给ChannelPipeline，并且排队直到它被冲刷</td></tr><tr><td align="center">flush</td><td align="left">将之前已写的数据冲刷到底层传输，如一个Socket</td></tr><tr><td align="center">writeAndFlush</td><td align="left">等同于调用write()并接着调用flush()方法</td></tr></tbody></table><p>前面我们也提到过，Netty的Channel实现是线程安全的，因此我们可以存储一个到Channel的引用，并且每当需要向远程节点写数据时，都可以使用它。</p><p>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChannelOperationExamples</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Channel CHANNEL_FROM_SOMEWHERE = <span class="hljs-keyword">new</span> NioSocketChannel();  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writingToChannelFromManyThreads</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 存储一个Channel的引用</span>        <span class="hljs-keyword">final</span> Channel channel = CHANNEL_FROM_SOMEWHERE;         <span class="hljs-comment">//创建持有要写数据的ByteBuf</span>        <span class="hljs-keyword">final</span> ByteBuf buf = Unpooled.copiedBuffer(<span class="hljs-string">"your data"</span>,                CharsetUtil.UTF_8);        <span class="hljs-comment">//创建将数据写到Channel 的 Runnable</span>        Runnable writer = <span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                channel.write(buf.duplicate());            &#125;        &#125;;        <span class="hljs-comment">//获取到线程池Executor 的引用</span>        Executor executor = Executors.newCachedThreadPool();        <span class="hljs-comment">//递交写任务给线程池以便在某个线程中执行</span>        executor.execute(writer);        <span class="hljs-comment">//递交另一个写任务以便在另一个线程中执行</span>        executor.execute(writer);        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><h2 id="内置的传输"><a href="#内置的传输" class="headerlink" title="内置的传输"></a>内置的传输</h2><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>NIO</td><td>基于选择器的方式</td></tr><tr><td>Epoll</td><td>由JNI驱动的epoll()和非阻塞IO，支持只有在Linux上可用的多种特性，如SO_REUSEPORT，比NIO传输更快，完全非阻塞</td></tr><tr><td>OIO</td><td>阻塞IO</td></tr><tr><td>Local</td><td>可以在VM内部通过管道进行通信的本地传输</td></tr><tr><td>Embedded</td><td>允许使用ChannelHandler而又不需要一个真正的基于网络的传输，主要用于测试</td></tr></tbody></table><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>NIO提供了一个所有I/O操作的全异步的实现，利用选择器来获取Channel状态改变时的通知，可能的状态变化有：</p><ul><li>新的Channel已被接收并且就绪；</li><li>Channel连接已经完成；</li><li>Channel有已经就绪的可供读取的数据；</li><li>Channel可用于写数据。</li></ul><p>选择器运行在一个检查状态变化并对其做出响应的线程上，在应用程序对状态的改变作出响应之后，选择器将会被重置，并将重复这个过程。</p><p>选择操作的位模式：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>OP_ACCEPT</td><td>请求在接收新连接并创建Channel时获得通知</td></tr><tr><td>OP_CONNECT</td><td>请求在建立一个连接时获得通知</td></tr><tr><td>OP_READ</td><td>请求当数据已经就绪，可以从Channel中读取时获得通知</td></tr><tr><td>OP_WRITE</td><td>请求当可以向Channel中写入更多的数据时获得通知</td></tr></tbody></table><p>处理流程如下：</p><p><img src="https://img-blog.csdnimg.cn/20200531232937617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>知识点扩展：</p><p>零拷贝：零拷贝时一种目前只有在使用NIO和Epoll传输时才可使用的特性，可以快速高效地将数据从文件系统移动到网络接口，而不需要将其从内核空间复制到用户空间。但是它对于实现了数据加密或者压缩的文件系统是不可用的，只能传输文件的原始内容。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.Netty--Netty的组件和设计</title>
    <link href="/2020/05/31/3-Netty-Netty%E7%9A%84%E7%BB%84%E4%BB%B6%E5%92%8C%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/05/31/3-Netty-Netty%E7%9A%84%E7%BB%84%E4%BB%B6%E5%92%8C%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>Netty的技术和体系结构方面的内容</li><li>Channel、EventLoop和ChannelFuture</li><li>ChannelHandler和ChannelPipeline</li><li>引导</li></ul></blockquote><p>学习Netty是因为它是基于Java NIO 的异步和事件驱动的实现，保证了高负载下应用程序性能的最大化和可伸缩性；同时它包含了一组设计模式，实现了应用程序逻辑从网络层解耦，简化了开发过程，最大限度地提高了可测试性、模块化以及代码的可重用性。</p><h2 id="1-Channel、EventLoop和ChannelFuture"><a href="#1-Channel、EventLoop和ChannelFuture" class="headerlink" title="1. Channel、EventLoop和ChannelFuture"></a>1. Channel、EventLoop和ChannelFuture</h2><ul><li><p>Channel：Socket；</p></li><li><p>EventLoop：控制流、多线程处理、并发；</p></li><li><p>ChannelFuture：异步通知</p></li></ul><h3 id="Channel接口"><a href="#Channel接口" class="headerlink" title="Channel接口"></a>Channel接口</h3><p>基本的I/O操作（bind、connect、read、write）都依赖于底层网络传送所提供的原语，也就是Socket，而Netty中的Channel就是简化Socket编程的复杂性。</p><h3 id="EventLoop接口"><a href="#EventLoop接口" class="headerlink" title="EventLoop接口"></a>EventLoop接口</h3><p>用于处理连接的生命周期中所发生的事件。</p><p><img src="https://img-blog.csdnimg.cn/20200531232619159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>其关系是：</p><ul><li>一个EventLoopGroup包含一个或多个EventLoop；</li><li>一个EventLoop在它的生命周期内只和一个Thread绑定；</li><li>所有由EventLoop处理的I/O事件都将在它专有的Thread上被处理（<strong>消除了对同步的需求</strong>）</li><li>一个Channel在它的生命周期内只注册于一个EventLoop；</li><li>一个EventLoop可能会被分配给一个或多个Channel。</li></ul><h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><p>正因为Netty中所有的I/O操作都是异步的，其执行结果不会立即返回，所以Netty提供了ChannelFuture接口，其addListener()方法注册了一个ChannelFutureListener，以便在某个操作完成时(无论是否成功)都能得到通知。</p><h2 id="2-ChannelHandler和ChannelPipeline"><a href="#2-ChannelHandler和ChannelPipeline" class="headerlink" title="2. ChannelHandler和ChannelPipeline"></a>2. ChannelHandler和ChannelPipeline</h2><p>管理数据流以及执行应用程序处理逻辑的组件</p><h3 id="ChannelHandler接口"><a href="#ChannelHandler接口" class="headerlink" title="ChannelHandler接口"></a>ChannelHandler接口</h3><p>充当了所有处理入站和出站数据的应用程序逻辑的容器，因为<code>ChannelHandler</code>的方法是由<strong>网络事件触发</strong>的。</p><h3 id="ChannelPipeline接口"><a href="#ChannelPipeline接口" class="headerlink" title="ChannelPipeline接口"></a>ChannelPipeline接口</h3><p>提供了ChannelHandler链的容器，并定义了用于在该链上传播入站和出站事件流的API，当Channel被创建时，他会被自动的分配到它专属的ChannelPipeline。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//在创建Channel时向ChannelPipeline中添加一个EchoClientHandler实例</span>.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> EchoClientHandler());    &#125;&#125;);</code></pre></div><p><img src="https://img-blog.csdnimg.cn/2020053123263110.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>执行顺序由添加顺序所决定，ChannelHandler处理完后将数据传递给链中的下一个ChannelHandler，该ChanelHandler不一定会去修改数据，如果数据到达ChannelPipeline一端，也就说明处理结束。</p><p>当ChannelHandler被添加到ChannelPipeline时，它将会被分配一个ChannelHandlerContext，其代表了ChannelHandler和ChannelPipeline之间的绑定，主要用于写出站数据。</p><p>在Netty中有两种发送消息的方式，直接写到Channel中，也可以写到ChannelHandlerContext对象中，前一种方式将会导致消息从ChannelPipeline的尾端开始流动，后者将导致消息从ChannelPipeline中的下一个ChannelHandler开始流动。</p><h3 id="编码器和解码器"><a href="#编码器和解码器" class="headerlink" title="编码器和解码器"></a>编码器和解码器</h3><p>因为网络数据总是一系列的字节，而我们写的代码是一些对象</p><p>所有由Netty提供的编码器/解码器适配器类都实现了ChannelInboundHandler接口或者ChannelOutboundHandler接口。</p><h3 id="抽象类SimpleChannelInboundHandler"><a href="#抽象类SimpleChannelInboundHandler" class="headerlink" title="抽象类SimpleChannelInboundHandler"></a>抽象类SimpleChannelInboundHandler</h3><p>当我们利用一个ChannelHandler来接收解码消息，并对该数据应用业务逻辑，基本上只需要扩展基类SimpleChannelInboundHandler<T>，其中T就是我们要处理的Java类型。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;<span class="hljs-comment">//这里的ByteBuf应该是跟服务端代码没有关系的，根据我们自身的业务需求来定的</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">"Client received: "</span>+ byteBuf.toString(CharsetUtil.UTF_8));    &#125;</code></pre></div><h3 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h3><p>Netty的引导类为应用程序的<strong>网络层</strong>配置提供了容器，有两种类型的引导：一种用于客户端，另一种用于服务器，区别如下：</p><table><thead><tr><th align="center">区别</th><th align="center">BootStrap</th><th align="center">ServerBootStrap</th></tr></thead><tbody><tr><td align="center">网络编程中的作用</td><td align="center">连接到远程主机和端口</td><td align="center">绑定到一个本地端口</td></tr><tr><td align="center">EventLoopGroup的数目</td><td align="center">1</td><td align="center">2</td></tr></tbody></table><p>为什么ServerBootStrap需要两个EventLoopGroup呢？</p><p>因为服务器需要两组不同的Channel，第一组将只包含一个ServerChannel，代表服务器自身的已绑定到某个本地端口的正在监听的套接字，而第二组将包含所有已创建的用来处理传入客户端连接的Channel。</p><p><img src="https://img-blog.csdnimg.cn/20200531232645361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.Netty--你的第一款Netty应用</title>
    <link href="/2020/05/31/2-Netty-%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%BENetty%E5%BA%94%E7%94%A8/"/>
    <url>/2020/05/31/2-Netty-%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%BENetty%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li><p>设置开发环境</p></li><li><p>编写Echo服务器和客户端</p></li><li><p>构建并测试应用程序</p></li></ul></blockquote><h3 id="1-设置开发环境"><a href="#1-设置开发环境" class="headerlink" title="1.设置开发环境"></a>1.设置开发环境</h3><p>准备好JDK和Maven</p><h3 id="2-Netty客户端-服务器概览"><a href="#2-Netty客户端-服务器概览" class="headerlink" title="2.Netty客户端/服务器概览"></a>2.Netty客户端/服务器概览</h3><p><img src="https://img-blog.csdnimg.cn/20200531232146835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>在客户端建立一个连接之后，它会向服务器发送一个或多个消息，反过来，服务器又会将每个消息回送给客户端。</p><h3 id="3-编写Echo服务器"><a href="#3-编写Echo服务器" class="headerlink" title="3.编写Echo服务器"></a>3.编写Echo服务器</h3><p>首先明确的一点是，所有的Netty服务器都需要以下两部分：</p><ul><li>至少一个ChannelHandler：用户实现服务器对从客户端接收的数据的处理，即业务逻辑。</li><li>引导：配置服务器的启动代码，如将服务器绑定到它需要监听连接请求的端口上。</li></ul><h4 id="3-1ChannelHandler和业务逻辑"><a href="#3-1ChannelHandler和业务逻辑" class="headerlink" title="3.1ChannelHandler和业务逻辑"></a>3.1ChannelHandler和业务逻辑</h4><p>ChannelHandler是一个父接口，它的实现负责接收并响应事件通知。</p><p>这里我们的Echo服务器需要响应传入的消息，所以需要实现ChannelInboundHandler接口，用来定义响应入站事件的方法，这里我们继承ChannelInboundHandlerAdapter类。</p><p>主要有如下方法可以调用：</p><ul><li><p>channelRead(): 对于每个传入的消息都要调用</p></li><li><p>channelReadComplete()：表明了本次从 Socket 读了数据，但是否是完整的数据它其实并不知道</p></li><li><p>exceptionCaught()：在读取操作期间 ，有异常抛出时会调用</p></li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/** Sharable标识一个ChannelHandler可以被多个Channel安全地共享 **/</span><span class="hljs-meta">@ChannelHandler</span>.Sharable<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ByteBuf in = (ByteBuf)msg;        System.out.println(<span class="hljs-string">"Server received: "</span> + in.toString(CharsetUtil.UTF_8));        <span class="hljs-comment">//将接收到的消息写给发送者</span>        ctx.write(in);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//将消息冲刷到客户端，并且关闭该Channel</span>        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//打印异常栈跟踪</span>        cause.printStackTrace();        <span class="hljs-comment">//关闭该Channel</span>        ctx.close();    &#125;&#125;</code></pre></div><h4 id="3-2-引导服务器"><a href="#3-2-引导服务器" class="headerlink" title="3.2 引导服务器"></a>3.2 引导服务器</h4><p>主要内容如下：</p><ul><li>绑定服务器将在其上监听并接收传入连接请求的端口；</li><li>配置Channel，以将有关的入站消息通知给EchoServerHandler实例</li></ul><p>编写EchoServer类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EchoServer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;        <span class="hljs-keyword">this</span>.port = port;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">//设置端口值不正确</span>        <span class="hljs-keyword">if</span>(args.length != <span class="hljs-number">1</span>)&#123;            System.err.print("Usage: "+EchoServer.class.getSimpleName() + "&lt;port&gt;");        &#125;        <span class="hljs-keyword">int</span> port = Integer.parseInt(args[<span class="hljs-number">0</span>]);        <span class="hljs-comment">//调用服务器的start()方法</span>        <span class="hljs-keyword">new</span> EchoServer(port).start();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">final</span> EchoServerHandler serverHandler = <span class="hljs-keyword">new</span> EchoServerHandler();        <span class="hljs-comment">//创建EventLoopGroup，因为我们使用的是NIO传输，所以要指定NioEventLoopGroup来接收和处理新的连接</span>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建ServerBootstrap</span>            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();            b.group(group)                    <span class="hljs-comment">//指定所使用的NIO传输Channel，同理因为NIO传输</span>                    .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                    //使用指定的端口设置套接字地址，服务器将绑定到这个地址以监听新的连接请求</span><span class="hljs-class">                    .<span class="hljs-title">localAddress</span>(<span class="hljs-title">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-title">port</span>))</span><span class="hljs-class">                    //当一个新的连接被接收时，一个新的子<span class="hljs-title">Channel</span>将会被创建，<span class="hljs-title">ChannelInitializer</span>会把<span class="hljs-title">EchoServerHandler</span>的实例添加到<span class="hljs-title">Channel</span>的<span class="hljs-title">ChannelPipeline</span>中,这个<span class="hljs-title">ChannelHandler</span>会接收入站消息的通知。</span><span class="hljs-class">                    .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            <span class="hljs-comment">//由于EchoServerHandler被标注位@Shareable，所以我们使用的是同一个EchoServerHandler</span>                            socketChannel.pipeline().addLast(serverHandler);                        &#125;                    &#125;);            <span class="hljs-comment">//异步的绑定服务器，调用sync()方法阻塞等待直到绑定完成</span>            ChannelFuture f = b.bind().sync();            <span class="hljs-comment">//获取Channel的CloseFuture，并且阻塞当前线程直到它完成</span>            f.channel().closeFuture().sync();        &#125;<span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//关闭EventLoopGroup，并且释放所有的资源</span>            group.shutdownGracefully().sync();        &#125;    &#125;&#125;</code></pre></div><p>主要步骤：</p><ul><li>EchoServerHandler实现业务逻辑；</li><li>main()方法引导了服务器</li></ul><p>在引导过程中的步骤：</p><ul><li><p>使用一个EchoServerHandler实例来初始化每一个新的Channel</p></li><li><p>创建并分配一个NioEventLoopGroup实例以进行事件的处理，如接收新连接以及读/写数据；</p></li><li><p>创建一个ServerBootstrap的实例以引导和绑定服务器；</p></li><li><p>指定服务器绑定的本地InetSocketAddress</p></li><li><p>调用ServerBootstrap.bind()方法来绑定服务器</p></li></ul><h3 id="4-编写Echo客户端"><a href="#4-编写Echo客户端" class="headerlink" title="4. 编写Echo客户端"></a>4. 编写Echo客户端</h3><p>Echo客户端主要任务：</p><ul><li>连接到服务端</li><li>发送一个或多个消息；</li><li>对于每个消息，等待并接收从服务器发回的消息；</li><li>关闭连接</li></ul><p>客户端所涉及到的两个主要代码部分也是业务逻辑和引导</p><h4 id="4-1-通过ChannelHandler实现客户端逻辑"><a href="#4-1-通过ChannelHandler实现客户端逻辑" class="headerlink" title="4.1 通过ChannelHandler实现客户端逻辑"></a>4.1 通过ChannelHandler实现客户端逻辑</h4><p>客户端也拥有一个用来处理数据的ChannelInboundHandler，这里我们扩展SimpleChannelInboundHandler类来处理所有必须的任务，重写以下方法：</p><ul><li><p>channelActive()：在到服务器的连接已经建立之后将被调用</p></li><li><p>channel Read0()：当从服务器接收到一条消息时被调用</p></li><li><p>exceptionCaught()：在处理过程中引发异常时被调用</p></li></ul><p>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;    <span class="hljs-comment">/** 连接服务器后调用该方法 **/</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">"Netty rocks!"</span>, CharsetUtil.UTF_8));    &#125;    <span class="hljs-comment">/** 从服务器接收到消息后调用该方法 **/</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">"Client received: "</span>+ byteBuf.toString(CharsetUtil.UTF_8));    &#125;    <span class="hljs-comment">/** 发生异常时，记录错误并关闭Channel **/</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre></div><p>注意： 从服务器发送的消息可能会被分块接收，channelRead0()方法因此有可能被调用多次。</p><p>还有一点值得注意的是Echo 服务端使用的ChannelHandler是 ChannelInboundHandlerAdapter，而 Echo 客户端使用的却是 SimpleChannelInboundHandler，其实它们是继承关系。</p><p><img src="https://img-blog.csdnimg.cn/20200531232251632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>既然是继承关系，也就是说，”你有的我也有，你没有的我还有。” 那么 SimpleChannelInboundHandler 里面肯定重写或者新增了 ChannelInboundHandlerAdapter 里面的方法功能 - channelRead0 和 channelRead()。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, I msg)</span> <span class="hljs-keyword">throws</span> Exception</span>;</code></pre></div><p>至于为什么会这样设计，原因是在客户端，当 channelRead0() 方法完成时，你已经有了传入消息，并且已经处理完它了。当该方法返回时，SimpleChannelInboundHandler负责释放指向保存该消息的ByteBuf的内存引用。而在服务端，你仍然需要将传入消息回送给发送者，而 write() 操作是异步的，直到 channelRead() 方法返回后可能仍然没有完成。为此，EchoServerHandler扩展了 ChannelInboundHandlerAdapter ，其在这个时间点上不会释放消息。</p><h4 id="4-2-引导客户端"><a href="#4-2-引导客户端" class="headerlink" title="4.2 引导客户端"></a>4.2 引导客户端</h4><p>客户端使用主机和端口号来连接远程地址</p><p>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoClient</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String host;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EchoClient</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port)</span> </span>&#123;        <span class="hljs-keyword">this</span>.host = host;        <span class="hljs-keyword">this</span>.port = port;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">if</span>(args.length != <span class="hljs-number">2</span>)&#123;            System.err.println("Usage: "+ EchoClient.class.getSimpleName()+"&lt;host&gt; &lt;port&gt;");            <span class="hljs-keyword">return</span>;        &#125;        String host = args[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> port = Integer.parseInt(args[<span class="hljs-number">1</span>]);        <span class="hljs-keyword">new</span> EchoClient(host,port).start();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            Bootstrap b = <span class="hljs-keyword">new</span> Bootstrap();            b.group(group)                    .channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                    .<span class="hljs-title">remoteAddress</span>(<span class="hljs-title">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-title">host</span>,<span class="hljs-title">port</span>))</span><span class="hljs-class">                    //在创建<span class="hljs-title">Channel</span>时向<span class="hljs-title">ChannelPipeline</span>中添加一个<span class="hljs-title">EchoClientHandler</span>实例</span><span class="hljs-class">                    .<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> EchoClientHandler());                        &#125;                    &#125;);            ChannelFuture f = b.connect().sync();            f.channel().closeFuture().sync();        &#125;<span class="hljs-keyword">finally</span> &#123;            group.shutdownGracefully().sync();        &#125;    &#125;&#125;</code></pre></div><h3 id="5-构建和运行Echo服务器和客户端"><a href="#5-构建和运行Echo服务器和客户端" class="headerlink" title="5. 构建和运行Echo服务器和客户端"></a>5. 构建和运行Echo服务器和客户端</h3><p>目录如下：</p><p><img src="https://img-blog.csdnimg.cn/20200531231945351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>注意要在pom.xml文件中引入netty依赖以及编译maven模板需要的插件。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.netty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>netty-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.42.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.mojo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>exec-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>                  <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>                      <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                          <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>                      <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>                  <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                  <span class="hljs-comment">&lt;!--指定main文件,不指定会报错，如果是client就要变成EchoClient--&gt;</span>                  <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>EchoServer<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><p>先执行<code>mvn clean package</code>来清除指定的包，然后<code>cd server</code>，执行<code>exec:java -Dexec.args=&quot;1&quot;</code>,接下来点击右下角的加号新建一个终端，然后<code>cd client</code>，执行<code>exec:java -Dexec.args=&quot;0 1&quot;</code>，即可看到效果。一定一定要先开启服务器然后再开客户端，否则会报错。</p><p>效果：</p><p><img src="https://img-blog.csdnimg.cn/20200531231925350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>补充一个遇到的坑：</p><p><img src="https://img-blog.csdnimg.cn/20200531231845780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>如果在执行<code>mvn exec:java -Dexec.args=&quot;0 1&quot;</code>的时候出现上面错误，首先去自己的maven的目录下查看配置文件setting.xml</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\Software\apache-maven-3.6.1\repository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span></code></pre></div><p>看路径是否正确，其次检查IDEA中的MAVEN配置。</p><p><img src="https://img-blog.csdnimg.cn/20200531232454527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.Netty--异步和事件驱动</title>
    <link href="/2020/05/30/1-Netty-%E5%BC%82%E6%AD%A5%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/"/>
    <url>/2020/05/30/1-Netty-%E5%BC%82%E6%AD%A5%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本系列文章主要来自《Netty IN ACTION》</p><p>本章主要内容：</p><ul><li><p>Java网络编程</p></li><li><p>Netty简介</p></li><li><p>Netty核心组件</p></li></ul></blockquote><h2 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h2><p>首先来看一个典型的阻塞I/O示例：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//创建一个新的ServerSocket，用于监听指定端口上的连接请求</span>ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(portNumber);<span class="hljs-comment">//1</span><span class="hljs-comment">//以阻塞的方式来调用accept()方法，直到一个连接建立</span>Socket clientSocket = serverSocket.accept();<span class="hljs-comment">//2</span><span class="hljs-comment">//BufferedReader和PrintWriter分别用于从字符输入流中读取文本和将对象格式化到文本输出流</span>BufferedReader in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(clientSocket.getInputStream()));PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(clientSocket.getOutputStream(),<span class="hljs-keyword">true</span>);String request,response;<span class="hljs-comment">//循环对输入流进行判断处理</span><span class="hljs-keyword">while</span>((request = in.readLine()) != <span class="hljs-keyword">null</span>)&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-string">"Done"</span>.equals(request))&#123;        <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-comment">//服务器处理客户端的请求，并作出响应</span>    response = processRequest(request);    <span class="hljs-comment">//输出响应</span>    out.println(response);</code></pre></div><p>这里<code>ServerSocket</code>的作用是监听某一路端口是否有连接，如果有连接就会创建一个新的<code>Socket</code>用于客户端和服务器进行通信，而此时<code>ServerSocket</code>并不会断开连接，而是会继续监听传入的连接。</p><p><img src="https://img-blog.csdnimg.cn/20200531231530747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>这里就体现出弊端了，如果有多个并发客户端，那就需要为每个客户端Socket创建一个Thread，弊端有三：</p><ul><li>资源浪费，并不是每时每刻都有数据在传输，大部分情况下线程都处在休眠状态；</li><li>内存消耗，需要为每个线程的调度栈分配内存；</li><li>上下文切换带来的开销大；</li></ul><h3 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h3><p>使用setSockopt()方法配置套接字，以便读/写调用在没有数据的时候立即返回</p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>使用<code>java.nio.channels.Selector</code>这个类，利用事件通知API来确定在一组非阻塞套接字中有哪些已经就绪能够进行I/O相关的操作。</p><p><img src="https://img-blog.csdnimg.cn/20200531231550220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="Netty简介"><a href="#Netty简介" class="headerlink" title="Netty简介"></a>Netty简介</h2><p>Netty是一个<strong>NIO</strong>客户端/服务器<strong>框架</strong>，支持快速、简单地开发网络应用，如协议服务器和客户端。</p><h2 id="Netty核心组件"><a href="#Netty核心组件" class="headerlink" title="Netty核心组件"></a>Netty核心组件</h2><p>Netty的主要构建块：</p><ul><li>Channel</li><li>回调</li><li>Future</li><li>事件和Channelhandler</li></ul><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>简单理解就是传入或者传出数据的载体，可以被打开或者被关闭，连接或者断开连接。</p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>回调其实就是一个方法，回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。Netty内部使用了回调来处理事件，当一个回调被触发时，相关的事件被一个ChannelHandler的实现来处理，</p><p>看下面一段代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(channelHandlerContect ctx)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        System.out.println(<span class="hljs-string">"Client "</span> + ctx.channel().remoteAddress() + <span class="hljs-string">" connected"</span>);    &#125;&#125;</code></pre></div><p>当一个新的连接已经被建立时，ChannelHandler的channelActive()回调方法将会被调用，并将打印一条信息。</p><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>可以看作是一个异步操作的结果的占位符，可以在未来提供对其结果的访问；</p><p>Netty提供了自己的ChannelFuture，用于在执行异步操作的时候使用。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectExample</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Channel CHANNEL_FROM_SOMEWHERE = <span class="hljs-keyword">new</span> NioSocketChannel();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">()</span> </span>&#123;        Channel channel = CHANNEL_FROM_SOMEWHERE;         <span class="hljs-comment">//异步地连接到远程节点</span>        ChannelFuture future = channel.connect(                <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"192.168.0.1"</span>, <span class="hljs-number">25</span>));        <span class="hljs-comment">//注册一个 ChannelFutureListener，以便在操作完成时获得通知</span>        future.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> </span>&#123;                <span class="hljs-comment">//检查操作的状态</span>                <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;                    <span class="hljs-comment">//如果操作是成功的，则创建一个 ByteBuf 以持有数据</span>                    ByteBuf buffer = Unpooled.copiedBuffer(                            <span class="hljs-string">"Hello"</span>, Charset.defaultCharset());                    <span class="hljs-comment">//将数据异步地发送到远程节点。返回一个 ChannelFuture</span>                    ChannelFuture wf = future.channel()                            .writeAndFlush(buffer);                    <span class="hljs-comment">// ...</span>                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">//如果发生错误，则访问描述原因的 Throwable</span>                    Throwable cause = future.cause();                    cause.printStackTrace();                &#125;            &#125;        &#125;);    &#125;&#125;</code></pre></div><p>可以看到，回调和Future是相互补充的机制，而ChannelFutureListener可以看作是回调的一个更加精细的版本。</p><h3 id="事件和Channelhandler"><a href="#事件和Channelhandler" class="headerlink" title="事件和Channelhandler"></a>事件和Channelhandler</h3><p>Netty使用不同的事件来通知我们状态的改变或者是操作的状态，因此我们可以利用事件来进行相应的处理，比如：</p><ul><li>记录日志</li><li>数据转换</li><li>流控制</li><li>应用程序逻辑</li></ul><p>Netty作为一个网络编程框架，主要事件分为入站事件和出站事件，入站事件包括：</p><ul><li>连接已被激活或者连接失活</li><li>数据读取</li><li>用户事件</li><li>错误事件</li></ul><p>出站事件包括：</p><ul><li>打开或者关闭远程节点的连接</li><li>将数据写到或者冲刷到套接字</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(9)--角色继承</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-9-%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-9-%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<p>在本节中，补充下<strong>角色继承</strong>的知识点。角色继承其实是一个十分常见的需求，因为一般系统中角色权限呈金字塔型，高层用户拥有底层用户的权限。</p><p>例如存在以下角色：普通用户、VIP 用户、SVIP 用户、星悦会员，那么对应的权限可以是“星悦会员 &gt; SVIP 用户 &gt; VIP 用户 &gt; 普通用户”。那么如何在 Spring Security 中实现这样的功能呢？</p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>为了简便起见，我直接使用<a href="https://www.jitwxs.cn/5f5715e6.html" target="_blank" rel="noopener">《SpringBoot 集成 Spring Security（1）——入门程序》</a> 的代码。</p><p>在该章中，我们存在两个角色，<code>ROLE_ADMIN</code> 和 <code>ROLE_USER</code>，并且经过我们的实验，<code>/admin</code> 接口只有 ROLE_ADMIN 有权限，<code>/user</code> 接口只有 ROLE_USER 有权限。</p><p>但是如果我想让 ROLE_ADMIN 用户继承 ROLE_USER 用户的所有权限，该如何做呢？</p><h3 id="RoleHierarchy"><a href="#RoleHierarchy" class="headerlink" title="RoleHierarchy"></a>RoleHierarchy</h3><p>这里就需要引入 <code>RoleHierarch</code>了，我们只需要自定义一个 RoleHierarchy，并将其注入容器即可。修改 <code>WebSecurityConfig</code>，在其中注入 RoleHierarchy：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> RoleHierarchy <span class="hljs-title">roleHierarchy</span><span class="hljs-params">()</span></span>&#123;    RoleHierarchyImpl roleHierarchy = <span class="hljs-keyword">new</span> RoleHierarchyImpl();    String hierarchy = <span class="hljs-string">"ROLE_ADMIN &gt; ROLE_USER"</span>;    roleHierarchy.setHierarchy(hierarchy);    <span class="hljs-keyword">return</span> roleHierarchy;&#125;</code></pre></div><p><code>roleHierarchy.setHierarchy()</code> 指定了角色的继承关系，参数就是一个字符串，比大小即可，是不是非常简单？</p><p>让我们使用 ROLE_ADMIN 账号登陆，发现原本无法访问的 <code>/user</code> 接口也可以访问了：</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>角色关系的实现也比较简单，本质就是将字符串使用正则切分，并将角色关系存放进一个 Map 中，map 的 key 是大的角色，value 是一个 Set，存放所有比它小的角色。然后交由后续处理，有兴趣的可以继续阅读源码。</p><p><img src="https://www.jitwxs.cn/images/posts/20190902233900717.png" srcset="/img/loading.gif" alt="buildRolesReachableInOneStepMap()"></p><p>如果有多个继承关系，在 SpringBoot 2.1 中，就应该改写为：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> RoleHierarchy <span class="hljs-title">roleHierarchy</span><span class="hljs-params">()</span> </span>&#123;    String separator = System.lineSeparator();        RoleHierarchyImpl roleHierarchy = <span class="hljs-keyword">new</span> RoleHierarchyImpl();    String hierarchy = <span class="hljs-string">"ROLE_ADMIN &gt; ROLE_USER "</span> + separator + <span class="hljs-string">" ROLE_USER &gt; ROLE_TOURISTS"</span>;    roleHierarchy.setHierarchy(hierarchy);    <span class="hljs-keyword">return</span> roleHierarchy;&#125;</code></pre></div><p>另外换行符大家都知道在不同系统中表示不一样，例如 Windows 中为 <code>\r\n</code>，Mac 为 <code>\r</code>，Linux 为 <code>\n</code>，因此以上代码我是用的 <code>java.lang</code> 包的 System 类中封装的方法，不用判断当前操作系统。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(8)--短信验证码登录</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-8-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E5%BD%95/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-8-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一、理论说明"><a href="#一、理论说明" class="headerlink" title="一、理论说明"></a>一、理论说明</h2><p>在开始编码前，先理解下短信验证码的实现流程。如果你能对<a href="https://www.jitwxs.cn/a28c0db7.html" target="_blank" rel="noopener">《SpringBoot集成Spring Security（7）——认证流程》</a>这篇文章有一定的了解的话，那么这篇文章的学习你会轻松许多。</p><h3 id="1-1-用户名密码登录逻辑"><a href="#1-1-用户名密码登录逻辑" class="headerlink" title="1.1 用户名密码登录逻辑"></a>1.1 用户名密码登录逻辑</h3><p>废话不多说，在上一篇文章中，以标准的用户名密码登录为例，讲解了整个认证流程。大致流程如下：</p><ol><li><p>先进入 <code>UsernamePasswordAuthenticationFilter</code> 中，根据输入的用户名和密码信息，构造出一个暂时没有鉴权的 <code>UsernamePasswordAuthenticationToken</code>，并将 UsernamePasswordAuthenticationToken 交给 <code>AuthenticationManager</code>处理。</p></li><li><p><code>AuthenticationManager</code>本身并不做验证处理，他通过 for-each 遍历找到符合当前登录方式的一个 AuthenticationProvider，并交给它进行验证处理，对于用户名密码登录方式，这个 Provider 就是 <code>DaoAuthenticationProvider</code>。</p></li><li><p>在这个 Provider 中进行一系列的验证处理，如果验证通过，就会重新构造一个添加了鉴权的 <code>UsernamePasswordAuthenticationToken</code>，并将这个 token 传回到 <code>UsernamePasswordAuthenticationFilter</code> 中。</p></li><li><p>在该 Filter 的父类 <code>AbstractAuthenticationProcessingFilter</code> 中，会根据上一步验证的结果，跳转到 successHandler 或者是 failureHandler。</p><p><img src="https://www.jitwxs.cn/images/posts/20181202095539982.png" srcset="/img/loading.gif" alt="img"></p><p>​                                                    Spring Security 认证流程（部分）</p></li></ol><h3 id="1-2-短信验证码登录逻辑"><a href="#1-2-短信验证码登录逻辑" class="headerlink" title="1.2 短信验证码登录逻辑"></a>1.2 短信验证码登录逻辑</h3><p>我们可以仿照用户名密码登录的逻辑，来实现短信验证码的登录逻辑。</p><ol><li>用户名密码登录有个 <code>UsernamePasswordAuthenticationFilter</code> ，我们搞一个 <code>SmsAuthenticationFilter</code>，代码粘过来改一改。</li><li>用户名密码登录需要 <code>UsernamePasswordAuthenticationToken</code>，我们搞一个 <code>SmsAuthenticationToken</code>，代码粘过来改一改。</li><li>用户名密码登录需要 <code>DaoAuthenticationProvider</code>，我们模仿它也implenments AuthenticationProvider，叫做 <code>SmsAuthenticationProvider</code>。</li></ol><p><img src="https://www.jitwxs.cn/images/posts/2019010916114182.png" srcset="/img/loading.gif" alt="短信登录验证逻辑"></p><p>​                                                                                短信登录验证逻辑</p><p>我们自己搞了上面三个类以后，想要实现的效果如上图所示。当我们使用短信验证码登录的时候：</p><ol><li>先经过 <code>SmsAuthenticationFilter</code>，构造一个没有鉴权的 <code>SmsAuthenticationToken</code>，然后交给 AuthenticationManager 处理。</li><li>AuthenticationManager 通过 for-each 挑选出一个合适的 provider 进行处理，当然我们希望这个 provider 要是 <code>SmsAuthenticationProvider</code>。</li><li>验证通过后，重新构造一个有鉴权的 <code>SmsAuthenticationToken</code>，并返回给 <code>SmsAuthenticationFilter</code>。</li><li>filter 根据上一步的验证结果，跳转到成功或者失败的处理逻辑。</li></ol><h2 id="二、代码实战"><a href="#二、代码实战" class="headerlink" title="二、代码实战"></a>二、代码实战</h2><p>请通过 github 链接下载第一章代码，或者参看<a href="https://www.jitwxs.cn/5f5715e6.html" target="_blank" rel="noopener">《SpringBoot集成Spring Security（1）——入门程序》</a>初始化项目，这里就不再赘述了。</p><h3 id="2-1-SmsAuthenticationToken"><a href="#2-1-SmsAuthenticationToken" class="headerlink" title="2.1 SmsAuthenticationToken"></a>2.1 SmsAuthenticationToken</h3><p>首先我们编写 <code>SmsAuthenticationToken</code>，这里直接参考 <code>UsernamePasswordAuthenticationToken</code> 源码，直接粘过来，改一改。</p><p><strong>步骤：</strong></p><ol><li><code>principal</code> 原本代表用户名，这里保留，只是代表了手机号码。</li><li><code>credentials</code> 原本代码密码，短信登录用不到，直接删掉。</li><li><code>SmsCodeAuthenticationToken()</code> 两个构造方法一个是构造没有鉴权的，一个是构造有鉴权的。</li><li>剩下的几个方法去除无用属性即可。</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsAuthenticationToken</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAuthenticationToken</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-comment">/** 表示用户的手机号 **/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object principal;    <span class="hljs-comment">/** 构建一个没有鉴权的SmsAuthenticationToken **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmsAuthenticationToken</span><span class="hljs-params">(Object principal)</span></span>&#123;        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">null</span>);        <span class="hljs-keyword">this</span>.principal = principal;        setAuthenticated(<span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-comment">/** 构建一个有鉴权的SmsAuthenticationToken **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmsAuthenticationToken</span><span class="hljs-params">(Collection&lt;? extends GrantedAuthority&gt; authorities, Object principal)</span> </span>&#123;        <span class="hljs-keyword">super</span>(authorities);        <span class="hljs-keyword">this</span>.principal = principal;        <span class="hljs-keyword">super</span>.setAuthenticated(<span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getPrincipal</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.principal;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getCredentials</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthenticated</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isAuthenticated)</span></span>&#123;        <span class="hljs-keyword">if</span>(isAuthenticated)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Cannot set this token to trusted-user constructor which takes a GrantedAuthority list instead"</span>);        &#125;        <span class="hljs-keyword">super</span>.setAuthenticated(<span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eraseCredentials</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.eraseCredentials();    &#125;&#125;</code></pre></div><h3 id="2-2-SmsAuthenticationFilter"><a href="#2-2-SmsAuthenticationFilter" class="headerlink" title="2.2 SmsAuthenticationFilter"></a>2.2 SmsAuthenticationFilter</h3><p>然后编写 <code>SmsAuthenticationFilter</code>，参考 UsernamePasswordAuthenticationFilter 的源码，直接粘过来，改一改。</p><p><strong>步骤：</strong></p><ol><li><p>原本的静态字段有 username 和 password，都干掉，换成我们的手机号字段。</p></li><li><p><code>SmsCodeAuthenticationFilter()</code> 中指定了这个 filter 的拦截 Url，我指定为 post 方式的 <code>/sms/login</code>。</p></li><li><p>剩下来的方法把无效的删删改改就好了。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsAuthenticationFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAuthenticationProcessingFilter</span> </span>&#123;    <span class="hljs-comment">/** form表单中手机号码的字段name **/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SPRING_SECURITY_FORM_MOBILE_KEY = <span class="hljs-string">"mobile"</span>;    <span class="hljs-keyword">private</span> String mobileParameter = SPRING_SECURITY_FORM_MOBILE_KEY;    <span class="hljs-comment">/** 是否仅为post方式 **/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> postOnly = <span class="hljs-keyword">true</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmsAuthenticationFilter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//短信登录请求post方式的/sms/login</span>        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> AntPathRequestMatcher(<span class="hljs-string">"/sms/login"</span>,<span class="hljs-string">"POST"</span>));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException, IOException, ServletException </span>&#123;        <span class="hljs-keyword">if</span>(postOnly &amp;&amp; !request.getMethod().equals(<span class="hljs-string">"POST"</span>))&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">"Authentication method not support:"</span>+request.getMethod());        &#125;        String mobile = obtainMobile(request);                <span class="hljs-keyword">if</span>(mobile == <span class="hljs-keyword">null</span>)&#123;            mobile = <span class="hljs-string">""</span>;        &#125;        mobile = mobile.trim();        SmsAuthenticationToken authRequest = <span class="hljs-keyword">new</span> SmsAuthenticationToken(mobile);        setDetails(request,authRequest);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDetails</span><span class="hljs-params">(HttpServletRequest request, SmsAuthenticationToken authRequest)</span> </span>&#123;        authRequest.setDetails(authenticationDetailsSource.buildDetails(request));    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">obtainMobile</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;        <span class="hljs-keyword">return</span> request.getParameter(mobileParameter);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMobileParameter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> mobileParameter;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMobileParameter</span><span class="hljs-params">(String mobileParameter)</span> </span>&#123;        Assert.hasText(mobileParameter,<span class="hljs-string">"Mobile parameter must not be empty or null"</span>);        <span class="hljs-keyword">this</span>.mobileParameter = mobileParameter;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPostOnly</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> postOnly;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPostOnly</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> postOnly)</span> </span>&#123;        <span class="hljs-keyword">this</span>.postOnly = postOnly;    &#125;&#125;</code></pre></div></li></ol><h3 id="2-3-SmsAuthenticationProvider"><a href="#2-3-SmsAuthenticationProvider" class="headerlink" title="2.3 SmsAuthenticationProvider"></a>2.3 SmsAuthenticationProvider</h3><p>这个方法比较重要，这个方法首先能够在使用短信验证码登录时候被 <code>AuthenticationManager</code> 挑中，其次要在这个类中处理验证逻辑。</p><p><strong>步骤：</strong></p><ol><li><p>实现 AuthenticationProvider 接口，实现 authenticate() 和 supports() 方法。</p></li><li><p><code>supports()</code>方法决定了这个 Provider 要怎么被 AuthenticationManager 挑中，</p><p>我这里通过 <code>return SmsCodeAuthenticationToken.class.isAssignableFrom(authentication)</code>，处理所有 SmsCodeAuthenticationToken 及其子类或子接口。</p></li><li><p><code>authenticate()</code>方法处理验证逻辑。</p><ol><li>首先将 authentication 强转为 <code>SmsCodeAuthenticationToken</code>。</li><li>从中取出登录的 principal，也就是手机号。</li><li>调用自己写的 checkSmsCode() 方法，进行验证码校验，如果不合法，抛出 AuthenticationException 异常。</li><li>如果此时仍然没有异常，通过调用 <code>loadUserByUsername(mobile)</code> 读取出数据库中的用户信息。</li><li>如果仍然能够成功读取，没有异常，这里验证就完成了。</li><li>重新构造鉴权后的 SmsCodeAuthenticationToken，并返回给 SmsCodeAuthenticationFilter 。</li></ol></li><li><p>SmsCodeAuthenticationFilter 的父类在 <code>doFilter()</code> 方法中处理是否有异常，是否成功，根据处理结果跳转到登录成功/失败逻辑。</p></li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsAuthenticationProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationProvider</span> </span>&#123;    <span class="hljs-keyword">private</span> UserDetailsService userDetailsService;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        SmsAuthenticationToken authenticationToken = (SmsAuthenticationToken) authentication;        String mobile = (String) authenticationToken.getPrincipal();        <span class="hljs-comment">//验证码校验</span>        checkSmsCode(mobile);        UserDetails userDetails = userDetailsService.loadUserByUsername(mobile);        <span class="hljs-comment">// 此时鉴权成功后，应当重新 new 一个拥有鉴权的 authenticationResult 返回</span>        SmsAuthenticationToken smsAuthenticationToken = <span class="hljs-keyword">new</span> SmsAuthenticationToken(userDetails.getAuthorities(), userDetails);        smsAuthenticationToken.setDetails(authenticationToken.getDetails());        <span class="hljs-keyword">return</span> smsAuthenticationToken;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkSmsCode</span><span class="hljs-params">(String mobile)</span> </span>&#123;        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();        String inputCode = request.getParameter(<span class="hljs-string">"smsCode"</span>);        Map&lt;String, Object&gt; smsCode = (Map&lt;String, Object&gt;) request.getSession().getAttribute(<span class="hljs-string">"smsCode"</span>);        <span class="hljs-keyword">if</span>(smsCode == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">"未检测到申请验证码"</span>);        &#125;        String applyMobile = (String) smsCode.get(<span class="hljs-string">"mobile"</span>);        <span class="hljs-keyword">int</span> code = (<span class="hljs-keyword">int</span>) smsCode.get(<span class="hljs-string">"code"</span>);        <span class="hljs-keyword">if</span>(!applyMobile.equals(mobile))&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">"申请的手机号与登录的手机号不一致"</span>);        &#125;        <span class="hljs-keyword">if</span>(code != Integer.parseInt(inputCode))&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">"验证码错误"</span>);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; authentication)</span> </span>&#123;        <span class="hljs-comment">//判断Authentication是不是SmsCodeAuthenticationToken的子类或子接口</span>        <span class="hljs-keyword">return</span>  SmsAuthenticationToken<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">isAssignableFrom</span>(<span class="hljs-title">authentication</span>)</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetailsService <span class="hljs-title">getUserDetailsService</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> userDetailsService;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserDetailsService</span><span class="hljs-params">(UserDetailsService userDetailsService)</span> </span>&#123;        <span class="hljs-keyword">this</span>.userDetailsService = userDetailsService;    &#125;&#125;</code></pre></div><h3 id="2-4-成功与失败处理逻辑"><a href="#2-4-成功与失败处理逻辑" class="headerlink" title="2.4 成功与失败处理逻辑"></a>2.4 成功与失败处理逻辑</h3><p>上面最后说到，在 SmsCodeAuthenticationFilter 的父类，会根据验证结果跳转到成功或失败处理逻辑，现在我们就编写下这个的处理。</p><p>这里之前也说过了，直接贴代码了，如果有疑问，请参考<a href="https://www.jitwxs.cn/59f4016e.html" target="_blank" rel="noopener">《SpringBoot集成Spring Security（6）——登录管理》</a>。</p><p><strong>验证成功处理：</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationSuccessHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationSuccessHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Autowired</span>    ObjectMapper objectMapper;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        logger.info(<span class="hljs-string">"登录成功"</span>);        response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);        response.getWriter().write(objectMapper.writeValueAsString(authentication));    &#125;&#125;</code></pre></div><p><strong>验证失败处理</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationFailurehandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationFailureHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Autowired</span>    ObjectMapper objectMapper;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        logger.info(<span class="hljs-string">"登陆失败"</span>);        response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);        response.getWriter().write(objectMapper.writeValueAsString(exception.getMessage()));    &#125;&#125;</code></pre></div><h3 id="2-5-SmsCodeAuthenticationSecurityConfig"><a href="#2-5-SmsCodeAuthenticationSecurityConfig" class="headerlink" title="2.5 SmsCodeAuthenticationSecurityConfig"></a>2.5 SmsCodeAuthenticationSecurityConfig</h3><p>下面我们需要把我们自己写的这么多类添加进 Spring Security 框架中，在以往，我们都是直接往 WebSecurityConfig 中加，但是这样会导致 WebSecurityConfig 内容太多，难以维护。</p><p>因此我们可以为每种登录方式都建议一个专属于它的配置文件，再把这个配置文件加入到 WebSecurityConfig 中，进行解耦。</p><p>因此建立短信验证码登录的配置文件 <code>SmsCodeAuthenticationSecurityConfig</code>:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsCodeAuthenticationSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SecurityConfigurerAdapter</span>&lt;<span class="hljs-title">DefaultSecurityFilterChain</span>, <span class="hljs-title">HttpSecurity</span>&gt; </span>&#123;    <span class="hljs-meta">@Autowired</span>    UserDetailsService userDetailsService;    <span class="hljs-meta">@Autowired</span>    CustomAuthenticationSuccessHandler customAuthenticationSuccessHandler;    <span class="hljs-meta">@Autowired</span>    CustomAuthenticationFailureHandler customAuthenticationFailureHandler;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity builder)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        SmsAuthenticationFilter smsAuthenticationFilter = <span class="hljs-keyword">new</span> SmsAuthenticationFilter();        smsAuthenticationFilter.setAuthenticationManager(builder.getSharedObject(AuthenticationManager<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;        smsAuthenticationFilter.setAuthenticationSuccessHandler(customAuthenticationSuccessHandler);        smsAuthenticationFilter.setAuthenticationFailureHandler(customAuthenticationFailureHandler);                SmsAuthenticationProvider smsAuthenticationProvider = <span class="hljs-keyword">new</span> SmsAuthenticationProvider();        smsAuthenticationProvider.setUserDetailsService(userDetailsService);                builder.authenticationProvider(smsAuthenticationProvider).addFilterAfter(smsAuthenticationFilter, UsernamePasswordAuthenticationFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;&#125;</code></pre></div><p>在这个配置文件中，首先给 SmsCodeAuthenticationFilter 指定了：</p><ol><li>AuthenticationManager：不指定这个上面的流程图就断掉了。</li><li>指定登录成功/失败处理逻辑，方便其父类调用。</li></ol><p>然后指定了 SmsCodeAuthenticationProvider，并指定了 UserDetailsService ，方便在验证处理时候通过 <code>loadUserByUsername()</code> 读取出数据库中的用户信息。</p><p>最后将 filter 和 provider 都加入 HttpSecurity 配置中。</p><p><strong>另外说两句：</strong></p><blockquote><p>开头就说过了，为了方便介绍，写最少的代码，因此这是一个假的短信登录。如果你看这里的 UserDetailsService 的代码话，你会发现它是从数据库中根据 name 获取信息的，我其实就是把用户名来当手机号用。</p><p>因此，如果你想根据数据库中其他字段，例如 phone 来得到用户信息，可以再写一个叫做 SmsUserDetailsService，在这里注入到 provider 中。</p></blockquote><h3 id="2-6-WebSecurityConfig"><a href="#2-6-WebSecurityConfig" class="headerlink" title="2.6 WebSecurityConfig"></a>2.6 WebSecurityConfig</h3><p>下面我们就需要把自己写的 SmsCodeAuthenticationSecurityConfig 加入到 WebSecurityConfig 中了。</p><p>首先将 SmsCodeAuthenticationSecurityConfig 注入进来，然后通过 <code>http.apply(xxx)</code> 添加进去。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="hljs-keyword">true</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SmsCodeAuthenticationSecurityConfig smsCodeAuthenticationSecurityConfig;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.apply(smsCodeAuthenticationSecurityConfig)            .and()            .authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span>                .antMatchers(<span class="hljs-string">"/sms/**"</span>).permitAll()                .anyRequest().authenticated()                .and()                <span class="hljs-comment">// 设置登陆页</span>                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                <span class="hljs-comment">// 设置登陆成功页</span>                .defaultSuccessUrl(<span class="hljs-string">"/"</span>).permitAll()                .and()                .logout().permitAll();        <span class="hljs-comment">// 关闭CSRF跨域</span>        http.csrf().disable();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 设置拦截忽略文件夹，可以对静态资源放行</span>        web.ignoring().antMatchers(<span class="hljs-string">"/css/**"</span>, <span class="hljs-string">"/js/**"</span>);    &#125;&#125;</code></pre></div><h3 id="2-7-接口与页面"><a href="#2-7-接口与页面" class="headerlink" title="2.7 接口与页面"></a>2.7 接口与页面</h3><p>然后在 controller 中写一个读取验证码的接口，注意这个接口在 <code>WebSecurityConfig</code> 中要放行：</p><div class="hljs"><pre><code class="hljs java">   <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/sms/code"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sms</span><span class="hljs-params">(String mobile, HttpSession session)</span></span>&#123;        <span class="hljs-keyword">int</span> code = (<span class="hljs-keyword">int</span>)Math.ceil(Math.random()*<span class="hljs-number">9000</span>+<span class="hljs-number">1000</span>);        Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">16</span>);        map.put(<span class="hljs-string">"mobile"</span>,mobile);        map.put(<span class="hljs-string">"code"</span>,code);                session.setAttribute(<span class="hljs-string">"smsCode"</span>,map);        logger.info(<span class="hljs-string">"&#123;&#125;:为&#123;&#125;设置短信验证码：&#123;&#125;"</span>,session.getId(),mobile,code);    &#125;&#125;</code></pre></div><p>然后修改 login.html 页面，添加短信登录的内容：</p><blockquote><p>注意这里的登录 Url <code>/sms/login</code> 是配置在 SmsAuthenticationFilter 中的 Url。</p></blockquote><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>欢迎来到登录页面<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>立即登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/sms/login"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        手机号：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mobile"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mobile"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jitwxs"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        验证码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"smsCode"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"javascript:;"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"sendSms()"</span>&gt;</span>获取验证码<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>立即登陆<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendSms</span><span class="hljs-params">()</span> </span>&#123;</span><span class="javascript">        <span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">'/sms/code?mobile='</span> + <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"mobile"</span>).value;</span>    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="三、测试代码"><a href="#三、测试代码" class="headerlink" title="三、测试代码"></a>三、测试代码</h2><p>因此只是测试，所以页面懒得弄了，当你输入手机号（实际上就是用户名），点击获取验证码，页面会跳转出去，然后自己再按一下浏览器的后退键退回来。</p><p>在控制台就会打印当前用户的 sessionId，以及为哪一个手机号所申请的验证码。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(7)--认证流程</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-7-%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-7-%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>在前面的六章中，介绍了 Spring Security 的基础使用，在继续深入向下的学习前，有必要理解清楚 Spring Security 的认证流程，这样才能理解为什么要这样写代码，也方便后续的扩展。</p><h2 id="一、认证流程"><a href="#一、认证流程" class="headerlink" title="一、认证流程"></a>一、认证流程</h2><p><img src="https://www.jitwxs.cn/images/posts/20181202095539982.png" srcset="/img/loading.gif" alt="Spring Security 认证流程（部分）"></p><blockquote><p>上图是 Spring Security 认证流程的一部分，下面的讲解以上图为依据。</p></blockquote><p><strong>（1）</strong> 用户发起表单登录请求后，首先进入 <code>UsernamePasswordAuthenticationFilter</code>：</p><p><img src="https://www.jitwxs.cn/images/posts/2018120210045295.png" srcset="/img/loading.gif" alt="UsernamePasswordAuthenticationFilter"></p><p>​                                                                        UsernamePasswordAuthenticationFilter</p><p>在 UsernamePasswordAuthenticationFilter 中根据用户输入的用户名、密码构建了 <code>UsernamePasswordAuthenticationToken</code>，并将其交给 AuthenticationManager 来进行认证处理。</p><p>AuthenticationManager 本身不包含认证逻辑，其核心是用来管理所有的 <code>AuthenticationProvider</code>，通过交由合适的 AuthenticationProvider 来实现认证。</p><p><strong>（2）</strong> 下面跳转到了 <code>ProviderManager</code> ，该类是 AuthenticationManager 的实现类：</p><p><img src="https://www.jitwxs.cn/images/posts/20181202102203137.png" srcset="/img/loading.gif" alt="ProviderManager"></p><p>​                                                                                        ProviderManager</p><p>我们知道不同的登录逻辑它的认证方式是不一样的，比如我们表单登录需要认证用户名和密码，但是当我们使用三方登录时就不需要验证密码。</p><p>Spring Security 支持多种认证逻辑，<strong>每一种认证逻辑的认证方式其实就是一种 AuthenticationProvider</strong>。通过 <code>getProviders()</code> 方法就能获取所有的 AuthenticationProvider，通过 <code>provider.supports()</code> 来判断 provider 是否支持当前的认证逻辑。</p><p>当选择好一个合适的 AuthenticationProvider 后，通过 <code>provider.authenticate(authentication)</code> 来让 AuthenticationProvider 进行认证。</p><p><strong>（3）</strong> 传统表单登录的 AuthenticationProvider 主要是由 <code>AbstractUserDetailsAuthenticationProvider</code> 来进行处理的，我们来看下它的 <code>authenticate()</code>方法。</p><p>首先通过 <code>retrieveUser()</code> 方法读取到数据库中的用户信息：</p><div class="hljs"><pre><code class="hljs java">user = retrieveUser(username,(UsernamePasswordAuthenticationToken) authentication);</code></pre></div><p>retrieveUser() 的具体实现在 <code>DaoAuthenticationProvider</code> 中，代码如下：</p><p><img src="https://www.jitwxs.cn/images/posts/20181202103804350.png" srcset="/img/loading.gif" alt="DaoAuthenticationProvider"></p><p>​                                                                                DaoAuthenticationProvider</p><p><img src="https://www.jitwxs.cn/images/posts/20181202105844461.png" srcset="/img/loading.gif" alt="AbstractUserDetailsAuthenticationProvider"></p><p>​                                                                                AbstractUserDetailsAuthenticationProvider</p><p>在上图中，我们可以看到认证校验分为 <strong>前校验</strong>、<strong>附加校验</strong>和<strong>后校验</strong>，如果任何一个校验出错，就会抛出相应的异常。所有校验都通过后，调用 <code>createSuccessAuthentication()</code> 返回认证信息。</p><p><img src="https://www.jitwxs.cn/images/posts/20181202111353423.png" srcset="/img/loading.gif" alt="createSuccessAuthentication()"></p><p>​                                                                                        createSuccessAuthentication()</p><p>在<code>createSuccessAuthentication</code>方法中，我们发现它重新 new 了一个 <code>UsernamePasswordAuthenticationToken</code>，因为到这里认证已经通过了，所以将 authorities 注入进去，并设置 authenticated 为 true，即已经认证。</p><p>（4）至此认证信息就被传递回 UsernamePasswordAuthenticationFilter 中，在 UsernamePasswordAuthenticationFilter 的父类 <code>AbstractAuthenticationProcessingFilter</code> 的 <code>doFilter()</code> 中，会根据认证的成功或者失败调用相应的 handler：</p><p><img src="https://www.jitwxs.cn/images/posts/20181202113101881.png" srcset="/img/loading.gif" alt="AbstractAuthenticationProcessingFilter"></p><p>​                                                                            AbstractAuthenticationProcessingFilter</p><p>这里调用的 handler 实际就是在<a href="https://www.jitwxs.cn/59f4016e.html" target="_blank" rel="noopener">《SpringBoot集成Spring Security（6）——登录管理》</a>中我们在配置文件中配置的 <code>successHandler()</code> 和 <code>failureHandler()</code>。</p><h2 id="二、多个请求共享认证信息"><a href="#二、多个请求共享认证信息" class="headerlink" title="二、多个请求共享认证信息"></a>二、多个请求共享认证信息</h2><p>Spring Security 通过 <code>Session</code> 来保存用户的认证信息，那么 Spring Security 到底是在什么时候将认证信息放入 Session，又在什么时候将认证信息从 Session 中取出来的呢？</p><p>下面将 Spring Security 的认证流程补充完整，如下图：</p><p><img src="https://www.jitwxs.cn/images/posts/20180630104958316.png" srcset="/img/loading.gif" alt="Spring Security 认证流程"></p><p>​                                                                                                    Spring Security 认证流程</p><p>在上一节认证成功的 <code>successfulAuthentication()</code>方法中，有一行语句：</p><div class="hljs"><pre><code class="hljs java">SecurityContextHolder.getContext().setAuthentication(authResult);</code></pre></div><p>其实就是在这里将认证信息放入 Session 中。</p><p>查看 <code>SecurityContext</code> 源码，发现内部就是对 Authentication 的封装，提供了 equals、hashcode、toString等方法，而<code>SecurityContextHolder</code> 可以理解为线程中的 <code>ThreadLocal</code>。</p><p>我们知道一个 HTTP 请求和响应都是在一个线程中执行，因此在整个处理的任何一个方法中都可以通过 <code>SecurityContextHolder.getContext()</code>来取得存放进去的认证信息。</p><p>从 Session 中对认证信息的处理由 <code>SecurityContextPersistenceFilter</code> 来处理，它位于 Spring Security 过滤器链的最前面，它的主要作用是：</p><ul><li>当请求时，检查 Session 中是否存在 SecurityContext，如果有将其放入到线程中</li><li>当响应时，检查线程中是否存在 SecurityContext，如果有将其放入到 Session 中</li></ul><p><img src="https://www.jitwxs.cn/images/posts/20180630114216422.png" srcset="/img/loading.gif" alt="img"></p><h2 id="三、获取用户认证信息"><a href="#三、获取用户认证信息" class="headerlink" title="三、获取用户认证信息"></a>三、获取用户认证信息</h2><p>通过调用 <code>SecurityContextHolder.getContext().getAuthentication()</code> 就能够取得认证信息：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/me"</span>)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">me</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> SecurityContextHolder.getContext().getAuthentication();&#125;</code></pre></div><p><img src="https://www.jitwxs.cn/images/posts/20181202140404470.png" srcset="/img/loading.gif" alt="img"></p><p>上面的写法有点啰嗦，我们可以简写成下面这种， Spring MVC 会自动帮我们从 Spring Security 中注入：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/me"</span>)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">me</span><span class="hljs-params">(Authentication authentication)</span> </span>&#123;    <span class="hljs-keyword">return</span> authentication;&#125;</code></pre></div><p>如果你仅想获取 <code>UserDetails</code> 对象，也是可以的，写法如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/me"</span>)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">me</span><span class="hljs-params">(@AuthenticationPrincipal UserDetails userDetails)</span> </span>&#123;    <span class="hljs-keyword">return</span> userDetails;&#125;</code></pre></div><p><img src="https://www.jitwxs.cn/images/posts/20181202140702514.png" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(6)--登录管理</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-6-%E7%99%BB%E5%BD%95%E7%AE%A1%E7%90%86/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-6-%E7%99%BB%E5%BD%95%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="一、自定义认证成功、失败处理"><a href="#一、自定义认证成功、失败处理" class="headerlink" title="一、自定义认证成功、失败处理"></a>一、自定义认证成功、失败处理</h2><p>有些时候我们想要在认证成功后做一些业务处理，例如添加积分；有些时候我们想要在认证失败后也做一些业务处理，例如记录日志。</p><p>在之前的文章中，关于认证成功、失败后的处理都是如下配置的：</p><div class="hljs"><pre><code class="hljs java">http.authorizeRequests()    <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span><span class="hljs-comment">//    .antMatchers().permitAll()</span>    .anyRequest().authenticated().and()    <span class="hljs-comment">// 设置登录页</span>    .formLogin().loginPage(<span class="hljs-string">"/login"</span>)    .failureUrl(<span class="hljs-string">"/login/error"</span>)    .defaultSuccessUrl(<span class="hljs-string">"/"</span>)    .permitAll()    ...;</code></pre></div><p>即 <code>failureUrl()</code> 指定认证失败后Url，<code>defaultSuccessUrl()</code> 指定认证成功后Url。我们可以通过设置 <code>successHandler()</code> 和 <code>failureHandler()</code> 来实现自定义认证成功、失败处理。</p><blockquote><p>PS：当我们设置了这两个后，需要去除 <code>failureUrl()</code> 和 <code>defaultSuccessUrl()</code> 的设置，否则无法生效。这两套配置同时只能存在一套。</p></blockquote><h3 id="1-1-CustomAuthenticationSuccessHandler"><a href="#1-1-CustomAuthenticationSuccessHandler" class="headerlink" title="1.1 CustomAuthenticationSuccessHandler"></a>1.1 CustomAuthenticationSuccessHandler</h3><p>自定义 CustomAuthenticationSuccessHandler 类来实现 <code>AuthenticationSuccessHandler</code> 接口，用来处理认证成功后逻辑：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationSuccessHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationSuccessHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,                 Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        logger.info(<span class="hljs-string">"登录成功，&#123;&#125;"</span>,authentication);                response.sendRedirect(<span class="hljs-string">"/"</span>);    &#125;&#125;</code></pre></div><p><code>onAuthenticationSuccess()</code> 方法的第三个参数 <code>Authentication</code> 为认证后该用户的认证信息，这里打印日志后，重定向到了首页。</p><h3 id="1-2-CustomAuthenticationFailureHandler"><a href="#1-2-CustomAuthenticationFailureHandler" class="headerlink" title="1.2 CustomAuthenticationFailureHandler"></a>1.2 CustomAuthenticationFailureHandler</h3><p>自定义 CustomAuthenticationFailureHandler 类来实现 <code>AuthenticationFailureHandler</code> 接口，用来处理认证失败后逻辑：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationFailureHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationFailureHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Autowired</span>    ObjectMapper objectMapper;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        logger.info(<span class="hljs-string">"登录失败"</span>);        response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());        response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);        response.getWriter().write(objectMapper.writeValueAsString(exception.getMessage()));    &#125;&#125;</code></pre></div><p><code>onAuthenticationFailure()</code>方法的第三个参数 <code>exception</code> 为认证失败所产生的异常，这里也是简单的返回到前台。</p><h3 id="1-3-修改-WebSecurityConfig"><a href="#1-3-修改-WebSecurityConfig" class="headerlink" title="1.3 修改 WebSecurityConfig"></a>1.3 修改 WebSecurityConfig</h3><div class="hljs"><pre><code class="hljs java">    <span class="hljs-meta">@Autowired</span>    CustomAuthenticationSuccessHandler authenticationSuccessHandler;    <span class="hljs-meta">@Autowired</span>    CustomAuthenticationFailureHandler authenticationFailureHandler; <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span><span class="hljs-comment">//                .antMatchers().permitAll()</span>                .anyRequest().authenticated()                .and()                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                .successHandler(authenticationSuccessHandler)                .failureHandler(authenticationFailureHandler)            .permitAll() <span class="hljs-comment">//很关键</span><span class="hljs-comment">//                .defaultSuccessUrl("/").permitAll()</span>                .and()                .logout()                .logoutSuccessUrl(<span class="hljs-string">"/logout"</span>)                .permitAll();        <span class="hljs-comment">//关闭CRSF跨域</span>        http.csrf().disable();    &#125;</code></pre></div><ol><li>首先将 <code>customAuthenticationSuccessHandler</code> 和 <code>customAuthenticationFailureHandler</code>注入进来</li><li>配置 <code>successHandler()</code> 和 <code>failureHandler()</code></li><li>注释 <code>failureUrl()</code> 和 <code>defaultSuccessUrl()</code></li></ol><h3 id="1-4-运行程序"><a href="#1-4-运行程序" class="headerlink" title="1.4 运行程序"></a>1.4 运行程序</h3><p>运行程序，当我们成功登陆后，发现日志信息被打印出来，页面被重定向到了首页：</p><p><img src="https://www.jitwxs.cn/images/posts/20190110174809434.png" srcset="/img/loading.gif" alt="img"></p><p>当我们认证失败后，发现日志中“登陆失败”被打印出来，页面展示了认证失败的异常消息：</p><p><img src="https://www.jitwxs.cn/images/posts/20190110174827988.png" srcset="/img/loading.gif" alt="img"></p><h2 id="二、Session-超时"><a href="#二、Session-超时" class="headerlink" title="二、Session 超时"></a>二、Session 超时</h2><p>当用户登录后，我们可以设置 session 的超时时间，当达到超时时间后，自动将用户退出登录。</p><p>Session 超时的配置是 SpringBoot 原生支持的，我们只需要在 <code>application.properties</code> 配置文件中配置：</p><div class="hljs"><pre><code class="hljs java">server.servlet.session.timeout=<span class="hljs-number">60</span>s</code></pre></div><blockquote><p>Tip：<br>从用户最后一次操作开始计算过期时间。<br>过期时间最小值为 60 秒，如果你设置的值小于 60 秒，也会被更改为 60 秒。</p></blockquote><p>我们可以在 Spring Security 中配置处理逻辑，在 session 过期退出时调用。修改 WebSecurityConfig 的 <code>configure()</code> 方法，添加：</p><div class="hljs"><pre><code class="hljs java">.sessionManagement()    <span class="hljs-comment">// 以下二选一</span>    <span class="hljs-comment">//.invalidSessionStrategy()</span>    <span class="hljs-comment">//.invalidSessionUrl();</span></code></pre></div><p>Spring Security 提供了两种处理配置，一个是 <code>invalidSessionStrategy()</code>，另外一个是 <code>invalidSessionUrl()</code>。</p><p>这两个的区别就是一个是前者是在一个类中进行处理，后者是直接跳转到一个 Url。简单起见，我就直接用 <code>invalidSessionUrl()</code>了，跳转到 <code>/login/invalid</code>，我们需要把该 Url 设置为免授权访问， 配置如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http.authorizeRequests()            <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span>            .antMatchers(<span class="hljs-string">"/login/invalid"</span>).permitAll()            .anyRequest().authenticated().and()            ...            .sessionManagement()                .invalidSessionUrl(<span class="hljs-string">"/login/invalid"</span>);    <span class="hljs-comment">// 关闭CSRF跨域</span>    http.csrf().disable();&#125;</code></pre></div><p>在 controller 中写一个接口进行处理：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/login/invalid"</span>)<span class="hljs-meta">@ResponseStatus</span>(HttpStatus.UNAUTHORIZED)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">invalid</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"Session 已过期，请重新登录"</span>;&#125;</code></pre></div><p>运行程序，登录成功后等待一分钟（或者重启服务器），刷新页面：</p><p><img src="https://www.jitwxs.cn/images/posts/20190110171026663.png" srcset="/img/loading.gif" alt="session 过期"></p><h2 id="三、限制最大登录数"><a href="#三、限制最大登录数" class="headerlink" title="三、限制最大登录数"></a>三、限制最大登录数</h2><p>接下来实现限制最大登录数，原理就是限制单个用户能够存在的最大 session 数。</p><p>在上一节的基础上，修改 <code>configure()</code> 为：</p><div class="hljs"><pre><code class="hljs java">.sessionManagement()    .invalidSessionUrl(<span class="hljs-string">"/login/invalid"</span>)    .maximumSessions(<span class="hljs-number">1</span>)    <span class="hljs-comment">// 当达到最大值时，是否保留已经登录的用户</span>    .maxSessionsPreventsLogin(<span class="hljs-keyword">false</span>)    <span class="hljs-comment">// 当达到最大值时，旧用户被踢出后的操作</span>    .expiredSessionStrategy(<span class="hljs-keyword">new</span> CustomExpiredSessionStrategy())</code></pre></div><p>增加了下面三行代码，其中：</p><ul><li><code>maximumSessions(int)</code>：指定最大登录数</li><li><code>maxSessionsPreventsLogin(boolean)</code>：是否保留已经登录的用户；为true，新用户无法登录；为 false，旧用户被踢出</li><li><code>expiredSessionStrategy(SessionInformationExpiredStrategy)</code>：旧用户被踢出后处理方法</li></ul><blockquote><p><code>maxSessionsPreventsLogin()</code>可能不太好理解，这里我们先设为 false，效果和 QQ 登录是一样的，登录后之前登录的账户被踢出。</p></blockquote><p>编写 CustomExpiredSessionStrategy 类，来处理旧用户登录失败的逻辑：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomExpiredSessionStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SessionInformationExpiredStrategy</span> </span>&#123;    <span class="hljs-keyword">private</span> ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();<span class="hljs-comment">//    private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onExpiredSessionDetected</span><span class="hljs-params">(SessionInformationExpiredEvent event)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        Map&lt;String,Object&gt;map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">16</span>);        map.put(<span class="hljs-string">"code"</span>,<span class="hljs-number">0</span>);        map.put(<span class="hljs-string">"msg"</span>,<span class="hljs-string">"已经另一台机器登录，您被迫下线"</span>);        <span class="hljs-comment">//Map -&gt; json</span>        String json = objectMapper.writeValueAsString(map);        event.getResponse().setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);        event.getResponse().getWriter().write(json);                <span class="hljs-comment">//如果是跳转html页面，url代表跳转的地址</span><span class="hljs-comment">//        redirectStrategy.sendRedirect(event.getRequest(),event.getResponse(),"url");</span>    &#125;&#125;</code></pre></div><p>在 <code>onExpiredSessionDetected()</code> 方法中，处理相关逻辑，我这里只是简单的返回一句话。</p><p>执行程序，打开两个浏览器，登录同一个账户。因为我设置了 <code>maximumSessions(1)</code>，也就是单个用户只能存在一个 session，因此当你刷新先登录的那个浏览器时，被提示踢出了。</p><p><img src="https://www.jitwxs.cn/images/posts/2019011017515758.png" srcset="/img/loading.gif" alt="maxSessionsPreventsLogin 为 false"></p><p>下面我们来测试下 <code>maxSessionsPreventsLogin(true)</code> 时的情况，我们发现第一个浏览器登录后，第二个浏览器无法登录：</p><p><img src="https://www.jitwxs.cn/images/posts/20190110175325653.png" srcset="/img/loading.gif" alt="maxSessionsPreventsLogin 为 true"></p><h2 id="四、踢出用户"><a href="#四、踢出用户" class="headerlink" title="四、踢出用户"></a>四、踢出用户</h2><p>下面来看下如何主动踢出一个用户。</p><p>首先需要在容器中注入名为 <code>SessionRegistry</code> 的 Bean，这里我就简单的写在 WebSecurityConfig 中：</p><p>修改 WebSecurityConfig 的 configure() 方法，在最后添加一行 <code>.sessionRegistry()</code>：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    ...    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SessionRegistry <span class="hljs-title">sessionRegistry</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SessionRegistryImpl();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span>                .antMatchers(<span class="hljs-string">"/login/invalid"</span>).permitAll()                .anyRequest().authenticated().and()                <span class="hljs-comment">// 设置登录页</span>                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                .successHandler(customAuthenticationSuccessHandler)                .failureHandler(customAuthenticationFailureHandler)                .permitAll().and()                .logout().and()                .sessionManagement()                    .invalidSessionUrl(<span class="hljs-string">"/login/invalid"</span>)                    .maximumSessions(<span class="hljs-number">1</span>)                    <span class="hljs-comment">// 当达到最大值时，是否保留已经登录的用户</span>                    .maxSessionsPreventsLogin(<span class="hljs-keyword">false</span>)                    <span class="hljs-comment">// 当达到最大值时，旧用户被踢出后的操作</span>                    .expiredSessionStrategy(<span class="hljs-keyword">new</span> CustomExpiredSessionStrategy())                    .sessionRegistry(sessionRegistry());        <span class="hljs-comment">// 关闭CSRF跨域</span>        http.csrf().disable();    &#125;&#125;</code></pre></div><p>编写一个接口用于测试踢出用户：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SessionRegistry sessionRegistry;    ...    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/kick"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">removeUserSessionByUsername</span><span class="hljs-params">(@RequestParam String username)</span> </span>&#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 获取session中所有的用户信息</span>        List&lt;Object&gt; users = sessionRegistry.getAllPrincipals();        <span class="hljs-keyword">for</span> (Object principal : users) &#123;            <span class="hljs-keyword">if</span> (principal <span class="hljs-keyword">instanceof</span> User) &#123;                String principalName = ((User)principal).getUsername();                <span class="hljs-keyword">if</span> (principalName.equals(username)) &#123;                    <span class="hljs-comment">// 参数二：是否包含过期的Session</span>                    List&lt;SessionInformation&gt; sessionsInfo = sessionRegistry.getAllSessions(principal, <span class="hljs-keyword">false</span>);                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != sessionsInfo &amp;&amp; sessionsInfo.size() &gt; <span class="hljs-number">0</span>) &#123;                        <span class="hljs-keyword">for</span> (SessionInformation sessionInformation : sessionsInfo) &#123;                            sessionInformation.expireNow();                            count++;                        &#125;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">"操作成功，清理session共"</span> + count + <span class="hljs-string">"个"</span>;    &#125;&#125;</code></pre></div><ol><li><code>sessionRegistry.getAllPrincipals();</code> 获取所有 principal 信息</li><li>通过 <code>principal.getUsername</code>是否等于输入值，获取到指定用户的 principal</li><li><code>sessionRegistry.getAllSessions(principal, false)</code>获取该 principal 上的所有 session</li><li>通过 <code>sessionInformation.expireNow()</code> 使得 session 过期</li></ol><p>运行程序，分别使用 admin 和 jitwxs 账户登录，admin 访问 <code>/kick?username=jitwxs</code> 来踢出用户 jitwxs，jitwxs 刷新页面，发现被踢出。</p><p><img src="https://img-blog.csdnimg.cn/20200531234209914.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="五、退出登录"><a href="#五、退出登录" class="headerlink" title="五、退出登录"></a>五、退出登录</h2><p>补充一下退出登录的内容，在之前，我们直接在 WebSecurityConfig 的 configure() 方法中，配置了：</p><div class="hljs"><pre><code class="hljs java">http.logout();</code></pre></div><p>这就是 Spring Security 的默认退出配置，Spring Security 在退出时候做了这样几件事：</p><ol><li>使当前的 session 失效</li><li>清除与当前用户有关的 remember-me 记录</li><li>清空当前的 SecurityContext</li><li>重定向到登录页</li></ol><p>Spring Security 默认的退出 Url 是 <code>/logout</code>，我们可以修改默认的退出 Url，例如修改为 <code>/signout</code>：</p><div class="hljs"><pre><code class="hljs java">http.logout()    .logoutUrl(<span class="hljs-string">"/signout"</span>);</code></pre></div><p>我们也可以配置当退出时清除浏览器的 Cookie，例如清除 名为 JSESSIONID 的 cookie：</p><div class="hljs"><pre><code class="hljs java">http.logout()    .logoutUrl(<span class="hljs-string">"/signout"</span>)    .deleteCookies(<span class="hljs-string">"JSESSIONID"</span>);</code></pre></div><p>我们也可以配置退出后处理的逻辑，方便做一些别的操作：</p><div class="hljs"><pre><code class="hljs java">http.logout()    .logoutUrl(<span class="hljs-string">"/signout"</span>)    .deleteCookies(<span class="hljs-string">"JSESSIONID"</span>)    .logoutSuccessHandler(logoutSuccessHandler);</code></pre></div><p>创建类 <code>DefaultLogoutSuccessHandler</code>：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomLogoutSuccessHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LogoutSuccessHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLogoutSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        String username = ((User) authentication.getPrincipal()).getUsername();        logger.info(<span class="hljs-string">"退出成功，用户名：&#123;&#125;"</span>,username);        <span class="hljs-comment">//重定向到登录页</span>        response.sendRedirect(<span class="hljs-string">"/login"</span>);    &#125;&#125;</code></pre></div><p>最后把它注入到 WebSecurityConfig 即可：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> CustomLogoutSuccessHandler logoutSuccessHandler;</code></pre></div><p>效果：</p><p><img src="https://img-blog.csdnimg.cn/2020053123365730.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="六、Session-共享"><a href="#六、Session-共享" class="headerlink" title="六、Session 共享"></a>六、Session 共享</h2><p>在最后补充下关于 Session 共享的知识点，一般情况下，一个程序为了保证稳定至少要部署两个，构成集群。那么就牵扯到了 Session 共享的问题，不然用户在 8080 登录成功后，后续访问了 8060 服务器，结果又提示没有登录。</p><p>这里就简单实现下 Session 共享，采用 Redis 来存储。</p><h3 id="6-1-配置-Redis"><a href="#6-1-配置-Redis" class="headerlink" title="6.1 配置 Redis"></a>6.1 配置 Redis</h3><p>为了方便起见，我直接使用 Docker 快速部署，如果你需要传统方式安装，可以参考文章<a href="https://www.jitwxs.cn/e331e26a.html" target="_blank" rel="noopener">《Redis 初探（1）——Redis 的安装》</a>。</p><div class="hljs"><pre><code class="hljs applescript">docker pull redisdocker <span class="hljs-built_in">run</span> <span class="hljs-comment">--name myredis -p 6379:6379 -d redis</span>docker exec -<span class="hljs-keyword">it</span> myredis redis-cli</code></pre></div><p>这里因为我ubutun连不上网，所以用的是redis客户端</p><h3 id="6-2-配置-Session-共享"><a href="#6-2-配置-Session-共享" class="headerlink" title="6.2 配置 Session 共享"></a>6.2 配置 Session 共享</h3><p>首先需要导入依赖，因为我们采用 Redis 方式实现，因此导入：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--redis相关依赖--&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>在 <code>application.xml</code> 中新增配置指定 redis 地址以及 session 的存储方式：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-comment">#redis相关配置</span><span class="hljs-string">spring.redis.host=localhost</span><span class="hljs-string">spring.redis.port=6379</span><span class="hljs-string">spring.session.store-type=redis</span></code></pre></div><p>然后为主类添加 <code>@EnableRedisHttpSession</code> 注解。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@EnableRedisHttpSession</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringSecuriity06Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(SpringSecuriity06Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><h3 id="6-3-运行程序"><a href="#6-3-运行程序" class="headerlink" title="6.3 运行程序"></a>6.3 运行程序</h3><p>这样就完成了基于 Redis 的 Session 共享，下面来测试下。首先修改 IDEA 配置来允许项目在多端口运行，勾选 <code>Allow running in parallel</code>(2018.2版本好像没有该选项，应该是取消勾选<code>Single instance only</code>)：</p><p><img src="https://img-blog.csdnimg.cn/20200531233713573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>运行程序，然后修改配置文件，将 <code>server.port</code> 更改为 8060，再次运行。这样项目就会分别在默认的 8080 端口和 8060 端口运行。</p><p><img src="https://img-blog.csdnimg.cn/20200531233941130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>先访问 <code>localhost:8080</code>，登录成功后，再访问 <code>localhost:8060</code>，发现无需登录。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(5)--权限控制</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-5-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-5-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>在第一篇中，我们说过，<strong>用户&lt;–&gt;角色&lt;–&gt;权限</strong>三层中，暂时不考虑权限，在这一篇，是时候把它完成了。</p><p>为了方便演示，这里的权限只是对角色赋予权限，也就是说同一个角色的用户，权限是一样的。当然了，你也可以精细化到为每一个用户设置权限，但是这不在本篇的探讨范围，有兴趣可以自己实验，原理都是一样的。</p><h2 id="一、数据准备"><a href="#一、数据准备" class="headerlink" title="一、数据准备"></a>一、数据准备</h2><h3 id="1-1-创建-sys-permission-表"><a href="#1-1-创建-sys-permission-表" class="headerlink" title="1.1 创建 sys_permission 表"></a>1.1 创建 sys_permission 表</h3><p>让我们先创建一张权限表，名为 <code>sys_permission</code>：</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`sys_permission`</span>(<span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,<span class="hljs-string">`url`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,<span class="hljs-string">`role_id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,<span class="hljs-string">`permission`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,PRIMARY <span class="hljs-keyword">KEY</span>(<span class="hljs-string">`id`</span>),<span class="hljs-keyword">KEY</span> <span class="hljs-string">`fk_roleId`</span>(<span class="hljs-string">`role_id`</span>),<span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-string">`fk_roleId`</span> <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span>(<span class="hljs-string">`role_id`</span>) <span class="hljs-keyword">REFERENCES</span> <span class="hljs-string">`sys_role`</span>(<span class="hljs-string">`id`</span>) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">CASCADE</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">CASCADE</span>)<span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">5</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4;</code></pre></div><p>内容就是两条数据，通过 <code>url</code> + <code>role_id</code> + <code>permission</code> 唯一标识了一个角色访问某一url时的权限，其中权限暂定为c、r、u、d，代表了增、删、改、查。</p><p><img src="https://www.jitwxs.cn/images/posts/20180515185020939.png" srcset="/img/loading.gif" alt="sys_permission 表数据"></p><h3 id="1-2-创建-Model、Mapper、Service"><a href="#1-2-创建-Model、Mapper、Service" class="headerlink" title="1.2 创建 Model、Mapper、Service"></a>1.2 创建 Model、Mapper、Service</h3><p>（1）Model</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysPermission</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String url;    <span class="hljs-keyword">private</span> Integer roleId;    <span class="hljs-keyword">private</span> String permission;    <span class="hljs-keyword">private</span> List permissions;    <span class="hljs-comment">//省略getter，setter</span>&#125;</code></pre></div><p>这里需要注意的时相比于数据库，多了一个 <code>permissions</code> 属性，该字段将 <code>permission</code> 按逗号分割为了 list。</p><p>（2）mapper</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysPermissionMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_permission WHERE role_id=#&#123;roleId&#125;"</span>)    List&lt;SysPermission&gt;listByRoleId(Integer roleId);&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysRoleMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_role WHERE id = #&#123;id&#125;"</span>)    <span class="hljs-function">SysRole <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_role WHERE name = #&#123;name&#125;"</span>)    <span class="hljs-function">SysRole <span class="hljs-title">selectByName</span><span class="hljs-params">(String name)</span></span>;&#125;</code></pre></div><p>（3）Service</p><p>SysPermissionService 中有一个方法，根据 roleId 获取所有的 <code>SysPermission</code>。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysPermissionService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysPermissionMapper permissionMapper;        <span class="hljs-comment">/**获取指定角色所有权限**/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;SysPermission&gt; <span class="hljs-title">listByRoleId</span><span class="hljs-params">(Integer roleId)</span></span>&#123;        <span class="hljs-keyword">return</span> permissionMapper.listByRoleId(roleId);    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysRoleService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysRoleMapper sysRoleMapper;        <span class="hljs-function"><span class="hljs-keyword">public</span> SysRole <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>&#123;        <span class="hljs-keyword">return</span> sysRoleMapper.selectById(id);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> SysRole <span class="hljs-title">selectByName</span><span class="hljs-params">(String name)</span></span>&#123;        <span class="hljs-keyword">return</span> sysRoleMapper.selectByName(name);    &#125;&#125;</code></pre></div><h3 id="1-3-修改接口"><a href="#1-3-修改接口" class="headerlink" title="1.3 修改接口"></a>1.3 修改接口</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;    <span class="hljs-comment">//...</span>    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/admin"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasPermission('/admin','r')"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">printAdminR</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"如果你看见这句话，说明你访问/admin路径具有r权限"</span>;    &#125;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/admin/c"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasPermission('/admin','c')"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">printAdminC</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"如果你看见这句话，说明你访问/admin路径具有c权限"</span>;    &#125;&#125;</code></pre></div><p>让我们修改下我们要访问的接口，<code>@PreAuthorize(&quot;hasPermission(&#39;/admin&#39;,&#39;r&#39;)&quot;)</code> 是关键，参数1指明了<strong>访问该接口需要的url</strong>，参数2指明了<strong>访问该接口需要的权限</strong>。</p><h2 id="二、PermissionEvaluator"><a href="#二、PermissionEvaluator" class="headerlink" title="二、PermissionEvaluator"></a>二、PermissionEvaluator</h2><p>我们需要自定义对 <code>hasPermission()</code> 方法的处理，就需要自定义 <code>PermissionEvaluator</code>，创建类 <code>CustomPermissionEvaluator</code>，实现 <code>PermissionEvaluator</code> 接口。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomPermissionEvaluator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PermissionEvaluator</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysPermissionService permissionService;    <span class="hljs-meta">@Autowired</span>    SysRoleService roleService;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPermission</span><span class="hljs-params">(Authentication authentication, Object targetUrl, Object targetPermission)</span> </span>&#123;        <span class="hljs-comment">//获得loadUserByUsername()方法的结果</span>        User user = (User) authentication.getPrincipal();        <span class="hljs-comment">//获得loadUserByUsername()中注入的角色</span>        Collection&lt;GrantedAuthority&gt; authorities = user.getAuthorities();        <span class="hljs-comment">//遍历用户所有角色</span>        <span class="hljs-keyword">for</span>(GrantedAuthority authority:authorities)&#123;            String roleName = authority.getAuthority();            Integer roleId = roleService.selectByName(roleName).getId();            <span class="hljs-comment">//得到角色所有的权限</span>            List&lt;SysPermission&gt; permissionList = permissionService.listByRoleId(roleId);            <span class="hljs-comment">//遍历permissionList</span>            <span class="hljs-keyword">for</span>(SysPermission sysPermission:permissionList)&#123;                <span class="hljs-comment">//获取权限集</span>                List permissions = sysPermission.getPermissions();                <span class="hljs-comment">//如果访问的url和权限用户符合的话，返回true</span>                <span class="hljs-keyword">if</span>(targetUrl.equals(sysPermission.getUrl()) &amp;&amp; permissions.contains(targetPermission))&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPermission</span><span class="hljs-params">(Authentication authentication, Serializable targetId, String targetType, Object permission)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><p>在 <code>hasPermission()</code> 方法中，参数 1 代表<strong>用户的权限身份</strong>，参数 2 参数 3 分别和 <code>@PreAuthorize(&quot;hasPermission(&#39;/admin&#39;,&#39;r&#39;)&quot;)</code> 中的参数对应，即<strong>访问 url 和权限</strong>。</p><p>思路如下：</p><ol><li>通过 <code>Authentication</code> 取出登录用户的所有 <code>Role</code></li><li>遍历每一个 <code>Role</code>，获取到每个<code>Role</code>的所有 <code>Permission</code></li><li>遍历每一个 <code>Permission</code>，只要有一个 <code>Permission</code> 的 <code>url</code> 和传入的url相同，且该 <code>Permission</code> 中包含传入的权限，返回 true</li><li>如果遍历都结束，还没有找到，返回false</li></ol><p>下面就是在 <code>WebSecurityConfig</code> 中注册 <code>CustomPermissionEvaluator</code>：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DefaultWebSecurityExpressionHandler <span class="hljs-title">webSecurityExpressionHandler</span><span class="hljs-params">()</span></span>&#123;        DefaultWebSecurityExpressionHandler handler = <span class="hljs-keyword">new</span> DefaultWebSecurityExpressionHandler();        handler.setPermissionEvaluator(<span class="hljs-keyword">new</span> CustomPermissionEvaluator());        <span class="hljs-keyword">return</span> handler;    &#125;&#125;</code></pre></div><h2 id="三、运行程序"><a href="#三、运行程序" class="headerlink" title="三、运行程序"></a>三、运行程序</h2><p>当我使用角色为 <code>ROLE_USER</code> 的用户仍然能访问，因为该用户访问 <code>/admin</code> 路径具有 <code>r</code> 权限：</p><p><img src="https://www.jitwxs.cn/images/posts/2018051519070954.png" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(4)--自定义表单登录</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%8D%95%E7%99%BB%E5%BD%95/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%8D%95%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="一、添加验证码"><a href="#一、添加验证码" class="headerlink" title="一、添加验证码"></a>一、添加验证码</h3><h4 id="1-1-验证码-Servlet"><a href="#1-1-验证码-Servlet" class="headerlink" title="1.1 验证码 Servlet"></a>1.1 验证码 Servlet</h4><p>验证码的 Servlet 代码，大家无需关心其内部实现，我也是百度直接捞了一个，直接复制即可。</p><div class="hljs"><pre><code class="hljs java">com.gavin.springsecurity04.common.VerifyServlet    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VerifyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123; <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">5051097528828603895L</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 验证码图片的宽度。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> width = <span class="hljs-number">100</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *  验证码图片的高度。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height = <span class="hljs-number">30</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 验证码字符个数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> codeCount = <span class="hljs-number">4</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 字体高度</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> fontHeight;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 干扰线数量</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> interLine = <span class="hljs-number">16</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 第一个字符的x轴值，因为后面的字符坐标依次递增，所以它们的x轴值是codeX的倍数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> codeX;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * codeY ,验证字符的y轴值，因为并行所以值一样</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> codeY;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * codeSequence 表示字符允许出现的序列值</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">char</span>[] codeSequence = &#123; <span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>, <span class="hljs-string">'H'</span>, <span class="hljs-string">'I'</span>, <span class="hljs-string">'J'</span>,            <span class="hljs-string">'K'</span>, <span class="hljs-string">'L'</span>, <span class="hljs-string">'M'</span>, <span class="hljs-string">'N'</span>, <span class="hljs-string">'O'</span>, <span class="hljs-string">'P'</span>, <span class="hljs-string">'Q'</span>, <span class="hljs-string">'R'</span>, <span class="hljs-string">'S'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">'U'</span>, <span class="hljs-string">'V'</span>, <span class="hljs-string">'W'</span>,            <span class="hljs-string">'X'</span>, <span class="hljs-string">'Y'</span>, <span class="hljs-string">'Z'</span>, <span class="hljs-string">'0'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'6'</span>, <span class="hljs-string">'7'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'9'</span> &#125;;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 初始化验证图片属性</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;        <span class="hljs-comment">// 从web.xml中获取初始信息</span>        <span class="hljs-comment">// 宽度</span>        String strWidth = <span class="hljs-keyword">this</span>.getInitParameter(<span class="hljs-string">"width"</span>);        <span class="hljs-comment">// 高度</span>        String strHeight = <span class="hljs-keyword">this</span>.getInitParameter(<span class="hljs-string">"height"</span>);        <span class="hljs-comment">// 字符个数</span>        String strCodeCount = <span class="hljs-keyword">this</span>.getInitParameter(<span class="hljs-string">"codeCount"</span>);        <span class="hljs-comment">// 将配置的信息转换成数值</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (strWidth != <span class="hljs-keyword">null</span> &amp;&amp; strWidth.length() != <span class="hljs-number">0</span>) &#123;                width = Integer.parseInt(strWidth);            &#125;            <span class="hljs-keyword">if</span> (strHeight != <span class="hljs-keyword">null</span> &amp;&amp; strHeight.length() != <span class="hljs-number">0</span>) &#123;                height = Integer.parseInt(strHeight);            &#125;            <span class="hljs-keyword">if</span> (strCodeCount != <span class="hljs-keyword">null</span> &amp;&amp; strCodeCount.length() != <span class="hljs-number">0</span>) &#123;                codeCount = Integer.parseInt(strCodeCount);            &#125;        &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-comment">//width-4 除去左右多余的位置，使验证码更加集中显示，减得越多越集中。</span>        <span class="hljs-comment">//codeCount+1     //等比分配显示的宽度，包括左右两边的空格</span>        codeX = (width-<span class="hljs-number">4</span>) / (codeCount+<span class="hljs-number">1</span>);        <span class="hljs-comment">//height - 10 集中显示验证码</span>        fontHeight = height - <span class="hljs-number">10</span>;        codeY = height - <span class="hljs-number">7</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ServletException</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> java.io.IOException</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, java.io.IOException </span>&#123;        <span class="hljs-comment">// 定义图像buffer</span>        BufferedImage buffImg = <span class="hljs-keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);        Graphics2D gd = buffImg.createGraphics();        <span class="hljs-comment">// 创建一个随机数生成器类</span>        Random random = <span class="hljs-keyword">new</span> Random();        <span class="hljs-comment">// 将图像填充为白色</span>        gd.setColor(Color.LIGHT_GRAY);        gd.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);        <span class="hljs-comment">// 创建字体，字体的大小应该根据图片的高度来定。</span>        Font font = <span class="hljs-keyword">new</span> Font(<span class="hljs-string">"Times New Roman"</span>, Font.PLAIN, fontHeight);        <span class="hljs-comment">// 设置字体。</span>        gd.setFont(font);        <span class="hljs-comment">// 画边框。</span>        gd.setColor(Color.BLACK);        gd.drawRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width - <span class="hljs-number">1</span>, height - <span class="hljs-number">1</span>);        <span class="hljs-comment">// 随机产生16条干扰线，使图象中的认证码不易被其它程序探测到。</span>        gd.setColor(Color.gray);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; interLine; i++) &#123;            <span class="hljs-keyword">int</span> x = random.nextInt(width);            <span class="hljs-keyword">int</span> y = random.nextInt(height);            <span class="hljs-keyword">int</span> xl = random.nextInt(<span class="hljs-number">12</span>);            <span class="hljs-keyword">int</span> yl = random.nextInt(<span class="hljs-number">12</span>);            gd.drawLine(x, y, x + xl, y + yl);        &#125;        <span class="hljs-comment">// randomCode用于保存随机产生的验证码，以便用户登录后进行验证。</span>        StringBuffer randomCode = <span class="hljs-keyword">new</span> StringBuffer();        <span class="hljs-keyword">int</span> red = <span class="hljs-number">0</span>, green = <span class="hljs-number">0</span>, blue = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 随机产生codeCount数字的验证码。</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; codeCount; i++) &#123;            <span class="hljs-comment">// 得到随机产生的验证码数字。</span>            String strRand = String.valueOf(codeSequence[random.nextInt(<span class="hljs-number">36</span>)]);            <span class="hljs-comment">// 产生随机的颜色分量来构造颜色值，这样输出的每位数字的颜色值都将不同。</span>            red = random.nextInt(<span class="hljs-number">255</span>);            green = random.nextInt(<span class="hljs-number">255</span>);            blue = random.nextInt(<span class="hljs-number">255</span>);            <span class="hljs-comment">// 用随机产生的颜色将验证码绘制到图像中。</span>            gd.setColor(<span class="hljs-keyword">new</span> Color(red,green,blue));            gd.drawString(strRand, (i + <span class="hljs-number">1</span>) * codeX, codeY);            <span class="hljs-comment">// 将产生的四个随机数组合在一起。</span>            randomCode.append(strRand);        &#125;        <span class="hljs-comment">// 将四位数字的验证码保存到Session中。</span>        HttpSession session = request.getSession();        session.setAttribute(<span class="hljs-string">"validateCode"</span>, randomCode.toString());        <span class="hljs-comment">// 禁止图像缓存。</span>        response.setHeader(<span class="hljs-string">"Pragma"</span>, <span class="hljs-string">"no-cache"</span>);        response.setHeader(<span class="hljs-string">"Cache-Control"</span>, <span class="hljs-string">"no-cache"</span>);        response.setDateHeader(<span class="hljs-string">"Expires"</span>, <span class="hljs-number">0</span>);        response.setContentType(<span class="hljs-string">"image/jpeg"</span>);        <span class="hljs-comment">// 将图像输出到Servlet输出流中。</span>        ServletOutputStream sos = response.getOutputStream();        ImageIO.write(buffImg, <span class="hljs-string">"jpeg"</span>, sos);        sos.close();    &#125;  &#125;</code></pre></div><p>然后在 Application 中注入该 Servlet：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringSecurity04Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(SpringSecurity04Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">indexServletRegistration</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//利用ServletRegistrationBean接口来使用servlet功能</span>        ServletRegistrationBean registration = <span class="hljs-keyword">new</span> ServletRegistrationBean(<span class="hljs-keyword">new</span> VerifyServlet());        registration.addUrlMappings(<span class="hljs-string">"/getVerifyCode"</span>);        <span class="hljs-keyword">return</span> registration;    &#125;&#125;</code></pre></div><h4 id="1-2-修改-login-html"><a href="#1-2-修改-login-html" class="headerlink" title="1.2 修改 login.html"></a>1.2 修改 login.html</h4><p>在原本的 login 页面基础上加上验证码字段：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>登陆<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>登陆<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"verifyCode"</span> <span class="hljs-attr">required</span>=<span class="hljs-string">"required"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"验证码"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"getVerifyCode"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"看不清，请点我"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"refresh(this)"</span> <span class="hljs-attr">onmouseover</span>=<span class="hljs-string">"mouseover(this)"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"remember-me"</span>/&gt;</span>自动登录<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>立即登陆<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">refresh</span>(<span class="hljs-params">obj</span>) </span>&#123; obj.src = <span class="hljs-string">"getVerifyCode?"</span> + <span class="hljs-built_in">Math</span>.random(); &#125;</span><span class="actionscript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mouseover</span><span class="hljs-params">(obj)</span> </span>&#123; obj.style.cursor = <span class="hljs-string">"pointer"</span>; &#125;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="1-3-添加匿名访问-Url"><a href="#1-3-添加匿名访问-Url" class="headerlink" title="1.3 添加匿名访问 Url"></a>1.3 添加匿名访问 Url</h4><p>不要忘记在 WebSecurityConfig 中允许该 Url 的匿名访问，不然没有登录是没有办法访问该 Url 的：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">//设置拦截忽略文件夹，可以对静态资源访问</span>    web.ignoring().antMatchers(<span class="hljs-string">"/css/**"</span>,<span class="hljs-string">"/js/**"</span>,<span class="hljs-string">"/css/**"</span>,<span class="hljs-string">"/getVerifyCode"</span>);&#125;</code></pre></div><p>效果如下：</p><p><img src="D:%5C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%5CBlog%5CMyBlog%5Csource_posts%5Cimage-20200523174552543.png" srcset="/img/loading.gif" alt="效果"></p><p>下面才算是这篇文章真正的部分。我们如何才能实现验证码验证呢，思考一下，应该有以下几种实现方式：</p><ol><li>登录表单提交前发送 AJAX 验证验证码</li><li>使用自定义过滤器(Filter)，在 Spring security 校验前验证验证码合法性</li><li>和用户名、密码一起发送到后台，在 Spring security 中进行验证</li></ol><h3 id="二、AJAX-验证"><a href="#二、AJAX-验证" class="headerlink" title="二、AJAX 验证"></a>二、AJAX 验证</h3><p>使用 AJAX 方式验证和我们 Spring Security 框架就没有任何关系了，其实就是表单提交前先发个 HTTP 请求验证验证码，本篇不再赘述。</p><h3 id="三、过滤器验证"><a href="#三、过滤器验证" class="headerlink" title="三、过滤器验证"></a>三、过滤器验证</h3><p>使用过滤器的思路是：<strong>在Spring Security 处理登录验证请求前，验证验证码，如果正确，放行；如果不正确，跳到异常</strong>。</p><h4 id="3-1-编写验证码过滤器"><a href="#3-1-编写验证码过滤器" class="headerlink" title="3.1 编写验证码过滤器"></a>3.1 编写验证码过滤器</h4><p>自定义一个过滤器，实现 <code>OncePerRequestFilter</code> （该 Filter 保证每次请求一定会过滤），在 <code>isProtectedUrl()</code> 方法中拦截了 POST 方式的 /login 请求。</p><p>在逻辑处理中从 request 中取出验证码，并进行验证，如果验证成功，放行；验证失败，手动生成异常。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VerifyFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OncePerRequestFilter</span> </span>&#123;    <span class="hljs-comment">/**获取路径信息**/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> PathMatcher PATH_MATCHER = <span class="hljs-keyword">new</span> AntPathMatcher();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-comment">//如果是POST请求，并且请求路径是/login，就去进行验证码校验</span>        <span class="hljs-keyword">if</span>(isProtectedUrl(httpServletRequest))&#123;            String verifyCode = httpServletRequest.getParameter(<span class="hljs-string">"verifyCode"</span>);            <span class="hljs-comment">//如果验证码错误，就抛出异常，否则正常执行</span>            <span class="hljs-keyword">if</span>(!validateVerify(verifyCode))&#123;                <span class="hljs-comment">//手动设置异常</span>                httpServletRequest.setAttribute(<span class="hljs-string">"SPRING_SECURITY_LAST_EXCEPTION"</span>,<span class="hljs-keyword">new</span> DisabledException(<span class="hljs-string">"验证码输入错误"</span>));                <span class="hljs-comment">//转发到错误url</span>       httpServletRequest.getRequestDispatcher(<span class="hljs-string">"/login/error"</span>).forward(httpServletRequest,httpServletResponse);            &#125;<span class="hljs-keyword">else</span> &#123;                filterChain.doFilter(httpServletRequest,httpServletResponse);            &#125;        &#125;<span class="hljs-keyword">else</span> &#123;            filterChain.doFilter(httpServletRequest,httpServletResponse);        &#125;    &#125;    <span class="hljs-comment">/**校验验证码**/</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validateVerify</span><span class="hljs-params">(String verifyCode)</span> </span>&#123;        <span class="hljs-comment">//获取当前线程绑定的request对象</span>        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = requestAttributes.getRequest();        <span class="hljs-comment">//下面这个validateCode是在servlet中存入session的名字</span>        String validateCode = ((String) request.getSession().getAttribute(<span class="hljs-string">"validateCode"</span>)).toLowerCase();        verifyCode = verifyCode.toLowerCase();        System.out.println(<span class="hljs-string">"验证码："</span>+validateCode+<span class="hljs-string">"用户输入："</span>+verifyCode);        <span class="hljs-keyword">return</span> validateCode.equals(verifyCode);    &#125;    <span class="hljs-comment">/**拦截/login的POST请求**/</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isProtectedUrl</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"POST"</span>.equals(request.getMethod()) &amp;&amp; PATH_MATCHER.match(<span class="hljs-string">"/login"</span>,request.getServletPath());    &#125;&#125;</code></pre></div><h4 id="3-2-注入过滤器"><a href="#3-2-注入过滤器" class="headerlink" title="3.2 注入过滤器"></a>3.2 注入过滤器</h4><p>修改 WebSecurityConfig 的 configure 方法，添加一个 <code>addFilterBefore()</code> ，具有两个参数，作用是在参数二之前执行参数一设置的过滤器。</p><p>Spring Security 对于用户名/密码登录方式是通过 <code>UsernamePasswordAuthenticationFilter</code> 处理的，我们在它之前执行验证码过滤器即可。</p><div class="hljs"><pre><code class="hljs java">.addFilterBefore(<span class="hljs-keyword">new</span> VerifyFilter(), UsernamePasswordAuthenticationFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span></code></pre></div><p>测试效果不理想，不推荐这种方式。</p><h3 id="四、Spring-Security-验证"><a href="#四、Spring-Security-验证" class="headerlink" title="四、Spring Security 验证"></a>四、Spring Security 验证</h3><p>使用过滤器就已经实现了验证码功能，但其实它和 AJAX 验证差别不大。</p><ul><li>AJAX 是在提交前发一个请求，请求返回成功就提交，否则不提交；</li><li>过滤器是先验证验证码，验证成功就让 Spring Security 验证用户名和密码；验证失败，则产生异常·。</li></ul><p>如果我们要做的需求是用户登录是需要多个验证字段，不单单是用户名和密码，那么使用过滤器会让逻辑变得复杂，这时候可以考虑自定义 Spring Security 的验证逻辑了…</p><h4 id="4-1-WebAuthenticationDetails"><a href="#4-1-WebAuthenticationDetails" class="headerlink" title="4.1 WebAuthenticationDetails"></a>4.1 WebAuthenticationDetails</h4><p>我们知道 Spring security 默认只会处理用户名和密码信息。这时候就要请出我们的主角——<code>WebAuthenticationDetails</code>。</p><blockquote><p><code>WebAuthenticationDetails</code>: 该类提供了获取用户登录时携带的额外信息的功能，默认提供了 remoteAddress 与 sessionId 信息。</p></blockquote><p>我们需要实现自定义的 <code>WebAuthenticationDetails</code>，并在其中加入我们的验证码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomWebAuthenticationDetails</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebAuthenticationDetails</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">6975601077710753878L</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String verifyCode;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Records the remote address and will also set the session Id if a session already</span><span class="hljs-comment">     * exists (it won't create one).</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request that the authentication request was received from</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomWebAuthenticationDetails</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;        <span class="hljs-keyword">super</span>(request);        verifyCode = request.getParameter(<span class="hljs-string">"verifyCode"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getVerifyCode</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.verifyCode;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        sb.append(<span class="hljs-keyword">super</span>.toString()).append(<span class="hljs-string">";VerifiCode:"</span>).append(<span class="hljs-keyword">this</span>.verifyCode);        <span class="hljs-keyword">return</span> sb.toString();    &#125;&#125;</code></pre></div><p>在这个方法中，我们将前台form表单中的verifyCode获取到，并通过get方法方便调用。</p><h4 id="4-2-AuthenticationDetailsSource"><a href="#4-2-AuthenticationDetailsSource" class="headerlink" title="4.2 AuthenticationDetailsSource"></a>4.2 AuthenticationDetailsSource</h4><p>自定义了<code>WebAuthenticationDetails</code>，我i们还需要将其放入 <code>AuthenticationDetailsSource</code> 中来替换原本的 <code>WebAuthenticationDetails</code> ，因此还得实现自定义 <code>AuthenticationDetailsSource</code> ：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>(<span class="hljs-string">"authenticationDetailsSource"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationDetailsSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationDetailsSource</span>&lt;<span class="hljs-title">HttpServletRequest</span>, <span class="hljs-title">WebAuthenticationDetails</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> WebAuthenticationDetails <span class="hljs-title">buildDetails</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CustomWebAuthenticationDetails(request);    &#125;&#125;</code></pre></div><p>该类是将原本的 <code>WebAuthenticationDetails</code> 替换为了我们的 <code>CustomWebAuthenticationDetails</code>。</p><p>接下来我们只需将 <code>CustomAuthenticationDetailsSource</code> 注入Spring Security中，替换掉默认的 <code>AuthenticationDetailsSource</code>。</p><p>通过修改 <code>WebSecurityConfig</code>将其注入，然后在config()中使用 <code>authenticationDetailsSource(authenticationDetailsSource)</code>方法来指定它。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>  AuthenticationDetailsSource&lt;HttpServletRequest, WebAuthenticationDetails&gt; authenticationDetailsSource;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;      http.authorizeRequests()      ....省略   .authenticationDetailsSource(authenticationDetailsSource)</code></pre></div><h4 id="4-3-AuthenticationProvider"><a href="#4-3-AuthenticationProvider" class="headerlink" title="4.3 AuthenticationProvider"></a>4.3 AuthenticationProvider</h4><p>至此我们通过自定义 <code>WebAuthenticationDetails</code> 和 <code>AuthenticationDetailsSource</code> 将验证码和用户名、密码一起带入了 Spring Security 中，下面我们需要将它取出来。</p><p>这里需要我们自定义 <code>AuthenticationProvider</code>，需要注意的是，<strong>如果是我们自己实现 <code>AuthenticationProvider</code>，那么我们就需要自己做密码校验了。</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationProvider</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> CustomUserDetailsService customUserDetailsService;    <span class="hljs-comment">/**用来验证用户身份**/</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        <span class="hljs-comment">//1.获取用户的用户名和密码</span>        String inputName = authentication.getName();        String inputPassword = authentication.getCredentials().toString();        CustomWebAuthenticationDetails details = (CustomWebAuthenticationDetails) authentication.getDetails();        String verifyCode = details.getVerifyCode();        <span class="hljs-keyword">if</span>(!validateVerify(verifyCode))&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisabledException(<span class="hljs-string">"验证码输入错误"</span>);        &#125;        <span class="hljs-comment">// userDetails为数据库中查询到的用户信息</span>        UserDetails userDetails = customUserDetailsService.loadUserByUsername(inputName);        <span class="hljs-comment">// 如果是自定义AuthenticationProvider，需要手动密码校验</span>        <span class="hljs-keyword">if</span>(!userDetails.getPassword().equals(inputPassword) || !userDetails.getUsername().equals(inputName))&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">"用户名或密码错误"</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(inputName,inputPassword,userDetails.getAuthorities());    &#125;    <span class="hljs-comment">/**验证码核对**/</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validateVerify</span><span class="hljs-params">(String verifiCode)</span> </span>&#123;        <span class="hljs-comment">//获取当前线程绑定的request对象</span>        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = requestAttributes.getRequest();        String validateCode = ((String) request.getSession().getAttribute(<span class="hljs-string">"validateCode"</span>)).toLowerCase();        verifiCode = verifiCode.toLowerCase();        System.out.println(<span class="hljs-string">"验证码："</span>+validateCode+<span class="hljs-string">";用户输入："</span>+verifiCode);        <span class="hljs-keyword">return</span> validateCode.equals(verifiCode);    &#125;    <span class="hljs-comment">/**判断当前的AuthenticationProvider是否支持对应的Authentication**/</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; authentication)</span> </span>&#123;        <span class="hljs-keyword">return</span> (UsernamePasswordAuthenticationToken<span class="hljs-class">.<span class="hljs-keyword">class</span></span><span class="hljs-class">                .<span class="hljs-title">isAssignableFrom</span>(<span class="hljs-title">authentication</span>))</span>;    &#125;&#125;</code></pre></div><p>最后在 <code>WebSecurityConfig</code> 中将其注入，并在 config 方法中通过 <code>auth.authenticationProvider()</code> 指定使用。</p><div class="hljs"><pre><code class="hljs java"> <span class="hljs-meta">@Autowired</span> CustomAuthenticationProvider customAuthenticationProvider; <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;     auth.authenticationProvider(customAuthenticationProvider); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(3)--异常处理</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>思考：为何登录失败自动跳转到/login?error，而且没有异常提示？</p><p><img src="https://img-blog.csdnimg.cn/20200531223128165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>因为首先 <code>/login?error</code> 是 Spring security 默认的失败 Url，其次<strong>如果你不手动处理这个异常，这个异常是不会被处理的</strong>。</p><h2 id="一、常见异常"><a href="#一、常见异常" class="headerlink" title="一、常见异常"></a>一、常见异常</h2><p>我们先来列举下一些 Spring Security 中常见的异常：</p><ul><li><code>UsernameNotFoundException</code>（用户不存在）</li><li><code>DisabledException</code>（用户已被禁用）</li><li><code>BadCredentialsException</code>（坏的凭据）</li><li><code>LockedException</code>（账户锁定）</li><li><code>AccountExpiredException</code> （账户过期）</li><li><code>CredentialsExpiredException</code>（证书过期）</li><li>…</li></ul><p>以上列出的这些异常都是 <code>AuthenticationException</code> 的子类，然后我们来看看 Spring security 如何处理 <code>AuthenticationException</code> 异常的。</p><h2 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h2><p>我们知道异常一般在过滤器中处理，在 <code>AbstractAuthenticationProcessingFilter</code> 中我们找到了对 <code>AuthenticationException</code> 的处理：</p><div class="hljs"><pre><code class="hljs jAVA">org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter#doFilter    <span class="hljs-keyword">try</span> &#123;authResult = attemptAuthentication(request, response);<span class="hljs-comment">//1.认证</span><span class="hljs-keyword">if</span> (authResult == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span>;&#125;sessionStrategy.onAuthentication(authResult, request, response); <span class="hljs-comment">//2.并发问题</span>&#125;<span class="hljs-keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;logger.error(<span class="hljs-string">"An internal error occurred while trying to authenticate the user."</span>,failed);unsuccessfulAuthentication(request, response, failed);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">catch</span> (AuthenticationException failed) &#123;unsuccessfulAuthentication(request, response, failed);<span class="hljs-comment">//3.认证失败</span><span class="hljs-keyword">return</span>;&#125;</code></pre></div><p>(1)，先是调用attemptAuthentication（）方法对请求参数进行提取</p><div class="hljs"><pre><code class="hljs java">org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter#attemptAuthentication<span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;<span class="hljs-keyword">if</span> (postOnly &amp;&amp; !request.getMethod().equals(<span class="hljs-string">"POST"</span>)) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">"Authentication method not supported: "</span> + request.getMethod());&#125;String username = obtainUsername(request);String password = obtainPassword(request);<span class="hljs-keyword">if</span> (username == <span class="hljs-keyword">null</span>) &#123;username = <span class="hljs-string">""</span>;&#125;<span class="hljs-keyword">if</span> (password == <span class="hljs-keyword">null</span>) &#123;password = <span class="hljs-string">""</span>;&#125;username = username.trim();UsernamePasswordAuthenticationToken authRequest = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(username, password);<span class="hljs-comment">// 设置“details”属性</span>setDetails(request, authRequest);<span class="hljs-comment">//认证</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);&#125;</code></pre></div><p>我们来看看<code>setDetails(request,authRequest)</code>做了些什么：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDetails</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">UsernamePasswordAuthenticationToken authRequest)</span> </span>&#123;authRequest.setDetails(authenticationDetailsSource.buildDetails(request));&#125;</code></pre></div><p>UsernamePasswordAuthenticationToken是Authentication的具体实现，所以这里实际上就是在设置details，至于details的值，则是通过authenticationDetailsSource来构建：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebAuthenticationDetailsSource</span> <span class="hljs-keyword">implements</span></span><span class="hljs-class"><span class="hljs-title">AuthenticationDetailsSource</span>&lt;<span class="hljs-title">HttpServletRequest</span>, <span class="hljs-title">WebAuthenticationDetails</span>&gt; </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> WebAuthenticationDetails <span class="hljs-title">buildDetails</span><span class="hljs-params">(HttpServletRequest context)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WebAuthenticationDetails(context);&#125;&#125;</code></pre></div><p>这里我们也就知道<code>buildDetails</code>方法返回的其实是一个<code>WebAuthenticationDetails</code>对象，而<code>WebAuthenticationDetails</code>对象默认有哪些属性呢？</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WebAuthenticationDetails</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<span class="hljs-keyword">this</span>.remoteAddress = request.getRemoteAddr();HttpSession session = request.getSession(<span class="hljs-keyword">false</span>);<span class="hljs-keyword">this</span>.sessionId = (session != <span class="hljs-keyword">null</span>) ? session.getId() : <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p>如果我们想保存更多关于Http请求的信息，可以通过自定义<code>WebAuthenticationDetails</code>来实现，同时<code>WebAuthenticationDetailsSource</code>也要一起重新定义。</p><p>接下来进入到<code>org.springframework.security.authentication.ProviderManager#authenticate</code>方法中：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;Class&lt;? extends Authentication&gt; toTest = authentication.getClass();AuthenticationException lastException = <span class="hljs-keyword">null</span>;AuthenticationException parentException = <span class="hljs-keyword">null</span>;Authentication result = <span class="hljs-keyword">null</span>;Authentication parentResult = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">boolean</span> debug = logger.isDebugEnabled();<span class="hljs-comment">//逐个遍历AuthenticationProvider，并调用他们的authenticate方法来做认证：</span><span class="hljs-keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;            <span class="hljs-comment">//首先要判断当前的AuthenticationProvider是否支持对应的Authentication</span><span class="hljs-keyword">if</span> (!provider.supports(toTest)) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (debug) &#123;logger.debug(<span class="hljs-string">"Authentication attempt using "</span>+ provider.getClass().getName());&#125;<span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//实际验证交给AuthenticationProvider来处理</span>result = provider.authenticate(authentication);<span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;copyDetails(authentication, result);<span class="hljs-keyword">break</span>;&#125;&#125;            <span class="hljs-comment">//如果验证过程中有异常，就会被捕获</span><span class="hljs-keyword">catch</span> (AccountStatusException | InternalAuthenticationServiceException e) &#123;prepareException(e, authentication);<span class="hljs-keyword">throw</span> e;&#125; <span class="hljs-keyword">catch</span> (AuthenticationException e) &#123;lastException = e;&#125;&#125;</code></pre></div><p>（2），调用 <code>attemptAuthentication</code>方法走完认证流程之后，回来之后，接下来就是调用 <code>sessionStrategy.onAuthentication</code>方法，这个方法就是用来处理 <code>session</code>的并发问题：</p><div class="hljs"><pre><code class="hljs java">org.springframework.security.web.authentication.session.ConcurrentSessionControlAuthenticationStrategy#onAuthentication<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthentication</span><span class="hljs-params">(Authentication authentication,</span></span><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<span class="hljs-comment">//1.获取当前用户的所有 session，该方法在调用时，传递两个参数，一个是当前用户的 authentication，</span><span class="hljs-comment">//另一个参数 false 表示不包含已经过期的 session（在用户登录成功后，会将用户的 sessionid 存起来，</span><span class="hljs-comment">//其中 key 是用户的主体（principal），value 则是该主体对应的 sessionid 组成的一个集合）。</span><span class="hljs-keyword">final</span> List&lt;SessionInformation&gt; sessions = sessionRegistry.getAllSessions(authentication.getPrincipal(), <span class="hljs-keyword">false</span>);<span class="hljs-comment">//接下来计算出当前用户已经有几个有效 session 了，同时获取允许的 session 并发数。</span><span class="hljs-keyword">int</span> sessionCount = sessions.size();<span class="hljs-keyword">int</span> allowedSessions = getMaximumSessionsForThisUser(authentication);<span class="hljs-comment">//如果当前 session 数（sessionCount）小于 session 并发数（allowedSessions），则不做任何处理</span><span class="hljs-keyword">if</span> (sessionCount &lt; allowedSessions) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//如果 allowedSessions 的值为 -1，表示对 session 数量不做任何限制。</span><span class="hljs-keyword">if</span> (allowedSessions == -<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (sessionCount == allowedSessions) &#123;HttpSession session = request.getSession(<span class="hljs-keyword">false</span>);<span class="hljs-keyword">if</span> (session != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 只有当这个请求与一个已经注册的会话相同时才允许它</span><span class="hljs-keyword">for</span> (SessionInformation si : sessions) &#123;<span class="hljs-keyword">if</span> (si.getSessionId().equals(session.getId())) &#123;<span class="hljs-keyword">return</span>;&#125;&#125;&#125;&#125;<span class="hljs-comment">//首先会有 exceptionIfMaximumExceeded 属性，这就是我们在 SecurityConfig 中配置的 maxSessionsPreventsLogin 的值，默认为 false，如果为 true，就直接抛出异常，禁止新的登录（参照微信），如果为 false，则对 sessions 按照请求时间进行排序，然后再使多余的 session 过期即可（参照QQ）。</span>allowableSessionsExceeded(sessions, allowedSessions, sessionRegistry);&#125;</code></pre></div><p>配置文件如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-comment">//1</span><span class="hljs-function">HttpSessionEventPub1isher <span class="hljs-title">httpSessionEventPub1isher</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HttpSessionEventPub1isher();&#125;<span class="hljs-comment">//关闭CRSF跨域</span>        http.csrf()                .disable()                .sessionManagement()                .maximumSessions(<span class="hljs-number">1</span>)                .maxSessionsPreventsLogin(<span class="hljs-keyword">true</span>);</code></pre></div><p>为什么要加这个Bean呢？因为在Spring Security中，它是通过监听session的销毁事件来及时清理session的记录的，用户从不同的浏览器登录后，都会有对应的session，当用户注销登录之后，session就会失效，但是默认的失效是通过调用<code>StandardSession#invalidate</code>方法来实现的，这一失效事件无法被Spring容器感知到，进而导致当用户注销登录之后，Spring Security没有及时清理会话信息表，以为用户还在线，进而导致用户无法重新登录进来。</p><p>为了解决这一问题，我们提供了一个HttpSessionEventPublisher，这个类实现了httpSessionListener接口，在该Bean中，可以将session创建以及销毁的事件及时感知到，并且调用Sprign中的事件机制将相关的创建和销毁事件发布出去，进而被Spring Security感知到。</p><p>(3)，当用户登录失败时，被异常捕获，转到 <code>unsuccessfulAuthentication()</code> 方法中，然后转交给了 <code>SimpleUrlAuthenticationFailureHandler</code> 类的 <code>onAuthenticationFailure()</code> 处理。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unsuccessfulAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;    SecurityContextHolder.clearContext();    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logger.isDebugEnabled()) &#123;        <span class="hljs-keyword">this</span>.logger.debug(<span class="hljs-string">"Authentication request failed: "</span> + failed.toString(), failed);        <span class="hljs-keyword">this</span>.logger.debug(<span class="hljs-string">"Updated SecurityContextHolder to contain null Authentication"</span>);        <span class="hljs-keyword">this</span>.logger.debug(<span class="hljs-string">"Delegating to authentication failure handler "</span> + <span class="hljs-keyword">this</span>.failureHandler);    &#125;    <span class="hljs-keyword">this</span>.rememberMeServices.loginFail(request, response);    <span class="hljs-keyword">this</span>.failureHandler.onAuthenticationFailure(request, response, failed);&#125;</code></pre></div><p>在 <code>onAuthenticationFailure()</code> 中，首先判断有没有设置 <code>defaultFailureUrl</code>。</p><ul><li>如果没有设置，直接返回 401 错误，即 <code>HttpStatus.UNAUTHORIZED</code> 的值。</li><li>如果设置了，首先执行 <code>saveException()</code> 方法。然后判断 <code>forwardToDestination</code> ，即是否是服务器跳转，默认使用重定向即客户端跳转。</li></ul><div class="hljs"><pre><code class="hljs java">org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler#onAuthenticationFailure<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">      HttpServletResponse response, AuthenticationException exception)</span></span><span class="hljs-function">      <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;       <span class="hljs-keyword">if</span> (defaultFailureUrl == <span class="hljs-keyword">null</span>) &#123;      logger.debug(<span class="hljs-string">"No failure URL set, sending 401 Unauthorized error"</span>);      response.sendError(HttpStatus.UNAUTHORIZED.value(),         HttpStatus.UNAUTHORIZED.getReasonPhrase());   &#125;   <span class="hljs-keyword">else</span> &#123;      saveException(request, exception);<span class="hljs-comment">//判断是转发还是重定向</span>  <span class="hljs-comment">//直接转发</span>      <span class="hljs-keyword">if</span> (forwardToDestination) &#123;         logger.debug(<span class="hljs-string">"Forwarding to "</span> + defaultFailureUrl);         request.getRequestDispatcher(defaultFailureUrl)               .forward(request, response);      &#125;      <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//重定向</span>         logger.debug(<span class="hljs-string">"Redirecting to "</span> + defaultFailureUrl);         redirectStrategy.sendRedirect(request, response, defaultFailureUrl);      &#125;   &#125;&#125;</code></pre></div><p>来到<code>org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler#saveException</code>方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveException</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">AuthenticationException exception)</span> </span>&#123;<span class="hljs-keyword">if</span> (forwardToDestination) &#123;request.setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION, exception);&#125;<span class="hljs-keyword">else</span> &#123;HttpSession session = request.getSession(<span class="hljs-keyword">false</span>);<span class="hljs-keyword">if</span> (session != <span class="hljs-keyword">null</span> || allowSessionCreation) &#123;request.getSession().setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION,exception);&#125;&#125;&#125;</code></pre></div><p>在 <code>saveException()</code> 方法中，首先判断<code>forwardToDestination</code>，如果使用服务器跳转则写入 Request，客户端跳转则写入 Session。写入名为 <code>SPRING_SECURITY_LAST_EXCEPTION</code> ，值为 <code>AuthenticationException</code>。</p><p>至此 Spring security 完成了异常处理，总结一下流程：</p><p>–&gt; AbstractAuthenticationProcessingFilter<code>.doFilter()</code></p><p>–&gt; AbstractAuthenticationProcessingFilter.<code>unsuccessfulAuthentication()</code></p><p>–&gt; SimpleUrlAuthenticationFailureHandler.<code>onAuthenticationFailure()</code></p><p>–&gt; SimpleUrlAuthenticationFailureHandler.<code>saveException()</code></p><h2 id="三、处理异常"><a href="#三、处理异常" class="headerlink" title="三、处理异常"></a>三、处理异常</h2><p>上面源码说了那么多，真正处理起来很简单，我们只需要指定错误的url，然后再该方法中对异常进行处理即可。</p><p>（1）指定错误url，<code>WebSecurityConfig</code> 中添加 <code>.failureUrl(&quot;/login/error&quot;)</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http.authorizeRequests()            .anyRequest().authenticated()            .and()            .formLogin().loginPage(<span class="hljs-string">"/login"</span>)            <span class="hljs-comment">//登录失败url</span>            .failureUrl(<span class="hljs-string">"/login/error"</span>)            <span class="hljs-comment">//登录成功url</span>            .defaultSuccessUrl(<span class="hljs-string">"/"</span>).permitAll()</code></pre></div><p>（2）在 Controller 中处理异常</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/login/error"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loginError</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;    response.setContentType(<span class="hljs-string">"text/html;charset=utf-8"</span>);    AuthenticationException exception =            (AuthenticationException)request.getSession().getAttribute(<span class="hljs-string">"SPRING_SECURITY_LAST_EXCEPTION"</span>);    <span class="hljs-keyword">try</span> &#123;        response.getWriter().write(exception.toString());    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre></div><p>我们首先获取了 session 中的 <code>SPRING_SECURITY_LAST_EXCEPTION</code> 。为了演示，我只是简单的将错误信息返回给了页面。运行程序，当我们输入错误密码时：</p><p><img src="https://img-blog.csdnimg.cn/20200531223348529.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>来到我们自己设置的错误页面，显示我们设置的错误信息。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(2)--自动登录</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-2-%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-2-%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一、修改-login-html"><a href="#一、修改-login-html" class="headerlink" title="一、修改 login.html"></a>一、修改 login.html</h2><p>在登录页添加自动登录的选项，注意自动登录字段的 name 属性必须是 <code>remember-me</code> ：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>欢迎来到登录页面<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"remember-me"</span>&gt;</span>记住我<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>立即登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="二、两种实现方式"><a href="#二、两种实现方式" class="headerlink" title="二、两种实现方式"></a>二、两种实现方式</h2><h3 id="2-1-Cookie-存储"><a href="#2-1-Cookie-存储" class="headerlink" title="2.1 Cookie 存储"></a>2.1 Cookie 存储</h3><p>这种方式十分简单，只要在 WebSecurityConfig 中的 configure() 方法添加一个 <code>rememberMe()</code> 即可,如下所示：</p><div class="hljs"><pre><code class="hljs java"> http.authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span><span class="hljs-comment">//                .antMatchers().permitAll()</span>                .anyRequest().authenticated()                .and()                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                .defaultSuccessUrl(<span class="hljs-string">"/"</span>).permitAll()                <span class="hljs-comment">// 自定义登录用户名和密码参数，默认为username和password</span><span class="hljs-comment">//                .usernameParameter("username")</span><span class="hljs-comment">//                .passwordParameter("password")</span>                .and()                <span class="hljs-comment">// 开启自动登录</span>                .rememberMe()                .and()                .logout()                .permitAll();        <span class="hljs-comment">//关闭CRSF跨域</span>        http.csrf().disable();    &#125;</code></pre></div><p>当我们登录时勾选自动登录时，会自动在 Cookie 中保存一个名为 <code>remember-me</code> 的cookie，默认有效期为2周，其值是一个加密字符串：</p><p><img src="https://www.jitwxs.cn/images/posts/20180509100451811.png" srcset="/img/loading.gif" alt="基于缓存的自动登录"></p><h3 id="2-2-数据库存储"><a href="#2-2-数据库存储" class="headerlink" title="2.2 数据库存储"></a>2.2 数据库存储</h3><p>使用 Cookie 存储虽然很方便，但是大家都知道 Cookie 毕竟是保存在客户端的，而且 Cookie 的值还与用户名、密码这些敏感数据相关，虽然加密了，但是将敏感信息存在客户端，毕竟不太安全。</p><p>Spring security 还提供了另一种相对更安全的实现机制：<strong>在客户端的 Cookie 中，仅保存一个无意义的加密串（与用户名、密码等敏感数据无关），然后在数据库中保存该加密串-用户信息的对应关系，自动登录时，用 Cookie 中的加密串，到数据库中验证，如果通过，自动登录才算通过。</strong></p><h4 id="2-2-1-基本原理"><a href="#2-2-1-基本原理" class="headerlink" title="2.2.1 基本原理"></a>2.2.1 基本原理</h4><p>当浏览器发起表单登录请求时，当通过 <code>UsernamePasswordAuthenticationFilter</code> 认证成功后，会经过 <code>RememberMeService</code>，在其中有个 <code>TokenRepository</code>，它会生成一个 token，首先将 token 写入到浏览器的 Cookie 中，然后将 token、认证成功的用户名写入到数据库中。</p><p>当浏览器下次请求时，会经过 <code>RememberMeAuthenticationFilter</code>，它会读取 Cookie 中的 token，交给 RememberMeService 从数据库中查询记录。如果存在记录，会读取用户名并去调用 <code>UserDetailsService</code>，获取用户信息，并将用户信息放入Spring Security 中，实现自动登录。</p><p><img src="https://www.jitwxs.cn/images/posts/20181202143630639.png" srcset="/img/loading.gif" alt="实现原理"></p><p>RememberMeAuthenticationFilter 在整个过滤器链中是比较靠后的位置，也就是说在传统登录方式都无法登录的情况下才会使用自动登录。</p><p><img src="https://www.jitwxs.cn/images/posts/20181202144420871.png" srcset="/img/loading.gif" alt="spring security过滤器链"></p><h4 id="2-2-2-代码实现"><a href="#2-2-2-代码实现" class="headerlink" title="2.2.2 代码实现"></a>2.2.2 代码实现</h4><p>首先需要创建一张表来存储 token 信息：</p><div class="hljs"><pre><code class="hljs SQL"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`persistent_logins`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`persistent_logins`</span>(<span class="hljs-string">`username`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<span class="hljs-string">`series`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    <span class="hljs-string">`token`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    <span class="hljs-string">`last_used`</span> <span class="hljs-built_in">timestamp</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span>,    PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`series`</span>))<span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4;</code></pre></div><p>在 WebSecurityConfig 中注入 <code>dataSource</code> ，创建一个 <code>PersistentTokenRepository</code> 的Bean：</p><div class="hljs"><pre><code class="hljs java">    <span class="hljs-meta">@Autowired</span>    DataSource dataSource;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersistentTokenRepository <span class="hljs-title">persistentTokenRepository</span><span class="hljs-params">()</span></span>&#123;        JdbcTokenRepositoryImpl tokenRepository = <span class="hljs-keyword">new</span> JdbcTokenRepositoryImpl();        tokenRepository.setDataSource(dataSource);                <span class="hljs-comment">//如果token表不存在，使用下面语句可以初始化该表，若存在，则需要注释掉这条语句，否则会报错</span><span class="hljs-comment">//        tokenRepository.setCreateTableOnStartup(true);</span>        <span class="hljs-keyword">return</span> tokenRepository;    &#125;</code></pre></div><p>在 <code>configure()</code> 中按如下所示配置自动登录：</p><div class="hljs"><pre><code class="hljs java"> <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span><span class="hljs-comment">//                .antMatchers().permitAll()</span>                .anyRequest().authenticated()                .and()                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                .defaultSuccessUrl(<span class="hljs-string">"/"</span>).permitAll()                .and()                <span class="hljs-comment">// 开启自动登录</span>                .rememberMe()                .tokenRepository(persistentTokenRepository())                <span class="hljs-comment">//有效时间(单位；s)</span>                .tokenValiditySeconds(<span class="hljs-number">60</span>)                .userDetailsService(userDetailsService)                .and()                .logout()                .permitAll();        <span class="hljs-comment">//关闭CRSF跨域</span>        http.csrf().disable();    &#125;</code></pre></div><h2 id="三、运行程序"><a href="#三、运行程序" class="headerlink" title="三、运行程序"></a>三、运行程序</h2><p>勾选自动登录后，Cookie 和数据库中均存储了 token 信息：</p><p><img src="https://www.jitwxs.cn/images/posts/20180509102031410.png" srcset="/img/loading.gif" alt="效果"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(1)--基础入门</title>
    <link href="/2020/05/29/SpringBoot%E9%9B%86%E6%88%90Spring-Security-1-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <url>/2020/05/29/SpringBoot%E9%9B%86%E6%88%90Spring-Security-1-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一、导入依赖"><a href="#一、导入依赖" class="headerlink" title="一、导入依赖"></a>一、导入依赖</h1><p>导入 <code>spring-boot-starter-security</code> 依赖，在 SpringBoot 2.0 环境下默认使用的是 5.0 版本。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-comment">&lt;!--注意，这里必须要指定版本，MySQL5用的驱动url是com.mysql.jdbc.Driver，</span><span class="hljs-comment">      MySQL6以后用的是com.mysql.cj.jdbc.Driver。版本不匹配便会报驱动类已过时的错误。--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.15<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h1 id="二、创建数据库"><a href="#二、创建数据库" class="headerlink" title="二、创建数据库"></a>二、创建数据库</h1><p>一般权限控制有三层，即：<code>用户</code>&lt;–&gt;<code>角色</code>&lt;–&gt;<code>权限</code>，用户与角色是多对多，角色和权限也是多对多。这里我们先暂时不考虑权限，只考虑<code>用户</code>&lt;–&gt;<code>角色</code>。</p><div class="hljs"><pre><code class="hljs mysql">-- 创建用户表 sys_user： --DROP TABLE IF EXISTS &#96;sys_user&#96;;CREATE TABLE &#96;sys_user&#96;(&#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,&#96;name&#96; varchar(255) NOT NULL,&#96;password&#96; varchar(255) NOT NULL,    PRIMARY KEY (&#96;id&#96;))ENGINE&#x3D;InnoDB DEFAULT CHARSET &#x3D; utf8;-- 创建权限表 sys_role： --DROP TABLE IF EXISTS &#96;sys_role&#96;;CREATE TABLE &#96;sys_role&#96;(&#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,    &#96;name&#96; varchar(255) NOT NULL,    PRIMARY KEY (&#96;id&#96;))ENGINE&#x3D;InnoDB DEFAULT CHARSET &#x3D; utf8;-- 创建用户-角色表 sys_user_role：（外键这里有点困惑，先标记下） --DROP TABLE IF EXISTS &#96;sys_user_role&#96;;CREATE TABLE &#96;sys_user_role&#96;(&#96;user_id&#96; int(11) NOT NULL ,    &#96;role_id&#96; int(11) NOT NULL,    PRIMARY KEY (&#96;user_id&#96;,&#96;role_id&#96;),    KEY &#96;fk_role_id&#96; (&#96;role_id&#96;),    CONSTRAINT &#96;fk_role_id&#96; FOREIGN KEY (&#96;role_id&#96;) REFERENCES &#96;sys_role&#96; (&#96;id&#96;) ON DELETE CASCADE ON UPDATE CASCADE,    CONSTRAINT &#96;fk_user_id&#96; FOREIGN KEY (&#96;user_id&#96;) REFERENCES &#96;sys_user&#96; (&#96;id&#96;) ON DELETE CASCADE ON UPDATE CASCADE)ENGINE&#x3D;InnoDB DEFAULT CHARSET &#x3D; utf8;-- 添加数据：（注意：传值的时候里面是单引号，如：&#39;1&#39;） --INSERT INTO &#96;sys_role&#96; VALUES (&#39;1&#39;, &#39;ROLE_ADMIN&#39;);INSERT INTO &#96;sys_role&#96; VALUES (&#39;2&#39;, &#39;ROLE_USER&#39;);INSERT INTO &#96;sys_user&#96; VALUES (&#39;1&#39;, &#39;admin&#39;, &#39;123&#39;);INSERT INTO &#96;sys_user&#96; VALUES (&#39;2&#39;, &#39;jitwxs&#39;, &#39;123&#39;);INSERT INTO &#96;sys_user_role&#96; VALUES (&#39;1&#39;, &#39;1&#39;);INSERT INTO &#96;sys_user_role&#96; VALUES (&#39;2&#39;, &#39;2&#39;);</code></pre></div><p>注意：权限格式为 <code>ROLE_XXX</code>，是 Spring Security 的规定。</p><h1 id="三、准备页面"><a href="#三、准备页面" class="headerlink" title="三、准备页面"></a>三、准备页面</h1><p>因为是示例程序，页面越简单越好，只用于登录的 <code>login.html</code> 以及用于登录成功后的 <code>home.html</code>，将其放置在 <code>resources/static</code> 目录下：</p><p>(1)login.html</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>欢迎来到登录页面<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>立即登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>注意：用户的登录认证是由 Spring Security 进行处理的，请求路径默认为 <code>/login</code>，用户名字段默认为 <code>username</code>，密码字段默认为 <code>password</code> 。</p><p>(2)home.html</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>欢迎回家<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>登录成功<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/admin"</span>&gt;</span>检测是否具有ROLE_ADMIN角色<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/user"</span>&gt;</span>检测是否具有ROLE_USER角色<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"window.location.href='/logout'"</span>&gt;</span>退出登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h1 id="四、配置-application-properties"><a href="#四、配置-application-properties" class="headerlink" title="四、配置 application.properties"></a>四、配置 application.properties</h1><p>在配置文件中配置下数据库连接：</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">root</span><span class="hljs-comment">#JDBC连接MySQL6 （com.mysql.cj.jdbc.Driver）， 需要指定时区serverTimezone，否则会报错</span><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/spring_security?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><span class="hljs-meta">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><span class="hljs-comment">#开启下划线转驼峰命令法</span><span class="hljs-meta">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="hljs-string">true</span></code></pre></div><h1 id="五、创建Model实体、Mapper、Service-和-Controller"><a href="#五、创建Model实体、Mapper、Service-和-Controller" class="headerlink" title="五、创建Model实体、Mapper、Service 和 Controller"></a>五、创建Model实体、Mapper、Service 和 Controller</h1><h2 id="5-1-Model"><a href="#5-1-Model" class="headerlink" title="5.1 Model"></a>5.1 Model</h2><p>(1)SysUser</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//com.gavin.springsecuriity01.Model.SysUser</span>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysUser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-comment">//这里必须是name，与数据库对应，否则运行会报错</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-comment">// 省略getter/setter</span>&#125;</code></pre></div><p>(2)SysRole</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysRole</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-comment">// 省略getter/setter</span>&#125;</code></pre></div><p>(3)SysUserRole</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysUserRole</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-keyword">private</span> Integer userId;    <span class="hljs-keyword">private</span> Integer roleId;        <span class="hljs-comment">// 省略getter/setter</span>&#125;</code></pre></div><h2 id="5-2-Mapper"><a href="#5-2-Mapper" class="headerlink" title="5.2 Mapper"></a>5.2 Mapper</h2><p>(1)SysUserMapper</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//com.gavin.springsecuriity01.Mapper.SysUserMapper</span><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysUserMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_user WHERE id = #&#123;id&#125;"</span>)    <span class="hljs-function">SysUser <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_user WHERE name = #&#123;name&#125;"</span>)    <span class="hljs-function">SysUser <span class="hljs-title">selectByName</span><span class="hljs-params">(String name)</span></span>;&#125;</code></pre></div><p>(2)SysRoleMapper</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysRoleMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_role WHERE id = #&#123;id&#125;"</span>)    <span class="hljs-function">SysRole <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>;&#125;</code></pre></div><p>(3)SysUserRoleMapper</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysUserRoleMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_user_role WHERE user_id = #&#123;id&#125;"</span>)    <span class="hljs-function">List&lt;SysUserRole&gt; <span class="hljs-title">listByUserId</span><span class="hljs-params">(Integer userId)</span></span>; &#125;</code></pre></div><h2 id="5-3-Service"><a href="#5-3-Service" class="headerlink" title="5.3 Service"></a>5.3 Service</h2><p>(1)SysUserService</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysUserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysUserMapper sysUserMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> SysUser <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>&#123;        <span class="hljs-keyword">return</span> sysUserMapper.selectById(id);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> SysUser <span class="hljs-title">selectByName</span><span class="hljs-params">(String name)</span></span>&#123;        <span class="hljs-keyword">return</span> sysUserMapper.selectByName(name);    &#125;&#125;</code></pre></div><p>(2)SysRoleService</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysRoleService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysRoleMapper sysRoleMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> SysRole <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>&#123;        <span class="hljs-keyword">return</span> sysRoleMapper.selectById(id);    &#125;&#125;</code></pre></div><p>(3)SysUserRoleService</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysUserRoleService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysUserRoleMapper sysUserRoleMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;SysUserRole&gt; <span class="hljs-title">listByUserId</span><span class="hljs-params">(Integer userId)</span></span>&#123;        <span class="hljs-keyword">return</span> sysUserRoleMapper.listByUserId(userId);    &#125;&#125;</code></pre></div><h2 id="5-4-Controller"><a href="#5-4-Controller" class="headerlink" title="5.4 Controller"></a>5.4 Controller</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(LoginController<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">showHome</span><span class="hljs-params">()</span></span>&#123;        String name = SecurityContextHolder.getContext().getAuthentication().getName();        logger.info(<span class="hljs-string">"当前登录用户："</span>+name);        <span class="hljs-keyword">return</span> <span class="hljs-string">"home.html"</span>;    &#125;        <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/login"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">showLogin</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"login.html"</span>;    &#125;        <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/admin"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasRole('ROLE_ADMIN')"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">printAdmin</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"如果你看见这句话，说明你有ROLE_ADMIN角色"</span>;    &#125;        <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasRole('ROLE_USER')"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">printUser</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"如果你看见这句话，说明你有ROLE_USER角色"</span>;    &#125;&#125;</code></pre></div><ul><li>如代码所示，获取当前登录用户：<code>SecurityContextHolder.getContext().getAuthentication()</code></li><li><code>@PreAuthorize</code> 用于判断用户是否有指定权限，没有就不能访问</li></ul><h1 id="六、配置-SpringSecurity"><a href="#六、配置-SpringSecurity" class="headerlink" title="六、配置 SpringSecurity"></a>六、配置 SpringSecurity</h1><h2 id="6-1-UserDetailsService"><a href="#6-1-UserDetailsService" class="headerlink" title="6.1 UserDetailsService"></a>6.1 UserDetailsService</h2><p>首先我们需要自定义 <code>UserDetailsService</code> ，将用户信息和权限注入进来。</p><p>我们需要重写 <code>loadUserByUsername</code> 方法，参数是用户输入的用户名。返回值是<code>UserDetails</code>，这是一个接口，一般使用它的子类<code>org.springframework.security.core.userdetails.User</code>，它有三个参数，分别是用户名、密码和权限集。</p><blockquote><p>实际情况下，大多将 DAO 中的 User 类继承 <code>org.springframework.security.core.userdetails.User</code> 返回。</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>(<span class="hljs-string">"userDetailsService"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomUserDetailsService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysUserService sysUserService;        <span class="hljs-meta">@Autowired</span>    SysRoleService sysRoleService;        <span class="hljs-meta">@Autowired</span>    SysUserRoleService sysUserRoleService;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;        Collection&lt;GrantedAuthority&gt; authorities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();                <span class="hljs-comment">//从数据库中取出用户信息</span>        SysUser user = sysUserService.selectByName(username);                <span class="hljs-comment">//判断用户是否存在</span>        <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">"用户名不存在！！"</span>);        &#125;                <span class="hljs-comment">//如果用户存在，就添加权限给他</span>        List&lt;SysUserRole&gt; userRoles = sysUserRoleService.listByUserId(user.getId());        <span class="hljs-keyword">for</span>(SysUserRole userRole:userRoles)&#123;            SysRole role = sysRoleService.selectById(userRole.getRoleId());            authorities.add(<span class="hljs-keyword">new</span> SimpleGrantedAuthority(role.getName()));        &#125;        <span class="hljs-comment">//返回UserDetails的实现类</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(user.getName(),user.getPassword(),authorities);    &#125;&#125;</code></pre></div><h1 id="6-2-WebSecurityConfig"><a href="#6-2-WebSecurityConfig" class="headerlink" title="6.2 WebSecurityConfig"></a>6.2 WebSecurityConfig</h1><p>该类是 Spring Security 的配置类，该类的三个注解分别是标识该类是配置类、开启 Security 服务、开启全局 Securtiy 注解。</p><p>首先将我们自定义的 <code>userDetailsService</code> 注入进来，在 <code>configure()</code> 方法中使用 <code>auth.userDetailsService()</code> 方法替换掉默认的 userDetailsService。</p><p>这里我们还指定了密码的加密方式（5.0 版本强制要求设置），因为我们数据库是明文存储的，所以明文返回即可，如下所示：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="hljs-keyword">true</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    CustomUserDetailsService userDetailsService;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth.userDetailsService(userDetailsService).passwordEncoder(<span class="hljs-keyword">new</span> PasswordEncoder() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">encode</span><span class="hljs-params">(CharSequence rawPassword)</span> </span>&#123;                <span class="hljs-keyword">return</span> rawPassword.toString();            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(CharSequence rawPassword, String encodedPassword)</span> </span>&#123;                <span class="hljs-keyword">return</span> encodedPassword.equals(rawPassword.toString());            &#125;        &#125;);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//设置拦截忽略文件夹，可以对静态资源访问</span>        web.ignoring().antMatchers(<span class="hljs-string">"/css/**"</span>,<span class="hljs-string">"/js/**"</span>,<span class="hljs-string">"/css/**"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span><span class="hljs-comment">//                .antMatchers().permitAll()</span>                .anyRequest().authenticated()                .and()                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                .defaultSuccessUrl(<span class="hljs-string">"/"</span>).permitAll()                <span class="hljs-comment">// 自定义登录用户名和密码参数，默认为username和password</span><span class="hljs-comment">//                .usernameParameter("username")</span><span class="hljs-comment">//                .passwordParameter("password")</span>                .and()                .logout().permitAll();        <span class="hljs-comment">//关闭CRSF跨域</span>        http.csrf().disable();    &#125;&#125;</code></pre></div><h1 id="七、运行程序"><a href="#七、运行程序" class="headerlink" title="七、运行程序"></a>七、运行程序</h1><blockquote><p>ROLE_ADMIN 账户：用户名 <strong>admin</strong>，密码 <strong>123</strong><br>ROLE_USER 账户：用户名 <strong>jitwxs</strong>，密码 <strong>123</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
