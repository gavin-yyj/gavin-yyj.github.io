<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>4.Netty--传输</title>
    <link href="/2020/05/31/4-Netty-%E4%BC%A0%E8%BE%93/"/>
    <url>/2020/05/31/4-Netty-%E4%BC%A0%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>OIO：阻塞传输</li><li>NIO：异步传输</li><li>Local：JVM内部的异步通信</li><li>Embedded：测试你的ChannelHandler</li></ul></blockquote><h2 id="案例研究：传输迁移"><a href="#案例研究：传输迁移" class="headerlink" title="案例研究：传输迁移"></a>案例研究：传输迁移</h2><h3 id="不通过Netty使用OIO和NIO"><a href="#不通过Netty使用OIO和NIO" class="headerlink" title="不通过Netty使用OIO和NIO"></a>不通过Netty使用OIO和NIO</h3><p>未使用Netty的阻塞网络编程代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlainOioServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//将服务器绑定到指定端口</span>        ServerSocket socket = <span class="hljs-keyword">new</span> ServerSocket(port);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span>(;;)&#123;                <span class="hljs-comment">//接收连接</span>                <span class="hljs-keyword">final</span> Socket clientSocket = socket.accept();                System.out.println(<span class="hljs-string">"Accepted connection from "</span>+ clientSocket);                <span class="hljs-comment">//创建一个新的线程来处理该连接</span>                <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                        OutputStream out;                        <span class="hljs-keyword">try</span> &#123;                            out = clientSocket.getOutputStream();                            out.write(<span class="hljs-string">"Hi!\r\n"</span>.getBytes(CharsetUtil.UTF_8));                            <span class="hljs-comment">//关闭连接</span>                            clientSocket.close();                        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                            e.printStackTrace();                        &#125;                        <span class="hljs-keyword">finally</span> &#123;                            <span class="hljs-keyword">try</span> &#123;                                clientSocket.close();                            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                                                            &#125;                        &#125;                    &#125;                &#125;).start();<span class="hljs-comment">//启动线程</span>            &#125;        &#125;        <span class="hljs-keyword">catch</span> (IOException e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre></div><p>未使用Netty的异步网络编程代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlainNioServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        ServerSocketChannel serverChannel = ServerSocketChannel.open();        serverChannel.configureBlocking(<span class="hljs-keyword">false</span>);        ServerSocket serverSocket = serverChannel.socket();        InetSocketAddress address = <span class="hljs-keyword">new</span> InetSocketAddress(port);        <span class="hljs-comment">//将服务器绑定到选定的端口</span>        serverSocket.bind(address);        <span class="hljs-comment">//打开Selector来处理Channel</span>        Selector selector = Selector.open();        <span class="hljs-comment">//将ServerSocket注册到Selector来接收连接</span>        serverChannel.register(selector, SelectionKey.OP_ACCEPT);        <span class="hljs-keyword">final</span> ByteBuffer msg = ByteBuffer.wrap(<span class="hljs-string">"Hi!\r\n"</span>.getBytes());        <span class="hljs-comment">//等待需要处理的新事件，阻塞将一直持续到下一个传入事件</span>        <span class="hljs-keyword">for</span> (;;)&#123;            <span class="hljs-keyword">try</span> &#123;                selector.select();            &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;                e.printStackTrace();                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-comment">//获取所有接收事件的SelectorKey实例</span>            Set&lt;SelectionKey&gt; readKeys = selector.selectedKeys();            Iterator&lt;SelectionKey&gt; iterator = readKeys.iterator();            <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;                SelectionKey key = iterator.next();                iterator.remove();                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">//检测事件是否是一个新的并且已经就绪可以被接收的连接</span>                    <span class="hljs-keyword">if</span>(key.isAcceptable())&#123;                        ServerSocketChannel server = (ServerSocketChannel) key.channel();                        SocketChannel client = server.accept();                        client.configureBlocking(<span class="hljs-keyword">false</span>);                        <span class="hljs-comment">//接收客户端，并将它注册到选择器</span>                        client.register(selector,SelectionKey.OP_WRITE |                                 SelectionKey.OP_READ,msg.duplicate());                        System.out.println(<span class="hljs-string">"Accepted connection from "</span> + client);                    &#125;                    <span class="hljs-comment">//检查套接字是否已经准备好写数据</span>                    <span class="hljs-keyword">if</span>(key.isWritable())&#123;                        SocketChannel client = (SocketChannel) key.channel();                        ByteBuffer buffer = (ByteBuffer) key.attachment();                        <span class="hljs-keyword">while</span>(buffer.hasRemaining())&#123;                            <span class="hljs-comment">//将数据写到已连接的客户端</span>                            <span class="hljs-keyword">if</span>(client.write(buffer) == <span class="hljs-number">0</span>)&#123;                                <span class="hljs-keyword">break</span>;                            &#125;                        &#125;                        <span class="hljs-comment">//关闭连接</span>                        client.close();                    &#125;                &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;                    key.cancel();                    <span class="hljs-keyword">try</span> &#123;                        key.channel().close();                    &#125;<span class="hljs-keyword">catch</span> (IOException ex)&#123;                                            &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="通过Netty使用OIO和NIO"><a href="#通过Netty使用OIO和NIO" class="headerlink" title="通过Netty使用OIO和NIO"></a>通过Netty使用OIO和NIO</h3><p>使用Netty的阻塞网络处理代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyOioServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">final</span> ByteBuf buf = Unpooled.unreleasableBuffer(                Unpooled.copiedBuffer(<span class="hljs-string">"Hi!\r\n"</span>, CharsetUtil.UTF_8));        OioEventLoopGroup group = <span class="hljs-keyword">new</span> OioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建ServerBootstrap</span>            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();            b.group(group)                    <span class="hljs-comment">//使用OioEventLoopGroup以允许阻塞模式</span>                    .channel(OioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                    .<span class="hljs-title">localAddress</span>(<span class="hljs-title">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-title">port</span>))</span><span class="hljs-class">                    //指定<span class="hljs-title">ChannelInitializer</span>，对于每个已接收的连接都调用它</span><span class="hljs-class">                    .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            <span class="hljs-comment">//添加一个ChannelInboundHandlerAdapter以拦截和处理事件</span>                            socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;                                <span class="hljs-meta">@Override</span>                                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span></span>&#123;                                    <span class="hljs-comment">//将消息写到客户端，并添加ChannelFutureListener，以便消息一被写完就关闭连接</span>                                    ctx.writeAndFlush(buf.duplicate()).addListener(ChannelFutureListener.CLOSE);                                &#125;                            &#125;);                        &#125;                    &#125;);            ChannelFuture f = b.bind().sync();            f.channel().closeFuture().sync();        &#125;<span class="hljs-keyword">finally</span> &#123;            group.shutdownGracefully().sync();        &#125;            &#125;&#125;</code></pre></div><p>非阻塞的Netty版本</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyNioServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">final</span> ByteBuf buf = Unpooled.unreleasableBuffer(                Unpooled.copiedBuffer(<span class="hljs-string">"Hi!\r\n"</span>, CharsetUtil.UTF_8));        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<span class="hljs-comment">//</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建ServerBootstrap</span>            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();            b.group(group)                    <span class="hljs-comment">//使用OioEventLoopGroup以允许阻塞模式</span>                    .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)//</span><span class="hljs-class">                    .<span class="hljs-title">localAddress</span>(<span class="hljs-title">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-title">port</span>))</span><span class="hljs-class">                    //指定<span class="hljs-title">ChannelInitializer</span>，对于每个已接收的连接都调用它</span><span class="hljs-class">                    .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            <span class="hljs-comment">//添加一个ChannelInboundHandlerAdapter以拦截和处理事件</span>                            socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;                                <span class="hljs-meta">@Override</span>                                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span></span>&#123;                                    <span class="hljs-comment">//将消息写到客户端，并添加ChannelFutureListener，以便消息一被写完就关闭连接</span>                                    ctx.writeAndFlush(buf.duplicate()).addListener(ChannelFutureListener.CLOSE);                                &#125;                            &#125;);                        &#125;                    &#125;);            ChannelFuture f = b.bind().sync();            f.channel().closeFuture().sync();        &#125;<span class="hljs-keyword">finally</span> &#123;            group.shutdownGracefully().sync();        &#125;    &#125;&#125;</code></pre></div><p>我们发现使用Netty框架，从阻塞传输切换到非阻塞传输代码要做的更改非常小。</p><h2 id="传输API"><a href="#传输API" class="headerlink" title="传输API"></a>传输API</h2><p>传输API 的核心就是Channel接口，它被用于所有的I/O操作，其层次结构如下图所示：</p><p><img src="D:%5C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%5CBlog%5CMyBlog%5Csource_posts%5Cimage-20200531151609709.png" srcset="/img/loading.gif" alt="image-20200531151609709"></p><p>如图所示，每个Channel都将会被分配一个ChannelPipeline和ChannelConfig，ChannelConfig包含了该Channel的所有配置设置，并且支持热更新。</p><p>ChannelPipeline持有所有将应用于入站和出站数据以及事件的ChannelHandler实例，这些ChannelHandler实现了应用程序用于处理状态变化以及数据处理的逻辑。</p><p>ChannelHandler的典型用途包括：</p><ul><li>将数据从一种格式转换为另一种格式：</li><li>提供异常的通知；</li><li>提供Channel变为活动的或者非活动的通知；</li><li>提供当Channel注册到EventLoop或者从EventLoop注销时的通知；</li><li>提供有关用户自定义事件的通知。</li></ul><p>channel的方法：</p><table><thead><tr><th align="center">方法名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">eventLoop</td><td align="left">返回分配给Channel的EventLoop</td></tr><tr><td align="center">pipeline</td><td align="left">返回分配给Channel的ChannelPipeline</td></tr><tr><td align="center">isActive</td><td align="left">如果Channel是活动的，则返回true</td></tr><tr><td align="center">localAddress</td><td align="left">返回本地的SocketAddress</td></tr><tr><td align="center">remoteAddress</td><td align="left">返回远程的SocketAddress</td></tr><tr><td align="center">write</td><td align="left">将数据写到远程节点，这个数据将被传递给ChannelPipeline，并且排队直到它被冲刷</td></tr><tr><td align="center">flush</td><td align="left">将之前已写的数据冲刷到底层传输，如一个Socket</td></tr><tr><td align="center">writeAndFlush</td><td align="left">等同于调用write()并接着调用flush()方法</td></tr></tbody></table><p>前面我们也提到过，Netty的Channel实现是线程安全的，因此我们可以存储一个到Channel的引用，并且每当需要向远程节点写数据时，都可以使用它。</p><p>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChannelOperationExamples</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Channel CHANNEL_FROM_SOMEWHERE = <span class="hljs-keyword">new</span> NioSocketChannel();  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writingToChannelFromManyThreads</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 存储一个Channel的引用</span>        <span class="hljs-keyword">final</span> Channel channel = CHANNEL_FROM_SOMEWHERE;         <span class="hljs-comment">//创建持有要写数据的ByteBuf</span>        <span class="hljs-keyword">final</span> ByteBuf buf = Unpooled.copiedBuffer(<span class="hljs-string">"your data"</span>,                CharsetUtil.UTF_8);        <span class="hljs-comment">//创建将数据写到Channel 的 Runnable</span>        Runnable writer = <span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                channel.write(buf.duplicate());            &#125;        &#125;;        <span class="hljs-comment">//获取到线程池Executor 的引用</span>        Executor executor = Executors.newCachedThreadPool();        <span class="hljs-comment">//递交写任务给线程池以便在某个线程中执行</span>        executor.execute(writer);        <span class="hljs-comment">//递交另一个写任务以便在另一个线程中执行</span>        executor.execute(writer);        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><h2 id="内置的传输"><a href="#内置的传输" class="headerlink" title="内置的传输"></a>内置的传输</h2><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>NIO</td><td>基于选择器的方式</td></tr><tr><td>Epoll</td><td>由JNI驱动的epoll()和非阻塞IO，支持只有在Linux上可用的多种特性，如SO_REUSEPORT，比NIO传输更快，完全非阻塞</td></tr><tr><td>OIO</td><td>阻塞IO</td></tr><tr><td>Local</td><td>可以在VM内部通过管道进行通信的本地传输</td></tr><tr><td>Embedded</td><td>允许使用ChannelHandler而又不需要一个真正的基于网络的传输，主要用于测试</td></tr></tbody></table><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>NIO提供了一个所有I/O操作的全异步的实现，利用选择器来获取Channel状态改变时的通知，可能的状态变化有：</p><ul><li>新的Channel已被接收并且就绪；</li><li>Channel连接已经完成；</li><li>Channel有已经就绪的可供读取的数据；</li><li>Channel可用于写数据。</li></ul><p>选择器运行在一个检查状态变化并对其做出响应的线程上，在应用程序对状态的改变作出响应之后，选择器将会被重置，并将重复这个过程。</p><p>选择操作的位模式：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>OP_ACCEPT</td><td>请求在接收新连接并创建Channel时获得通知</td></tr><tr><td>OP_CONNECT</td><td>请求在建立一个连接时获得通知</td></tr><tr><td>OP_READ</td><td>请求当数据已经就绪，可以从Channel中读取时获得通知</td></tr><tr><td>OP_WRITE</td><td>请求当可以向Channel中写入更多的数据时获得通知</td></tr></tbody></table><p>处理流程如下：</p><p><img src="D:%5C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%5CBlog%5CMyBlog%5Csource_posts%5Cimage-20200531162714677.png" srcset="/img/loading.gif" alt="image-20200531162714677">    </p><p>知识点扩展：</p><p>零拷贝：零拷贝时一种目前只有在使用NIO和Epoll传输时才可使用的特性，可以快速高效地将数据从文件系统移动到网络接口，而不需要将其从内核空间复制到用户空间。但是它对于实现了数据加密或者压缩的文件系统是不可用的，只能传输文件的原始内容。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.Netty--Netty的组件和设计</title>
    <link href="/2020/05/31/3-Netty-Netty%E7%9A%84%E7%BB%84%E4%BB%B6%E5%92%8C%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/05/31/3-Netty-Netty%E7%9A%84%E7%BB%84%E4%BB%B6%E5%92%8C%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>Netty的技术和体系结构方面的内容</li><li>Channel、EventLoop和ChannelFuture</li><li>ChannelHandler和ChannelPipeline</li><li>引导</li></ul></blockquote><p>学习Netty是因为它是基于Java NIO 的异步和事件驱动的实现，保证了高负载下应用程序性能的最大化和可伸缩性；同时它包含了一组设计模式，实现了应用程序逻辑从网络层解耦，简化了开发过程，最大限度地提高了可测试性、模块化以及代码的可重用性。</p><h2 id="1-Channel、EventLoop和ChannelFuture"><a href="#1-Channel、EventLoop和ChannelFuture" class="headerlink" title="1. Channel、EventLoop和ChannelFuture"></a>1. Channel、EventLoop和ChannelFuture</h2><ul><li><p>Channel：Socket；</p></li><li><p>EventLoop：控制流、多线程处理、并发；</p></li><li><p>ChannelFuture：异步通知</p></li></ul><h3 id="Channel接口"><a href="#Channel接口" class="headerlink" title="Channel接口"></a>Channel接口</h3><p>基本的I/O操作（bind、connect、read、write）都依赖于底层网络传送所提供的原语，也就是Socket，而Netty中的Channel就是简化Socket编程的复杂性。</p><h3 id="EventLoop接口"><a href="#EventLoop接口" class="headerlink" title="EventLoop接口"></a>EventLoop接口</h3><p>用于处理连接的生命周期中所发生的事件。</p><p><img src="D:%5C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%5CBlog%5CMyBlog%5Csource_posts%5Cimage-20200531101754279.png" srcset="/img/loading.gif" alt="image-20200531101754279"></p><p>其关系是：</p><ul><li>一个EventLoopGroup包含一个或多个EventLoop；</li><li>一个EventLoop在它的生命周期内只和一个Thread绑定；</li><li>所有由EventLoop处理的I/O事件都将在它专有的Thread上被处理（<strong>消除了对同步的需求</strong>）</li><li>一个Channel在它的生命周期内只注册于一个EventLoop；</li><li>一个EventLoop可能会被分配给一个或多个Channel。</li></ul><h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><p>正因为Netty中所有的I/O操作都是异步的，其执行结果不会立即返回，所以Netty提供了ChannelFuture接口，其addListener()方法注册了一个ChannelFutureListener，以便在某个操作完成时(无论是否成功)都能得到通知。</p><h2 id="2-ChannelHandler和ChannelPipeline"><a href="#2-ChannelHandler和ChannelPipeline" class="headerlink" title="2. ChannelHandler和ChannelPipeline"></a>2. ChannelHandler和ChannelPipeline</h2><p>管理数据流以及执行应用程序处理逻辑的组件</p><h3 id="ChannelHandler接口"><a href="#ChannelHandler接口" class="headerlink" title="ChannelHandler接口"></a>ChannelHandler接口</h3><p>充当了所有处理入站和出站数据的应用程序逻辑的容器，因为<code>ChannelHandler</code>的方法是由<strong>网络事件触发</strong>的。</p><h3 id="ChannelPipeline接口"><a href="#ChannelPipeline接口" class="headerlink" title="ChannelPipeline接口"></a>ChannelPipeline接口</h3><p>提供了ChannelHandler链的容器，并定义了用于在该链上传播入站和出站事件流的API，当Channel被创建时，他会被自动的分配到它专属的ChannelPipeline。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//在创建Channel时向ChannelPipeline中添加一个EchoClientHandler实例</span>.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> EchoClientHandler());    &#125;&#125;);</code></pre></div><p><img src="D:%5C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%5CBlog%5CMyBlog%5Csource_posts%5Cimage-20200531105603364.png" srcset="/img/loading.gif" alt="image-20200531105603364"></p><p>执行顺序由添加顺序所决定，ChannelHandler处理完后将数据传递给链中的下一个ChannelHandler，该ChanelHandler不一定会去修改数据，如果数据到达ChannelPipeline一端，也就说明处理结束。</p><p>当ChannelHandler被添加到ChannelPipeline时，它将会被分配一个ChannelHandlerContext，其代表了ChannelHandler和ChannelPipeline之间的绑定，主要用于写出站数据。</p><p>在Netty中有两种发送消息的方式，直接写到Channel中，也可以写到ChannelHandlerContext对象中，前一种方式将会导致消息从ChannelPipeline的尾端开始流动，后者将导致消息从ChannelPipeline中的下一个ChannelHandler开始流动。</p><h3 id="编码器和解码器"><a href="#编码器和解码器" class="headerlink" title="编码器和解码器"></a>编码器和解码器</h3><p>因为网络数据总是一系列的字节，而我们写的代码是一些对象</p><p>所有由Netty提供的编码器/解码器适配器类都实现了ChannelInboundHandler接口或者ChannelOutboundHandler接口。</p><h3 id="抽象类SimpleChannelInboundHandler"><a href="#抽象类SimpleChannelInboundHandler" class="headerlink" title="抽象类SimpleChannelInboundHandler"></a>抽象类SimpleChannelInboundHandler</h3><p>当我们利用一个ChannelHandler来接收解码消息，并对该数据应用业务逻辑，基本上只需要扩展基类SimpleChannelInboundHandler<T>，其中T就是我们要处理的Java类型。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;<span class="hljs-comment">//这里的ByteBuf应该是跟服务端代码没有关系的，根据我们自身的业务需求来定的</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">"Client received: "</span>+ byteBuf.toString(CharsetUtil.UTF_8));    &#125;</code></pre></div><h3 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h3><p>Netty的引导类为应用程序的<strong>网络层</strong>配置提供了容器，有两种类型的引导：一种用于客户端，另一种用于服务器，区别如下：</p><table><thead><tr><th align="center">区别</th><th align="center">BootStrap</th><th align="center">ServerBootStrap</th></tr></thead><tbody><tr><td align="center">网络编程中的作用</td><td align="center">连接到远程主机和端口</td><td align="center">绑定到一个本地端口</td></tr><tr><td align="center">EventLoopGroup的数目</td><td align="center">1</td><td align="center">2</td></tr></tbody></table><p>为什么ServerBootStrap需要两个EventLoopGroup呢？</p><p>因为服务器需要两组不同的Channel，第一组将只包含一个ServerChannel，代表服务器自身的已绑定到某个本地端口的正在监听的套接字，而第二组将包含所有已创建的用来处理传入客户端连接的Channel。</p><p><img src="D:%5C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%5CBlog%5CMyBlog%5Csource_posts%5Cimage-20200531115618470.png" srcset="/img/loading.gif" alt="image-20200531115618470"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.Netty--你的第一款Netty应用</title>
    <link href="/2020/05/31/2-Netty-%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%BENetty%E5%BA%94%E7%94%A8/"/>
    <url>/2020/05/31/2-Netty-%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%BENetty%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li><p>设置开发环境</p></li><li><p>编写Echo服务器和客户端</p></li><li><p>构建并测试应用程序</p></li></ul></blockquote><h3 id="1-设置开发环境"><a href="#1-设置开发环境" class="headerlink" title="1.设置开发环境"></a>1.设置开发环境</h3><p>准备好JDK和Maven</p><h3 id="2-Netty客户端-服务器概览"><a href="#2-Netty客户端-服务器概览" class="headerlink" title="2.Netty客户端/服务器概览"></a>2.Netty客户端/服务器概览</h3><p><img src="D:%5C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%5CBlog%5CMyBlog%5Csource_posts%5Cimage-20200530220611801.png" srcset="/img/loading.gif" alt="Echo客户端和服务器"></p><p>在客户端建立一个连接之后，它会向服务器发送一个或多个消息，反过来，服务器又会将每个消息回送给客户端。</p><h3 id="3-编写Echo服务器"><a href="#3-编写Echo服务器" class="headerlink" title="3.编写Echo服务器"></a>3.编写Echo服务器</h3><p>首先明确的一点是，所有的Netty服务器都需要以下两部分：</p><ul><li>至少一个ChannelHandler：用户实现服务器对从客户端接收的数据的处理，即业务逻辑。</li><li>引导：配置服务器的启动代码，如将服务器绑定到它需要监听连接请求的端口上。</li></ul><h4 id="3-1ChannelHandler和业务逻辑"><a href="#3-1ChannelHandler和业务逻辑" class="headerlink" title="3.1ChannelHandler和业务逻辑"></a>3.1ChannelHandler和业务逻辑</h4><p>ChannelHandler是一个父接口，它的实现负责接收并响应事件通知。</p><p>这里我们的Echo服务器需要响应传入的消息，所以需要实现ChannelInboundHandler接口，用来定义响应入站事件的方法，这里我们继承ChannelInboundHandlerAdapter类。</p><p>主要有如下方法可以调用：</p><ul><li><p>channelRead(): 对于每个传入的消息都要调用</p></li><li><p>channelReadComplete()：表明了本次从 Socket 读了数据，但是否是完整的数据它其实并不知道</p></li><li><p>exceptionCaught()：在读取操作期间 ，有异常抛出时会调用</p></li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/** Sharable标识一个ChannelHandler可以被多个Channel安全地共享 **/</span><span class="hljs-meta">@ChannelHandler</span>.Sharable<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ByteBuf in = (ByteBuf)msg;        System.out.println(<span class="hljs-string">"Server received: "</span> + in.toString(CharsetUtil.UTF_8));        <span class="hljs-comment">//将接收到的消息写给发送者</span>        ctx.write(in);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//将消息冲刷到客户端，并且关闭该Channel</span>        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//打印异常栈跟踪</span>        cause.printStackTrace();        <span class="hljs-comment">//关闭该Channel</span>        ctx.close();    &#125;&#125;</code></pre></div><h4 id="3-2-引导服务器"><a href="#3-2-引导服务器" class="headerlink" title="3.2 引导服务器"></a>3.2 引导服务器</h4><p>主要内容如下：</p><ul><li>绑定服务器将在其上监听并接收传入连接请求的端口；</li><li>配置Channel，以将有关的入站消息通知给EchoServerHandler实例</li></ul><p>编写EchoServer类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EchoServer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;        <span class="hljs-keyword">this</span>.port = port;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">//设置端口值不正确</span>        <span class="hljs-keyword">if</span>(args.length != <span class="hljs-number">1</span>)&#123;            System.err.print("Usage: "+EchoServer.class.getSimpleName() + "&lt;port&gt;");        &#125;        <span class="hljs-keyword">int</span> port = Integer.parseInt(args[<span class="hljs-number">0</span>]);        <span class="hljs-comment">//调用服务器的start()方法</span>        <span class="hljs-keyword">new</span> EchoServer(port).start();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">final</span> EchoServerHandler serverHandler = <span class="hljs-keyword">new</span> EchoServerHandler();        <span class="hljs-comment">//创建EventLoopGroup，因为我们使用的是NIO传输，所以要指定NioEventLoopGroup来接收和处理新的连接</span>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建ServerBootstrap</span>            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();            b.group(group)                    <span class="hljs-comment">//指定所使用的NIO传输Channel，同理因为NIO传输</span>                    .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                    //使用指定的端口设置套接字地址，服务器将绑定到这个地址以监听新的连接请求</span><span class="hljs-class">                    .<span class="hljs-title">localAddress</span>(<span class="hljs-title">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-title">port</span>))</span><span class="hljs-class">                    //当一个新的连接被接收时，一个新的子<span class="hljs-title">Channel</span>将会被创建，<span class="hljs-title">ChannelInitializer</span>会把<span class="hljs-title">EchoServerHandler</span>               //的实例添加到<span class="hljs-title">Channel</span>的<span class="hljs-title">ChannelPipeline</span>中,这个<span class="hljs-title">ChannelHandler</span>会接收入站消息的通知。</span><span class="hljs-class">                    .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            <span class="hljs-comment">//由于EchoServerHandler被标注位@Shareable，所以我们使用的是同一个EchoServerHandler</span>                            socketChannel.pipeline().addLast(serverHandler);                        &#125;                    &#125;);            <span class="hljs-comment">//异步的绑定服务器，调用sync()方法阻塞等待直到绑定完成</span>            ChannelFuture f = b.bind().sync();            <span class="hljs-comment">//获取Channel的CloseFuture，并且阻塞当前线程直到它完成</span>            f.channel().closeFuture().sync();        &#125;<span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//关闭EventLoopGroup，并且释放所有的资源</span>            group.shutdownGracefully().sync();        &#125;    &#125;&#125;</code></pre></div><p>主要步骤：</p><ul><li>EchoServerHandler实现业务逻辑；</li><li>main()方法引导了服务器</li></ul><p>在引导过程中的步骤：</p><ul><li><p>使用一个EchoServerHandler实例来初始化每一个新的Channel</p></li><li><p>创建并分配一个NioEventLoopGroup实例以进行事件的处理，如接收新连接以及读/写数据；</p></li><li><p>创建一个ServerBootstrap的实例以引导和绑定服务器；</p></li><li><p>指定服务器绑定的本地InetSocketAddress</p></li><li><p>调用ServerBootstrap.bind()方法来绑定服务器</p></li></ul><h3 id="4-编写Echo客户端"><a href="#4-编写Echo客户端" class="headerlink" title="4. 编写Echo客户端"></a>4. 编写Echo客户端</h3><p>Echo客户端主要任务：</p><ul><li>连接到服务端</li><li>发送一个或多个消息；</li><li>对于每个消息，等待并接收从服务器发回的消息；</li><li>关闭连接</li></ul><p>客户端所涉及到的两个主要代码部分也是业务逻辑和引导</p><h4 id="4-1-通过ChannelHandler实现客户端逻辑"><a href="#4-1-通过ChannelHandler实现客户端逻辑" class="headerlink" title="4.1 通过ChannelHandler实现客户端逻辑"></a>4.1 通过ChannelHandler实现客户端逻辑</h4><p>客户端也拥有一个用来处理数据的ChannelInboundHandler，这里我们扩展SimpleChannelInboundHandler类来处理所有必须的任务，重写以下方法：</p><ul><li><p>channelActive()：在到服务器的连接已经建立之后将被调用</p></li><li><p>channel Read0()：当从服务器接收到一条消息时被调用</p></li><li><p>exceptionCaught()：在处理过程中引发异常时被调用</p></li></ul><p>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;    <span class="hljs-comment">/** 连接服务器后调用该方法 **/</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">"Netty rocks!"</span>, CharsetUtil.UTF_8));    &#125;    <span class="hljs-comment">/** 从服务器接收到消息后调用该方法 **/</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">"Client received: "</span>+ byteBuf.toString(CharsetUtil.UTF_8));    &#125;    <span class="hljs-comment">/** 发生异常时，记录错误并关闭Channel **/</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre></div><p>注意： 从服务器发送的消息可能会被分块接收，channelRead0()方法因此有可能被调用多次。</p><p>还有一点值得注意的是Echo 服务端使用的ChannelHandler是 ChannelInboundHandlerAdapter，而 Echo 客户端使用的却是 SimpleChannelInboundHandler，其实它们是继承关系。</p><p><img src="D:%5C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%5CBlog%5CMyBlog%5Csource_posts%5Cimage-20200531000101367.png" srcset="/img/loading.gif" alt="关系图"></p><p>既然是继承关系，也就是说，”你有的我也有，你没有的我还有。” 那么 SimpleChannelInboundHandler 里面肯定重写或者新增了 ChannelInboundHandlerAdapter 里面的方法功能 - channelRead0 和 channelRead()。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, I msg)</span> <span class="hljs-keyword">throws</span> Exception</span>;</code></pre></div><p>至于为什么会这样设计，原因是在客户端，当 channelRead0() 方法完成时，你已经有了传入消息，并且已经处理完它了。当该方法返回时，SimpleChannelInboundHandler负责释放指向保存该消息的ByteBuf的内存引用。而在服务端，你仍然需要将传入消息回送给发送者，而 write() 操作是异步的，直到 channelRead() 方法返回后可能仍然没有完成。为此，EchoServerHandler扩展了 ChannelInboundHandlerAdapter ，其在这个时间点上不会释放消息。</p><h4 id="4-2-引导客户端"><a href="#4-2-引导客户端" class="headerlink" title="4.2 引导客户端"></a>4.2 引导客户端</h4><p>客户端使用主机和端口号来连接远程地址</p><p>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoClient</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String host;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EchoClient</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port)</span> </span>&#123;        <span class="hljs-keyword">this</span>.host = host;        <span class="hljs-keyword">this</span>.port = port;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">if</span>(args.length != <span class="hljs-number">2</span>)&#123;            System.err.println("Usage: "+ EchoClient.class.getSimpleName()+"&lt;host&gt; &lt;port&gt;");            <span class="hljs-keyword">return</span>;        &#125;        String host = args[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> port = Integer.parseInt(args[<span class="hljs-number">1</span>]);        <span class="hljs-keyword">new</span> EchoClient(host,port).start();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            Bootstrap b = <span class="hljs-keyword">new</span> Bootstrap();            b.group(group)                    .channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                    .<span class="hljs-title">remoteAddress</span>(<span class="hljs-title">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-title">host</span>,<span class="hljs-title">port</span>))</span><span class="hljs-class">                    //在创建<span class="hljs-title">Channel</span>时向<span class="hljs-title">ChannelPipeline</span>中添加一个<span class="hljs-title">EchoClientHandler</span>实例</span><span class="hljs-class">                    .<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> EchoClientHandler());                        &#125;                    &#125;);            ChannelFuture f = b.connect().sync();            f.channel().closeFuture().sync();        &#125;<span class="hljs-keyword">finally</span> &#123;            group.shutdownGracefully().sync();        &#125;    &#125;&#125;</code></pre></div><h3 id="5-构建和运行Echo服务器和客户端"><a href="#5-构建和运行Echo服务器和客户端" class="headerlink" title="5. 构建和运行Echo服务器和客户端"></a>5. 构建和运行Echo服务器和客户端</h3><p>目录如下：</p><p><img src="D:%5C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%5CBlog%5CMyBlog%5Csource_posts%5Cimage-20200531005801752.png" srcset="/img/loading.gif" alt="image-20200531005801752"></p><p>注意要在pom.xml文件中引入netty依赖以及编译maven模板需要的插件。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.netty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>netty-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.42.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.mojo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>exec-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>                  <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>                      <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                          <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>                      <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>                  <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                  <span class="hljs-comment">&lt;!--指定main文件,不指定会报错，如果是client就要变成EchoClient--&gt;</span>                  <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>EchoServer<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><p>先执行<code>mvn clean package</code>来清除指定的包，然后<code>cd server</code>，执行<code>exec:java -Dexec.args=&quot;1&quot;</code>,接下来点击右下角的加号新建一个终端，然后<code>cd client</code>，执行<code>exec:java -Dexec.args=&quot;0 1&quot;</code>，即可看到效果。一定一定要先开启服务器然后再开客户端，否则会报错。</p><p>效果：</p><p><img src="D:%5C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%5CBlog%5CMyBlog%5Csource_posts%5Cimage-20200531013137631.png" srcset="/img/loading.gif" alt="image-20200531013137631"></p><p>补充一个遇到的坑：</p><p><img src="D:%5C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%5CBlog%5CMyBlog%5Csource_posts%5Cimage-20200531005234930.png" srcset="/img/loading.gif" alt="image-20200531005234930"></p><p>如果在执行<code>mvn exec:java -Dexec.args=&quot;0 1&quot;</code>的时候出现上面错误，首先去自己的maven的目录下查看配置文件setting.xml</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\Software\apache-maven-3.6.1\repository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span></code></pre></div><p>看路径是否正确，其次检查IDEA中的MAVEN配置。</p><p><img src="D:%5C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%5CBlog%5CMyBlog%5Csource_posts%5Cimage-20200531005642681.png" srcset="/img/loading.gif" alt="image-20200531005642681"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.Netty--异步和事件驱动</title>
    <link href="/2020/05/30/1-Netty-%E5%BC%82%E6%AD%A5%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/"/>
    <url>/2020/05/30/1-Netty-%E5%BC%82%E6%AD%A5%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本系列文章主要来自《Netty IN ACTION》</p><p>本章主要内容：</p><ul><li><p>Java网络编程</p></li><li><p>Netty简介</p></li><li><p>Netty核心组件</p></li></ul></blockquote><h2 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h2><p>首先来看一个典型的阻塞I/O示例：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//创建一个新的ServerSocket，用于监听指定端口上的连接请求</span>ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(portNumber);<span class="hljs-comment">//1</span><span class="hljs-comment">//以阻塞的方式来调用accept()方法，直到一个连接建立</span>Socket clientSocket = serverSocket.accept();<span class="hljs-comment">//2</span><span class="hljs-comment">//BufferedReader和PrintWriter分别用于从字符输入流中读取文本和将对象格式化到文本输出流</span>BufferedReader in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(clientSocket.getInputStream()));PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(clientSocket.getOutputStream(),<span class="hljs-keyword">true</span>);String request,response;<span class="hljs-comment">//循环对输入流进行判断处理</span><span class="hljs-keyword">while</span>((request = in.readLine()) != <span class="hljs-keyword">null</span>)&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-string">"Done"</span>.equals(request))&#123;        <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-comment">//服务器处理客户端的请求，并作出响应</span>    response = processRequest(request);    <span class="hljs-comment">//输出响应</span>    out.println(response);</code></pre></div><p>这里<code>ServerSocket</code>的作用是监听某一路端口是否有连接，如果有连接就会创建一个新的<code>Socket</code>用于客户端和服务器进行通信，而此时<code>ServerSocket</code>并不会断开连接，而是会继续监听传入的连接。</p><p><img src="D:%5C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%5CBlog%5CMyBlog%5Csource_posts%5Cimage-20200530211626179.png" srcset="/img/loading.gif" alt="传统阻塞I/O"></p><p>这里就体现出弊端了，如果有多个并发客户端，那就需要为每个客户端Socket创建一个Thread，弊端有三：</p><ul><li>资源浪费，并不是每时每刻都有数据在传输，大部分情况下线程都处在休眠状态；</li><li>内存消耗，需要为每个线程的调度栈分配内存；</li><li>上下文切换带来的开销大；</li></ul><h3 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h3><p>使用setSockopt()方法配置套接字，以便读/写调用在没有数据的时候立即返回</p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>使用<code>java.nio.channels.Selector</code>这个类，利用事件通知API来确定在一组非阻塞套接字中有哪些已经就绪能够进行I/O相关的操作。</p><p><img src="D:%5C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%5CBlog%5CMyBlog%5Csource_posts%5Cimage-20200530211701935.png" srcset="/img/loading.gif" alt="使用Selector的非阻塞I/O"></p><h2 id="Netty简介"><a href="#Netty简介" class="headerlink" title="Netty简介"></a>Netty简介</h2><p>Netty是一个<strong>NIO</strong>客户端/服务器<strong>框架</strong>，支持快速、简单地开发网络应用，如协议服务器和客户端。</p><h2 id="Netty核心组件"><a href="#Netty核心组件" class="headerlink" title="Netty核心组件"></a>Netty核心组件</h2><p>Netty的主要构建块：</p><ul><li>Channel</li><li>回调</li><li>Future</li><li>事件和Channelhandler</li></ul><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>简单理解就是传入或者传出数据的载体，可以被打开或者被关闭，连接或者断开连接。</p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>回调其实就是一个方法，回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。Netty内部使用了回调来处理事件，当一个回调被触发时，相关的事件被一个ChannelHandler的实现来处理，</p><p>看下面一段代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(channelHandlerContect ctx)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        System.out.println(<span class="hljs-string">"Client "</span> + ctx.channel().remoteAddress() + <span class="hljs-string">" connected"</span>);    &#125;&#125;</code></pre></div><p>当一个新的连接已经被建立时，ChannelHandler的channelActive()回调方法将会被调用，并将打印一条信息。</p><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>可以看作是一个异步操作的结果的占位符，可以在未来提供对其结果的访问；</p><p>Netty提供了自己的ChannelFuture，用于在执行异步操作的时候使用。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectExample</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Channel CHANNEL_FROM_SOMEWHERE = <span class="hljs-keyword">new</span> NioSocketChannel();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">()</span> </span>&#123;        Channel channel = CHANNEL_FROM_SOMEWHERE;         <span class="hljs-comment">//异步地连接到远程节点</span>        ChannelFuture future = channel.connect(                <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"192.168.0.1"</span>, <span class="hljs-number">25</span>));        <span class="hljs-comment">//注册一个 ChannelFutureListener，以便在操作完成时获得通知</span>        future.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> </span>&#123;                <span class="hljs-comment">//检查操作的状态</span>                <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;                    <span class="hljs-comment">//如果操作是成功的，则创建一个 ByteBuf 以持有数据</span>                    ByteBuf buffer = Unpooled.copiedBuffer(                            <span class="hljs-string">"Hello"</span>, Charset.defaultCharset());                    <span class="hljs-comment">//将数据异步地发送到远程节点。返回一个 ChannelFuture</span>                    ChannelFuture wf = future.channel()                            .writeAndFlush(buffer);                    <span class="hljs-comment">// ...</span>                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">//如果发生错误，则访问描述原因的 Throwable</span>                    Throwable cause = future.cause();                    cause.printStackTrace();                &#125;            &#125;        &#125;);    &#125;&#125;</code></pre></div><p>可以看到，回调和Future是相互补充的机制，而ChannelFutureListener可以看作是回调的一个更加精细的版本。</p><h3 id="事件和Channelhandler"><a href="#事件和Channelhandler" class="headerlink" title="事件和Channelhandler"></a>事件和Channelhandler</h3><p>Netty使用不同的事件来通知我们状态的改变或者是操作的状态，因此我们可以利用事件来进行相应的处理，比如：</p><ul><li>记录日志</li><li>数据转换</li><li>流控制</li><li>应用程序逻辑</li></ul><p>Netty作为一个网络编程框架，主要事件分为入站事件和出站事件，入站事件包括：</p><ul><li>连接已被激活或者连接失活</li><li>数据读取</li><li>用户事件</li><li>错误事件</li></ul><p>出站事件包括：</p><ul><li>打开或者关闭远程节点的连接</li><li>将数据写到或者冲刷到套接字</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(9)--角色继承</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-9-%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-9-%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<p>在本节中，补充下<strong>角色继承</strong>的知识点。角色继承其实是一个十分常见的需求，因为一般系统中角色权限呈金字塔型，高层用户拥有底层用户的权限。</p><p>例如存在以下角色：普通用户、VIP 用户、SVIP 用户、星悦会员，那么对应的权限可以是“星悦会员 &gt; SVIP 用户 &gt; VIP 用户 &gt; 普通用户”。那么如何在 Spring Security 中实现这样的功能呢？</p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>为了简便起见，我直接使用<a href="https://www.jitwxs.cn/5f5715e6.html" target="_blank" rel="noopener">《SpringBoot 集成 Spring Security（1）——入门程序》</a> 的代码。</p><p>在该章中，我们存在两个角色，<code>ROLE_ADMIN</code> 和 <code>ROLE_USER</code>，并且经过我们的实验，<code>/admin</code> 接口只有 ROLE_ADMIN 有权限，<code>/user</code> 接口只有 ROLE_USER 有权限。</p><p>但是如果我想让 ROLE_ADMIN 用户继承 ROLE_USER 用户的所有权限，该如何做呢？</p><h3 id="RoleHierarchy"><a href="#RoleHierarchy" class="headerlink" title="RoleHierarchy"></a>RoleHierarchy</h3><p>这里就需要引入 <code>RoleHierarch</code>了，我们只需要自定义一个 RoleHierarchy，并将其注入容器即可。修改 <code>WebSecurityConfig</code>，在其中注入 RoleHierarchy：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> RoleHierarchy <span class="hljs-title">roleHierarchy</span><span class="hljs-params">()</span></span>&#123;    RoleHierarchyImpl roleHierarchy = <span class="hljs-keyword">new</span> RoleHierarchyImpl();    String hierarchy = <span class="hljs-string">"ROLE_ADMIN &gt; ROLE_USER"</span>;    roleHierarchy.setHierarchy(hierarchy);    <span class="hljs-keyword">return</span> roleHierarchy;&#125;</code></pre></div><p><code>roleHierarchy.setHierarchy()</code> 指定了角色的继承关系，参数就是一个字符串，比大小即可，是不是非常简单？</p><p>让我们使用 ROLE_ADMIN 账号登陆，发现原本无法访问的 <code>/user</code> 接口也可以访问了：</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>角色关系的实现也比较简单，本质就是将字符串使用正则切分，并将角色关系存放进一个 Map 中，map 的 key 是大的角色，value 是一个 Set，存放所有比它小的角色。然后交由后续处理，有兴趣的可以继续阅读源码。</p><p><img src="https://www.jitwxs.cn/images/posts/20190902233900717.png" srcset="/img/loading.gif" alt="buildRolesReachableInOneStepMap()"></p><p>如果有多个继承关系，在 SpringBoot 2.1 中，就应该改写为：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> RoleHierarchy <span class="hljs-title">roleHierarchy</span><span class="hljs-params">()</span> </span>&#123;    String separator = System.lineSeparator();        RoleHierarchyImpl roleHierarchy = <span class="hljs-keyword">new</span> RoleHierarchyImpl();    String hierarchy = <span class="hljs-string">"ROLE_ADMIN &gt; ROLE_USER "</span> + separator + <span class="hljs-string">" ROLE_USER &gt; ROLE_TOURISTS"</span>;    roleHierarchy.setHierarchy(hierarchy);    <span class="hljs-keyword">return</span> roleHierarchy;&#125;</code></pre></div><p>另外换行符大家都知道在不同系统中表示不一样，例如 Windows 中为 <code>\r\n</code>，Mac 为 <code>\r</code>，Linux 为 <code>\n</code>，因此以上代码我是用的 <code>java.lang</code> 包的 System 类中封装的方法，不用判断当前操作系统。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(8)--短信验证码登录</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-8-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E5%BD%95/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-8-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一、理论说明"><a href="#一、理论说明" class="headerlink" title="一、理论说明"></a>一、理论说明</h2><p>在开始编码前，先理解下短信验证码的实现流程。如果你能对<a href="https://www.jitwxs.cn/a28c0db7.html" target="_blank" rel="noopener">《SpringBoot集成Spring Security（7）——认证流程》</a>这篇文章有一定的了解的话，那么这篇文章的学习你会轻松许多。</p><h3 id="1-1-用户名密码登录逻辑"><a href="#1-1-用户名密码登录逻辑" class="headerlink" title="1.1 用户名密码登录逻辑"></a>1.1 用户名密码登录逻辑</h3><p>废话不多说，在上一篇文章中，以标准的用户名密码登录为例，讲解了整个认证流程。大致流程如下：</p><ol><li><p>先进入 <code>UsernamePasswordAuthenticationFilter</code> 中，根据输入的用户名和密码信息，构造出一个暂时没有鉴权的 <code>UsernamePasswordAuthenticationToken</code>，并将 UsernamePasswordAuthenticationToken 交给 <code>AuthenticationManager</code>处理。</p></li><li><p><code>AuthenticationManager</code>本身并不做验证处理，他通过 for-each 遍历找到符合当前登录方式的一个 AuthenticationProvider，并交给它进行验证处理，对于用户名密码登录方式，这个 Provider 就是 <code>DaoAuthenticationProvider</code>。</p></li><li><p>在这个 Provider 中进行一系列的验证处理，如果验证通过，就会重新构造一个添加了鉴权的 <code>UsernamePasswordAuthenticationToken</code>，并将这个 token 传回到 <code>UsernamePasswordAuthenticationFilter</code> 中。</p></li><li><p>在该 Filter 的父类 <code>AbstractAuthenticationProcessingFilter</code> 中，会根据上一步验证的结果，跳转到 successHandler 或者是 failureHandler。</p><p><img src="https://www.jitwxs.cn/images/posts/20181202095539982.png" srcset="/img/loading.gif" alt="img"></p><p>​                                                    Spring Security 认证流程（部分）</p></li></ol><h3 id="1-2-短信验证码登录逻辑"><a href="#1-2-短信验证码登录逻辑" class="headerlink" title="1.2 短信验证码登录逻辑"></a>1.2 短信验证码登录逻辑</h3><p>我们可以仿照用户名密码登录的逻辑，来实现短信验证码的登录逻辑。</p><ol><li>用户名密码登录有个 <code>UsernamePasswordAuthenticationFilter</code> ，我们搞一个 <code>SmsAuthenticationFilter</code>，代码粘过来改一改。</li><li>用户名密码登录需要 <code>UsernamePasswordAuthenticationToken</code>，我们搞一个 <code>SmsAuthenticationToken</code>，代码粘过来改一改。</li><li>用户名密码登录需要 <code>DaoAuthenticationProvider</code>，我们模仿它也implenments AuthenticationProvider，叫做 <code>SmsAuthenticationProvider</code>。</li></ol><p><img src="https://www.jitwxs.cn/images/posts/2019010916114182.png" srcset="/img/loading.gif" alt="短信登录验证逻辑"></p><p>​                                                                                短信登录验证逻辑</p><p>我们自己搞了上面三个类以后，想要实现的效果如上图所示。当我们使用短信验证码登录的时候：</p><ol><li>先经过 <code>SmsAuthenticationFilter</code>，构造一个没有鉴权的 <code>SmsAuthenticationToken</code>，然后交给 AuthenticationManager 处理。</li><li>AuthenticationManager 通过 for-each 挑选出一个合适的 provider 进行处理，当然我们希望这个 provider 要是 <code>SmsAuthenticationProvider</code>。</li><li>验证通过后，重新构造一个有鉴权的 <code>SmsAuthenticationToken</code>，并返回给 <code>SmsAuthenticationFilter</code>。</li><li>filter 根据上一步的验证结果，跳转到成功或者失败的处理逻辑。</li></ol><h2 id="二、代码实战"><a href="#二、代码实战" class="headerlink" title="二、代码实战"></a>二、代码实战</h2><p>请通过 github 链接下载第一章代码，或者参看<a href="https://www.jitwxs.cn/5f5715e6.html" target="_blank" rel="noopener">《SpringBoot集成Spring Security（1）——入门程序》</a>初始化项目，这里就不再赘述了。</p><h3 id="2-1-SmsAuthenticationToken"><a href="#2-1-SmsAuthenticationToken" class="headerlink" title="2.1 SmsAuthenticationToken"></a>2.1 SmsAuthenticationToken</h3><p>首先我们编写 <code>SmsAuthenticationToken</code>，这里直接参考 <code>UsernamePasswordAuthenticationToken</code> 源码，直接粘过来，改一改。</p><p><strong>步骤：</strong></p><ol><li><code>principal</code> 原本代表用户名，这里保留，只是代表了手机号码。</li><li><code>credentials</code> 原本代码密码，短信登录用不到，直接删掉。</li><li><code>SmsCodeAuthenticationToken()</code> 两个构造方法一个是构造没有鉴权的，一个是构造有鉴权的。</li><li>剩下的几个方法去除无用属性即可。</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsAuthenticationToken</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAuthenticationToken</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-comment">/** 表示用户的手机号 **/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object principal;    <span class="hljs-comment">/** 构建一个没有鉴权的SmsAuthenticationToken **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmsAuthenticationToken</span><span class="hljs-params">(Object principal)</span></span>&#123;        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">null</span>);        <span class="hljs-keyword">this</span>.principal = principal;        setAuthenticated(<span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-comment">/** 构建一个有鉴权的SmsAuthenticationToken **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmsAuthenticationToken</span><span class="hljs-params">(Collection&lt;? extends GrantedAuthority&gt; authorities, Object principal)</span> </span>&#123;        <span class="hljs-keyword">super</span>(authorities);        <span class="hljs-keyword">this</span>.principal = principal;        <span class="hljs-keyword">super</span>.setAuthenticated(<span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getPrincipal</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.principal;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getCredentials</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthenticated</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isAuthenticated)</span></span>&#123;        <span class="hljs-keyword">if</span>(isAuthenticated)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Cannot set this token to trusted-user constructor which takes a GrantedAuthority list instead"</span>);        &#125;        <span class="hljs-keyword">super</span>.setAuthenticated(<span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eraseCredentials</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.eraseCredentials();    &#125;&#125;</code></pre></div><h3 id="2-2-SmsAuthenticationFilter"><a href="#2-2-SmsAuthenticationFilter" class="headerlink" title="2.2 SmsAuthenticationFilter"></a>2.2 SmsAuthenticationFilter</h3><p>然后编写 <code>SmsAuthenticationFilter</code>，参考 UsernamePasswordAuthenticationFilter 的源码，直接粘过来，改一改。</p><p><strong>步骤：</strong></p><ol><li><p>原本的静态字段有 username 和 password，都干掉，换成我们的手机号字段。</p></li><li><p><code>SmsCodeAuthenticationFilter()</code> 中指定了这个 filter 的拦截 Url，我指定为 post 方式的 <code>/sms/login</code>。</p></li><li><p>剩下来的方法把无效的删删改改就好了。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsAuthenticationFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAuthenticationProcessingFilter</span> </span>&#123;    <span class="hljs-comment">/** form表单中手机号码的字段name **/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SPRING_SECURITY_FORM_MOBILE_KEY = <span class="hljs-string">"mobile"</span>;    <span class="hljs-keyword">private</span> String mobileParameter = SPRING_SECURITY_FORM_MOBILE_KEY;    <span class="hljs-comment">/** 是否仅为post方式 **/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> postOnly = <span class="hljs-keyword">true</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmsAuthenticationFilter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//短信登录请求post方式的/sms/login</span>        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> AntPathRequestMatcher(<span class="hljs-string">"/sms/login"</span>,<span class="hljs-string">"POST"</span>));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException, IOException, ServletException </span>&#123;        <span class="hljs-keyword">if</span>(postOnly &amp;&amp; !request.getMethod().equals(<span class="hljs-string">"POST"</span>))&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">"Authentication method not support:"</span>+request.getMethod());        &#125;        String mobile = obtainMobile(request);                <span class="hljs-keyword">if</span>(mobile == <span class="hljs-keyword">null</span>)&#123;            mobile = <span class="hljs-string">""</span>;        &#125;        mobile = mobile.trim();        SmsAuthenticationToken authRequest = <span class="hljs-keyword">new</span> SmsAuthenticationToken(mobile);        setDetails(request,authRequest);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDetails</span><span class="hljs-params">(HttpServletRequest request, SmsAuthenticationToken authRequest)</span> </span>&#123;        authRequest.setDetails(authenticationDetailsSource.buildDetails(request));    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">obtainMobile</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;        <span class="hljs-keyword">return</span> request.getParameter(mobileParameter);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMobileParameter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> mobileParameter;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMobileParameter</span><span class="hljs-params">(String mobileParameter)</span> </span>&#123;        Assert.hasText(mobileParameter,<span class="hljs-string">"Mobile parameter must not be empty or null"</span>);        <span class="hljs-keyword">this</span>.mobileParameter = mobileParameter;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPostOnly</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> postOnly;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPostOnly</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> postOnly)</span> </span>&#123;        <span class="hljs-keyword">this</span>.postOnly = postOnly;    &#125;&#125;</code></pre></div></li></ol><h3 id="2-3-SmsAuthenticationProvider"><a href="#2-3-SmsAuthenticationProvider" class="headerlink" title="2.3 SmsAuthenticationProvider"></a>2.3 SmsAuthenticationProvider</h3><p>这个方法比较重要，这个方法首先能够在使用短信验证码登录时候被 <code>AuthenticationManager</code> 挑中，其次要在这个类中处理验证逻辑。</p><p><strong>步骤：</strong></p><ol><li><p>实现 AuthenticationProvider 接口，实现 authenticate() 和 supports() 方法。</p></li><li><p><code>supports()</code>方法决定了这个 Provider 要怎么被 AuthenticationManager 挑中，</p><p>我这里通过 <code>return SmsCodeAuthenticationToken.class.isAssignableFrom(authentication)</code>，处理所有 SmsCodeAuthenticationToken 及其子类或子接口。</p></li><li><p><code>authenticate()</code>方法处理验证逻辑。</p><ol><li>首先将 authentication 强转为 <code>SmsCodeAuthenticationToken</code>。</li><li>从中取出登录的 principal，也就是手机号。</li><li>调用自己写的 checkSmsCode() 方法，进行验证码校验，如果不合法，抛出 AuthenticationException 异常。</li><li>如果此时仍然没有异常，通过调用 <code>loadUserByUsername(mobile)</code> 读取出数据库中的用户信息。</li><li>如果仍然能够成功读取，没有异常，这里验证就完成了。</li><li>重新构造鉴权后的 SmsCodeAuthenticationToken，并返回给 SmsCodeAuthenticationFilter 。</li></ol></li><li><p>SmsCodeAuthenticationFilter 的父类在 <code>doFilter()</code> 方法中处理是否有异常，是否成功，根据处理结果跳转到登录成功/失败逻辑。</p></li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsAuthenticationProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationProvider</span> </span>&#123;    <span class="hljs-keyword">private</span> UserDetailsService userDetailsService;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        SmsAuthenticationToken authenticationToken = (SmsAuthenticationToken) authentication;        String mobile = (String) authenticationToken.getPrincipal();        <span class="hljs-comment">//验证码校验</span>        checkSmsCode(mobile);        UserDetails userDetails = userDetailsService.loadUserByUsername(mobile);        <span class="hljs-comment">// 此时鉴权成功后，应当重新 new 一个拥有鉴权的 authenticationResult 返回</span>        SmsAuthenticationToken smsAuthenticationToken = <span class="hljs-keyword">new</span> SmsAuthenticationToken(userDetails.getAuthorities(), userDetails);        smsAuthenticationToken.setDetails(authenticationToken.getDetails());        <span class="hljs-keyword">return</span> smsAuthenticationToken;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkSmsCode</span><span class="hljs-params">(String mobile)</span> </span>&#123;        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();        String inputCode = request.getParameter(<span class="hljs-string">"smsCode"</span>);        Map&lt;String, Object&gt; smsCode = (Map&lt;String, Object&gt;) request.getSession().getAttribute(<span class="hljs-string">"smsCode"</span>);        <span class="hljs-keyword">if</span>(smsCode == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">"未检测到申请验证码"</span>);        &#125;        String applyMobile = (String) smsCode.get(<span class="hljs-string">"mobile"</span>);        <span class="hljs-keyword">int</span> code = (<span class="hljs-keyword">int</span>) smsCode.get(<span class="hljs-string">"code"</span>);        <span class="hljs-keyword">if</span>(!applyMobile.equals(mobile))&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">"申请的手机号与登录的手机号不一致"</span>);        &#125;        <span class="hljs-keyword">if</span>(code != Integer.parseInt(inputCode))&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">"验证码错误"</span>);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; authentication)</span> </span>&#123;        <span class="hljs-comment">//判断Authentication是不是SmsCodeAuthenticationToken的子类或子接口</span>        <span class="hljs-keyword">return</span>  SmsAuthenticationToken<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">isAssignableFrom</span>(<span class="hljs-title">authentication</span>)</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetailsService <span class="hljs-title">getUserDetailsService</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> userDetailsService;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserDetailsService</span><span class="hljs-params">(UserDetailsService userDetailsService)</span> </span>&#123;        <span class="hljs-keyword">this</span>.userDetailsService = userDetailsService;    &#125;&#125;</code></pre></div><h3 id="2-4-成功与失败处理逻辑"><a href="#2-4-成功与失败处理逻辑" class="headerlink" title="2.4 成功与失败处理逻辑"></a>2.4 成功与失败处理逻辑</h3><p>上面最后说到，在 SmsCodeAuthenticationFilter 的父类，会根据验证结果跳转到成功或失败处理逻辑，现在我们就编写下这个的处理。</p><p>这里之前也说过了，直接贴代码了，如果有疑问，请参考<a href="https://www.jitwxs.cn/59f4016e.html" target="_blank" rel="noopener">《SpringBoot集成Spring Security（6）——登录管理》</a>。</p><p><strong>验证成功处理：</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationSuccessHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationSuccessHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Autowired</span>    ObjectMapper objectMapper;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        logger.info(<span class="hljs-string">"登录成功"</span>);        response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);        response.getWriter().write(objectMapper.writeValueAsString(authentication));    &#125;&#125;</code></pre></div><p><strong>验证失败处理</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationFailurehandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationFailureHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Autowired</span>    ObjectMapper objectMapper;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        logger.info(<span class="hljs-string">"登陆失败"</span>);        response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);        response.getWriter().write(objectMapper.writeValueAsString(exception.getMessage()));    &#125;&#125;</code></pre></div><h3 id="2-5-SmsCodeAuthenticationSecurityConfig"><a href="#2-5-SmsCodeAuthenticationSecurityConfig" class="headerlink" title="2.5 SmsCodeAuthenticationSecurityConfig"></a>2.5 SmsCodeAuthenticationSecurityConfig</h3><p>下面我们需要把我们自己写的这么多类添加进 Spring Security 框架中，在以往，我们都是直接往 WebSecurityConfig 中加，但是这样会导致 WebSecurityConfig 内容太多，难以维护。</p><p>因此我们可以为每种登录方式都建议一个专属于它的配置文件，再把这个配置文件加入到 WebSecurityConfig 中，进行解耦。</p><p>因此建立短信验证码登录的配置文件 <code>SmsCodeAuthenticationSecurityConfig</code>:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsCodeAuthenticationSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SecurityConfigurerAdapter</span>&lt;<span class="hljs-title">DefaultSecurityFilterChain</span>, <span class="hljs-title">HttpSecurity</span>&gt; </span>&#123;    <span class="hljs-meta">@Autowired</span>    UserDetailsService userDetailsService;    <span class="hljs-meta">@Autowired</span>    CustomAuthenticationSuccessHandler customAuthenticationSuccessHandler;    <span class="hljs-meta">@Autowired</span>    CustomAuthenticationFailureHandler customAuthenticationFailureHandler;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity builder)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        SmsAuthenticationFilter smsAuthenticationFilter = <span class="hljs-keyword">new</span> SmsAuthenticationFilter();        smsAuthenticationFilter.setAuthenticationManager(builder.getSharedObject(AuthenticationManager<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;        smsAuthenticationFilter.setAuthenticationSuccessHandler(customAuthenticationSuccessHandler);        smsAuthenticationFilter.setAuthenticationFailureHandler(customAuthenticationFailureHandler);                SmsAuthenticationProvider smsAuthenticationProvider = <span class="hljs-keyword">new</span> SmsAuthenticationProvider();        smsAuthenticationProvider.setUserDetailsService(userDetailsService);                builder.authenticationProvider(smsAuthenticationProvider).addFilterAfter(smsAuthenticationFilter, UsernamePasswordAuthenticationFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;&#125;</code></pre></div><p>在这个配置文件中，首先给 SmsCodeAuthenticationFilter 指定了：</p><ol><li>AuthenticationManager：不指定这个上面的流程图就断掉了。</li><li>指定登录成功/失败处理逻辑，方便其父类调用。</li></ol><p>然后指定了 SmsCodeAuthenticationProvider，并指定了 UserDetailsService ，方便在验证处理时候通过 <code>loadUserByUsername()</code> 读取出数据库中的用户信息。</p><p>最后将 filter 和 provider 都加入 HttpSecurity 配置中。</p><p><strong>另外说两句：</strong></p><blockquote><p>开头就说过了，为了方便介绍，写最少的代码，因此这是一个假的短信登录。如果你看这里的 UserDetailsService 的代码话，你会发现它是从数据库中根据 name 获取信息的，我其实就是把用户名来当手机号用。</p><p>因此，如果你想根据数据库中其他字段，例如 phone 来得到用户信息，可以再写一个叫做 SmsUserDetailsService，在这里注入到 provider 中。</p></blockquote><h3 id="2-6-WebSecurityConfig"><a href="#2-6-WebSecurityConfig" class="headerlink" title="2.6 WebSecurityConfig"></a>2.6 WebSecurityConfig</h3><p>下面我们就需要把自己写的 SmsCodeAuthenticationSecurityConfig 加入到 WebSecurityConfig 中了。</p><p>首先将 SmsCodeAuthenticationSecurityConfig 注入进来，然后通过 <code>http.apply(xxx)</code> 添加进去。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="hljs-keyword">true</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SmsCodeAuthenticationSecurityConfig smsCodeAuthenticationSecurityConfig;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.apply(smsCodeAuthenticationSecurityConfig)            .and()            .authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span>                .antMatchers(<span class="hljs-string">"/sms/**"</span>).permitAll()                .anyRequest().authenticated()                .and()                <span class="hljs-comment">// 设置登陆页</span>                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                <span class="hljs-comment">// 设置登陆成功页</span>                .defaultSuccessUrl(<span class="hljs-string">"/"</span>).permitAll()                .and()                .logout().permitAll();        <span class="hljs-comment">// 关闭CSRF跨域</span>        http.csrf().disable();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 设置拦截忽略文件夹，可以对静态资源放行</span>        web.ignoring().antMatchers(<span class="hljs-string">"/css/**"</span>, <span class="hljs-string">"/js/**"</span>);    &#125;&#125;</code></pre></div><h3 id="2-7-接口与页面"><a href="#2-7-接口与页面" class="headerlink" title="2.7 接口与页面"></a>2.7 接口与页面</h3><p>然后在 controller 中写一个读取验证码的接口，注意这个接口在 <code>WebSecurityConfig</code> 中要放行：</p><div class="hljs"><pre><code class="hljs java">   <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/sms/code"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sms</span><span class="hljs-params">(String mobile, HttpSession session)</span></span>&#123;        <span class="hljs-keyword">int</span> code = (<span class="hljs-keyword">int</span>)Math.ceil(Math.random()*<span class="hljs-number">9000</span>+<span class="hljs-number">1000</span>);        Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">16</span>);        map.put(<span class="hljs-string">"mobile"</span>,mobile);        map.put(<span class="hljs-string">"code"</span>,code);                session.setAttribute(<span class="hljs-string">"smsCode"</span>,map);        logger.info(<span class="hljs-string">"&#123;&#125;:为&#123;&#125;设置短信验证码：&#123;&#125;"</span>,session.getId(),mobile,code);    &#125;&#125;</code></pre></div><p>然后修改 login.html 页面，添加短信登录的内容：</p><blockquote><p>注意这里的登录 Url <code>/sms/login</code> 是配置在 SmsAuthenticationFilter 中的 Url。</p></blockquote><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>欢迎来到登录页面<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>立即登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/sms/login"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        手机号：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mobile"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mobile"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jitwxs"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        验证码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"smsCode"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"javascript:;"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"sendSms()"</span>&gt;</span>获取验证码<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>立即登陆<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendSms</span><span class="hljs-params">()</span> </span>&#123;</span><span class="javascript">        <span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">'/sms/code?mobile='</span> + <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"mobile"</span>).value;</span>    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="三、测试代码"><a href="#三、测试代码" class="headerlink" title="三、测试代码"></a>三、测试代码</h2><p>因此只是测试，所以页面懒得弄了，当你输入手机号（实际上就是用户名），点击获取验证码，页面会跳转出去，然后自己再按一下浏览器的后退键退回来。</p><p>在控制台就会打印当前用户的 sessionId，以及为哪一个手机号所申请的验证码。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(7)--认证流程</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-7-%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-7-%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>在前面的六章中，介绍了 Spring Security 的基础使用，在继续深入向下的学习前，有必要理解清楚 Spring Security 的认证流程，这样才能理解为什么要这样写代码，也方便后续的扩展。</p><h2 id="一、认证流程"><a href="#一、认证流程" class="headerlink" title="一、认证流程"></a>一、认证流程</h2><p><img src="https://www.jitwxs.cn/images/posts/20181202095539982.png" srcset="/img/loading.gif" alt="Spring Security 认证流程（部分）"></p><blockquote><p>上图是 Spring Security 认证流程的一部分，下面的讲解以上图为依据。</p></blockquote><p><strong>（1）</strong> 用户发起表单登录请求后，首先进入 <code>UsernamePasswordAuthenticationFilter</code>：</p><p><img src="https://www.jitwxs.cn/images/posts/2018120210045295.png" srcset="/img/loading.gif" alt="UsernamePasswordAuthenticationFilter"></p><p>​                                                                        UsernamePasswordAuthenticationFilter</p><p>在 UsernamePasswordAuthenticationFilter 中根据用户输入的用户名、密码构建了 <code>UsernamePasswordAuthenticationToken</code>，并将其交给 AuthenticationManager 来进行认证处理。</p><p>AuthenticationManager 本身不包含认证逻辑，其核心是用来管理所有的 <code>AuthenticationProvider</code>，通过交由合适的 AuthenticationProvider 来实现认证。</p><p><strong>（2）</strong> 下面跳转到了 <code>ProviderManager</code> ，该类是 AuthenticationManager 的实现类：</p><p><img src="https://www.jitwxs.cn/images/posts/20181202102203137.png" srcset="/img/loading.gif" alt="ProviderManager"></p><p>​                                                                                        ProviderManager</p><p>我们知道不同的登录逻辑它的认证方式是不一样的，比如我们表单登录需要认证用户名和密码，但是当我们使用三方登录时就不需要验证密码。</p><p>Spring Security 支持多种认证逻辑，<strong>每一种认证逻辑的认证方式其实就是一种 AuthenticationProvider</strong>。通过 <code>getProviders()</code> 方法就能获取所有的 AuthenticationProvider，通过 <code>provider.supports()</code> 来判断 provider 是否支持当前的认证逻辑。</p><p>当选择好一个合适的 AuthenticationProvider 后，通过 <code>provider.authenticate(authentication)</code> 来让 AuthenticationProvider 进行认证。</p><p><strong>（3）</strong> 传统表单登录的 AuthenticationProvider 主要是由 <code>AbstractUserDetailsAuthenticationProvider</code> 来进行处理的，我们来看下它的 <code>authenticate()</code>方法。</p><p>首先通过 <code>retrieveUser()</code> 方法读取到数据库中的用户信息：</p><div class="hljs"><pre><code class="hljs java">user = retrieveUser(username,(UsernamePasswordAuthenticationToken) authentication);</code></pre></div><p>retrieveUser() 的具体实现在 <code>DaoAuthenticationProvider</code> 中，代码如下：</p><p><img src="https://www.jitwxs.cn/images/posts/20181202103804350.png" srcset="/img/loading.gif" alt="DaoAuthenticationProvider"></p><p>​                                                                                DaoAuthenticationProvider</p><p><img src="https://www.jitwxs.cn/images/posts/20181202105844461.png" srcset="/img/loading.gif" alt="AbstractUserDetailsAuthenticationProvider"></p><p>​                                                                                AbstractUserDetailsAuthenticationProvider</p><p>在上图中，我们可以看到认证校验分为 <strong>前校验</strong>、<strong>附加校验</strong>和<strong>后校验</strong>，如果任何一个校验出错，就会抛出相应的异常。所有校验都通过后，调用 <code>createSuccessAuthentication()</code> 返回认证信息。</p><p><img src="https://www.jitwxs.cn/images/posts/20181202111353423.png" srcset="/img/loading.gif" alt="createSuccessAuthentication()"></p><p>​                                                                                        createSuccessAuthentication()</p><p>在<code>createSuccessAuthentication</code>方法中，我们发现它重新 new 了一个 <code>UsernamePasswordAuthenticationToken</code>，因为到这里认证已经通过了，所以将 authorities 注入进去，并设置 authenticated 为 true，即已经认证。</p><p>（4）至此认证信息就被传递回 UsernamePasswordAuthenticationFilter 中，在 UsernamePasswordAuthenticationFilter 的父类 <code>AbstractAuthenticationProcessingFilter</code> 的 <code>doFilter()</code> 中，会根据认证的成功或者失败调用相应的 handler：</p><p><img src="https://www.jitwxs.cn/images/posts/20181202113101881.png" srcset="/img/loading.gif" alt="AbstractAuthenticationProcessingFilter"></p><p>​                                                                            AbstractAuthenticationProcessingFilter</p><p>这里调用的 handler 实际就是在<a href="https://www.jitwxs.cn/59f4016e.html" target="_blank" rel="noopener">《SpringBoot集成Spring Security（6）——登录管理》</a>中我们在配置文件中配置的 <code>successHandler()</code> 和 <code>failureHandler()</code>。</p><h2 id="二、多个请求共享认证信息"><a href="#二、多个请求共享认证信息" class="headerlink" title="二、多个请求共享认证信息"></a>二、多个请求共享认证信息</h2><p>Spring Security 通过 <code>Session</code> 来保存用户的认证信息，那么 Spring Security 到底是在什么时候将认证信息放入 Session，又在什么时候将认证信息从 Session 中取出来的呢？</p><p>下面将 Spring Security 的认证流程补充完整，如下图：</p><p><img src="https://www.jitwxs.cn/images/posts/20180630104958316.png" srcset="/img/loading.gif" alt="Spring Security 认证流程"></p><p>​                                                                                                    Spring Security 认证流程</p><p>在上一节认证成功的 <code>successfulAuthentication()</code>方法中，有一行语句：</p><div class="hljs"><pre><code class="hljs java">SecurityContextHolder.getContext().setAuthentication(authResult);</code></pre></div><p>其实就是在这里将认证信息放入 Session 中。</p><p>查看 <code>SecurityContext</code> 源码，发现内部就是对 Authentication 的封装，提供了 equals、hashcode、toString等方法，而<code>SecurityContextHolder</code> 可以理解为线程中的 <code>ThreadLocal</code>。</p><p>我们知道一个 HTTP 请求和响应都是在一个线程中执行，因此在整个处理的任何一个方法中都可以通过 <code>SecurityContextHolder.getContext()</code>来取得存放进去的认证信息。</p><p>从 Session 中对认证信息的处理由 <code>SecurityContextPersistenceFilter</code> 来处理，它位于 Spring Security 过滤器链的最前面，它的主要作用是：</p><ul><li>当请求时，检查 Session 中是否存在 SecurityContext，如果有将其放入到线程中</li><li>当响应时，检查线程中是否存在 SecurityContext，如果有将其放入到 Session 中</li></ul><p><img src="https://www.jitwxs.cn/images/posts/20180630114216422.png" srcset="/img/loading.gif" alt="img"></p><h2 id="三、获取用户认证信息"><a href="#三、获取用户认证信息" class="headerlink" title="三、获取用户认证信息"></a>三、获取用户认证信息</h2><p>通过调用 <code>SecurityContextHolder.getContext().getAuthentication()</code> 就能够取得认证信息：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/me"</span>)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">me</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> SecurityContextHolder.getContext().getAuthentication();&#125;</code></pre></div><p><img src="https://www.jitwxs.cn/images/posts/20181202140404470.png" srcset="/img/loading.gif" alt="img"></p><p>上面的写法有点啰嗦，我们可以简写成下面这种， Spring MVC 会自动帮我们从 Spring Security 中注入：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/me"</span>)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">me</span><span class="hljs-params">(Authentication authentication)</span> </span>&#123;    <span class="hljs-keyword">return</span> authentication;&#125;</code></pre></div><p>如果你仅想获取 <code>UserDetails</code> 对象，也是可以的，写法如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/me"</span>)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">me</span><span class="hljs-params">(@AuthenticationPrincipal UserDetails userDetails)</span> </span>&#123;    <span class="hljs-keyword">return</span> userDetails;&#125;</code></pre></div><p><img src="https://www.jitwxs.cn/images/posts/20181202140702514.png" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(6)--登录管理</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-6-%E7%99%BB%E5%BD%95%E7%AE%A1%E7%90%86/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-6-%E7%99%BB%E5%BD%95%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="一、自定义认证成功、失败处理"><a href="#一、自定义认证成功、失败处理" class="headerlink" title="一、自定义认证成功、失败处理"></a>一、自定义认证成功、失败处理</h2><p>有些时候我们想要在认证成功后做一些业务处理，例如添加积分；有些时候我们想要在认证失败后也做一些业务处理，例如记录日志。</p><p>在之前的文章中，关于认证成功、失败后的处理都是如下配置的：</p><div class="hljs"><pre><code class="hljs java">http.authorizeRequests()    <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span><span class="hljs-comment">//    .antMatchers().permitAll()</span>    .anyRequest().authenticated().and()    <span class="hljs-comment">// 设置登录页</span>    .formLogin().loginPage(<span class="hljs-string">"/login"</span>)    .failureUrl(<span class="hljs-string">"/login/error"</span>)    .defaultSuccessUrl(<span class="hljs-string">"/"</span>)    .permitAll()    ...;</code></pre></div><p>即 <code>failureUrl()</code> 指定认证失败后Url，<code>defaultSuccessUrl()</code> 指定认证成功后Url。我们可以通过设置 <code>successHandler()</code> 和 <code>failureHandler()</code> 来实现自定义认证成功、失败处理。</p><blockquote><p>PS：当我们设置了这两个后，需要去除 <code>failureUrl()</code> 和 <code>defaultSuccessUrl()</code> 的设置，否则无法生效。这两套配置同时只能存在一套。</p></blockquote><h3 id="1-1-CustomAuthenticationSuccessHandler"><a href="#1-1-CustomAuthenticationSuccessHandler" class="headerlink" title="1.1 CustomAuthenticationSuccessHandler"></a>1.1 CustomAuthenticationSuccessHandler</h3><p>自定义 CustomAuthenticationSuccessHandler 类来实现 <code>AuthenticationSuccessHandler</code> 接口，用来处理认证成功后逻辑：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationSuccessHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationSuccessHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,                 Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        logger.info(<span class="hljs-string">"登录成功，&#123;&#125;"</span>,authentication);                response.sendRedirect(<span class="hljs-string">"/"</span>);    &#125;&#125;</code></pre></div><p><code>onAuthenticationSuccess()</code> 方法的第三个参数 <code>Authentication</code> 为认证后该用户的认证信息，这里打印日志后，重定向到了首页。</p><h3 id="1-2-CustomAuthenticationFailureHandler"><a href="#1-2-CustomAuthenticationFailureHandler" class="headerlink" title="1.2 CustomAuthenticationFailureHandler"></a>1.2 CustomAuthenticationFailureHandler</h3><p>自定义 CustomAuthenticationFailureHandler 类来实现 <code>AuthenticationFailureHandler</code> 接口，用来处理认证失败后逻辑：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationFailureHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationFailureHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Autowired</span>    ObjectMapper objectMapper;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        logger.info(<span class="hljs-string">"登录失败"</span>);        response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());        response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);        response.getWriter().write(objectMapper.writeValueAsString(exception.getMessage()));    &#125;&#125;</code></pre></div><p><code>onAuthenticationFailure()</code>方法的第三个参数 <code>exception</code> 为认证失败所产生的异常，这里也是简单的返回到前台。</p><h3 id="1-3-修改-WebSecurityConfig"><a href="#1-3-修改-WebSecurityConfig" class="headerlink" title="1.3 修改 WebSecurityConfig"></a>1.3 修改 WebSecurityConfig</h3><div class="hljs"><pre><code class="hljs java">    <span class="hljs-meta">@Autowired</span>    CustomAuthenticationSuccessHandler authenticationSuccessHandler;    <span class="hljs-meta">@Autowired</span>    CustomAuthenticationFailureHandler authenticationFailureHandler; <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span><span class="hljs-comment">//                .antMatchers().permitAll()</span>                .anyRequest().authenticated()                .and()                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                .successHandler(authenticationSuccessHandler)                .failureHandler(authenticationFailureHandler)            .permitAll() <span class="hljs-comment">//很关键</span><span class="hljs-comment">//                .defaultSuccessUrl("/").permitAll()</span>                .and()                .logout()                .logoutSuccessUrl(<span class="hljs-string">"/logout"</span>)                .permitAll();        <span class="hljs-comment">//关闭CRSF跨域</span>        http.csrf().disable();    &#125;</code></pre></div><ol><li>首先将 <code>customAuthenticationSuccessHandler</code> 和 <code>customAuthenticationFailureHandler</code>注入进来</li><li>配置 <code>successHandler()</code> 和 <code>failureHandler()</code></li><li>注释 <code>failureUrl()</code> 和 <code>defaultSuccessUrl()</code></li></ol><h3 id="1-4-运行程序"><a href="#1-4-运行程序" class="headerlink" title="1.4 运行程序"></a>1.4 运行程序</h3><p>运行程序，当我们成功登陆后，发现日志信息被打印出来，页面被重定向到了首页：</p><p><img src="https://www.jitwxs.cn/images/posts/20190110174809434.png" srcset="/img/loading.gif" alt="img"></p><p>当我们认证失败后，发现日志中“登陆失败”被打印出来，页面展示了认证失败的异常消息：</p><p><img src="https://www.jitwxs.cn/images/posts/20190110174827988.png" srcset="/img/loading.gif" alt="img"></p><h2 id="二、Session-超时"><a href="#二、Session-超时" class="headerlink" title="二、Session 超时"></a>二、Session 超时</h2><p>当用户登录后，我们可以设置 session 的超时时间，当达到超时时间后，自动将用户退出登录。</p><p>Session 超时的配置是 SpringBoot 原生支持的，我们只需要在 <code>application.properties</code> 配置文件中配置：</p><div class="hljs"><pre><code class="hljs java">server.servlet.session.timeout=<span class="hljs-number">60</span>s</code></pre></div><blockquote><p>Tip：<br>从用户最后一次操作开始计算过期时间。<br>过期时间最小值为 60 秒，如果你设置的值小于 60 秒，也会被更改为 60 秒。</p></blockquote><p>我们可以在 Spring Security 中配置处理逻辑，在 session 过期退出时调用。修改 WebSecurityConfig 的 <code>configure()</code> 方法，添加：</p><div class="hljs"><pre><code class="hljs java">.sessionManagement()    <span class="hljs-comment">// 以下二选一</span>    <span class="hljs-comment">//.invalidSessionStrategy()</span>    <span class="hljs-comment">//.invalidSessionUrl();</span></code></pre></div><p>Spring Security 提供了两种处理配置，一个是 <code>invalidSessionStrategy()</code>，另外一个是 <code>invalidSessionUrl()</code>。</p><p>这两个的区别就是一个是前者是在一个类中进行处理，后者是直接跳转到一个 Url。简单起见，我就直接用 <code>invalidSessionUrl()</code>了，跳转到 <code>/login/invalid</code>，我们需要把该 Url 设置为免授权访问， 配置如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http.authorizeRequests()            <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span>            .antMatchers(<span class="hljs-string">"/login/invalid"</span>).permitAll()            .anyRequest().authenticated().and()            ...            .sessionManagement()                .invalidSessionUrl(<span class="hljs-string">"/login/invalid"</span>);    <span class="hljs-comment">// 关闭CSRF跨域</span>    http.csrf().disable();&#125;</code></pre></div><p>在 controller 中写一个接口进行处理：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/login/invalid"</span>)<span class="hljs-meta">@ResponseStatus</span>(HttpStatus.UNAUTHORIZED)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">invalid</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"Session 已过期，请重新登录"</span>;&#125;</code></pre></div><p>运行程序，登录成功后等待一分钟（或者重启服务器），刷新页面：</p><p><img src="https://www.jitwxs.cn/images/posts/20190110171026663.png" srcset="/img/loading.gif" alt="session 过期"></p><h2 id="三、限制最大登录数"><a href="#三、限制最大登录数" class="headerlink" title="三、限制最大登录数"></a>三、限制最大登录数</h2><p>接下来实现限制最大登录数，原理就是限制单个用户能够存在的最大 session 数。</p><p>在上一节的基础上，修改 <code>configure()</code> 为：</p><div class="hljs"><pre><code class="hljs java">.sessionManagement()    .invalidSessionUrl(<span class="hljs-string">"/login/invalid"</span>)    .maximumSessions(<span class="hljs-number">1</span>)    <span class="hljs-comment">// 当达到最大值时，是否保留已经登录的用户</span>    .maxSessionsPreventsLogin(<span class="hljs-keyword">false</span>)    <span class="hljs-comment">// 当达到最大值时，旧用户被踢出后的操作</span>    .expiredSessionStrategy(<span class="hljs-keyword">new</span> CustomExpiredSessionStrategy())</code></pre></div><p>增加了下面三行代码，其中：</p><ul><li><code>maximumSessions(int)</code>：指定最大登录数</li><li><code>maxSessionsPreventsLogin(boolean)</code>：是否保留已经登录的用户；为true，新用户无法登录；为 false，旧用户被踢出</li><li><code>expiredSessionStrategy(SessionInformationExpiredStrategy)</code>：旧用户被踢出后处理方法</li></ul><blockquote><p><code>maxSessionsPreventsLogin()</code>可能不太好理解，这里我们先设为 false，效果和 QQ 登录是一样的，登录后之前登录的账户被踢出。</p></blockquote><p>编写 CustomExpiredSessionStrategy 类，来处理旧用户登录失败的逻辑：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomExpiredSessionStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SessionInformationExpiredStrategy</span> </span>&#123;    <span class="hljs-keyword">private</span> ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();<span class="hljs-comment">//    private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onExpiredSessionDetected</span><span class="hljs-params">(SessionInformationExpiredEvent event)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        Map&lt;String,Object&gt;map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">16</span>);        map.put(<span class="hljs-string">"code"</span>,<span class="hljs-number">0</span>);        map.put(<span class="hljs-string">"msg"</span>,<span class="hljs-string">"已经另一台机器登录，您被迫下线"</span>);        <span class="hljs-comment">//Map -&gt; json</span>        String json = objectMapper.writeValueAsString(map);        event.getResponse().setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);        event.getResponse().getWriter().write(json);                <span class="hljs-comment">//如果是跳转html页面，url代表跳转的地址</span><span class="hljs-comment">//        redirectStrategy.sendRedirect(event.getRequest(),event.getResponse(),"url");</span>    &#125;&#125;</code></pre></div><p>在 <code>onExpiredSessionDetected()</code> 方法中，处理相关逻辑，我这里只是简单的返回一句话。</p><p>执行程序，打开两个浏览器，登录同一个账户。因为我设置了 <code>maximumSessions(1)</code>，也就是单个用户只能存在一个 session，因此当你刷新先登录的那个浏览器时，被提示踢出了。</p><p><img src="https://www.jitwxs.cn/images/posts/2019011017515758.png" srcset="/img/loading.gif" alt="maxSessionsPreventsLogin 为 false"></p><p>下面我们来测试下 <code>maxSessionsPreventsLogin(true)</code> 时的情况，我们发现第一个浏览器登录后，第二个浏览器无法登录：</p><p><img src="https://www.jitwxs.cn/images/posts/20190110175325653.png" srcset="/img/loading.gif" alt="maxSessionsPreventsLogin 为 true"></p><h2 id="四、踢出用户"><a href="#四、踢出用户" class="headerlink" title="四、踢出用户"></a>四、踢出用户</h2><p>下面来看下如何主动踢出一个用户。</p><p>首先需要在容器中注入名为 <code>SessionRegistry</code> 的 Bean，这里我就简单的写在 WebSecurityConfig 中：</p><p>修改 WebSecurityConfig 的 configure() 方法，在最后添加一行 <code>.sessionRegistry()</code>：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    ...    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SessionRegistry <span class="hljs-title">sessionRegistry</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SessionRegistryImpl();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span>                .antMatchers(<span class="hljs-string">"/login/invalid"</span>).permitAll()                .anyRequest().authenticated().and()                <span class="hljs-comment">// 设置登录页</span>                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                .successHandler(customAuthenticationSuccessHandler)                .failureHandler(customAuthenticationFailureHandler)                .permitAll().and()                .logout().and()                .sessionManagement()                    .invalidSessionUrl(<span class="hljs-string">"/login/invalid"</span>)                    .maximumSessions(<span class="hljs-number">1</span>)                    <span class="hljs-comment">// 当达到最大值时，是否保留已经登录的用户</span>                    .maxSessionsPreventsLogin(<span class="hljs-keyword">false</span>)                    <span class="hljs-comment">// 当达到最大值时，旧用户被踢出后的操作</span>                    .expiredSessionStrategy(<span class="hljs-keyword">new</span> CustomExpiredSessionStrategy())                    .sessionRegistry(sessionRegistry());        <span class="hljs-comment">// 关闭CSRF跨域</span>        http.csrf().disable();    &#125;&#125;</code></pre></div><p>编写一个接口用于测试踢出用户：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SessionRegistry sessionRegistry;    ...    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/kick"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">removeUserSessionByUsername</span><span class="hljs-params">(@RequestParam String username)</span> </span>&#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 获取session中所有的用户信息</span>        List&lt;Object&gt; users = sessionRegistry.getAllPrincipals();        <span class="hljs-keyword">for</span> (Object principal : users) &#123;            <span class="hljs-keyword">if</span> (principal <span class="hljs-keyword">instanceof</span> User) &#123;                String principalName = ((User)principal).getUsername();                <span class="hljs-keyword">if</span> (principalName.equals(username)) &#123;                    <span class="hljs-comment">// 参数二：是否包含过期的Session</span>                    List&lt;SessionInformation&gt; sessionsInfo = sessionRegistry.getAllSessions(principal, <span class="hljs-keyword">false</span>);                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != sessionsInfo &amp;&amp; sessionsInfo.size() &gt; <span class="hljs-number">0</span>) &#123;                        <span class="hljs-keyword">for</span> (SessionInformation sessionInformation : sessionsInfo) &#123;                            sessionInformation.expireNow();                            count++;                        &#125;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">"操作成功，清理session共"</span> + count + <span class="hljs-string">"个"</span>;    &#125;&#125;</code></pre></div><ol><li><code>sessionRegistry.getAllPrincipals();</code> 获取所有 principal 信息</li><li>通过 <code>principal.getUsername</code>是否等于输入值，获取到指定用户的 principal</li><li><code>sessionRegistry.getAllSessions(principal, false)</code>获取该 principal 上的所有 session</li><li>通过 <code>sessionInformation.expireNow()</code> 使得 session 过期</li></ol><p>运行程序，分别使用 admin 和 jitwxs 账户登录，admin 访问 <code>/kick?username=jitwxs</code> 来踢出用户 jitwxs，jitwxs 刷新页面，发现被踢出。</p><p><img src="D:%5C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%5CBlog%5CMyBlog%5Csource_posts%5Cimage-20200524210531605.png" srcset="/img/loading.gif" alt="image-20200524210531605"></p><h2 id="五、退出登录"><a href="#五、退出登录" class="headerlink" title="五、退出登录"></a>五、退出登录</h2><p>补充一下退出登录的内容，在之前，我们直接在 WebSecurityConfig 的 configure() 方法中，配置了：</p><div class="hljs"><pre><code class="hljs java">http.logout();</code></pre></div><p>这就是 Spring Security 的默认退出配置，Spring Security 在退出时候做了这样几件事：</p><ol><li>使当前的 session 失效</li><li>清除与当前用户有关的 remember-me 记录</li><li>清空当前的 SecurityContext</li><li>重定向到登录页</li></ol><p>Spring Security 默认的退出 Url 是 <code>/logout</code>，我们可以修改默认的退出 Url，例如修改为 <code>/signout</code>：</p><div class="hljs"><pre><code class="hljs java">http.logout()    .logoutUrl(<span class="hljs-string">"/signout"</span>);</code></pre></div><p>我们也可以配置当退出时清除浏览器的 Cookie，例如清除 名为 JSESSIONID 的 cookie：</p><div class="hljs"><pre><code class="hljs java">http.logout()    .logoutUrl(<span class="hljs-string">"/signout"</span>)    .deleteCookies(<span class="hljs-string">"JSESSIONID"</span>);</code></pre></div><p>我们也可以配置退出后处理的逻辑，方便做一些别的操作：</p><div class="hljs"><pre><code class="hljs java">http.logout()    .logoutUrl(<span class="hljs-string">"/signout"</span>)    .deleteCookies(<span class="hljs-string">"JSESSIONID"</span>)    .logoutSuccessHandler(logoutSuccessHandler);</code></pre></div><p>创建类 <code>DefaultLogoutSuccessHandler</code>：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomLogoutSuccessHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LogoutSuccessHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLogoutSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        String username = ((User) authentication.getPrincipal()).getUsername();        logger.info(<span class="hljs-string">"退出成功，用户名：&#123;&#125;"</span>,username);        <span class="hljs-comment">//重定向到登录页</span>        response.sendRedirect(<span class="hljs-string">"/login"</span>);    &#125;&#125;</code></pre></div><p>最后把它注入到 WebSecurityConfig 即可：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> CustomLogoutSuccessHandler logoutSuccessHandler;</code></pre></div><p>效果：</p><p><img src="D:%5C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%5CBlog%5CMyBlog%5Csource_posts%5Cimage-20200524214054848.png" srcset="/img/loading.gif" alt="image-20200524214054848"></p><h2 id="六、Session-共享"><a href="#六、Session-共享" class="headerlink" title="六、Session 共享"></a>六、Session 共享</h2><p>在最后补充下关于 Session 共享的知识点，一般情况下，一个程序为了保证稳定至少要部署两个，构成集群。那么就牵扯到了 Session 共享的问题，不然用户在 8080 登录成功后，后续访问了 8060 服务器，结果又提示没有登录。</p><p>这里就简单实现下 Session 共享，采用 Redis 来存储。</p><h3 id="6-1-配置-Redis"><a href="#6-1-配置-Redis" class="headerlink" title="6.1 配置 Redis"></a>6.1 配置 Redis</h3><p>为了方便起见，我直接使用 Docker 快速部署，如果你需要传统方式安装，可以参考文章<a href="https://www.jitwxs.cn/e331e26a.html" target="_blank" rel="noopener">《Redis 初探（1）——Redis 的安装》</a>。</p><div class="hljs"><pre><code class="hljs applescript">docker pull redisdocker <span class="hljs-built_in">run</span> <span class="hljs-comment">--name myredis -p 6379:6379 -d redis</span>docker exec -<span class="hljs-keyword">it</span> myredis redis-cli</code></pre></div><p>这里因为我ubutun连不上网，所以用的是redis客户端</p><h3 id="6-2-配置-Session-共享"><a href="#6-2-配置-Session-共享" class="headerlink" title="6.2 配置 Session 共享"></a>6.2 配置 Session 共享</h3><p>首先需要导入依赖，因为我们采用 Redis 方式实现，因此导入：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--redis相关依赖--&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>在 <code>application.xml</code> 中新增配置指定 redis 地址以及 session 的存储方式：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-comment">#redis相关配置</span><span class="hljs-string">spring.redis.host=localhost</span><span class="hljs-string">spring.redis.port=6379</span><span class="hljs-string">spring.session.store-type=redis</span></code></pre></div><p>然后为主类添加 <code>@EnableRedisHttpSession</code> 注解。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@EnableRedisHttpSession</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringSecuriity06Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(SpringSecuriity06Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><h3 id="6-3-运行程序"><a href="#6-3-运行程序" class="headerlink" title="6.3 运行程序"></a>6.3 运行程序</h3><p>这样就完成了基于 Redis 的 Session 共享，下面来测试下。首先修改 IDEA 配置来允许项目在多端口运行，勾选 <code>Allow running in parallel</code>(2018.2版本好像没有该选项，应该是取消勾选<code>Single instance only</code>)：</p><p><img src="D:%5C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%5CBlog%5CMyBlog%5Csource_posts%5Cimage-20200524220218834.png" srcset="/img/loading.gif" alt="image-20200524220218834"></p><p>运行程序，然后修改配置文件，将 <code>server.port</code> 更改为 8060，再次运行。这样项目就会分别在默认的 8080 端口和 8060 端口运行。</p><p><img src="https://www.jitwxs.cn/images/posts/20190118113440171.png" srcset="/img/loading.gif" alt="img"></p><p>先访问 <code>localhost:8080</code>，登录成功后，再访问 <code>localhost:8060</code>，发现无需登录。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(5)--权限控制</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-5-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-5-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>在第一篇中，我们说过，<strong>用户&lt;–&gt;角色&lt;–&gt;权限</strong>三层中，暂时不考虑权限，在这一篇，是时候把它完成了。</p><p>为了方便演示，这里的权限只是对角色赋予权限，也就是说同一个角色的用户，权限是一样的。当然了，你也可以精细化到为每一个用户设置权限，但是这不在本篇的探讨范围，有兴趣可以自己实验，原理都是一样的。</p><h2 id="一、数据准备"><a href="#一、数据准备" class="headerlink" title="一、数据准备"></a>一、数据准备</h2><h3 id="1-1-创建-sys-permission-表"><a href="#1-1-创建-sys-permission-表" class="headerlink" title="1.1 创建 sys_permission 表"></a>1.1 创建 sys_permission 表</h3><p>让我们先创建一张权限表，名为 <code>sys_permission</code>：</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`sys_permission`</span>(<span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,<span class="hljs-string">`url`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,<span class="hljs-string">`role_id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,<span class="hljs-string">`permission`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,PRIMARY <span class="hljs-keyword">KEY</span>(<span class="hljs-string">`id`</span>),<span class="hljs-keyword">KEY</span> <span class="hljs-string">`fk_roleId`</span>(<span class="hljs-string">`role_id`</span>),<span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-string">`fk_roleId`</span> <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span>(<span class="hljs-string">`role_id`</span>) <span class="hljs-keyword">REFERENCES</span> <span class="hljs-string">`sys_role`</span>(<span class="hljs-string">`id`</span>) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">CASCADE</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">CASCADE</span>)<span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">5</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4;</code></pre></div><p>内容就是两条数据，通过 <code>url</code> + <code>role_id</code> + <code>permission</code> 唯一标识了一个角色访问某一url时的权限，其中权限暂定为c、r、u、d，代表了增、删、改、查。</p><p><img src="https://www.jitwxs.cn/images/posts/20180515185020939.png" srcset="/img/loading.gif" alt="sys_permission 表数据"></p><h3 id="1-2-创建-Model、Mapper、Service"><a href="#1-2-创建-Model、Mapper、Service" class="headerlink" title="1.2 创建 Model、Mapper、Service"></a>1.2 创建 Model、Mapper、Service</h3><p>（1）Model</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysPermission</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String url;    <span class="hljs-keyword">private</span> Integer roleId;    <span class="hljs-keyword">private</span> String permission;    <span class="hljs-keyword">private</span> List permissions;    <span class="hljs-comment">//省略getter，setter</span>&#125;</code></pre></div><p>这里需要注意的时相比于数据库，多了一个 <code>permissions</code> 属性，该字段将 <code>permission</code> 按逗号分割为了 list。</p><p>（2）mapper</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysPermissionMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_permission WHERE role_id=#&#123;roleId&#125;"</span>)    List&lt;SysPermission&gt;listByRoleId(Integer roleId);&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysRoleMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_role WHERE id = #&#123;id&#125;"</span>)    <span class="hljs-function">SysRole <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_role WHERE name = #&#123;name&#125;"</span>)    <span class="hljs-function">SysRole <span class="hljs-title">selectByName</span><span class="hljs-params">(String name)</span></span>;&#125;</code></pre></div><p>（3）Service</p><p>SysPermissionService 中有一个方法，根据 roleId 获取所有的 <code>SysPermission</code>。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysPermissionService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysPermissionMapper permissionMapper;        <span class="hljs-comment">/**获取指定角色所有权限**/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;SysPermission&gt; <span class="hljs-title">listByRoleId</span><span class="hljs-params">(Integer roleId)</span></span>&#123;        <span class="hljs-keyword">return</span> permissionMapper.listByRoleId(roleId);    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysRoleService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysRoleMapper sysRoleMapper;        <span class="hljs-function"><span class="hljs-keyword">public</span> SysRole <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>&#123;        <span class="hljs-keyword">return</span> sysRoleMapper.selectById(id);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> SysRole <span class="hljs-title">selectByName</span><span class="hljs-params">(String name)</span></span>&#123;        <span class="hljs-keyword">return</span> sysRoleMapper.selectByName(name);    &#125;&#125;</code></pre></div><h3 id="1-3-修改接口"><a href="#1-3-修改接口" class="headerlink" title="1.3 修改接口"></a>1.3 修改接口</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;    <span class="hljs-comment">//...</span>    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/admin"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasPermission('/admin','r')"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">printAdminR</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"如果你看见这句话，说明你访问/admin路径具有r权限"</span>;    &#125;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/admin/c"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasPermission('/admin','c')"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">printAdminC</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"如果你看见这句话，说明你访问/admin路径具有c权限"</span>;    &#125;&#125;</code></pre></div><p>让我们修改下我们要访问的接口，<code>@PreAuthorize(&quot;hasPermission(&#39;/admin&#39;,&#39;r&#39;)&quot;)</code> 是关键，参数1指明了<strong>访问该接口需要的url</strong>，参数2指明了<strong>访问该接口需要的权限</strong>。</p><h2 id="二、PermissionEvaluator"><a href="#二、PermissionEvaluator" class="headerlink" title="二、PermissionEvaluator"></a>二、PermissionEvaluator</h2><p>我们需要自定义对 <code>hasPermission()</code> 方法的处理，就需要自定义 <code>PermissionEvaluator</code>，创建类 <code>CustomPermissionEvaluator</code>，实现 <code>PermissionEvaluator</code> 接口。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomPermissionEvaluator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PermissionEvaluator</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysPermissionService permissionService;    <span class="hljs-meta">@Autowired</span>    SysRoleService roleService;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPermission</span><span class="hljs-params">(Authentication authentication, Object targetUrl, Object targetPermission)</span> </span>&#123;        <span class="hljs-comment">//获得loadUserByUsername()方法的结果</span>        User user = (User) authentication.getPrincipal();        <span class="hljs-comment">//获得loadUserByUsername()中注入的角色</span>        Collection&lt;GrantedAuthority&gt; authorities = user.getAuthorities();        <span class="hljs-comment">//遍历用户所有角色</span>        <span class="hljs-keyword">for</span>(GrantedAuthority authority:authorities)&#123;            String roleName = authority.getAuthority();            Integer roleId = roleService.selectByName(roleName).getId();            <span class="hljs-comment">//得到角色所有的权限</span>            List&lt;SysPermission&gt; permissionList = permissionService.listByRoleId(roleId);            <span class="hljs-comment">//遍历permissionList</span>            <span class="hljs-keyword">for</span>(SysPermission sysPermission:permissionList)&#123;                <span class="hljs-comment">//获取权限集</span>                List permissions = sysPermission.getPermissions();                <span class="hljs-comment">//如果访问的url和权限用户符合的话，返回true</span>                <span class="hljs-keyword">if</span>(targetUrl.equals(sysPermission.getUrl()) &amp;&amp; permissions.contains(targetPermission))&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPermission</span><span class="hljs-params">(Authentication authentication, Serializable targetId, String targetType, Object permission)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><p>在 <code>hasPermission()</code> 方法中，参数 1 代表<strong>用户的权限身份</strong>，参数 2 参数 3 分别和 <code>@PreAuthorize(&quot;hasPermission(&#39;/admin&#39;,&#39;r&#39;)&quot;)</code> 中的参数对应，即<strong>访问 url 和权限</strong>。</p><p>思路如下：</p><ol><li>通过 <code>Authentication</code> 取出登录用户的所有 <code>Role</code></li><li>遍历每一个 <code>Role</code>，获取到每个<code>Role</code>的所有 <code>Permission</code></li><li>遍历每一个 <code>Permission</code>，只要有一个 <code>Permission</code> 的 <code>url</code> 和传入的url相同，且该 <code>Permission</code> 中包含传入的权限，返回 true</li><li>如果遍历都结束，还没有找到，返回false</li></ol><p>下面就是在 <code>WebSecurityConfig</code> 中注册 <code>CustomPermissionEvaluator</code>：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DefaultWebSecurityExpressionHandler <span class="hljs-title">webSecurityExpressionHandler</span><span class="hljs-params">()</span></span>&#123;        DefaultWebSecurityExpressionHandler handler = <span class="hljs-keyword">new</span> DefaultWebSecurityExpressionHandler();        handler.setPermissionEvaluator(<span class="hljs-keyword">new</span> CustomPermissionEvaluator());        <span class="hljs-keyword">return</span> handler;    &#125;&#125;</code></pre></div><h2 id="三、运行程序"><a href="#三、运行程序" class="headerlink" title="三、运行程序"></a>三、运行程序</h2><p>当我使用角色为 <code>ROLE_USER</code> 的用户仍然能访问，因为该用户访问 <code>/admin</code> 路径具有 <code>r</code> 权限：</p><p><img src="https://www.jitwxs.cn/images/posts/2018051519070954.png" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(4)--自定义表单登录</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%8D%95%E7%99%BB%E5%BD%95/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%8D%95%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="一、添加验证码"><a href="#一、添加验证码" class="headerlink" title="一、添加验证码"></a>一、添加验证码</h3><h4 id="1-1-验证码-Servlet"><a href="#1-1-验证码-Servlet" class="headerlink" title="1.1 验证码 Servlet"></a>1.1 验证码 Servlet</h4><p>验证码的 Servlet 代码，大家无需关心其内部实现，我也是百度直接捞了一个，直接复制即可。</p><div class="hljs"><pre><code class="hljs java">com.gavin.springsecurity04.common.VerifyServlet    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VerifyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123; <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">5051097528828603895L</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 验证码图片的宽度。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> width = <span class="hljs-number">100</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *  验证码图片的高度。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height = <span class="hljs-number">30</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 验证码字符个数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> codeCount = <span class="hljs-number">4</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 字体高度</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> fontHeight;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 干扰线数量</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> interLine = <span class="hljs-number">16</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 第一个字符的x轴值，因为后面的字符坐标依次递增，所以它们的x轴值是codeX的倍数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> codeX;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * codeY ,验证字符的y轴值，因为并行所以值一样</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> codeY;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * codeSequence 表示字符允许出现的序列值</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">char</span>[] codeSequence = &#123; <span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>, <span class="hljs-string">'H'</span>, <span class="hljs-string">'I'</span>, <span class="hljs-string">'J'</span>,            <span class="hljs-string">'K'</span>, <span class="hljs-string">'L'</span>, <span class="hljs-string">'M'</span>, <span class="hljs-string">'N'</span>, <span class="hljs-string">'O'</span>, <span class="hljs-string">'P'</span>, <span class="hljs-string">'Q'</span>, <span class="hljs-string">'R'</span>, <span class="hljs-string">'S'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">'U'</span>, <span class="hljs-string">'V'</span>, <span class="hljs-string">'W'</span>,            <span class="hljs-string">'X'</span>, <span class="hljs-string">'Y'</span>, <span class="hljs-string">'Z'</span>, <span class="hljs-string">'0'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'6'</span>, <span class="hljs-string">'7'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'9'</span> &#125;;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 初始化验证图片属性</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;        <span class="hljs-comment">// 从web.xml中获取初始信息</span>        <span class="hljs-comment">// 宽度</span>        String strWidth = <span class="hljs-keyword">this</span>.getInitParameter(<span class="hljs-string">"width"</span>);        <span class="hljs-comment">// 高度</span>        String strHeight = <span class="hljs-keyword">this</span>.getInitParameter(<span class="hljs-string">"height"</span>);        <span class="hljs-comment">// 字符个数</span>        String strCodeCount = <span class="hljs-keyword">this</span>.getInitParameter(<span class="hljs-string">"codeCount"</span>);        <span class="hljs-comment">// 将配置的信息转换成数值</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (strWidth != <span class="hljs-keyword">null</span> &amp;&amp; strWidth.length() != <span class="hljs-number">0</span>) &#123;                width = Integer.parseInt(strWidth);            &#125;            <span class="hljs-keyword">if</span> (strHeight != <span class="hljs-keyword">null</span> &amp;&amp; strHeight.length() != <span class="hljs-number">0</span>) &#123;                height = Integer.parseInt(strHeight);            &#125;            <span class="hljs-keyword">if</span> (strCodeCount != <span class="hljs-keyword">null</span> &amp;&amp; strCodeCount.length() != <span class="hljs-number">0</span>) &#123;                codeCount = Integer.parseInt(strCodeCount);            &#125;        &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-comment">//width-4 除去左右多余的位置，使验证码更加集中显示，减得越多越集中。</span>        <span class="hljs-comment">//codeCount+1     //等比分配显示的宽度，包括左右两边的空格</span>        codeX = (width-<span class="hljs-number">4</span>) / (codeCount+<span class="hljs-number">1</span>);        <span class="hljs-comment">//height - 10 集中显示验证码</span>        fontHeight = height - <span class="hljs-number">10</span>;        codeY = height - <span class="hljs-number">7</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ServletException</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> java.io.IOException</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, java.io.IOException </span>&#123;        <span class="hljs-comment">// 定义图像buffer</span>        BufferedImage buffImg = <span class="hljs-keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);        Graphics2D gd = buffImg.createGraphics();        <span class="hljs-comment">// 创建一个随机数生成器类</span>        Random random = <span class="hljs-keyword">new</span> Random();        <span class="hljs-comment">// 将图像填充为白色</span>        gd.setColor(Color.LIGHT_GRAY);        gd.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);        <span class="hljs-comment">// 创建字体，字体的大小应该根据图片的高度来定。</span>        Font font = <span class="hljs-keyword">new</span> Font(<span class="hljs-string">"Times New Roman"</span>, Font.PLAIN, fontHeight);        <span class="hljs-comment">// 设置字体。</span>        gd.setFont(font);        <span class="hljs-comment">// 画边框。</span>        gd.setColor(Color.BLACK);        gd.drawRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width - <span class="hljs-number">1</span>, height - <span class="hljs-number">1</span>);        <span class="hljs-comment">// 随机产生16条干扰线，使图象中的认证码不易被其它程序探测到。</span>        gd.setColor(Color.gray);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; interLine; i++) &#123;            <span class="hljs-keyword">int</span> x = random.nextInt(width);            <span class="hljs-keyword">int</span> y = random.nextInt(height);            <span class="hljs-keyword">int</span> xl = random.nextInt(<span class="hljs-number">12</span>);            <span class="hljs-keyword">int</span> yl = random.nextInt(<span class="hljs-number">12</span>);            gd.drawLine(x, y, x + xl, y + yl);        &#125;        <span class="hljs-comment">// randomCode用于保存随机产生的验证码，以便用户登录后进行验证。</span>        StringBuffer randomCode = <span class="hljs-keyword">new</span> StringBuffer();        <span class="hljs-keyword">int</span> red = <span class="hljs-number">0</span>, green = <span class="hljs-number">0</span>, blue = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 随机产生codeCount数字的验证码。</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; codeCount; i++) &#123;            <span class="hljs-comment">// 得到随机产生的验证码数字。</span>            String strRand = String.valueOf(codeSequence[random.nextInt(<span class="hljs-number">36</span>)]);            <span class="hljs-comment">// 产生随机的颜色分量来构造颜色值，这样输出的每位数字的颜色值都将不同。</span>            red = random.nextInt(<span class="hljs-number">255</span>);            green = random.nextInt(<span class="hljs-number">255</span>);            blue = random.nextInt(<span class="hljs-number">255</span>);            <span class="hljs-comment">// 用随机产生的颜色将验证码绘制到图像中。</span>            gd.setColor(<span class="hljs-keyword">new</span> Color(red,green,blue));            gd.drawString(strRand, (i + <span class="hljs-number">1</span>) * codeX, codeY);            <span class="hljs-comment">// 将产生的四个随机数组合在一起。</span>            randomCode.append(strRand);        &#125;        <span class="hljs-comment">// 将四位数字的验证码保存到Session中。</span>        HttpSession session = request.getSession();        session.setAttribute(<span class="hljs-string">"validateCode"</span>, randomCode.toString());        <span class="hljs-comment">// 禁止图像缓存。</span>        response.setHeader(<span class="hljs-string">"Pragma"</span>, <span class="hljs-string">"no-cache"</span>);        response.setHeader(<span class="hljs-string">"Cache-Control"</span>, <span class="hljs-string">"no-cache"</span>);        response.setDateHeader(<span class="hljs-string">"Expires"</span>, <span class="hljs-number">0</span>);        response.setContentType(<span class="hljs-string">"image/jpeg"</span>);        <span class="hljs-comment">// 将图像输出到Servlet输出流中。</span>        ServletOutputStream sos = response.getOutputStream();        ImageIO.write(buffImg, <span class="hljs-string">"jpeg"</span>, sos);        sos.close();    &#125;  &#125;</code></pre></div><p>然后在 Application 中注入该 Servlet：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringSecurity04Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(SpringSecurity04Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">indexServletRegistration</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//利用ServletRegistrationBean接口来使用servlet功能</span>        ServletRegistrationBean registration = <span class="hljs-keyword">new</span> ServletRegistrationBean(<span class="hljs-keyword">new</span> VerifyServlet());        registration.addUrlMappings(<span class="hljs-string">"/getVerifyCode"</span>);        <span class="hljs-keyword">return</span> registration;    &#125;&#125;</code></pre></div><h4 id="1-2-修改-login-html"><a href="#1-2-修改-login-html" class="headerlink" title="1.2 修改 login.html"></a>1.2 修改 login.html</h4><p>在原本的 login 页面基础上加上验证码字段：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>登陆<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>登陆<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"verifyCode"</span> <span class="hljs-attr">required</span>=<span class="hljs-string">"required"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"验证码"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"getVerifyCode"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"看不清，请点我"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"refresh(this)"</span> <span class="hljs-attr">onmouseover</span>=<span class="hljs-string">"mouseover(this)"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"remember-me"</span>/&gt;</span>自动登录<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>立即登陆<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">refresh</span>(<span class="hljs-params">obj</span>) </span>&#123; obj.src = <span class="hljs-string">"getVerifyCode?"</span> + <span class="hljs-built_in">Math</span>.random(); &#125;</span><span class="actionscript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mouseover</span><span class="hljs-params">(obj)</span> </span>&#123; obj.style.cursor = <span class="hljs-string">"pointer"</span>; &#125;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="1-3-添加匿名访问-Url"><a href="#1-3-添加匿名访问-Url" class="headerlink" title="1.3 添加匿名访问 Url"></a>1.3 添加匿名访问 Url</h4><p>不要忘记在 WebSecurityConfig 中允许该 Url 的匿名访问，不然没有登录是没有办法访问该 Url 的：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">//设置拦截忽略文件夹，可以对静态资源访问</span>    web.ignoring().antMatchers(<span class="hljs-string">"/css/**"</span>,<span class="hljs-string">"/js/**"</span>,<span class="hljs-string">"/css/**"</span>,<span class="hljs-string">"/getVerifyCode"</span>);&#125;</code></pre></div><p>效果如下：</p><p><img src="D:%5C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%5CBlog%5CMyBlog%5Csource_posts%5Cimage-20200523174552543.png" srcset="/img/loading.gif" alt="效果"></p><p>下面才算是这篇文章真正的部分。我们如何才能实现验证码验证呢，思考一下，应该有以下几种实现方式：</p><ol><li>登录表单提交前发送 AJAX 验证验证码</li><li>使用自定义过滤器(Filter)，在 Spring security 校验前验证验证码合法性</li><li>和用户名、密码一起发送到后台，在 Spring security 中进行验证</li></ol><h3 id="二、AJAX-验证"><a href="#二、AJAX-验证" class="headerlink" title="二、AJAX 验证"></a>二、AJAX 验证</h3><p>使用 AJAX 方式验证和我们 Spring Security 框架就没有任何关系了，其实就是表单提交前先发个 HTTP 请求验证验证码，本篇不再赘述。</p><h3 id="三、过滤器验证"><a href="#三、过滤器验证" class="headerlink" title="三、过滤器验证"></a>三、过滤器验证</h3><p>使用过滤器的思路是：<strong>在Spring Security 处理登录验证请求前，验证验证码，如果正确，放行；如果不正确，跳到异常</strong>。</p><h4 id="3-1-编写验证码过滤器"><a href="#3-1-编写验证码过滤器" class="headerlink" title="3.1 编写验证码过滤器"></a>3.1 编写验证码过滤器</h4><p>自定义一个过滤器，实现 <code>OncePerRequestFilter</code> （该 Filter 保证每次请求一定会过滤），在 <code>isProtectedUrl()</code> 方法中拦截了 POST 方式的 /login 请求。</p><p>在逻辑处理中从 request 中取出验证码，并进行验证，如果验证成功，放行；验证失败，手动生成异常。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VerifyFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OncePerRequestFilter</span> </span>&#123;    <span class="hljs-comment">/**获取路径信息**/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> PathMatcher PATH_MATCHER = <span class="hljs-keyword">new</span> AntPathMatcher();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-comment">//如果是POST请求，并且请求路径是/login，就去进行验证码校验</span>        <span class="hljs-keyword">if</span>(isProtectedUrl(httpServletRequest))&#123;            String verifyCode = httpServletRequest.getParameter(<span class="hljs-string">"verifyCode"</span>);            <span class="hljs-comment">//如果验证码错误，就抛出异常，否则正常执行</span>            <span class="hljs-keyword">if</span>(!validateVerify(verifyCode))&#123;                <span class="hljs-comment">//手动设置异常</span>                httpServletRequest.setAttribute(<span class="hljs-string">"SPRING_SECURITY_LAST_EXCEPTION"</span>,<span class="hljs-keyword">new</span> DisabledException(<span class="hljs-string">"验证码输入错误"</span>));                <span class="hljs-comment">//转发到错误url</span>       httpServletRequest.getRequestDispatcher(<span class="hljs-string">"/login/error"</span>).forward(httpServletRequest,httpServletResponse);            &#125;<span class="hljs-keyword">else</span> &#123;                filterChain.doFilter(httpServletRequest,httpServletResponse);            &#125;        &#125;<span class="hljs-keyword">else</span> &#123;            filterChain.doFilter(httpServletRequest,httpServletResponse);        &#125;    &#125;    <span class="hljs-comment">/**校验验证码**/</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validateVerify</span><span class="hljs-params">(String verifyCode)</span> </span>&#123;        <span class="hljs-comment">//获取当前线程绑定的request对象</span>        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = requestAttributes.getRequest();        <span class="hljs-comment">//下面这个validateCode是在servlet中存入session的名字</span>        String validateCode = ((String) request.getSession().getAttribute(<span class="hljs-string">"validateCode"</span>)).toLowerCase();        verifyCode = verifyCode.toLowerCase();        System.out.println(<span class="hljs-string">"验证码："</span>+validateCode+<span class="hljs-string">"用户输入："</span>+verifyCode);        <span class="hljs-keyword">return</span> validateCode.equals(verifyCode);    &#125;    <span class="hljs-comment">/**拦截/login的POST请求**/</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isProtectedUrl</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"POST"</span>.equals(request.getMethod()) &amp;&amp; PATH_MATCHER.match(<span class="hljs-string">"/login"</span>,request.getServletPath());    &#125;&#125;</code></pre></div><h4 id="3-2-注入过滤器"><a href="#3-2-注入过滤器" class="headerlink" title="3.2 注入过滤器"></a>3.2 注入过滤器</h4><p>修改 WebSecurityConfig 的 configure 方法，添加一个 <code>addFilterBefore()</code> ，具有两个参数，作用是在参数二之前执行参数一设置的过滤器。</p><p>Spring Security 对于用户名/密码登录方式是通过 <code>UsernamePasswordAuthenticationFilter</code> 处理的，我们在它之前执行验证码过滤器即可。</p><div class="hljs"><pre><code class="hljs java">.addFilterBefore(<span class="hljs-keyword">new</span> VerifyFilter(), UsernamePasswordAuthenticationFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span></code></pre></div><p>测试效果不理想，不推荐这种方式。</p><h3 id="四、Spring-Security-验证"><a href="#四、Spring-Security-验证" class="headerlink" title="四、Spring Security 验证"></a>四、Spring Security 验证</h3><p>使用过滤器就已经实现了验证码功能，但其实它和 AJAX 验证差别不大。</p><ul><li>AJAX 是在提交前发一个请求，请求返回成功就提交，否则不提交；</li><li>过滤器是先验证验证码，验证成功就让 Spring Security 验证用户名和密码；验证失败，则产生异常·。</li></ul><p>如果我们要做的需求是用户登录是需要多个验证字段，不单单是用户名和密码，那么使用过滤器会让逻辑变得复杂，这时候可以考虑自定义 Spring Security 的验证逻辑了…</p><h4 id="4-1-WebAuthenticationDetails"><a href="#4-1-WebAuthenticationDetails" class="headerlink" title="4.1 WebAuthenticationDetails"></a>4.1 WebAuthenticationDetails</h4><p>我们知道 Spring security 默认只会处理用户名和密码信息。这时候就要请出我们的主角——<code>WebAuthenticationDetails</code>。</p><blockquote><p><code>WebAuthenticationDetails</code>: 该类提供了获取用户登录时携带的额外信息的功能，默认提供了 remoteAddress 与 sessionId 信息。</p></blockquote><p>我们需要实现自定义的 <code>WebAuthenticationDetails</code>，并在其中加入我们的验证码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomWebAuthenticationDetails</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebAuthenticationDetails</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">6975601077710753878L</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String verifyCode;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Records the remote address and will also set the session Id if a session already</span><span class="hljs-comment">     * exists (it won't create one).</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request that the authentication request was received from</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomWebAuthenticationDetails</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;        <span class="hljs-keyword">super</span>(request);        verifyCode = request.getParameter(<span class="hljs-string">"verifyCode"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getVerifyCode</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.verifyCode;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        sb.append(<span class="hljs-keyword">super</span>.toString()).append(<span class="hljs-string">";VerifiCode:"</span>).append(<span class="hljs-keyword">this</span>.verifyCode);        <span class="hljs-keyword">return</span> sb.toString();    &#125;&#125;</code></pre></div><p>在这个方法中，我们将前台form表单中的verifyCode获取到，并通过get方法方便调用。</p><h4 id="4-2-AuthenticationDetailsSource"><a href="#4-2-AuthenticationDetailsSource" class="headerlink" title="4.2 AuthenticationDetailsSource"></a>4.2 AuthenticationDetailsSource</h4><p>自定义了<code>WebAuthenticationDetails</code>，我i们还需要将其放入 <code>AuthenticationDetailsSource</code> 中来替换原本的 <code>WebAuthenticationDetails</code> ，因此还得实现自定义 <code>AuthenticationDetailsSource</code> ：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>(<span class="hljs-string">"authenticationDetailsSource"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationDetailsSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationDetailsSource</span>&lt;<span class="hljs-title">HttpServletRequest</span>, <span class="hljs-title">WebAuthenticationDetails</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> WebAuthenticationDetails <span class="hljs-title">buildDetails</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CustomWebAuthenticationDetails(request);    &#125;&#125;</code></pre></div><p>该类是将原本的 <code>WebAuthenticationDetails</code> 替换为了我们的 <code>CustomWebAuthenticationDetails</code>。</p><p>接下来我们只需将 <code>CustomAuthenticationDetailsSource</code> 注入Spring Security中，替换掉默认的 <code>AuthenticationDetailsSource</code>。</p><p>通过修改 <code>WebSecurityConfig</code>将其注入，然后在config()中使用 <code>authenticationDetailsSource(authenticationDetailsSource)</code>方法来指定它。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>  AuthenticationDetailsSource&lt;HttpServletRequest, WebAuthenticationDetails&gt; authenticationDetailsSource;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;      http.authorizeRequests()      ....省略   .authenticationDetailsSource(authenticationDetailsSource)</code></pre></div><h4 id="4-3-AuthenticationProvider"><a href="#4-3-AuthenticationProvider" class="headerlink" title="4.3 AuthenticationProvider"></a>4.3 AuthenticationProvider</h4><p>至此我们通过自定义 <code>WebAuthenticationDetails</code> 和 <code>AuthenticationDetailsSource</code> 将验证码和用户名、密码一起带入了 Spring Security 中，下面我们需要将它取出来。</p><p>这里需要我们自定义 <code>AuthenticationProvider</code>，需要注意的是，<strong>如果是我们自己实现 <code>AuthenticationProvider</code>，那么我们就需要自己做密码校验了。</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationProvider</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> CustomUserDetailsService customUserDetailsService;    <span class="hljs-comment">/**用来验证用户身份**/</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        <span class="hljs-comment">//1.获取用户的用户名和密码</span>        String inputName = authentication.getName();        String inputPassword = authentication.getCredentials().toString();        CustomWebAuthenticationDetails details = (CustomWebAuthenticationDetails) authentication.getDetails();        String verifyCode = details.getVerifyCode();        <span class="hljs-keyword">if</span>(!validateVerify(verifyCode))&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisabledException(<span class="hljs-string">"验证码输入错误"</span>);        &#125;        <span class="hljs-comment">// userDetails为数据库中查询到的用户信息</span>        UserDetails userDetails = customUserDetailsService.loadUserByUsername(inputName);        <span class="hljs-comment">// 如果是自定义AuthenticationProvider，需要手动密码校验</span>        <span class="hljs-keyword">if</span>(!userDetails.getPassword().equals(inputPassword) || !userDetails.getUsername().equals(inputName))&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">"用户名或密码错误"</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(inputName,inputPassword,userDetails.getAuthorities());    &#125;    <span class="hljs-comment">/**验证码核对**/</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validateVerify</span><span class="hljs-params">(String verifiCode)</span> </span>&#123;        <span class="hljs-comment">//获取当前线程绑定的request对象</span>        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = requestAttributes.getRequest();        String validateCode = ((String) request.getSession().getAttribute(<span class="hljs-string">"validateCode"</span>)).toLowerCase();        verifiCode = verifiCode.toLowerCase();        System.out.println(<span class="hljs-string">"验证码："</span>+validateCode+<span class="hljs-string">";用户输入："</span>+verifiCode);        <span class="hljs-keyword">return</span> validateCode.equals(verifiCode);    &#125;    <span class="hljs-comment">/**判断当前的AuthenticationProvider是否支持对应的Authentication**/</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; authentication)</span> </span>&#123;        <span class="hljs-keyword">return</span> (UsernamePasswordAuthenticationToken<span class="hljs-class">.<span class="hljs-keyword">class</span></span><span class="hljs-class">                .<span class="hljs-title">isAssignableFrom</span>(<span class="hljs-title">authentication</span>))</span>;    &#125;&#125;</code></pre></div><p>最后在 <code>WebSecurityConfig</code> 中将其注入，并在 config 方法中通过 <code>auth.authenticationProvider()</code> 指定使用。</p><div class="hljs"><pre><code class="hljs java"> <span class="hljs-meta">@Autowired</span> CustomAuthenticationProvider customAuthenticationProvider; <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;     auth.authenticationProvider(customAuthenticationProvider); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(3)--异常处理</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>思考：为何登录失败自动跳转到/login?error，而且没有异常提示？</p><p><img src="D:%5C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%5CBlog%5CMyBlog%5Csource_posts%5Cimage-20200523125639595.png" srcset="/img/loading.gif" alt="登录错误自动来到login?error"></p><p>因为首先 <code>/login?error</code> 是 Spring security 默认的失败 Url，其次<strong>如果你不手动处理这个异常，这个异常是不会被处理的</strong>。</p><h2 id="一、常见异常"><a href="#一、常见异常" class="headerlink" title="一、常见异常"></a>一、常见异常</h2><p>我们先来列举下一些 Spring Security 中常见的异常：</p><ul><li><code>UsernameNotFoundException</code>（用户不存在）</li><li><code>DisabledException</code>（用户已被禁用）</li><li><code>BadCredentialsException</code>（坏的凭据）</li><li><code>LockedException</code>（账户锁定）</li><li><code>AccountExpiredException</code> （账户过期）</li><li><code>CredentialsExpiredException</code>（证书过期）</li><li>…</li></ul><p>以上列出的这些异常都是 <code>AuthenticationException</code> 的子类，然后我们来看看 Spring security 如何处理 <code>AuthenticationException</code> 异常的。</p><h2 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h2><p>我们知道异常一般在过滤器中处理，在 <code>AbstractAuthenticationProcessingFilter</code> 中我们找到了对 <code>AuthenticationException</code> 的处理：</p><div class="hljs"><pre><code class="hljs jAVA">org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter#doFilter    <span class="hljs-keyword">try</span> &#123;authResult = attemptAuthentication(request, response);<span class="hljs-comment">//1.认证</span><span class="hljs-keyword">if</span> (authResult == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span>;&#125;sessionStrategy.onAuthentication(authResult, request, response); <span class="hljs-comment">//2.并发问题</span>&#125;<span class="hljs-keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;logger.error(<span class="hljs-string">"An internal error occurred while trying to authenticate the user."</span>,failed);unsuccessfulAuthentication(request, response, failed);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">catch</span> (AuthenticationException failed) &#123;unsuccessfulAuthentication(request, response, failed);<span class="hljs-comment">//3.认证失败</span><span class="hljs-keyword">return</span>;&#125;</code></pre></div><p>(1)，先是调用attemptAuthentication（）方法对请求参数进行提取</p><div class="hljs"><pre><code class="hljs java">org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter#attemptAuthentication<span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;<span class="hljs-keyword">if</span> (postOnly &amp;&amp; !request.getMethod().equals(<span class="hljs-string">"POST"</span>)) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">"Authentication method not supported: "</span> + request.getMethod());&#125;String username = obtainUsername(request);String password = obtainPassword(request);<span class="hljs-keyword">if</span> (username == <span class="hljs-keyword">null</span>) &#123;username = <span class="hljs-string">""</span>;&#125;<span class="hljs-keyword">if</span> (password == <span class="hljs-keyword">null</span>) &#123;password = <span class="hljs-string">""</span>;&#125;username = username.trim();UsernamePasswordAuthenticationToken authRequest = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(username, password);<span class="hljs-comment">// 设置“details”属性</span>setDetails(request, authRequest);<span class="hljs-comment">//认证</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);&#125;</code></pre></div><p>我们来看看<code>setDetails(request,authRequest)</code>做了些什么：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDetails</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">UsernamePasswordAuthenticationToken authRequest)</span> </span>&#123;authRequest.setDetails(authenticationDetailsSource.buildDetails(request));&#125;</code></pre></div><p>UsernamePasswordAuthenticationToken是Authentication的具体实现，所以这里实际上就是在设置details，至于details的值，则是通过authenticationDetailsSource来构建：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebAuthenticationDetailsSource</span> <span class="hljs-keyword">implements</span></span><span class="hljs-class"><span class="hljs-title">AuthenticationDetailsSource</span>&lt;<span class="hljs-title">HttpServletRequest</span>, <span class="hljs-title">WebAuthenticationDetails</span>&gt; </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> WebAuthenticationDetails <span class="hljs-title">buildDetails</span><span class="hljs-params">(HttpServletRequest context)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WebAuthenticationDetails(context);&#125;&#125;</code></pre></div><p>这里我们也就知道<code>buildDetails</code>方法返回的其实是一个<code>WebAuthenticationDetails</code>对象，而<code>WebAuthenticationDetails</code>对象默认有哪些属性呢？</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WebAuthenticationDetails</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<span class="hljs-keyword">this</span>.remoteAddress = request.getRemoteAddr();HttpSession session = request.getSession(<span class="hljs-keyword">false</span>);<span class="hljs-keyword">this</span>.sessionId = (session != <span class="hljs-keyword">null</span>) ? session.getId() : <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p>如果我们想保存更多关于Http请求的信息，可以通过自定义<code>WebAuthenticationDetails</code>来实现，同时<code>WebAuthenticationDetailsSource</code>也要一起重新定义。</p><p>接下来进入到<code>org.springframework.security.authentication.ProviderManager#authenticate</code>方法中：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;Class&lt;? extends Authentication&gt; toTest = authentication.getClass();AuthenticationException lastException = <span class="hljs-keyword">null</span>;AuthenticationException parentException = <span class="hljs-keyword">null</span>;Authentication result = <span class="hljs-keyword">null</span>;Authentication parentResult = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">boolean</span> debug = logger.isDebugEnabled();<span class="hljs-comment">//逐个遍历AuthenticationProvider，并调用他们的authenticate方法来做认证：</span><span class="hljs-keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;            <span class="hljs-comment">//首先要判断当前的AuthenticationProvider是否支持对应的Authentication</span><span class="hljs-keyword">if</span> (!provider.supports(toTest)) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (debug) &#123;logger.debug(<span class="hljs-string">"Authentication attempt using "</span>+ provider.getClass().getName());&#125;<span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//实际验证交给AuthenticationProvider来处理</span>result = provider.authenticate(authentication);<span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;copyDetails(authentication, result);<span class="hljs-keyword">break</span>;&#125;&#125;            <span class="hljs-comment">//如果验证过程中有异常，就会被捕获</span><span class="hljs-keyword">catch</span> (AccountStatusException | InternalAuthenticationServiceException e) &#123;prepareException(e, authentication);<span class="hljs-keyword">throw</span> e;&#125; <span class="hljs-keyword">catch</span> (AuthenticationException e) &#123;lastException = e;&#125;&#125;</code></pre></div><p>（2），调用 <code>attemptAuthentication</code>方法走完认证流程之后，回来之后，接下来就是调用 <code>sessionStrategy.onAuthentication</code>方法，这个方法就是用来处理 <code>session</code>的并发问题：</p><div class="hljs"><pre><code class="hljs java">org.springframework.security.web.authentication.session.ConcurrentSessionControlAuthenticationStrategy#onAuthentication<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthentication</span><span class="hljs-params">(Authentication authentication,</span></span><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<span class="hljs-comment">//1.获取当前用户的所有 session，该方法在调用时，传递两个参数，一个是当前用户的 authentication，</span><span class="hljs-comment">//另一个参数 false 表示不包含已经过期的 session（在用户登录成功后，会将用户的 sessionid 存起来，</span><span class="hljs-comment">//其中 key 是用户的主体（principal），value 则是该主体对应的 sessionid 组成的一个集合）。</span><span class="hljs-keyword">final</span> List&lt;SessionInformation&gt; sessions = sessionRegistry.getAllSessions(authentication.getPrincipal(), <span class="hljs-keyword">false</span>);<span class="hljs-comment">//接下来计算出当前用户已经有几个有效 session 了，同时获取允许的 session 并发数。</span><span class="hljs-keyword">int</span> sessionCount = sessions.size();<span class="hljs-keyword">int</span> allowedSessions = getMaximumSessionsForThisUser(authentication);<span class="hljs-comment">//如果当前 session 数（sessionCount）小于 session 并发数（allowedSessions），则不做任何处理</span><span class="hljs-keyword">if</span> (sessionCount &lt; allowedSessions) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//如果 allowedSessions 的值为 -1，表示对 session 数量不做任何限制。</span><span class="hljs-keyword">if</span> (allowedSessions == -<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (sessionCount == allowedSessions) &#123;HttpSession session = request.getSession(<span class="hljs-keyword">false</span>);<span class="hljs-keyword">if</span> (session != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 只有当这个请求与一个已经注册的会话相同时才允许它</span><span class="hljs-keyword">for</span> (SessionInformation si : sessions) &#123;<span class="hljs-keyword">if</span> (si.getSessionId().equals(session.getId())) &#123;<span class="hljs-keyword">return</span>;&#125;&#125;&#125;&#125;<span class="hljs-comment">//首先会有 exceptionIfMaximumExceeded 属性，这就是我们在 SecurityConfig 中配置的 maxSessionsPreventsLogin 的值，默认为 false，如果为 true，就直接抛出异常，禁止新的登录（参照微信），如果为 false，则对 sessions 按照请求时间进行排序，然后再使多余的 session 过期即可（参照QQ）。</span>allowableSessionsExceeded(sessions, allowedSessions, sessionRegistry);&#125;</code></pre></div><p>配置文件如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-comment">//1</span><span class="hljs-function">HttpSessionEventPub1isher <span class="hljs-title">httpSessionEventPub1isher</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HttpSessionEventPub1isher();&#125;<span class="hljs-comment">//关闭CRSF跨域</span>        http.csrf()                .disable()                .sessionManagement()                .maximumSessions(<span class="hljs-number">1</span>)                .maxSessionsPreventsLogin(<span class="hljs-keyword">true</span>);</code></pre></div><p>为什么要加这个Bean呢？因为在Spring Security中，它是通过监听session的销毁事件来及时清理session的记录的，用户从不同的浏览器登录后，都会有对应的session，当用户注销登录之后，session就会失效，但是默认的失效是通过调用<code>StandardSession#invalidate</code>方法来实现的，这一失效事件无法被Spring容器感知到，进而导致当用户注销登录之后，Spring Security没有及时清理会话信息表，以为用户还在线，进而导致用户无法重新登录进来。</p><p>为了解决这一问题，我们提供了一个HttpSessionEventPublisher，这个类实现了httpSessionListener接口，在该Bean中，可以将session创建以及销毁的事件及时感知到，并且调用Sprign中的事件机制将相关的创建和销毁事件发布出去，进而被Spring Security感知到。</p><p>(3)，当用户登录失败时，被异常捕获，转到 <code>unsuccessfulAuthentication()</code> 方法中，然后转交给了 <code>SimpleUrlAuthenticationFailureHandler</code> 类的 <code>onAuthenticationFailure()</code> 处理。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unsuccessfulAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;    SecurityContextHolder.clearContext();    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logger.isDebugEnabled()) &#123;        <span class="hljs-keyword">this</span>.logger.debug(<span class="hljs-string">"Authentication request failed: "</span> + failed.toString(), failed);        <span class="hljs-keyword">this</span>.logger.debug(<span class="hljs-string">"Updated SecurityContextHolder to contain null Authentication"</span>);        <span class="hljs-keyword">this</span>.logger.debug(<span class="hljs-string">"Delegating to authentication failure handler "</span> + <span class="hljs-keyword">this</span>.failureHandler);    &#125;    <span class="hljs-keyword">this</span>.rememberMeServices.loginFail(request, response);    <span class="hljs-keyword">this</span>.failureHandler.onAuthenticationFailure(request, response, failed);&#125;</code></pre></div><p>在 <code>onAuthenticationFailure()</code> 中，首先判断有没有设置 <code>defaultFailureUrl</code>。</p><ul><li>如果没有设置，直接返回 401 错误，即 <code>HttpStatus.UNAUTHORIZED</code> 的值。</li><li>如果设置了，首先执行 <code>saveException()</code> 方法。然后判断 <code>forwardToDestination</code> ，即是否是服务器跳转，默认使用重定向即客户端跳转。</li></ul><div class="hljs"><pre><code class="hljs java">org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler#onAuthenticationFailure<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">      HttpServletResponse response, AuthenticationException exception)</span></span><span class="hljs-function">      <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;       <span class="hljs-keyword">if</span> (defaultFailureUrl == <span class="hljs-keyword">null</span>) &#123;      logger.debug(<span class="hljs-string">"No failure URL set, sending 401 Unauthorized error"</span>);      response.sendError(HttpStatus.UNAUTHORIZED.value(),         HttpStatus.UNAUTHORIZED.getReasonPhrase());   &#125;   <span class="hljs-keyword">else</span> &#123;      saveException(request, exception);<span class="hljs-comment">//判断是转发还是重定向</span>  <span class="hljs-comment">//直接转发</span>      <span class="hljs-keyword">if</span> (forwardToDestination) &#123;         logger.debug(<span class="hljs-string">"Forwarding to "</span> + defaultFailureUrl);         request.getRequestDispatcher(defaultFailureUrl)               .forward(request, response);      &#125;      <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//重定向</span>         logger.debug(<span class="hljs-string">"Redirecting to "</span> + defaultFailureUrl);         redirectStrategy.sendRedirect(request, response, defaultFailureUrl);      &#125;   &#125;&#125;</code></pre></div><p>来到<code>org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler#saveException</code>方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveException</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">AuthenticationException exception)</span> </span>&#123;<span class="hljs-keyword">if</span> (forwardToDestination) &#123;request.setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION, exception);&#125;<span class="hljs-keyword">else</span> &#123;HttpSession session = request.getSession(<span class="hljs-keyword">false</span>);<span class="hljs-keyword">if</span> (session != <span class="hljs-keyword">null</span> || allowSessionCreation) &#123;request.getSession().setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION,exception);&#125;&#125;&#125;</code></pre></div><p>在 <code>saveException()</code> 方法中，首先判断<code>forwardToDestination</code>，如果使用服务器跳转则写入 Request，客户端跳转则写入 Session。写入名为 <code>SPRING_SECURITY_LAST_EXCEPTION</code> ，值为 <code>AuthenticationException</code>。</p><p>至此 Spring security 完成了异常处理，总结一下流程：</p><p>–&gt; AbstractAuthenticationProcessingFilter<code>.doFilter()</code></p><p>–&gt; AbstractAuthenticationProcessingFilter.<code>unsuccessfulAuthentication()</code></p><p>–&gt; SimpleUrlAuthenticationFailureHandler.<code>onAuthenticationFailure()</code></p><p>–&gt; SimpleUrlAuthenticationFailureHandler.<code>saveException()</code></p><h2 id="三、处理异常"><a href="#三、处理异常" class="headerlink" title="三、处理异常"></a>三、处理异常</h2><p>上面源码说了那么多，真正处理起来很简单，我们只需要指定错误的url，然后再该方法中对异常进行处理即可。</p><p>（1）指定错误url，<code>WebSecurityConfig</code> 中添加 <code>.failureUrl(&quot;/login/error&quot;)</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http.authorizeRequests()            .anyRequest().authenticated()            .and()            .formLogin().loginPage(<span class="hljs-string">"/login"</span>)            <span class="hljs-comment">//登录失败url</span>            .failureUrl(<span class="hljs-string">"/login/error"</span>)            <span class="hljs-comment">//登录成功url</span>            .defaultSuccessUrl(<span class="hljs-string">"/"</span>).permitAll()</code></pre></div><p>（2）在 Controller 中处理异常</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/login/error"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loginError</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;    response.setContentType(<span class="hljs-string">"text/html;charset=utf-8"</span>);    AuthenticationException exception =            (AuthenticationException)request.getSession().getAttribute(<span class="hljs-string">"SPRING_SECURITY_LAST_EXCEPTION"</span>);    <span class="hljs-keyword">try</span> &#123;        response.getWriter().write(exception.toString());    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre></div><p>我们首先获取了 session 中的 <code>SPRING_SECURITY_LAST_EXCEPTION</code> 。为了演示，我只是简单的将错误信息返回给了页面。运行程序，当我们输入错误密码时：</p><p><img src="D:%5C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%5CBlog%5CMyBlog%5Csource_posts%5Cimage-20200523162917851.png" srcset="/img/loading.gif" alt="错误页面"></p><p>来到我们自己设置的错误页面，显示我们设置的错误信息。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(2)--自动登录</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-2-%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-2-%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一、修改-login-html"><a href="#一、修改-login-html" class="headerlink" title="一、修改 login.html"></a>一、修改 login.html</h2><p>在登录页添加自动登录的选项，注意自动登录字段的 name 属性必须是 <code>remember-me</code> ：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>欢迎来到登录页面<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"remember-me"</span>&gt;</span>记住我<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>立即登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="二、两种实现方式"><a href="#二、两种实现方式" class="headerlink" title="二、两种实现方式"></a>二、两种实现方式</h2><h3 id="2-1-Cookie-存储"><a href="#2-1-Cookie-存储" class="headerlink" title="2.1 Cookie 存储"></a>2.1 Cookie 存储</h3><p>这种方式十分简单，只要在 WebSecurityConfig 中的 configure() 方法添加一个 <code>rememberMe()</code> 即可,如下所示：</p><div class="hljs"><pre><code class="hljs java"> http.authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span><span class="hljs-comment">//                .antMatchers().permitAll()</span>                .anyRequest().authenticated()                .and()                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                .defaultSuccessUrl(<span class="hljs-string">"/"</span>).permitAll()                <span class="hljs-comment">// 自定义登录用户名和密码参数，默认为username和password</span><span class="hljs-comment">//                .usernameParameter("username")</span><span class="hljs-comment">//                .passwordParameter("password")</span>                .and()                <span class="hljs-comment">// 开启自动登录</span>                .rememberMe()                .and()                .logout()                .permitAll();        <span class="hljs-comment">//关闭CRSF跨域</span>        http.csrf().disable();    &#125;</code></pre></div><p>当我们登录时勾选自动登录时，会自动在 Cookie 中保存一个名为 <code>remember-me</code> 的cookie，默认有效期为2周，其值是一个加密字符串：</p><p><img src="https://www.jitwxs.cn/images/posts/20180509100451811.png" srcset="/img/loading.gif" alt="基于缓存的自动登录"></p><h3 id="2-2-数据库存储"><a href="#2-2-数据库存储" class="headerlink" title="2.2 数据库存储"></a>2.2 数据库存储</h3><p>使用 Cookie 存储虽然很方便，但是大家都知道 Cookie 毕竟是保存在客户端的，而且 Cookie 的值还与用户名、密码这些敏感数据相关，虽然加密了，但是将敏感信息存在客户端，毕竟不太安全。</p><p>Spring security 还提供了另一种相对更安全的实现机制：<strong>在客户端的 Cookie 中，仅保存一个无意义的加密串（与用户名、密码等敏感数据无关），然后在数据库中保存该加密串-用户信息的对应关系，自动登录时，用 Cookie 中的加密串，到数据库中验证，如果通过，自动登录才算通过。</strong></p><h4 id="2-2-1-基本原理"><a href="#2-2-1-基本原理" class="headerlink" title="2.2.1 基本原理"></a>2.2.1 基本原理</h4><p>当浏览器发起表单登录请求时，当通过 <code>UsernamePasswordAuthenticationFilter</code> 认证成功后，会经过 <code>RememberMeService</code>，在其中有个 <code>TokenRepository</code>，它会生成一个 token，首先将 token 写入到浏览器的 Cookie 中，然后将 token、认证成功的用户名写入到数据库中。</p><p>当浏览器下次请求时，会经过 <code>RememberMeAuthenticationFilter</code>，它会读取 Cookie 中的 token，交给 RememberMeService 从数据库中查询记录。如果存在记录，会读取用户名并去调用 <code>UserDetailsService</code>，获取用户信息，并将用户信息放入Spring Security 中，实现自动登录。</p><p><img src="https://www.jitwxs.cn/images/posts/20181202143630639.png" srcset="/img/loading.gif" alt="实现原理"></p><p>RememberMeAuthenticationFilter 在整个过滤器链中是比较靠后的位置，也就是说在传统登录方式都无法登录的情况下才会使用自动登录。</p><p><img src="https://www.jitwxs.cn/images/posts/20181202144420871.png" srcset="/img/loading.gif" alt="spring security过滤器链"></p><h4 id="2-2-2-代码实现"><a href="#2-2-2-代码实现" class="headerlink" title="2.2.2 代码实现"></a>2.2.2 代码实现</h4><p>首先需要创建一张表来存储 token 信息：</p><div class="hljs"><pre><code class="hljs SQL"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`persistent_logins`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`persistent_logins`</span>(<span class="hljs-string">`username`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<span class="hljs-string">`series`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    <span class="hljs-string">`token`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    <span class="hljs-string">`last_used`</span> <span class="hljs-built_in">timestamp</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span>,    PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`series`</span>))<span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4;</code></pre></div><p>在 WebSecurityConfig 中注入 <code>dataSource</code> ，创建一个 <code>PersistentTokenRepository</code> 的Bean：</p><div class="hljs"><pre><code class="hljs java">    <span class="hljs-meta">@Autowired</span>    DataSource dataSource;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersistentTokenRepository <span class="hljs-title">persistentTokenRepository</span><span class="hljs-params">()</span></span>&#123;        JdbcTokenRepositoryImpl tokenRepository = <span class="hljs-keyword">new</span> JdbcTokenRepositoryImpl();        tokenRepository.setDataSource(dataSource);                <span class="hljs-comment">//如果token表不存在，使用下面语句可以初始化该表，若存在，则需要注释掉这条语句，否则会报错</span><span class="hljs-comment">//        tokenRepository.setCreateTableOnStartup(true);</span>        <span class="hljs-keyword">return</span> tokenRepository;    &#125;</code></pre></div><p>在 <code>configure()</code> 中按如下所示配置自动登录：</p><div class="hljs"><pre><code class="hljs java"> <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span><span class="hljs-comment">//                .antMatchers().permitAll()</span>                .anyRequest().authenticated()                .and()                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                .defaultSuccessUrl(<span class="hljs-string">"/"</span>).permitAll()                .and()                <span class="hljs-comment">// 开启自动登录</span>                .rememberMe()                .tokenRepository(persistentTokenRepository())                <span class="hljs-comment">//有效时间(单位；s)</span>                .tokenValiditySeconds(<span class="hljs-number">60</span>)                .userDetailsService(userDetailsService)                .and()                .logout()                .permitAll();        <span class="hljs-comment">//关闭CRSF跨域</span>        http.csrf().disable();    &#125;</code></pre></div><h2 id="三、运行程序"><a href="#三、运行程序" class="headerlink" title="三、运行程序"></a>三、运行程序</h2><p>勾选自动登录后，Cookie 和数据库中均存储了 token 信息：</p><p><img src="https://www.jitwxs.cn/images/posts/20180509102031410.png" srcset="/img/loading.gif" alt="效果"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(1)--基础入门</title>
    <link href="/2020/05/29/SpringBoot%E9%9B%86%E6%88%90Spring-Security-1-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <url>/2020/05/29/SpringBoot%E9%9B%86%E6%88%90Spring-Security-1-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一、导入依赖"><a href="#一、导入依赖" class="headerlink" title="一、导入依赖"></a>一、导入依赖</h1><p>导入 <code>spring-boot-starter-security</code> 依赖，在 SpringBoot 2.0 环境下默认使用的是 5.0 版本。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-comment">&lt;!--注意，这里必须要指定版本，MySQL5用的驱动url是com.mysql.jdbc.Driver，</span><span class="hljs-comment">      MySQL6以后用的是com.mysql.cj.jdbc.Driver。版本不匹配便会报驱动类已过时的错误。--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.15<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h1 id="二、创建数据库"><a href="#二、创建数据库" class="headerlink" title="二、创建数据库"></a>二、创建数据库</h1><p>一般权限控制有三层，即：<code>用户</code>&lt;–&gt;<code>角色</code>&lt;–&gt;<code>权限</code>，用户与角色是多对多，角色和权限也是多对多。这里我们先暂时不考虑权限，只考虑<code>用户</code>&lt;–&gt;<code>角色</code>。</p><div class="hljs"><pre><code class="hljs mysql">-- 创建用户表 sys_user： --DROP TABLE IF EXISTS &#96;sys_user&#96;;CREATE TABLE &#96;sys_user&#96;(&#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,&#96;name&#96; varchar(255) NOT NULL,&#96;password&#96; varchar(255) NOT NULL,    PRIMARY KEY (&#96;id&#96;))ENGINE&#x3D;InnoDB DEFAULT CHARSET &#x3D; utf8;-- 创建权限表 sys_role： --DROP TABLE IF EXISTS &#96;sys_role&#96;;CREATE TABLE &#96;sys_role&#96;(&#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,    &#96;name&#96; varchar(255) NOT NULL,    PRIMARY KEY (&#96;id&#96;))ENGINE&#x3D;InnoDB DEFAULT CHARSET &#x3D; utf8;-- 创建用户-角色表 sys_user_role：（外键这里有点困惑，先标记下） --DROP TABLE IF EXISTS &#96;sys_user_role&#96;;CREATE TABLE &#96;sys_user_role&#96;(&#96;user_id&#96; int(11) NOT NULL ,    &#96;role_id&#96; int(11) NOT NULL,    PRIMARY KEY (&#96;user_id&#96;,&#96;role_id&#96;),    KEY &#96;fk_role_id&#96; (&#96;role_id&#96;),    CONSTRAINT &#96;fk_role_id&#96; FOREIGN KEY (&#96;role_id&#96;) REFERENCES &#96;sys_role&#96; (&#96;id&#96;) ON DELETE CASCADE ON UPDATE CASCADE,    CONSTRAINT &#96;fk_user_id&#96; FOREIGN KEY (&#96;user_id&#96;) REFERENCES &#96;sys_user&#96; (&#96;id&#96;) ON DELETE CASCADE ON UPDATE CASCADE)ENGINE&#x3D;InnoDB DEFAULT CHARSET &#x3D; utf8;-- 添加数据：（注意：传值的时候里面是单引号，如：&#39;1&#39;） --INSERT INTO &#96;sys_role&#96; VALUES (&#39;1&#39;, &#39;ROLE_ADMIN&#39;);INSERT INTO &#96;sys_role&#96; VALUES (&#39;2&#39;, &#39;ROLE_USER&#39;);INSERT INTO &#96;sys_user&#96; VALUES (&#39;1&#39;, &#39;admin&#39;, &#39;123&#39;);INSERT INTO &#96;sys_user&#96; VALUES (&#39;2&#39;, &#39;jitwxs&#39;, &#39;123&#39;);INSERT INTO &#96;sys_user_role&#96; VALUES (&#39;1&#39;, &#39;1&#39;);INSERT INTO &#96;sys_user_role&#96; VALUES (&#39;2&#39;, &#39;2&#39;);</code></pre></div><p>注意：权限格式为 <code>ROLE_XXX</code>，是 Spring Security 的规定。</p><h1 id="三、准备页面"><a href="#三、准备页面" class="headerlink" title="三、准备页面"></a>三、准备页面</h1><p>因为是示例程序，页面越简单越好，只用于登录的 <code>login.html</code> 以及用于登录成功后的 <code>home.html</code>，将其放置在 <code>resources/static</code> 目录下：</p><p>(1)login.html</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>欢迎来到登录页面<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>立即登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>注意：用户的登录认证是由 Spring Security 进行处理的，请求路径默认为 <code>/login</code>，用户名字段默认为 <code>username</code>，密码字段默认为 <code>password</code> 。</p><p>(2)home.html</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>欢迎回家<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>登录成功<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/admin"</span>&gt;</span>检测是否具有ROLE_ADMIN角色<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/user"</span>&gt;</span>检测是否具有ROLE_USER角色<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"window.location.href='/logout'"</span>&gt;</span>退出登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h1 id="四、配置-application-properties"><a href="#四、配置-application-properties" class="headerlink" title="四、配置 application.properties"></a>四、配置 application.properties</h1><p>在配置文件中配置下数据库连接：</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">root</span><span class="hljs-comment">#JDBC连接MySQL6 （com.mysql.cj.jdbc.Driver）， 需要指定时区serverTimezone，否则会报错</span><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/spring_security?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><span class="hljs-meta">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><span class="hljs-comment">#开启下划线转驼峰命令法</span><span class="hljs-meta">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="hljs-string">true</span></code></pre></div><h1 id="五、创建Model实体、Mapper、Service-和-Controller"><a href="#五、创建Model实体、Mapper、Service-和-Controller" class="headerlink" title="五、创建Model实体、Mapper、Service 和 Controller"></a>五、创建Model实体、Mapper、Service 和 Controller</h1><h2 id="5-1-Model"><a href="#5-1-Model" class="headerlink" title="5.1 Model"></a>5.1 Model</h2><p>(1)SysUser</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//com.gavin.springsecuriity01.Model.SysUser</span>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysUser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-comment">//这里必须是name，与数据库对应，否则运行会报错</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-comment">// 省略getter/setter</span>&#125;</code></pre></div><p>(2)SysRole</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysRole</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-comment">// 省略getter/setter</span>&#125;</code></pre></div><p>(3)SysUserRole</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysUserRole</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-keyword">private</span> Integer userId;    <span class="hljs-keyword">private</span> Integer roleId;        <span class="hljs-comment">// 省略getter/setter</span>&#125;</code></pre></div><h2 id="5-2-Mapper"><a href="#5-2-Mapper" class="headerlink" title="5.2 Mapper"></a>5.2 Mapper</h2><p>(1)SysUserMapper</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//com.gavin.springsecuriity01.Mapper.SysUserMapper</span><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysUserMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_user WHERE id = #&#123;id&#125;"</span>)    <span class="hljs-function">SysUser <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_user WHERE name = #&#123;name&#125;"</span>)    <span class="hljs-function">SysUser <span class="hljs-title">selectByName</span><span class="hljs-params">(String name)</span></span>;&#125;</code></pre></div><p>(2)SysRoleMapper</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysRoleMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_role WHERE id = #&#123;id&#125;"</span>)    <span class="hljs-function">SysRole <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>;&#125;</code></pre></div><p>(3)SysUserRoleMapper</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysUserRoleMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_user_role WHERE user_id = #&#123;id&#125;"</span>)    <span class="hljs-function">List&lt;SysUserRole&gt; <span class="hljs-title">listByUserId</span><span class="hljs-params">(Integer userId)</span></span>; &#125;</code></pre></div><h2 id="5-3-Service"><a href="#5-3-Service" class="headerlink" title="5.3 Service"></a>5.3 Service</h2><p>(1)SysUserService</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysUserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysUserMapper sysUserMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> SysUser <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>&#123;        <span class="hljs-keyword">return</span> sysUserMapper.selectById(id);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> SysUser <span class="hljs-title">selectByName</span><span class="hljs-params">(String name)</span></span>&#123;        <span class="hljs-keyword">return</span> sysUserMapper.selectByName(name);    &#125;&#125;</code></pre></div><p>(2)SysRoleService</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysRoleService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysRoleMapper sysRoleMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> SysRole <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>&#123;        <span class="hljs-keyword">return</span> sysRoleMapper.selectById(id);    &#125;&#125;</code></pre></div><p>(3)SysUserRoleService</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysUserRoleService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysUserRoleMapper sysUserRoleMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;SysUserRole&gt; <span class="hljs-title">listByUserId</span><span class="hljs-params">(Integer userId)</span></span>&#123;        <span class="hljs-keyword">return</span> sysUserRoleMapper.listByUserId(userId);    &#125;&#125;</code></pre></div><h2 id="5-4-Controller"><a href="#5-4-Controller" class="headerlink" title="5.4 Controller"></a>5.4 Controller</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(LoginController<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">showHome</span><span class="hljs-params">()</span></span>&#123;        String name = SecurityContextHolder.getContext().getAuthentication().getName();        logger.info(<span class="hljs-string">"当前登录用户："</span>+name);        <span class="hljs-keyword">return</span> <span class="hljs-string">"home.html"</span>;    &#125;        <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/login"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">showLogin</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"login.html"</span>;    &#125;        <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/admin"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasRole('ROLE_ADMIN')"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">printAdmin</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"如果你看见这句话，说明你有ROLE_ADMIN角色"</span>;    &#125;        <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasRole('ROLE_USER')"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">printUser</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"如果你看见这句话，说明你有ROLE_USER角色"</span>;    &#125;&#125;</code></pre></div><ul><li>如代码所示，获取当前登录用户：<code>SecurityContextHolder.getContext().getAuthentication()</code></li><li><code>@PreAuthorize</code> 用于判断用户是否有指定权限，没有就不能访问</li></ul><h1 id="六、配置-SpringSecurity"><a href="#六、配置-SpringSecurity" class="headerlink" title="六、配置 SpringSecurity"></a>六、配置 SpringSecurity</h1><h2 id="6-1-UserDetailsService"><a href="#6-1-UserDetailsService" class="headerlink" title="6.1 UserDetailsService"></a>6.1 UserDetailsService</h2><p>首先我们需要自定义 <code>UserDetailsService</code> ，将用户信息和权限注入进来。</p><p>我们需要重写 <code>loadUserByUsername</code> 方法，参数是用户输入的用户名。返回值是<code>UserDetails</code>，这是一个接口，一般使用它的子类<code>org.springframework.security.core.userdetails.User</code>，它有三个参数，分别是用户名、密码和权限集。</p><blockquote><p>实际情况下，大多将 DAO 中的 User 类继承 <code>org.springframework.security.core.userdetails.User</code> 返回。</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>(<span class="hljs-string">"userDetailsService"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomUserDetailsService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysUserService sysUserService;        <span class="hljs-meta">@Autowired</span>    SysRoleService sysRoleService;        <span class="hljs-meta">@Autowired</span>    SysUserRoleService sysUserRoleService;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;        Collection&lt;GrantedAuthority&gt; authorities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();                <span class="hljs-comment">//从数据库中取出用户信息</span>        SysUser user = sysUserService.selectByName(username);                <span class="hljs-comment">//判断用户是否存在</span>        <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">"用户名不存在！！"</span>);        &#125;                <span class="hljs-comment">//如果用户存在，就添加权限给他</span>        List&lt;SysUserRole&gt; userRoles = sysUserRoleService.listByUserId(user.getId());        <span class="hljs-keyword">for</span>(SysUserRole userRole:userRoles)&#123;            SysRole role = sysRoleService.selectById(userRole.getRoleId());            authorities.add(<span class="hljs-keyword">new</span> SimpleGrantedAuthority(role.getName()));        &#125;        <span class="hljs-comment">//返回UserDetails的实现类</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(user.getName(),user.getPassword(),authorities);    &#125;&#125;</code></pre></div><h1 id="6-2-WebSecurityConfig"><a href="#6-2-WebSecurityConfig" class="headerlink" title="6.2 WebSecurityConfig"></a>6.2 WebSecurityConfig</h1><p>该类是 Spring Security 的配置类，该类的三个注解分别是标识该类是配置类、开启 Security 服务、开启全局 Securtiy 注解。</p><p>首先将我们自定义的 <code>userDetailsService</code> 注入进来，在 <code>configure()</code> 方法中使用 <code>auth.userDetailsService()</code> 方法替换掉默认的 userDetailsService。</p><p>这里我们还指定了密码的加密方式（5.0 版本强制要求设置），因为我们数据库是明文存储的，所以明文返回即可，如下所示：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="hljs-keyword">true</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    CustomUserDetailsService userDetailsService;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth.userDetailsService(userDetailsService).passwordEncoder(<span class="hljs-keyword">new</span> PasswordEncoder() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">encode</span><span class="hljs-params">(CharSequence rawPassword)</span> </span>&#123;                <span class="hljs-keyword">return</span> rawPassword.toString();            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(CharSequence rawPassword, String encodedPassword)</span> </span>&#123;                <span class="hljs-keyword">return</span> encodedPassword.equals(rawPassword.toString());            &#125;        &#125;);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//设置拦截忽略文件夹，可以对静态资源访问</span>        web.ignoring().antMatchers(<span class="hljs-string">"/css/**"</span>,<span class="hljs-string">"/js/**"</span>,<span class="hljs-string">"/css/**"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span><span class="hljs-comment">//                .antMatchers().permitAll()</span>                .anyRequest().authenticated()                .and()                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                .defaultSuccessUrl(<span class="hljs-string">"/"</span>).permitAll()                <span class="hljs-comment">// 自定义登录用户名和密码参数，默认为username和password</span><span class="hljs-comment">//                .usernameParameter("username")</span><span class="hljs-comment">//                .passwordParameter("password")</span>                .and()                .logout().permitAll();        <span class="hljs-comment">//关闭CRSF跨域</span>        http.csrf().disable();    &#125;&#125;</code></pre></div><h1 id="七、运行程序"><a href="#七、运行程序" class="headerlink" title="七、运行程序"></a>七、运行程序</h1><blockquote><p>ROLE_ADMIN 账户：用户名 <strong>admin</strong>，密码 <strong>123</strong><br>ROLE_USER 账户：用户名 <strong>jitwxs</strong>，密码 <strong>123</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
