<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>AbstractQueuedSynchronizer介绍</title>
    <link href="/2021/05/31/AbstractQueuedSynchronizer%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/05/31/AbstractQueuedSynchronizer%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>AbstractQueuedSynchronizer（以下简称AQS），又称队列同步器，作为java.util.concurrent包的基础，它提供了一套完整的同步编程框架，用来构建锁或者其他同步组件的基础框架，开发人员只需要实现其中几个简单的方法就能自由的使用诸如独占，共享，条件队列等多种同步模式。我们常用的比如ReentrantLock，CountDownLatch等等基础类库都是基于AQS实现的，足以说明这套框架的强大之处。鉴于此，我们开发人员更应该了解它的实现原理，这样才能在使用过程中得心应手。</p><h1 id="二、独占锁"><a href="#二、独占锁" class="headerlink" title="二、独占锁"></a>二、独占锁</h1><p><strong>执行过程概述</strong></p><p>获取锁的过程：</p><ol><li>当线程调用acquire()申请获取锁资源，如果成功，则进入临界区。</li><li>当获取锁失败时，则进入一个FIFO等待队列，然后被挂起等待唤醒。</li><li>当队列中的等待线程被唤醒以后就重新尝试获取锁资源，如果成功则进入临界区，否则继续挂起等待。</li></ol><p>释放锁过程：</p><ol><li>当线程调用release()进行锁资源释放时，如果没有其他线程在等待锁资源，则释放完成。</li><li>如果队列中有其他等待锁资源的线程需要唤醒，则唤醒队列中的第一个等待节点（先入先出）。</li></ol><p><strong>源码深入分析</strong></p><p>首先来看下获取锁的方法acquire()</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))selfInterrupt();&#125;</code></pre></div><p>代码虽然短，但包含的逻辑却很多，一步一步看下：</p><ol><li>首先是调用开发人员自己实现的tryAcquire()     方法尝试获取锁资源，如果成功则整个acquire()方法执行完毕，即当前线程获得锁资源，可以进入临界区。</li><li>如果获取锁失败，则开始进入后面的逻辑，首先是addWaiter(Node.EXCLUSIVE)方法。来看下这个方法的源码实现：</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//注意：该入队方法的返回值就是新创建的节点</span><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;    <span class="hljs-comment">//基于当前线程，节点类型（Node.EXCLUSIVE）创建新的节点</span>    <span class="hljs-comment">//由于这里是独占模式，因此节点类型就是Node.EXCLUSIVE</span>    Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);    Node pred = tail;    <span class="hljs-comment">//这里为了提搞性能，首先执行一次快速入队操作，即直接尝试将新节点加入队尾</span>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;        node.prev = pred;        <span class="hljs-comment">//这里根据CAS的逻辑，即使并发操作也只能有一个线程成功并返回，其余的都要执行后面的入队操作。即enq()方法</span>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;            pred.next = node;            <span class="hljs-keyword">return</span> node;        &#125;    &#125;    enq(node);    <span class="hljs-keyword">return</span> node;&#125;<span class="hljs-comment">//完整的入队操作</span><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;    <span class="hljs-keyword">for</span> (;;) &#123;        Node t = tail;        <span class="hljs-comment">//如果队列还没有初始化，则进行初始化，即创建一个空的头节点</span>        <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//同样是CAS，只有一个线程可以初始化头结点成功，其余的都要重复执行循环体</span>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))                tail = head;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//新创建的节点指向队列尾节点，毫无疑问并发情况下这里会有多个新创建的节点指向队列尾节点</span>            node.prev = t;            <span class="hljs-comment">//基于这一步的CAS，不管前一步有多少新节点都指向了尾节点，这一步只有一个能真正入队成功，其他的都必须重新执行循环体</span>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;                t.next = node;                <span class="hljs-comment">//该循环体唯一退出的操作，就是入队成功（否则就要无限重试）</span>                <span class="hljs-keyword">return</span> t;            &#125;        &#125;    &#125;&#125;</code></pre></div><p>上面的入队操作有两点需要说明：</p><p>一、初始化队列的触发条件就是当前已经有线程占有了锁资源，因此上面创建的空的头节点可以认为就是当前占有锁资源的节点（虽然它并没有设置任何属性）。</p><p>二、注意整个代码是处在一个死循环中，知道入队成功。如果失败了就会不断进行重试。</p><p>经过上面的操作，我们申请获取锁的线程已经成功加入了等待队列，通过文章最一开始说的独占锁获取流程，那么节点现在要做的就是挂起当前线程，等待被唤醒，这个逻辑是怎么实现的呢？来看下源码：</p><p>通过上面的分析，该方法入参node就是刚入队的包含当前线程信息的节点</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;    <span class="hljs-comment">//锁资源获取失败标记位</span>    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//等待线程被中断标记位</span>        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;        <span class="hljs-comment">//这个循环体执行的时机包括新节点入队和队列中等待节点被唤醒两个地方</span>        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-comment">//获取当前节点的前置节点</span>            <span class="hljs-keyword">final</span> Node p = node.predecessor();            <span class="hljs-comment">//如果前置节点就是头结点，则尝试获取锁资源</span>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;                <span class="hljs-comment">//当前节点获得锁资源以后设置为头节点，这里继续理解我上面说的那句话</span>                <span class="hljs-comment">//头结点就表示当前正占有锁资源的节点</span>                setHead(node);                p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//帮助GC</span>                <span class="hljs-comment">//表示锁资源成功获取，因此把failed置为false</span>                failed = <span class="hljs-keyword">false</span>;                <span class="hljs-comment">//返回中断标记，表示当前节点是被正常唤醒还是被中断唤醒</span>                <span class="hljs-keyword">return</span> interrupted;            &#125;            如果没有获取锁成功，则进入挂起逻辑            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                    parkAndCheckInterrupt())                interrupted = <span class="hljs-keyword">true</span>;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">//最后会分析获取锁失败处理逻辑</span>        <span class="hljs-keyword">if</span> (failed)            cancelAcquire(node);    &#125;&#125;</code></pre></div><p>挂起逻辑是很重要的逻辑，这里拿出来单独分析一下，首先要注意目前为止，我们只是根据当前线程，节点类型创建了一个节点并加入队列中，<strong>其他属性都是默认值</strong>。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//首先说明一下参数，node是当前线程的节点，pred是它的前置节点</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;    <span class="hljs-comment">//获取前置节点的waitStatus</span>    <span class="hljs-keyword">int</span> ws = pred.waitStatus;    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)        <span class="hljs-comment">//如果前置节点的waitStatus是Node.SIGNAL则返回true，然后会执行parkAndCheckInterrupt()方法进行挂起</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//由waitStatus的几个取值可以判断这里表示前置节点被取消</span>        <span class="hljs-keyword">do</span> &#123;            node.prev = pred = pred.prev;        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);        <span class="hljs-comment">//这里我们由当前节点的前置节点开始，一直向前找最近的一个没有被取消的节点</span>        <span class="hljs-comment">//注，由于头结点head是通过new Node()创建，它的waitStatus为0,因此这里不会出现空指针问题，也就是说最多就是找到头节点上面的循环就退出了</span>        pred.next = node;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//根据waitStatus的取值限定，这里waitStatus的值只能是0或者PROPAGATE，那么我们把前置节点的waitStatus设为Node.SIGNAL然后重新进入该方法进行判断</span>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre></div><p>上面这个方法逻辑比较复杂，它是用来判断当前节点是否可以被挂起，也就是唤醒条件是否已经具备，即如果挂起了，那一定是可以由其他线程来唤醒的。该方法如果返回false，即挂起条件没有完备，那就会重新执行acquireQueued方法的循环体，进行重新判断，如果返回true，那就表示万事俱备，可以挂起了，就会进入parkAndCheckInterrupt()方法看下源码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;    LockSupport.park(<span class="hljs-keyword">this</span>);    <span class="hljs-comment">//被唤醒之后，返回中断标记，即如果是正常唤醒则返回false，如果是由于中断醒来，就返回true</span>    <span class="hljs-keyword">return</span> Thread.interrupted();&#125;</code></pre></div><p>看acquireQueued方法中的源码，如果是因为中断醒来，那么就把中断标记置为true。不管是正常被唤醒还是由与中断醒来，都会去尝试获取锁资源。如果成功则返回中断标记，否则继续挂起等待。</p><p><strong>注：Thread.interrupted()方法在返回中断标记的同时会清除中断标记，也就是说当由于中断醒来然后获取锁成功，那么整个acquireQueued方法就会返回true表示是因为中断醒来，但如果中断醒来以后没有获取到锁，继续挂起，由于这次的中断已经被清除了，下次如果是被正常唤醒，那么acquireQueued方法就会返回false，表示没有中断。</strong></p><p>最后我们回到acquireQueued方法的最后一步，finally模块。这里是针对锁资源获取失败以后做的一些善后工作，翻看上面的代码，其实能进入这里的就是tryAcquire()方法抛出异常，也就是说AQS框架针对开发人员自己实现的获取锁操作如果抛出异常，也做了妥善的处理，一起来看下源码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//传入的方法参数是当前获取锁资源失败的节点</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancelAcquire</span><span class="hljs-params">(Node node)</span> </span>&#123;    <span class="hljs-comment">// 如果节点不存在则直接忽略</span>    <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">return</span>;    node.thread = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 跳过所有已经取消的前置节点，跟上面的那段跳转逻辑类似</span>    Node pred = node.prev;    <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>)        node.prev = pred = pred.prev;    <span class="hljs-comment">//这个是前置节点的后继节点，由于上面可能的跳节点的操作，所以这里可不一定就是当前节点，仔细想一下。^_^</span>    Node predNext = pred.next;    <span class="hljs-comment">//把当前节点waitStatus置为取消，这样别的节点在处理时就会跳过该节点</span>    node.waitStatus = Node.CANCELLED;    <span class="hljs-comment">//如果当前是尾节点，则直接删除，即出队</span>    <span class="hljs-comment">//注：这里不用关心CAS失败，因为即使并发导致失败，该节点也已经被成功删除</span>    <span class="hljs-keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;        compareAndSetNext(pred, predNext, <span class="hljs-keyword">null</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">int</span> ws;        <span class="hljs-keyword">if</span> (pred != head &amp;&amp;                ((ws = pred.waitStatus) == Node.SIGNAL ||                        (ws &lt;= <span class="hljs-number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;                pred.thread != <span class="hljs-keyword">null</span>) &#123;            Node next = node.next;            <span class="hljs-keyword">if</span> (next != <span class="hljs-keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="hljs-number">0</span>)                <span class="hljs-comment">//这里的判断逻辑很绕，具体就是如果当前节点的前置节点不是头节点且它后面的节点等待它唤醒（waitStatus小于0），</span>                <span class="hljs-comment">//再加上如果当前节点的后继节点没有被取消就把前置节点跟后置节点进行连接，相当于删除了当前节点</span>                compareAndSetNext(pred, predNext, next);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//进入这里，要么当前节点的前置节点是头结点，要么前置节点的waitStatus是PROPAGATE，直接唤醒当前节点的后继节点</span>            unparkSuccessor(node);        &#125;        node.next = node; <span class="hljs-comment">// help GC</span>    &#125;&#125;</code></pre></div><p>上面就是独占模式获取锁的核心源码，确实非常难懂，很绕，就这几个方法需要反反复复看很多遍，才能慢慢理解。</p><p>接下来看下释放锁的过程：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;        Node h = head;        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)            unparkSuccessor(h);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre></div><p>tryRelease()方法是用户自定义的释放锁逻辑，如果成功，就判断等待队列中有没有需要被唤醒的节点（waitStatus为0表示没有需要被唤醒的节点），一起看下唤醒操作：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;    <span class="hljs-keyword">int</span> ws = node.waitStatus;    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)        <span class="hljs-comment">//把标记为设置为0，表示唤醒操作已经开始进行，提高并发环境下性能</span>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);    Node s = node.next;    <span class="hljs-comment">//如果当前节点的后继节点为null，或者已经被取消</span>    <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;        s = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">//注意这个循环没有break，也就是说它是从后往前找，一直找到离当前节点最近的一个等待唤醒的节点</span>        <span class="hljs-keyword">for</span> (Node t = tail; t != <span class="hljs-keyword">null</span> &amp;&amp; t != node; t = t.prev)            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)                s = t;    &#125;    <span class="hljs-comment">//执行唤醒操作</span>    <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)        LockSupport.unpark(s.thread);&#125;</code></pre></div><p>相比而言，锁的释放操作就简单很多了，代码也比较少。</p><p><strong>总结</strong></p><p>以上就是AQS独占锁的获取与释放过程，大致思想很简单，就是尝试去获取锁，如果失败就加入一个队列中挂起。释放锁时，如果队列中有等待的线程就进行唤醒。但如果一步一步看源码，会发现细节非常多，很多地方很难搞明白，我自己也是反反复复学习很久才有点心得，但也不敢说已经研究通了AQS，甚至不敢说我上面的研究成果就是对的，只是写篇文章总结一下，跟同行交流交流心得。</p><p>除了独占锁，后面还会产出AQS一系列的文章，包括共享锁，条件队列的实现原理等。</p><p><strong>三、共享锁</strong></p><p><strong>执行过程概述</strong></p><p>获取锁的过程：</p><ol><li>当线程调用acquireShared()申请获取锁资源时，如果成功，则进入临界区。</li><li>当获取锁失败时，则创建一个共享类型的节点并进入一个FIFO等待队列，然后被挂起等待唤醒。</li><li>当队列中的等待线程被唤醒以后就重新尝试获取锁资源，如果成功则<strong>唤醒后面还在等待的共享节点并把该唤醒事件传递下去，即会依次唤醒在该节点后面的所有共享节点</strong>，然后进入临界区，否则继续挂起等待。</li></ol><p>释放锁过程：</p><p>当线程调用releaseShared()进行锁资源释放时，如果释放成功，则唤醒队列中等待的节点，如果有的话。</p><p><strong>源码深入分析</strong></p><p>基于上面所说的共享锁执行流程，我们接下来看下源码实现逻辑：</p><p>首先来看下获取锁的方法acquireShared()，如下</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;    <span class="hljs-comment">//尝试获取共享锁，返回值小于0表示获取失败</span>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)        <span class="hljs-comment">//执行获取锁失败以后的方法</span>        doAcquireShared(arg);&#125;</code></pre></div><p>这里tryAcquireShared()方法是留给用户去实现具体的获取锁逻辑的。关于该方法的实现有两点需要特别说明：</p><p><strong>一、该方法必须自己检查当前上下文是否支持获取共享锁，如果支持再进行获取。</strong></p><p><strong>二、该方法返回值是个重点。其一、由上面的源码片段可以看出返回值小于0表示获取锁失败，需要进入等待队列。其二、如果返回值等于0表示当前线程获取共享锁成功，但它后续的线程是无法继续获取的，也就是不需要把它后面等待的节点唤醒。最后、如果返回值大于0，表示当前线程获取共享锁成功且它后续等待的节点也有可能继续获取共享锁成功，也就是说此时需要把后续节点唤醒让它们去尝试获取共享锁。</strong></p><p>有了上面的约定，我们再来看下doAcquireShared方法的实现：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//参数不多说，就是传给acquireShared()的参数</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;    <span class="hljs-comment">//添加等待节点的方法跟独占锁一样，唯一区别就是节点类型变为了共享型，不再赘述</span>    <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-keyword">final</span> Node p = node.predecessor();            <span class="hljs-comment">//表示前面的节点已经获取到锁，自己会尝试获取锁</span>            <span class="hljs-keyword">if</span> (p == head) &#123;                <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);                <span class="hljs-comment">//注意上面说的， 等于0表示不用唤醒后继节点，大于0需要</span>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;                    <span class="hljs-comment">//这里是重点，获取到锁以后的唤醒操作，后面详细说</span>                    setHeadAndPropagate(node, r);                    p.next = <span class="hljs-keyword">null</span>;                    <span class="hljs-comment">//如果是因为中断醒来则设置中断标记位</span>                    <span class="hljs-keyword">if</span> (interrupted)                        selfInterrupt();                    failed = <span class="hljs-keyword">false</span>;                    <span class="hljs-keyword">return</span>;                &#125;            &#125;            <span class="hljs-comment">//挂起逻辑跟独占锁一样，不再赘述</span>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                    parkAndCheckInterrupt())                interrupted = <span class="hljs-keyword">true</span>;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">//获取失败的取消逻辑跟独占锁一样，不再赘述</span>        <span class="hljs-keyword">if</span> (failed)            cancelAcquire(node);    &#125;&#125;</code></pre></div><p>独占锁模式获取成功以后设置头结点然后返回中断状态，结束流程。而共享锁模式获取成功以后，调用了setHeadAndPropagate方法，从方法名就可以看出除了设置新的头结点以外还有一个传递动作，一起看下代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//两个入参，一个是当前成功获取共享锁的节点，一个就是tryAcquireShared方法的返回值，注意上面说的，它可能大于0也可能等于0</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> propagate)</span> </span>&#123;    Node h = head; <span class="hljs-comment">//记录当前头节点</span>    <span class="hljs-comment">//设置新的头节点，即把当前获取到锁的节点设置为头节点</span>    <span class="hljs-comment">//注：这里是获取到锁之后的操作，不需要并发控制</span>    setHead(node);    <span class="hljs-comment">//这里意思有两种情况是需要执行唤醒操作</span>    <span class="hljs-comment">//1.propagate &gt; 0 表示调用方指明了后继节点需要被唤醒</span>    <span class="hljs-comment">//2.头节点后面的节点需要被唤醒（waitStatus&lt;0），不论是老的头结点还是新的头结点</span>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||            (h = head) == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;        Node s = node.next;        <span class="hljs-comment">//如果当前节点的后继节点是共享类型获取没有后继节点，则进行唤醒</span>        <span class="hljs-comment">//这里可以理解为除非明确指明不需要唤醒（后继等待节点是独占类型），否则都要唤醒</span>        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.isShared())            <span class="hljs-comment">//后面详细说</span>            doReleaseShared();    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHead</span><span class="hljs-params">(Node node)</span> </span>&#123;    head = node;    node.thread = <span class="hljs-keyword">null</span>;    node.prev = <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p>最终的唤醒操作也很复杂，专门拿出来分析一下：</p><p><strong>注：这个唤醒操作在releaseShare()方法里也会调用。</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-comment">//唤醒操作由头结点开始，注意这里的头节点已经是上面新设置的头结点了</span>        <span class="hljs-comment">//其实就是唤醒上面新获取到共享锁的节点的后继节点</span>        Node h = head;        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;            <span class="hljs-keyword">int</span> ws = h.waitStatus;            <span class="hljs-comment">//表示后继节点需要被唤醒</span>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;                <span class="hljs-comment">//这里需要控制并发，因为入口有setHeadAndPropagate跟release两个，避免两次unpark</span>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))                    <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">//执行唤醒操作 </span>                unparkSuccessor(h);            &#125;            <span class="hljs-comment">//如果后继节点暂时不需要唤醒，则把当前节点状态设置为PROPAGATE确保以后可以传递下去</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;                    !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))                <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">//如果头结点没有发生变化，表示设置完成，退出循环</span>        <span class="hljs-comment">//如果头结点发生变化，比如说其他线程获取到了锁，为了使自己的唤醒动作可以传递，必须进行重试</span>        <span class="hljs-keyword">if</span> (h == head)            <span class="hljs-keyword">break</span>;    &#125;&#125;</code></pre></div><p>接下来看下释放共享锁的过程：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;    <span class="hljs-comment">//尝试释放共享锁</span>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;        <span class="hljs-comment">//唤醒过程，详情见上面分析</span>        doReleaseShared();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre></div><p><strong>注：上面的setHeadAndPropagate()方法表示等待队列中的线程成功获取到共享锁，这时候它需要唤醒它后面的共享节点（如果有），但是当通过releaseShared（）方法去释放一个共享锁的时候，接下来等待独占锁跟共享锁的线程都可以被唤醒进行尝试获取。</strong></p><p><strong>总结</strong></p><p>跟独占锁相比，共享锁的主要特征在于当一个在等待队列中的共享节点成功获取到锁以后（它获取到的是共享锁），既然是共享，那它必须要依次唤醒后面所有可以跟它一起共享当前锁资源的节点，毫无疑问，这些节点必须也是在等待共享锁（这是大前提，如果等待的是独占锁，那前面已经有一个共享节点获取锁了，它肯定是获取不到的）。当共享锁被释放的时候，可以用读写锁为例进行思考，当一个读锁被释放，此时不论是读锁还是写锁都是可以竞争资源的。</p>]]></content>
    
    
    <categories>
      
      <category>语言相关</category>
      
      <category>Java进阶</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池介绍</title>
    <link href="/2021/05/31/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/05/31/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p><strong>线程池的实现原理</strong> </p><p>当向线程池提交任务后，线程池会按下图所示流程去处理这个任务：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210531065006.png" srcset="/img/loading.gif" alt="image-20210531065005577"></p><p>1、线程池判断<strong>核心线程池</strong>里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</p><p>2、线程池判断<strong>工作队列</strong>是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</p><p>3、线程池判断<strong>线程池</strong>的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给<strong>饱和策略</strong>来处理这个任务。</p><p>ThreadPoolExecutor执行execute()方法的示意图如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210531065038.png" srcset="/img/loading.gif" alt="image-20210531065038144"></p><p>根据上图可以看出，ThreadPoolExector 执行 execute 方法分以下4种情况。</p><p>1、如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</p><p>2、如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</p><p>3、如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。</p><p>4、如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。根据不同的拒绝策略去处理。</p><p>ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。</p><p>在ThreadPoolExecutor完成预热之后（当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。</p><p><strong>工作线程</strong>：线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会循环获取工作队列里的任务来执行。</p><p><strong>线程池的使用</strong></p><p><strong>线程池的创建</strong></p><p>我们可以通过 ThreadPoolExecutor 来创建一个线程池。ThreadPoolExecutor有4个构造函数，简单的看下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 构造函数1</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span> maximumPoolSize,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span> keepAliveTime,</span></span><span class="hljs-function"><span class="hljs-params">TimeUnit unit,</span></span><span class="hljs-function"><span class="hljs-params">BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;<span class="hljs-comment">// ... 省略</span>&#125;<span class="hljs-comment">// 构造函数2</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span> maximumPoolSize,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span> keepAliveTime,</span></span><span class="hljs-function"><span class="hljs-params">TimeUnit unit,</span></span><span class="hljs-function"><span class="hljs-params">BlockingQueue&lt;Runnable&gt; workQueue,</span></span><span class="hljs-function"><span class="hljs-params">ThreadFactory threadFactory)</span> </span>&#123;<span class="hljs-comment">// ... 省略 </span>&#125;<span class="hljs-comment">// 构造函数3</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span> maximumPoolSize,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span> keepAliveTime,</span></span><span class="hljs-function"><span class="hljs-params">TimeUnit unit,</span></span><span class="hljs-function"><span class="hljs-params">BlockingQueue&lt;Runnable&gt; workQueue,</span></span><span class="hljs-function"><span class="hljs-params">RejectedExecutionHandler handler)</span> </span>&#123;<span class="hljs-comment">// ... 省略 </span>&#125; <span class="hljs-comment">// 构造函数4</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span> maximumPoolSize,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span> keepAliveTime,</span></span><span class="hljs-function"><span class="hljs-params">TimeUnit unit,</span></span><span class="hljs-function"><span class="hljs-params">BlockingQueue&lt;Runnable&gt; workQueue,</span></span><span class="hljs-function"><span class="hljs-params">ThreadFactory threadFactory,</span></span><span class="hljs-function"><span class="hljs-params">RejectedExecutionHandler handler)</span> </span>&#123;<span class="hljs-comment">// ... 省略 </span>&#125;</code></pre></div><p><strong>1、corePoolSize（线程池的基本大小）</strong>：当提交一个任务到线程池时，如果当前 poolSize &lt; corePoolSize 时，线程池会创建一个线程来执行任务，<strong>即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建</strong>。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</p><p><strong>2、maximumPoolSize（线程池最大数量）</strong>：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。</p><p><strong>3、keepAliveTime（线程活动保持时间）</strong>：<strong>线程池的工作线程空闲后，保持存活的时间</strong>。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。</p><p><strong>4、TimeUnit（线程活动保持时间的单位）</strong>：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。</p><p><strong>5、workQueue（任务队列）</strong>：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列：</p><ul><li>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。</li><li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li><li>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</li></ul><p><strong>6、threadFactory：</strong>用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线程设置有意义的名字，代码如下。</p><p>  new ThreadFactoryBuilder().setNameFormat(“XX-task-%d”).build();  </p><p><strong>7、RejectExecutionHandler（饱和策略）</strong>：队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略<strong>默认情况下是AbortPolicy，表示无法处理新任务时抛出异常</strong>。在JDK 1.5中Java线程池框架提供了以下4种策略：</p><ol><li>AbortPolicy：直接抛出异常。</li><li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li><li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li><li>DiscardPolicy：不处理，丢弃掉。</li></ol><p>当然，也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。</p><p><strong>向线程池提交任务</strong></p><p>可以使用两个方法向线程池提交任务，分别为 execute() 和 submit() 方法。这两个方法的区别是：execute用于提交不需要返回值的任务，submit()方法用于提交需要返回值的任务。</p><ul><li><strong>execute()</strong></li></ul><p>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。</p><div class="hljs"><pre><code class="hljs java">threadsPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// ...</span>&#125;&#125;);</code></pre></div><ul><li><strong>submit()</strong></li></ul><p>submit()方法用于提交需要返回值的任务。线程池会返回一个Future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get(long timeout，TimeUnit unit) 方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p><div class="hljs"><pre><code class="hljs java">Future&lt;Object&gt; future = executor.submit(haveReturnValuetask);<span class="hljs-keyword">try</span> &#123;Object s = future.get();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<span class="hljs-comment">// 处理中断异常</span>&#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<span class="hljs-comment">// 处理无法执行任务异常</span>&#125; <span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">// 关闭线程池</span>executor.shutdown();&#125;</code></pre></div><p><strong>关闭线程池</strong></p><p><strong>可以通过调用线程池的</strong> <strong>shutdown</strong> <strong>或</strong> <strong>shutdownNow</strong> <strong>方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt 方法来中断线程，所以**</strong>无法响应中断的任务可能永远无法终止<strong>**。</strong></p><p>但是它们存在一定的区别，shutdownNow 首先将线程池的状态设置成 STOP，然后尝试停止所有的<strong>正在执行或暂停任务的线程</strong>，并返回等待执行任务的列表，而 shutdown 只是将线程池的状态设置成 SHUTDOWN 状态，然后中断所有<strong>没有正在执行任务的线程</strong>。</p><p>只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。</p><p>至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p><p><strong>合理地配置线程池</strong></p><p>要想合理地配置线程池，就必须首先分析其任务特性，可以从以下几个角度来分析：</p><p>1、任务的性质：CPU密集型任务、IO密集型任务、混合型任务；</p><p>2、任务的优先级：高、中、低；</p><p>3、任务的执行时间：长、中、短；</p><p>4、任务的依赖性：是否依赖其他系统资源，如数据库连接。</p><p>性质不同的任务可以用不同规模的线程池分开处理。</p><ul><li>CPU密集型任务（需要给CPU更多的计算时间）应配置尽可能小的线程。</li><li>IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程。</li><li>混合型的任务，如果可以将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是很大，那么分解后执行的吞吐量将高于串行的吞吐量。</li></ul><p><strong>线程池的监控</strong></p><p>如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以根据线程池的使用状况快速定位问题。可以通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性：</p><p>1、taskCount：线程池需要执行的任务数量；</p><p>2、completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount；</p><p>3、largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过；</p><p>4、getPoolSize()：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。</p><p>5、getActiveCount()：获取活动的线程数。</p><p><strong>线程池的源码解析–总览</strong></p><p>java 线程池几个相关类的继承结构：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210531065917.png" srcset="/img/loading.gif" alt="image-20210531065917068"></p><p>先简单说说这个继承结构，Executor 位于最顶层，也是最简单的，就一个 execute(Runnable runnable) 接口方法定义。</p><p>ExecutorService 也是接口，在 Executor 接口的基础上添加了很多的接口方法，所以<strong>一般来说我们会使用这个接口</strong>。</p><p>然后再下来一层是 AbstractExecutorService，从名字我们就知道，这是抽象类，这里实现了非常有用的一些方法供子类直接使用，之后我们再细说。</p><p>然后才到我们的重点部分 ThreadPoolExecutor 类，这个类提供了关于线程池所需的非常丰富的功能。</p><p>另外，我们还涉及到下图中的这些类：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210531065954.png" srcset="/img/loading.gif" alt="image-20210531065954834"></p><p>同在并发包中的 Executors 类，类名中带字母 s，我们猜到这个是工具类，里面的方法都是静态方法，如以下我们最常用的用于生成 ThreadPoolExecutor 的实例的一些方法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,                              <span class="hljs-number">60L</span>, TimeUnit.SECONDS,                              <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,                          <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                          <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());&#125;</code></pre></div><p>另外，由于线程池支持获取线程执行的结果，所以，引入了 Future 接口，RunnableFuture 继承自此接口，然后我们最需要关心的就是它的实现类 FutureTask。到这里，记住这个概念，在线程池的使用过程中，我们是往线程池提交任务（task），使用过线程池的都知道，我们提交的每个任务是实现了 Runnable 接口的，其实就是先将 Runnable 的任务包装成 FutureTask，然后再提交到线程池。这样，读者才能比较容易记住 FutureTask 这个类名：它首先是一个任务（Task），然后具有 Future 接口的语义，即可以在将来（Future）得到执行的结果。</p><p>当然，线程池中的 BlockingQueue 也是非常重要的概念，如果线程数达到 corePoolSize，我们的每个任务会提交到等待队列中，等待线程池中的线程来取任务并执行。这里的 BlockingQueue 通常我们使用其实现类 LinkedBlockingQueue、ArrayBlockingQueue 和 SynchronousQueue，每个实现类都有不同的特征，使用场景之后会慢慢分析。</p><p>把事情说完整：除了上面说的这些类外，还有一个很重要的类，就是定时任务实现类 ScheduledThreadPoolExecutor，它继承自本文要重点讲解的 ThreadPoolExecutor，用于实现定时执行。不过本文不会介绍它的实现，我相信读者看完本文后可以比较容易地看懂它的源码。</p><p><strong>Executor 接口</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Executor</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span></span>;&#125;</code></pre></div><p>我们可以看到 Executor 接口非常简单，就一个 void execute(Runnable command) 方法，代表提交一个任务。为了让大家理解 java 线程池的整个设计方案，我会按照 Doug Lea 的设计思路来多说一些相关的东西。</p><p>我们经常这样启动一个线程：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable()&#123;<span class="hljs-comment">// do something</span>&#125;).start();</code></pre></div><p>用了线程池 Executor 后就可以像下面这么使用：</p><div class="hljs"><pre><code class="hljs java">Executor executor = anExecutor;executor.execute(<span class="hljs-keyword">new</span> RunnableTask1());executor.execute(<span class="hljs-keyword">new</span> RunnableTask2());</code></pre></div><p>如果我们希望线程池同步执行每一个任务，我们可以这么实现这个接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPerTaskExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Executor</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<span class="hljs-keyword">new</span> Thread(r).start(); <span class="hljs-comment">// 每个任务都用一个新的线程来执行</span>&#125;&#125;</code></pre></div><p>我们再来看下怎么组合两个 Executor 来使用，下面这个实现是将所有的任务都加到一个 queue 中，然后从 queue 中取任务，交给真正的执行器执行，这里采用 synchronized 进行并发控制：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SerialExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Executor</span> </span>&#123;<span class="hljs-comment">// 任务队列</span><span class="hljs-keyword">final</span> Queue&lt;Runnable&gt; tasks = <span class="hljs-keyword">new</span> ArrayDeque&lt;Runnable&gt;();<span class="hljs-comment">// 这个才是真正的执行器</span><span class="hljs-keyword">final</span> Executor executor;<span class="hljs-comment">// 当前正在执行的任务</span>Runnable active;<span class="hljs-comment">// 初始化的时候，指定执行器</span>SerialExecutor(Executor executor) &#123;<span class="hljs-keyword">this</span>.executor = executor;&#125;<span class="hljs-comment">// 添加任务到线程池: 将任务添加到任务队列，scheduleNext 触发执行器去任务队列取任务</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Runnable r)</span> </span>&#123;tasks.offer(<span class="hljs-keyword">new</span> Runnable() &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">try</span> &#123;r.run();&#125; <span class="hljs-keyword">finally</span> &#123;scheduleNext();&#125;&#125;&#125;);<span class="hljs-keyword">if</span> (active == <span class="hljs-keyword">null</span>) &#123;scheduleNext();&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleNext</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span> ((active = tasks.poll()) != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 具体的执行转给真正的执行器 executor</span>executor.execute(active);&#125;&#125;&#125;</code></pre></div><p>当然了，Executor 这个接口只有提交任务的功能，太简单了，我们想要更丰富的功能，比如我们想知道执行结果、我们想知道当前线程池有多少个线程活着、已经完成了多少任务等等，这些都是这个接口的不足的地方。接下来我们要介绍的是继承自 Executor 接口的 ExecutorService 接口，这个接口提供了比较丰富的功能，也是我们最常使用到的接口。</p><p><strong>ExecutorService</strong></p><p>一般我们定义一个线程池的时候，往往都是使用这个接口：</p><div class="hljs"><pre><code class="hljs java">ExecutorService executor = Executors.newFixedThreadPool(args...); ExecutorService executor = Executors.newCachedThreadPool(args...);</code></pre></div><p>因为这个接口中定义的一系列方法大部分情况下已经可以满足我们的需要了。</p><p>那么我们简单初略地来看一下这个接口中都有哪些方法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Executor</span> </span>&#123;<span class="hljs-comment">// 关闭线程池，已提交的任务继续执行，不接受继续提交新任务</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 关闭线程池，尝试停止正在执行的所有任务，不接受继续提交新任务</span><span class="hljs-comment">// 它和前面的方法相比，加了一个单词“now”，区别在于它会去停止当前正在进行的任务</span><span class="hljs-function">List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 线程池是否已关闭</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isShutdown</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 如果调用了 shutdown() 或 shutdownNow() 方法后，所有任务结束了，那么返回true</span><span class="hljs-comment">// 这个方法必须在调用shutdown或shutdownNow方法之后调用才会返回true</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTerminated</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 等待所有任务完成，并设置超时时间</span><span class="hljs-comment">// 我们这么理解，实际应用中是，先调用 shutdown 或 shutdownNow，</span><span class="hljs-comment">// 然后再调这个方法等待所有的线程真正地完成，返回值意味着有没有超时</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitTermination</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> InterruptedException</span>;<span class="hljs-comment">// 提交一个 Callable 任务</span>&lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span></span>;<span class="hljs-comment">// 提交一个 Runnable 任务，第二个参数将会放到 Future 中，作为返回值，</span><span class="hljs-comment">// 因为 Runnable 的 run 方法本身并不返回任何东西</span>&lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Runnable task, T result)</span></span>;<span class="hljs-comment">// 提交一个 Runnable 任务</span>Future&lt;?&gt; submit(Runnable task);<span class="hljs-comment">// 执行所有任务，返回 Future 类型的一个 list</span>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)<span class="hljs-keyword">throws</span> InterruptedException;<span class="hljs-comment">// 也是执行所有任务，但是这里设置了超时时间</span>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="hljs-keyword">long</span> timeout, TimeUnit unit)<span class="hljs-keyword">throws</span> InterruptedException;<span class="hljs-comment">// 只有其中的一个任务结束了，就可以返回，返回执行完的那个任务的结果</span>&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;<span class="hljs-comment">// 同上一个方法，只有其中的一个任务结束了，就可以返回，返回执行完的那个任务的结果，</span><span class="hljs-comment">// 不过这个带超时，超过指定的时间，抛出 TimeoutException 异常</span>&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;&#125;</code></pre></div><p>这些方法都很好理解，一个简单的线程池主要就是这些功能，能提交任务，能获取结果，能关闭线程池，这也是为什么我们经常用这个接口的原因。</p><p><strong>FutureTask</strong></p><p>在继续往下层介绍 ExecutorService 的实现类之前，我们先来说说相关的类 FutureTask。</p><p>Future -&gt; RunnableFuture -&gt; FutureTask</p><p>Runnable -&gt; RunnableFuture</p><p>FutureTask 通过 RunnableFuture 间接实现了 Runnable 接口，</p><p>所以每个 Runnable 通常都先包装成 FutureTask，</p><p>然后调用 executor.execute(Runnable command) 将其提交给线程池</p><p>我们知道，Runnable 的 void run() 方法是没有返回值的，所以，通常如果我们需要的话，会在 submit 中指定第二个参数作为返回值：</p><div class="hljs"><pre><code class="hljs java">&lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Runnable task, T result)</span></span>;</code></pre></div><p>其实到时候会通过这两个参数，将其包装成 Callable。</p><p>Callable 也是因为线程池的需要，所以才有了这个接口。它和 Runnable 的区别在于 run() 没有返回值，而 Callable 的 call() 方法有返回值，同时，如果运行出现异常，call() 方法会抛出异常。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractExecutorService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExecutorService</span> </span>&#123;    <span class="hljs-comment">// RunnableFuture 是用于获取执行结果的，我们常用它的子类 FutureTask</span>    <span class="hljs-comment">// 下面两个 newTaskFor 方法用于将我们的任务包装成 FutureTask 提交到线程池中执行</span>    <span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">RunnableFuture&lt;T&gt; <span class="hljs-title">newTaskFor</span><span class="hljs-params">(Runnable runnable, T value)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FutureTask&lt;T&gt;(runnable, value);    &#125;    <span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">RunnableFuture&lt;T&gt; <span class="hljs-title">newTaskFor</span><span class="hljs-params">(Callable&lt;T&gt; callable)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FutureTask&lt;T&gt;(callable);    &#125;    <span class="hljs-comment">// 提交任务</span>    <span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;        <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        <span class="hljs-comment">// 1. 将任务包装成 FutureTask</span>        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-keyword">null</span>);        <span class="hljs-comment">// 2. 交给执行器执行，execute 方法由具体的子类来实现</span>        <span class="hljs-comment">// 前面也说了，FutureTask 间接实现了Runnable 接口。</span>        execute(ftask);        <span class="hljs-keyword">return</span> ftask;    &#125;    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Runnable task, T result)</span> </span>&#123;        <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        <span class="hljs-comment">// 1. 将任务包装成 FutureTask</span>        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);        <span class="hljs-comment">// 2. 交给执行器执行</span>        execute(ftask);        <span class="hljs-keyword">return</span> ftask;    &#125;    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> </span>&#123;        <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        <span class="hljs-comment">// 1. 将任务包装成 FutureTask</span>        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);        <span class="hljs-comment">// 2. 交给执行器执行</span>        execute(ftask);        <span class="hljs-keyword">return</span> ftask;    &#125;    <span class="hljs-comment">// 此方法目的：将 tasks 集合中的任务提交到线程池执行，任意一个线程执行完后就可以结束了</span>    <span class="hljs-comment">// 第二个参数 timed 代表是否设置超时机制，超时时间为第三个参数，</span>    <span class="hljs-comment">// 如果 timed 为 true，同时超时了还没有一个线程返回结果，那么抛出 TimeoutException 异常</span>    <span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">doInvokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><span class="hljs-function"><span class="hljs-params">                              <span class="hljs-keyword">boolean</span> timed, <span class="hljs-keyword">long</span> nanos)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;        <span class="hljs-keyword">if</span> (tasks == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        <span class="hljs-comment">// 任务数</span>        <span class="hljs-keyword">int</span> ntasks = tasks.size();        <span class="hljs-keyword">if</span> (ntasks == <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();        <span class="hljs-comment">// </span>        List&lt;Future&lt;T&gt;&gt; futures= <span class="hljs-keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(ntasks);        <span class="hljs-comment">// ExecutorCompletionService 不是一个真正的执行器，参数 this 才是真正的执行器</span>        <span class="hljs-comment">// 它对执行器进行了包装，每个任务结束后，将结果保存到内部的一个 completionQueue 队列中</span>        <span class="hljs-comment">// 这也是为什么这个类的名字里面有个 Completion 的原因吧。</span>        ExecutorCompletionService&lt;T&gt; ecs =                <span class="hljs-keyword">new</span> ExecutorCompletionService&lt;T&gt;(<span class="hljs-keyword">this</span>);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 用于保存异常信息，此方法如果没有得到任何有效的结果，那么我们可以抛出最后得到的一个异常</span>            ExecutionException ee = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">long</span> lastTime = timed ? System.nanoTime() : <span class="hljs-number">0</span>;            Iterator&lt;? extends Callable&lt;T&gt;&gt; it = tasks.iterator();            <span class="hljs-comment">// 首先先提交一个任务，后面的任务到下面的 for 循环一个个提交</span>            futures.add(ecs.submit(it.next()));            <span class="hljs-comment">// 提交了一个任务，所以任务数量减 1</span>            --ntasks;            <span class="hljs-comment">// 正在执行的任务数(提交的时候 +1，任务结束的时候 -1)</span>            <span class="hljs-keyword">int</span> active = <span class="hljs-number">1</span>;            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-comment">// ecs 上面说了，其内部有一个 completionQueue 用于保存执行完成的结果</span>                <span class="hljs-comment">// BlockingQueue 的 poll 方法不阻塞，返回 null 代表队列为空</span>                Future&lt;T&gt; f = ecs.poll();                <span class="hljs-comment">// 为 null，说明刚刚提交的第一个线程还没有执行完成</span>                <span class="hljs-comment">// 在前面先提交一个任务，加上这里做一次检查，也是为了提高性能</span>                <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">if</span> (ntasks &gt; <span class="hljs-number">0</span>) &#123;                        --ntasks;                        futures.add(ecs.submit(it.next()));                        ++active;                    &#125;                    <span class="hljs-comment">// 这里是 else if，不是 if。这里说明，没有任务了，同时 active 为 0 说明</span>                    <span class="hljs-comment">// 任务都执行完成了。其实我也没理解为什么这里做一次 break？</span>                    <span class="hljs-comment">// 因为我认为 active 为 0 的情况，必然从下面的 f.get() 返回了</span>                    <span class="hljs-comment">// 2018-02-23 感谢读者 newmicro 的 comment，</span>                    <span class="hljs-comment">// 这里的 active == 0，说明所有的任务都执行失败，那么这里是 for 循环出口</span>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (active == <span class="hljs-number">0</span>)                        <span class="hljs-keyword">break</span>;                    <span class="hljs-comment">// 这里也是 else if。这里说的是，没有任务了，但是设置了超时时间，这里检测是否超时</span>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timed) &#123;                        <span class="hljs-comment">// 带等待的 poll 方法</span>                        f = ecs.poll(nanos, TimeUnit.NANOSECONDS);                        <span class="hljs-comment">// 如果已经超时，抛出 TimeoutException 异常，这整个方法就结束了</span>                        <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TimeoutException();                        <span class="hljs-keyword">long</span> now = System.nanoTime();                        nanos -= now - lastTime;                        lastTime = now;                    &#125;                    <span class="hljs-comment">// 这里是 else。说明，没有任务需要提交，但是池中的任务没有完成，还没有超时(如果设置了超时)</span>                    <span class="hljs-comment">// take() 方法会阻塞，直到有元素返回，说明有任务结束了</span>                    <span class="hljs-keyword">else</span>                        f = ecs.take();                &#125;                <span class="hljs-comment">/*</span><span class="hljs-comment">                * 我感觉上面这一段并不是很好理解，这里简单说下。</span><span class="hljs-comment">                * 1. 首先，这在一个 for 循环中，我们设想每一个任务都没那么快结束，</span><span class="hljs-comment">                * 那么，每一次都会进到第一个分支，进行提交任务，直到将所有的任务都提交了</span><span class="hljs-comment">                * 2. 任务都提交完成后，如果设置了超时，那么 for 循环其实进入了“一直检测是否超时”</span><span class="hljs-comment">                这件事情上</span><span class="hljs-comment">                * 3. 如果没有设置超时机制，那么不必要检测超时，那就会阻塞在 ecs.take() 方法上，</span><span class="hljs-comment">                等待获取第一个执行结果</span><span class="hljs-comment">                * 4. 如果所有的任务都执行失败，也就是说 future 都返回了，</span><span class="hljs-comment">                但是 f.get() 抛出异常，那么从 active == 0 分支出去(感谢 newmicro 提出)</span><span class="hljs-comment">                // 当然，这个需要看下面的 if 分支。</span><span class="hljs-comment">                */</span>                <span class="hljs-comment">// 有任务结束了</span>                <span class="hljs-keyword">if</span> (f != <span class="hljs-keyword">null</span>) &#123;                    --active;                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-comment">// 返回执行结果，如果有异常，都包装成 ExecutionException</span>                        <span class="hljs-keyword">return</span> f.get();                    &#125; <span class="hljs-keyword">catch</span> (ExecutionException eex) &#123;                        ee = eex;                    &#125; <span class="hljs-keyword">catch</span> (RuntimeException rex) &#123;                        ee = <span class="hljs-keyword">new</span> ExecutionException(rex);                    &#125;                &#125;            &#125;<span class="hljs-comment">// 注意看 for 循环的范围，一直到这里</span>            <span class="hljs-keyword">if</span> (ee == <span class="hljs-keyword">null</span>)                ee = <span class="hljs-keyword">new</span> ExecutionException();            <span class="hljs-keyword">throw</span> ee;        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">// 方法退出之前，取消其他的任务</span>            <span class="hljs-keyword">for</span> (Future&lt;T&gt; f : futures)                f.cancel(<span class="hljs-keyword">true</span>);        &#125;    &#125;    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> doInvokeAny(tasks, <span class="hljs-keyword">false</span>, <span class="hljs-number">0</span>);        &#125; <span class="hljs-keyword">catch</span> (TimeoutException cannotHappen) &#123;            <span class="hljs-keyword">assert</span> <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><span class="hljs-function"><span class="hljs-params">                           <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;        <span class="hljs-keyword">return</span> doInvokeAny(tasks, <span class="hljs-keyword">true</span>, unit.toNanos(timeout));    &#125;    <span class="hljs-comment">// 执行所有的任务，返回任务结果。</span>    <span class="hljs-comment">// 先不要看这个方法，我们先想想，其实我们自己提交任务到线程池，也是想要线程池执行所有的任务</span>    <span class="hljs-comment">// 只不过，我们是每次 submit 一个任务，这里以一个集合作为参数提交</span>    <span class="hljs-keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)            <span class="hljs-keyword">throws</span> InterruptedException &#123;        <span class="hljs-keyword">if</span> (tasks == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        List&lt;Future&lt;T&gt;&gt; futures = <span class="hljs-keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());        <span class="hljs-keyword">boolean</span> done = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 这个很简单</span>            <span class="hljs-keyword">for</span> (Callable&lt;T&gt; t : tasks) &#123;                <span class="hljs-comment">// 包装成 FutureTask</span>                RunnableFuture&lt;T&gt; f = newTaskFor(t);                futures.add(f);                <span class="hljs-comment">// 提交任务</span>                execute(f);            &#125;            <span class="hljs-keyword">for</span> (Future&lt;T&gt; f : futures) &#123;                <span class="hljs-keyword">if</span> (!f.isDone()) &#123;                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-comment">// 这是一个阻塞方法，直到获取到值，或抛出了异常</span>                        <span class="hljs-comment">// 这里有个小细节，其实 get 方法签名上是会抛出 InterruptedException 的</span>                        <span class="hljs-comment">// 可是这里没有进行处理，而是抛给外层去了。此异常发生于还没执行完的任务被取消了</span>                        f.get();                    &#125; <span class="hljs-keyword">catch</span> (CancellationException ignore) &#123;                    &#125; <span class="hljs-keyword">catch</span> (ExecutionException ignore) &#123;                    &#125;                &#125;            &#125;            done = <span class="hljs-keyword">true</span>;            <span class="hljs-comment">// 这个方法返回，不像其他的场景，返回 List&lt;Future&gt;，其实执行结果还没出来</span>            <span class="hljs-comment">// 这个方法返回是真正的返回，任务都结束了</span>            <span class="hljs-keyword">return</span> futures;        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">// 为什么要这个？就是上面说的有异常的情况</span>            <span class="hljs-keyword">if</span> (!done)                <span class="hljs-keyword">for</span> (Future&lt;T&gt; f : futures)                    f.cancel(<span class="hljs-keyword">true</span>);        &#125;    &#125;    <span class="hljs-comment">// 带超时的 invokeAll，我们找不同吧</span>    <span class="hljs-keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                                         <span class="hljs-keyword">long</span> timeout, TimeUnit unit)            <span class="hljs-keyword">throws</span> InterruptedException &#123;        <span class="hljs-keyword">if</span> (tasks == <span class="hljs-keyword">null</span> || unit == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);        List&lt;Future&lt;T&gt;&gt; futures = <span class="hljs-keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());        <span class="hljs-keyword">boolean</span> done = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span> (Callable&lt;T&gt; t : tasks)                futures.add(newTaskFor(t));            <span class="hljs-keyword">long</span> lastTime = System.nanoTime();            Iterator&lt;Future&lt;T&gt;&gt; it = futures.iterator();            <span class="hljs-comment">// 提交一个任务，检测一次是否超时</span>            <span class="hljs-keyword">while</span> (it.hasNext()) &#123;                execute((Runnable)(it.next()));                <span class="hljs-keyword">long</span> now = System.nanoTime();                nanos -= now - lastTime;                lastTime = now;                <span class="hljs-comment">// 超时</span>                <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>)                    <span class="hljs-keyword">return</span> futures;            &#125;            <span class="hljs-keyword">for</span> (Future&lt;T&gt; f : futures) &#123;                <span class="hljs-keyword">if</span> (!f.isDone()) &#123;                    <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>)                        <span class="hljs-keyword">return</span> futures;                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-comment">// 调用带超时的 get 方法，这里的参数 nanos 是剩余的时间，</span>                        <span class="hljs-comment">// 因为上面其实已经用掉了一些时间了</span>                        f.get(nanos, TimeUnit.NANOSECONDS);                    &#125; <span class="hljs-keyword">catch</span> (CancellationException ignore) &#123;                    &#125; <span class="hljs-keyword">catch</span> (ExecutionException ignore) &#123;                    &#125; <span class="hljs-keyword">catch</span> (TimeoutException toe) &#123;                        <span class="hljs-keyword">return</span> futures;                    &#125;                    <span class="hljs-keyword">long</span> now = System.nanoTime();                    nanos -= now - lastTime;                    lastTime = now;                &#125;            &#125;            done = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">return</span> futures;        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (!done)                <span class="hljs-keyword">for</span> (Future&lt;T&gt; f : futures)                    f.cancel(<span class="hljs-keyword">true</span>);        &#125;    &#125;&#125;</code></pre></div><p>到这里，我们发现，这个抽象类包装了一些基本的方法，可是像 submit、invokeAny、invokeAll 等方法，它们都没有真正开启线程来执行任务，它们都只是在方法内部调用了 execute 方法，所以最重要的 execute(Runnable runnable) 方法还没出现，需要等具体执行器来实现这个最重要的部分，这里我们要说的就是 ThreadPoolExecutor 类了。</p><p>鉴于本文的篇幅，我觉得看到这里的读者应该已经不多了，快餐文化使然啊！我写的每篇文章都力求让读者可以通过我的一篇文章而记住所有的相关知识点，所以篇幅不免长了些。其实，工作了很多年的话，会有一个感觉，比如说线程池，即使看了 20 篇各种总结，也不如一篇长文实实在在讲解清楚每一个知识点，有点少即是多，多即是少的意味了。</p><p><strong>ThreadPoolExecutor</strong></p><p>ThreadPoolExecutor 是 JDK 中的线程池实现，这个类实现了一个线程池需要的各个方法，它实现了任务提交、线程管理、监控等等方法。</p><p>我们可以基于它来进行业务上的扩展，以实现我们需要的其他功能，比如实现定时任务的类 ScheduledThreadPoolExecutor 就继承自 ThreadPoolExecutor。当然，这不是本文关注的重点，下面，还是赶紧进行源码分析吧。</p><p>首先，我们来看看线程池实现中的几个概念和处理流程。</p><p>我们先回顾下提交任务的几个方法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-keyword">null</span>);execute(ftask);<span class="hljs-keyword">return</span> ftask;&#125;<span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Runnable task, T result)</span> </span>&#123;<span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);execute(ftask);<span class="hljs-keyword">return</span> ftask;&#125;<span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> </span>&#123;<span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();RunnableFuture&lt;T&gt; ftask = newTaskFor(task);execute(ftask);<span class="hljs-keyword">return</span> ftask;&#125;</code></pre></div><p>一个最基本的概念是，submit 方法中，参数是 Runnable 类型（也有Callable 类型），这个参数不是用于 new Thread(runnable).start() 中的，此处的这个参数不是用于启动线程的，这里指的是任务，任务要做的事情是 run() 方法里面定义的或 Callable 中的 call() 方法里面定义的。</p><p>初学者往往会搞混这个，因为 Runnable 总是在各个地方出现，经常把一个 Runnable 包到另一个 Runnable 中。请把它想象成有个 Task 接口，这个接口里面有一个 run() 方法（我想作者只是不想因为这个再定义一个完全可以用 Runnable 来代替的接口，Callable 的出现，完全是因为 Runnable 不能满足需要）。</p><p>我们回过神来继续往下看，我画了一个简单的示意图来描述线程池中的一些主要的构件：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210531070538.png" srcset="/img/loading.gif" alt="image-20210531070538467"></p><p>当然，上图没有考虑队列是否有界，提交任务时队列满了怎么办？什么情况下会创建新的线程？提交任务时线程池满了怎么办？空闲线程怎么关掉？这些问题下面我们会一一解决。</p><p>我们经常会使用 Executors 这个工具类来快速构造一个线程池，对于初学者而言，这种工具类是很有用的，开发者不需要关注太多的细节，只要知道自己需要一个线程池，仅仅提供必需的参数就可以了，其他参数都采用作者提供的默认值。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,                          <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                          <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,                              <span class="hljs-number">60L</span>, TimeUnit.SECONDS,                              <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());&#125;</code></pre></div><p>这里先不说有什么区别，它们最终都会导向这个构造方法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><span class="hljs-function"><span class="hljs-params">                      <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><span class="hljs-function"><span class="hljs-params">                      <span class="hljs-keyword">long</span> keepAliveTime,</span></span><span class="hljs-function"><span class="hljs-params">                      TimeUnit unit,</span></span><span class="hljs-function"><span class="hljs-params">                      BlockingQueue&lt;Runnable&gt; workQueue,</span></span><span class="hljs-function"><span class="hljs-params">                      ThreadFactory threadFactory,</span></span><span class="hljs-function"><span class="hljs-params">                      RejectedExecutionHandler handler)</span> </span>&#123;<span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||maximumPoolSize &lt;= <span class="hljs-number">0</span> ||maximumPoolSize &lt; corePoolSize ||keepAliveTime &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<span class="hljs-comment">// 这几个参数都是必须要有的</span><span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || handler == <span class="hljs-keyword">null</span>)    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;<span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;<span class="hljs-keyword">this</span>.workQueue = workQueue;<span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<span class="hljs-keyword">this</span>.threadFactory = threadFactory;<span class="hljs-keyword">this</span>.handler = handler;&#125;</code></pre></div><p>基本上，上面的构造方法中列出了我们最需要关心的几个属性了，下面逐个介绍下构造方法中出现的这几个属性：</p><ul><li>corePoolSize</li></ul><p>核心线程数，不要抠字眼，反正先记着有这么个属性就可以了。</p><ul><li>maximumPoolSize</li></ul><p>最大线程数，线程池允许创建的最大线程数。</p><ul><li>workQueue</li></ul><p>任务队列，BlockingQueue 接口的某个实现（常使用 ArrayBlockingQueue 和 LinkedBlockingQueue）。</p><ul><li>keepAliveTime</li></ul><p>空闲线程的保活时间，如果某线程的空闲时间超过这个值都没有任务给它做，那么可以被关闭了。注意这个值并不会对所有线程起作用，如果线程池中的线程数少于等于核心线程数 corePoolSize，那么这些线程不会因为空闲太长时间而被关闭，当然，也可以通过调用 allowCoreThreadTimeOut(true)使核心线程数内的线程也可以被回收。</p><ul><li>threadFactory</li></ul><p>用于生成线程，一般我们可以用默认的就可以了。通常，我们可以通过它将我们的线程的名字设置得比较可读一些，如 Message-Thread-1， Message-Thread-2 类似这样。</p><ul><li>handler：</li></ul><p>当线程池已经满了，但是又有新的任务提交的时候，该采取什么策略由这个来指定。有几种方式可供选择，像抛出异常、直接拒绝然后返回等，也可以自己实现相应的接口实现自己的逻辑，这个之后再说。</p><p>除了上面几个属性外，我们再看看其他重要的属性。</p><p>Doug Lea 采用一个 32 位的整数来存放线程池的状态和当前池中的线程数，其中高 3 位用于存放线程池状态，低 29 位表示线程数（即使只有 29 位，也已经不小了，大概 5 亿多，现在还没有哪个机器能起这么多线程的吧）。我们知道，java 语言在整数编码上是统一的，都是采用补码的形式，下面是简单的移位操作和布尔操作，都是挺简单的。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));<span class="hljs-comment">// 这里 COUNT_BITS 设置为 29(32-3)，意味着前三位用于存放线程状态，后29位用于存放线程数</span><span class="hljs-comment">// 很多初学者很喜欢在自己的代码中写很多 29 这种数字，或者某个特殊的字符串，然后分布在各个地方，这是非常糟糕的</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>;<span class="hljs-comment">// 000 11111111111111111111111111111</span><span class="hljs-comment">// 这里得到的是 29 个 1，也就是说线程池的最大线程数是 2^29-1=536870911</span><span class="hljs-comment">// 以我们现在计算机的实际情况，这个数量还是够用的</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<span class="hljs-comment">// 我们说了，线程池的状态存放在高 3 位中</span><span class="hljs-comment">// 运算结果为 111跟29个0：111 00000000000000000000000000000</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<span class="hljs-comment">// 000 00000000000000000000000000000</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHUTDOWN = <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<span class="hljs-comment">// 001 00000000000000000000000000000</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP = <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<span class="hljs-comment">// 010 00000000000000000000000000000</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TIDYING = <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<span class="hljs-comment">// 011 00000000000000000000000000000</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TERMINATED = <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<span class="hljs-comment">// 将整数 c 的低 29 位修改为 0，就得到了线程池的状态</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">runStateOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;<span class="hljs-comment">// 将整数 c 的高 3 为修改为 0，就得到了线程池中的线程数</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ctlOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rs, <span class="hljs-keyword">int</span> wc)</span> </span>&#123; <span class="hljs-keyword">return</span> rs | wc; &#125;<span class="hljs-comment">/*</span><span class="hljs-comment">* Bit field accessors that don't require unpacking ctl.</span><span class="hljs-comment">* These depend on the bit layout and on workerCount being never negative.</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">runStateLessThan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> s)</span> </span>&#123;<span class="hljs-keyword">return</span> c &lt; s;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">runStateAtLeast</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> s)</span> </span>&#123;<span class="hljs-keyword">return</span> c &gt;= s;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRunning</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123;<span class="hljs-keyword">return</span> c &lt; SHUTDOWN;&#125;</code></pre></div><p>上面就是对一个整数的简单的位操作，几个操作方法将会在后面的源码中一直出现，所以读者最好把方法名字和其代表的功能记住，看源码的时候也就不需要来来回回翻了。</p><p>在这里，介绍下线程池中的各个状态和状态变化的转换过程：</p><ul><li>RUNNING：这个没什么好说的，这是最正常的状态：接受新的任务，处理等待队列中的任务</li><li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务</li><li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程</li><li>TIDYING：所有的任务都销毁了，workCount 为     0。线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()</li><li>TERMINATED：terminated()     方法结束后，线程池的状态就会变成这个</li></ul><p>RUNNING 定义为 -1，SHUTDOWN 定义为 0，其他的都比 0 大，所以等于 0 的时候不能提交任务，大于 0 的话，连正在执行的任务也需要中断。</p><p>看了这几种状态的介绍，读者大体也可以猜到十之八九的状态转换了，各个状态的转换过程有以下几种：</p><ul><li>RUNNING -&gt; SHUTDOWN：当调用了     shutdown() 后，会发生这个状态转换，这也是最重要的</li><li>(RUNNING or SHUTDOWN) -&gt;     STOP：当调用 shutdownNow() 后，会发生这个状态转换，这下要清楚 shutDown() 和 shutDownNow() 的区别了</li><li>SHUTDOWN -&gt;     TIDYING：当任务队列和线程池都清空后，会由 SHUTDOWN 转换为 TIDYING</li><li>STOP -&gt; TIDYING：当任务队列清空后，发生这个转换</li><li>TIDYING -&gt; TERMINATED：这个前面说了，当     terminated() 方法结束后</li></ul><p>上面的几个记住核心的就可以了，尤其第一个和第二个。</p><p>另外，我们还要看看一个内部类 Worker，因为 Doug Lea 把线程池中的线程包装成了一个个 Worker，翻译成工人，就是线程池中做任务的线程。所以到这里，我们知道任务是 Runnable（内部叫 task 或 command），线程是 Worker。</p><p>Worker 这里又用到了抽象类 AbstractQueuedSynchronizer。题外话，AQS 在并发中真的是到处出现，而且非常容易使用，写少量的代码就能实现自己需要的同步方式。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span><span class="hljs-class"></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">6138294804551838833L</span>;<span class="hljs-comment">// 这个是真正的线程，任务靠你啦</span><span class="hljs-keyword">final</span> Thread thread;<span class="hljs-comment">// 前面说了，这里的 Runnable 是任务。为什么叫 firstTask？因为在创建线程的时候，如果同时指定了</span><span class="hljs-comment">// 这个线程起来以后需要执行的第一个任务，那么第一个任务就是存放在这里的(线程可不止执行这一个任务)</span><span class="hljs-comment">// 当然了，也可以为 null，这样线程起来了，自己到任务队列（BlockingQueue）中取任务（getTask 方法）就行了</span>Runnable firstTask;<span class="hljs-comment">// 用于存放此线程完全的任务数，注意了，这里用了 volatile，保证可见性</span><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> completedTasks;<span class="hljs-comment">// Worker 只有这一个构造方法，传入 firstTask，也可以传 null</span>Worker(Runnable firstTask) &#123;setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><span class="hljs-keyword">this</span>.firstTask = firstTask;<span class="hljs-comment">// 调用 ThreadFactory 来创建一个新的线程</span><span class="hljs-keyword">this</span>.thread = getThreadFactory().newThread(<span class="hljs-keyword">this</span>);&#125;<span class="hljs-comment">// 这里调用了外部类的 runWorker 方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;runWorker(<span class="hljs-keyword">this</span>);&#125;...<span class="hljs-comment">// 其他几个方法没什么好看的，就是用 AQS 操作，来获取这个线程的执行权，用了独占锁</span>&#125;</code></pre></div><p>前面虽然啰嗦，但是简单。有了上面的这些基础后，我们终于可以看看 ThreadPoolExecutor 的 execute 方法了，前面源码分析的时候也说了，各种方法都最终依赖于 execute 方法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<span class="hljs-comment">// 前面说的那个表示 “线程池状态” 和 “线程数” 的整数</span><span class="hljs-keyword">int</span> c = ctl.get();<span class="hljs-comment">// 如果当前线程数少于核心线程数，那么直接添加一个 worker 来执行任务，</span><span class="hljs-comment">// 创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask)</span><span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<span class="hljs-comment">// 添加任务成功，那么就结束了。提交任务嘛，线程池已经接受了这个任务，这个方法也就可以返回了</span><span class="hljs-comment">// 至于执行的结果，到时候会包装到 FutureTask 中。</span><span class="hljs-comment">// 返回 false 代表线程池不允许提交任务</span><span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))<span class="hljs-keyword">return</span>;c = ctl.get();&#125;<span class="hljs-comment">// 到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了</span><span class="hljs-comment">// 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中 </span><span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<span class="hljs-comment">/* 这里面说的是，如果任务进入了 workQueue，我们是否需要开启新的线程</span><span class="hljs-comment">* 因为线程数在 [0, corePoolSize) 是无条件开启新的线程</span><span class="hljs-comment">* 如果线程数已经大于等于 corePoolSize，那么将任务添加到队列中，然后进到这里</span><span class="hljs-comment">*/</span><span class="hljs-keyword">int</span> recheck = ctl.get();<span class="hljs-comment">// 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略</span><span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))reject(command);<span class="hljs-comment">// 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程</span><span class="hljs-comment">// 到这里，我们知道了，这块代码的真正意图是：担心任务提交到队列中了，但是线程都关闭了</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);&#125;<span class="hljs-comment">// 如果 workQueue 队列满了，那么进入到这个分支</span><span class="hljs-comment">// 以 maximumPoolSize 为界创建新的 worker，</span><span class="hljs-comment">// 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))reject(command);&#125;</code></pre></div><p>对创建线程的错误理解：如果线程数少于 corePoolSize，创建一个线程，如果线程数在 [corePoolSize, maximumPoolSize] 之间那么可以创建线程或复用空闲线程，keepAliveTime 对这个区间的线程有效。</p><p>从上面的几个分支，我们就可以看出，上面的这段话是错误的。</p><p>上面这些一时半会也不可能全部消化搞定，我们先继续往下吧，到时候再回头看几遍。</p><p>这个方法非常重要 addWorker(Runnable firstTask, boolean core) 方法，我们看看它是怎么创建新的线程的：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 第一个参数是准备提交给这个线程执行的任务，之前说了，可以为 null</span><span class="hljs-comment">// 第二个参数为 true 代表使用核心线程数 corePoolSize 作为创建线程的界线，也就说创建这个线程的时候，</span><span class="hljs-comment">// 如果线程池中的线程总数已经达到 corePoolSize，那么不能响应这次创建线程的请求</span><span class="hljs-comment">// 如果是 false，代表使用最大线程数 maximumPoolSize 作为界线</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;    retry:    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-keyword">int</span> c = ctl.get();        <span class="hljs-keyword">int</span> rs = runStateOf(c);        <span class="hljs-comment">// 这个非常不好理解</span>        <span class="hljs-comment">// 如果线程池已关闭，并满足以下条件之一，那么不创建新的 worker：</span>        <span class="hljs-comment">// 1. 线程池状态大于 SHUTDOWN，其实也就是 STOP, TIDYING, 或 TERMINATED</span>        <span class="hljs-comment">// 2. firstTask != null</span>        <span class="hljs-comment">// 3. workQueue.isEmpty()</span>        <span class="hljs-comment">// 简单分析下：</span>        <span class="hljs-comment">// 还是状态控制的问题，当线程池处于 SHUTDOWN 的时候，不允许提交任务，但是已有的任务继续执行</span>        <span class="hljs-comment">// 当状态大于 SHUTDOWN 时，不允许提交任务，且中断正在执行的任务</span>        <span class="hljs-comment">// 多说一句：如果线程池处于 SHUTDOWN，但是 firstTask 为 null，且 workQueue 非空，那么是允许创建 worker 的</span>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span> &amp;&amp; ! workQueue.isEmpty()))            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-keyword">int</span> wc = workerCountOf(c);            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// 如果成功，那么就是所有创建线程前的条件校验都满足了，准备创建线程执行任务了</span>            <span class="hljs-comment">// 这里失败的话，说明有其他线程也在尝试往线程池中创建线程</span>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))                <span class="hljs-keyword">break</span> retry;            <span class="hljs-comment">// 由于有并发，重新再读取一下 ctl</span>            c = ctl.get();            <span class="hljs-comment">// 正常如果是 CAS 失败的话，进到下一个里层的for循环就可以了</span>            <span class="hljs-comment">// 可是如果是因为其他线程的操作，导致线程池的状态发生了变更，如有其他线程关闭了这个线程池</span>            <span class="hljs-comment">// 那么需要回到外层的for循环</span>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)                <span class="hljs-keyword">continue</span> retry;            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span>        &#125;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * 到这里，我们认为在当前这个时刻，可以开始创建线程来执行任务了，</span><span class="hljs-comment">     * 因为该校验的都校验了，至于以后会发生什么，那是以后的事，至少当前是满足条件的</span><span class="hljs-comment">     */</span>    <span class="hljs-comment">// worker 是否已经启动</span>    <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">// 是否已将这个 worker 添加到 workers 这个 HashSet 中</span>    <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;    Worker w = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;        <span class="hljs-comment">// 把 firstTask 传给 worker 的构造方法</span>        w = <span class="hljs-keyword">new</span> Worker(firstTask);        <span class="hljs-comment">// 取 worker 中的线程对象，之前说了，Worker的构造方法会调用 ThreadFactory 来创建一个新的线程</span>        <span class="hljs-keyword">final</span> Thread t = w.thread;        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 这个是整个类的全局锁，持有这个锁才能让下面的操作“顺理成章”，</span>            <span class="hljs-comment">// 因为关闭一个线程池需要这个锁，至少我持有锁的期间，线程池不会被关闭</span>            mainLock.lock();            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">int</span> c = ctl.get();                <span class="hljs-keyword">int</span> rs = runStateOf(c);                <span class="hljs-comment">// 小于 SHUTTDOWN 那就是 RUNNING，这个自不必说，是最正常的情况</span>                <span class="hljs-comment">// 如果等于 SHUTDOWN，前面说了，不接受新的任务，但是会继续执行等待队列中的任务</span>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||(rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;                    <span class="hljs-comment">// worker 里面的 thread 可不能是已经启动的</span>                    <span class="hljs-keyword">if</span> (t.isAlive())                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();                    <span class="hljs-comment">// 加到 workers 这个 HashSet 中</span>                    workers.add(w);                    <span class="hljs-keyword">int</span> s = workers.size();                    <span class="hljs-comment">// largestPoolSize 用于记录 workers 中的个数的最大值</span>                    <span class="hljs-comment">// 因为 workers 是不断增加减少的，通过这个值可以知道线程池的大小曾经达到的最大值</span>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)                        largestPoolSize = s;                    workerAdded = <span class="hljs-keyword">true</span>;                &#125;            &#125; <span class="hljs-keyword">finally</span> &#123;                mainLock.unlock();            &#125;            <span class="hljs-comment">// 添加成功的话，启动这个线程</span>            <span class="hljs-keyword">if</span> (workerAdded) &#123;                <span class="hljs-comment">// 启动线程</span>                t.start();                workerStarted = <span class="hljs-keyword">true</span>;            &#125;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// 如果线程没有启动，需要做一些清理工作，如前面 workCount 加了 1，将其减掉</span>        <span class="hljs-keyword">if</span> (! workerStarted)            addWorkerFailed(w);    &#125;    <span class="hljs-comment">// 返回线程是否启动成功</span>    <span class="hljs-keyword">return</span> workerStarted;&#125;简单看下 addWorkFailed 的处理：<span class="hljs-comment">// workers 中删除掉相应的 worker</span><span class="hljs-comment">// workCount 减 1</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addWorkerFailed</span><span class="hljs-params">(Worker w)</span> </span>&#123;    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;    mainLock.lock();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (w != <span class="hljs-keyword">null</span>)            workers.remove(w);        decrementWorkerCount();        <span class="hljs-comment">// rechecks for termination, in case the existence of this worker was holding up termination</span>        tryTerminate();    &#125; <span class="hljs-keyword">finally</span> &#123;        mainLock.unlock();    &#125;&#125;</code></pre></div><p>到这里，基本上也说完了整个流程，读者这个时候应该回到 execute(Runnable command) 方法，看看各个分支，我把代码贴过来一下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;    <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-comment">// 前面说的那个表示 “线程池状态” 和 “线程数” 的整数</span>    <span class="hljs-keyword">int</span> c = ctl.get();    <span class="hljs-comment">// 如果当前线程数少于核心线程数，那么直接添加一个 worker 来执行任务，</span>    <span class="hljs-comment">// 创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask)</span>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;        <span class="hljs-comment">// 添加任务成功，那么就结束了。提交任务嘛，线程池已经接受了这个任务，这个方法也就可以返回了</span>        <span class="hljs-comment">// 至于执行的结果，到时候会包装到 FutureTask 中。</span>        <span class="hljs-comment">// 返回 false 代表线程池不允许提交任务</span>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))            <span class="hljs-keyword">return</span>;        c = ctl.get();    &#125;    <span class="hljs-comment">// 到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了</span>    <span class="hljs-comment">// 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中</span>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;        <span class="hljs-comment">/* 这里面说的是，如果任务进入了 workQueue，我们是否需要开启新的线程</span><span class="hljs-comment">         * 因为线程数在 [0, corePoolSize) 是无条件开启新的线程</span><span class="hljs-comment">         * 如果线程数已经大于等于 corePoolSize，那么将任务添加到队列中，然后进到这里</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">int</span> recheck = ctl.get();        <span class="hljs-comment">// 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略</span>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))            reject(command);        <span class="hljs-comment">// 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程</span>        <span class="hljs-comment">// 到这里，我们知道了，这块代码的真正意图是：担心任务提交到队列中了，但是线程都关闭了</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)            addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-comment">// 如果 workQueue 队列满了，那么进入到这个分支</span>    <span class="hljs-comment">// 以 maximumPoolSize 为界创建新的 worker，</span>    <span class="hljs-comment">// 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))        reject(command);&#125;</code></pre></div><p>到这里，ThreadPoolExecutor 的源码算是分析结束了。单纯从源码的难易程度来说，ThreadPoolExecutor 的源码还算是比较简单的，只是需要我们静下心来好好看看罢了。</p><p><strong>结束线程池的相关方法</strong></p><p><strong>tryTerminate()</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryTerminate</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-keyword">int</span> c = ctl.get();        <span class="hljs-comment">// 线程池处于Running状态</span>        <span class="hljs-comment">// 线程池已经终止了</span>        <span class="hljs-comment">// 线程池处于ShutDown状态，但是阻塞队列不为空</span>        <span class="hljs-keyword">if</span> (isRunning(c) ||                runStateAtLeast(c, TIDYING) ||                (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))            <span class="hljs-keyword">return</span>;        <span class="hljs-comment">// 执行到这里，就意味着线程池要么处于STOP状态，要么处于SHUTDOWN且阻塞队列为空</span>        <span class="hljs-comment">// 这时如果线程池中还存在线程，则会尝试中断线程</span>        <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// /线程池还有线程，但是队列没有任务了，需要中断唤醒等待任务的线程</span>            <span class="hljs-comment">// （runwoker的时候首先就通过w.unlock设置线程可中断，getTask最后面的catch处理中断）</span>            interruptIdleWorkers(ONLY_ONE);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;        mainLock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 尝试终止线程池</span>            <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;                <span class="hljs-keyword">try</span> &#123;                    terminated();                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-comment">// 线程池状态转为TERMINATED</span>                    ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));                    termination.signalAll();                &#125;                <span class="hljs-keyword">return</span>;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            mainLock.unlock();        &#125;    &#125;&#125;</code></pre></div><p>在关闭线程池的过程中，如果线程池处于STOP状态或者处于SHUDOWN状态且阻塞队列为null，则线程池会调用interruptIdleWorkers()方法中断所有线程，注意ONLY_ONE== true，表示仅中断一个线程。</p><p><strong>interruptIdleWorkers</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> onlyOne)</span> </span>&#123;    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;    mainLock.lock();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">for</span> (Worker w : workers) &#123;            Thread t = w.thread;            <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;                <span class="hljs-keyword">try</span> &#123;                    t.interrupt();                &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;                &#125; <span class="hljs-keyword">finally</span> &#123;                    w.unlock();                &#125;            &#125;            <span class="hljs-keyword">if</span> (onlyOne)                <span class="hljs-keyword">break</span>;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        mainLock.unlock();    &#125;&#125;</code></pre></div><p>onlyOne==true仅终止一个线程，否则终止所有线程。</p><p><strong>线程终止</strong></p><p>线程池ThreadPoolExecutor提供了shutdown()和shutDownNow()用于关闭线程池。</p><p>shutdown()：按过去执行已提交任务的顺序发起一个有序的关闭，但是不接受新任务。</p><p>shutdownNow() :尝试停止所有的活动执行任务、暂停等待任务的处理，并返回等待执行的任务列表。</p><p><strong>shutdown</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;    mainLock.lock();    <span class="hljs-keyword">try</span> &#123;        checkShutdownAccess();        <span class="hljs-comment">// 推进线程状态</span>        advanceRunState(SHUTDOWN);        <span class="hljs-comment">// 中断空闲的线程</span>        interruptIdleWorkers();        <span class="hljs-comment">// 交给子类实现</span>        onShutdown();    &#125; <span class="hljs-keyword">finally</span> &#123;        mainLock.unlock();    &#125;    tryTerminate();&#125;</code></pre></div><p>与shutdown不同，shutdownNow会调用interruptWorkers()方法中断所有线程。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interruptWorkers</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;    mainLock.lock();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">for</span> (Worker w : workers)            w.interruptIfStarted();    &#125; <span class="hljs-keyword">finally</span> &#123;        mainLock.unlock();    &#125;&#125;</code></pre></div><p>同时会调用drainQueue()方法返回等待执行到任务列表。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Runnable&gt; <span class="hljs-title">drainQueue</span><span class="hljs-params">()</span> </span>&#123;    BlockingQueue&lt;Runnable&gt; q = workQueue;    ArrayList&lt;Runnable&gt; taskList = <span class="hljs-keyword">new</span> ArrayList&lt;Runnable&gt;();    q.drainTo(taskList);    <span class="hljs-keyword">if</span> (!q.isEmpty()) &#123;        <span class="hljs-keyword">for</span> (Runnable r : q.toArray(<span class="hljs-keyword">new</span> Runnable[<span class="hljs-number">0</span>])) &#123;            <span class="hljs-keyword">if</span> (q.remove(r))                taskList.add(r);        &#125;    &#125;    <span class="hljs-keyword">return</span> taskList;&#125;</code></pre></div><p><strong>Executors</strong></p><p>这节其实也不是分析 Executors 这个类，因为它仅仅是工具类，它的所有方法都是 static 的。</p><p><strong>1. FixedThreadPool</strong></p><p>创建固定长度的线程池，每次提交任务创建一个线程，直到达到线程池的最大数量，线程池的大小不再变化。</p><p>这个线程池可以创建固定线程数的线程池。特点就是可以重用固定数量线程的线程池。它的构造源码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="hljs-number">0L</span>,                                      TimeUnit.MILLISECONDS,                                       <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()); &#125;</code></pre></div><p>FixedThreadPool运行图如下</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210531071135.png" srcset="/img/loading.gif" alt="image-20210531071135473"></p><p>执行过程如下：</p><p>1.如果当前工作中的线程数量少于corePool的数量，就创建新的线程来执行任务。</p><p>2.当线程池的工作中的线程数量达到了corePool，则将任务加入LinkedBlockingQueue。</p><p>3.线程执行完1中的任务后会从队列中去任务。</p><p>注意LinkedBlockingQueue是无界队列，所以可以一直添加新任务到线程池。</p><p><strong>2. SingleThreadExecutor</strong></p><p>SingleThreadExecutor是使用单个worker线程的Executor。特点是使用单个工作线程执行任务。它的构造源码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService            (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                                    <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));&#125;</code></pre></div><p>SingleThreadExecutor的corePoolSize和maxiumPoolSize都被设置1。</p><p>其他参数均与FixedThreadPool相同，其运行图如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210531071237.png" srcset="/img/loading.gif" alt="image-20210531071237018"></p><p>执行过程如下：</p><p>1.如果当前工作中的线程数量少于corePool的数量，就创建一个新的线程来执行任务。</p><p>2.当线程池的工作中的线程数量达到了corePool，则将任务加入LinkedBlockingQueue。</p><p>3.线程执行完1中的任务后会从队列中去任务。</p><p>注意：由于在线程池中只有一个工作线程，所以任务可以按照添加顺序执行。</p><p> <strong>3. CachedThreadPool</strong></p><p> CachedThreadPool是一个”无限“容量的线程池，它会根据需要创建新线程。特点是可以根据需要来创建新的线程执行任务，没有特定的corePool。下面是它的构造方法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,                                      <span class="hljs-number">60L</span>, TimeUnit.SECONDS,                                      <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());&#125;</code></pre></div><p>CachedThreadPool的corePoolSize被设置为0，即corePool为空；maximumPoolSize被设置为Integer.MAX_VALUE，即maximum是无界的。这里keepAliveTime设置为60秒，意味着空闲的线程最多可以等待任务60秒，否则将被回收。</p><p>CachedThreadPool使用没有容量的SynchronousQueue作为主线程池的工作队列，它是一个没有容量的阻塞队列。每个插入操作必须等待另一个线程的对应移除操作。这意味着，如果主线程提交任务的速度高于线程池中处理任务的速度时，CachedThreadPool会不断创建新线程。极端情况下，CachedThreadPool会因为创建过多线程而耗尽CPU资源。其运行图如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210531071323.png" srcset="/img/loading.gif" alt="image-20210531071323246"></p><p>执行过程如下：</p><p>1.首先执行SynchronousQueue.offer(Runnable task)。如果在当前的线程池中有空闲的线程正在执行SynchronousQueue.poll()，那么主线程执行的offer操作与空闲线程执行的poll操作配对成功，主线程把任务交给空闲线程执行。，execute()方法执行成功，否则执行步骤2</p><p>2.当线程池为空(初始maximumPool为空)或没有空闲线程时，配对失败，将没有线程执行SynchronousQueue.poll操作。这种情况下，线程池会创建一个新的线程执行任务。</p><p>3.在创建完新的线程以后，将会执行poll操作。当步骤2的线程执行完成后，将等待60秒，如果此时主线程提交了一个新任务，那么这个空闲线程将执行新任务，否则被回收。因此长时间不提交任务的CachedThreadPool不会占用系统资源。</p><p>SynchronousQueue是一个不存储元素阻塞队列，每次要进行offer操作时必须等待poll操作，否则不能继续添加元素。</p><p><strong>具体使用案例：</strong></p><p>(1). newCachedThreadPool</p><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。示例代码如下：</p><div class="hljs"><pre><code class="hljs java">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(index * <span class="hljs-number">1000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;                  cachedThreadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;                  <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(index);        &#125;    &#125;);&#125;</code></pre></div><p>线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。</p><p>(2). newFixedThreadPool</p><p>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。示例代码如下：</p><div class="hljs"><pre><code class="hljs java">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;    fixedThreadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;              <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">try</span> &#123;                System.out.println(index);                Thread.sleep(<span class="hljs-number">2000</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                 <span class="hljs-comment">// TODO Auto-generated catch block</span>             e.printStackTrace();            &#125;        &#125;    &#125;);&#125;</code></pre></div><p>因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。</p><p>定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()。可参考<a href="http://www.trinea.cn/android/preloaddatacache支持预取的数据缓存，使用简单，支持多种缓/" target="_blank" rel="noopener">PreloadDataCache</a>。</p><p>(3) newScheduledThreadPool</p><p>创建一个定长线程池，支持定时及周期性任务执行。延迟执行示例代码如下：</p><div class="hljs"><pre><code class="hljs java">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="hljs-number">5</span>);scheduledThreadPool.schedule(<span class="hljs-keyword">new</span> Runnable() &#123;     <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">"delay 3 seconds"</span>);    &#125;&#125;, <span class="hljs-number">3</span>, TimeUnit.SECONDS);</code></pre></div><p>表示延迟3秒执行。</p><p>定期执行示例代码如下：</p><div class="hljs"><pre><code class="hljs java">scheduledThreadPool.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable() &#123;      <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"delay 1 seconds, and excute every 3 seconds"</span>);        &#125;&#125;, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS);</code></pre></div><p>表示延迟1秒后每3秒执行一次。</p><p>ScheduledExecutorService比Timer更安全，功能更强大，后面会有一篇单独进行对比。</p><p>(4)、newSingleThreadExecutor</p><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。示例代码如下：</p><div class="hljs"><pre><code class="hljs java">ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;    singleThreadExecutor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;          <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">try</span> &#123;                System.out.println(index);                Thread.sleep(<span class="hljs-number">2000</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                <span class="hljs-comment">// TODO Auto-generated catch block</span>                e.printStackTrace();            &#125;        &#125;    &#125;);&#125;</code></pre></div><p>结果依次输出，相当于顺序执行各个任务。</p><p>现行大多数GUI程序都是单线程的。Android中单线程可用于<a href="http://www.trinea.cn/android/database-performance/" target="_blank" rel="noopener">数据库操作</a>，文件操作，应用批量安装，应用批量删除等不适合并发但可能IO阻塞性及影响UI线程响应的操作。</p><p><strong>特别的线程池：</strong><a href="http://cmsblogs.com/?p=2451" target="_blank" rel="noopener"><strong>ScheduledThreadPoolExecutor</strong></a></p><p><strong>ScheduledThreadPoolExecutor解析</strong></p><p>我们知道Timer与TimerTask虽然可以实现线程的周期和延迟调度，但是Timer与TimerTask存在一些缺陷，所以对于这种定期、周期执行任务的调度策略，我们一般都是推荐ScheduledThreadPoolExecutor来实现。下面就深入分析ScheduledThreadPoolExecutor是如何来实现线程的周期、延迟调度的。</p><p>ScheduledThreadPoolExecutor，继承ThreadPoolExecutor且实现了ScheduledExecutorService接口，它就相当于提供了“延迟”和“周期执行”功能的ThreadPoolExecutor。在JDK API中是这样定义它的：ThreadPoolExecutor，它可另行安排在给定的延迟后运行命令，或者定期执行命令。需要多个辅助线程时，或者要求 ThreadPoolExecutor 具有额外的灵活性或功能时，此类要优于 Timer。 一旦启用已延迟的任务就执行它，但是有关何时启用，启用后何时执行则没有任何实时保证。按照提交的先进先出 (FIFO) 顺序来启用那些被安排在同一执行时间的任务。</p><p>它提供了四个构造方法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;    <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,            <span class="hljs-keyword">new</span> DelayedWorkQueue());&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><span class="hljs-function"><span class="hljs-params">                                   ThreadFactory threadFactory)</span> </span>&#123;    <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,            <span class="hljs-keyword">new</span> DelayedWorkQueue(), threadFactory);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><span class="hljs-function"><span class="hljs-params">                                   RejectedExecutionHandler handler)</span> </span>&#123;    <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,            <span class="hljs-keyword">new</span> DelayedWorkQueue(), handler);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><span class="hljs-function"><span class="hljs-params">                                   ThreadFactory threadFactory,</span></span><span class="hljs-function"><span class="hljs-params">                                   RejectedExecutionHandler handler)</span> </span>&#123;    <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,            <span class="hljs-keyword">new</span> DelayedWorkQueue(), threadFactory, handler);&#125;</code></pre></div><p>当然我们一般都不会直接通过其构造函数来生成一个ScheduledThreadPoolExecutor对象（例如new ScheduledThreadPoolExecutor(10)之类的），而是通过Executors类（例如Executors.newScheduledThreadPool(int);）</p><p>在ScheduledThreadPoolExecutor的构造函数中，我们发现它都是利用ThreadLocalExecutor来构造的，唯一变动的地方就在于它所使用的阻塞队列变成了DelayedWorkQueue，而不是ThreadLocalhExecutor的LinkedBlockingQueue（通过Executors产生ThreadLocalhExecutor对象）。DelayedWorkQueue为ScheduledThreadPoolExecutor中的内部类，它其实和阻塞队列DelayQueue有点儿类似。DelayQueue是可以提供延迟的阻塞队列，它只有在延迟期满时才能从中提取元素，其列头是延迟期满后保存时间最长的Delayed元素。如果延迟都还没有期满，则队列没有头部，并且 poll 将返回 null。有关于DelayQueue的更多介绍请参考这篇博客<a href="http://cmsblogs.com/?p=2413" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之阻塞队列：DelayQueue</a>。所以DelayedWorkQueue中的任务必然是按照延迟时间从短到长来进行排序的。下面我们再深入分析DelayedWorkQueue，这里留一个引子。</p><p>ScheduledThreadPoolExecutor提供了如下四个方法，也就是四个调度器：</p><ol><li>schedule(Callable     callable, long delay, TimeUnit unit) :创建并执行在给定延迟后启用的 ScheduledFuture。</li><li>schedule(Runnable     command, long delay, TimeUnit unit) :创建并执行在给定延迟后启用的一次性操作。</li><li>scheduleAtFixedRate(Runnable     command, long initialDelay, long period, TimeUnit unit)     :创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在     initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。</li><li>scheduleWithFixedDelay(Runnable     command, long initialDelay, long delay, TimeUnit unit)     :创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。</li></ol><p>第一、二个方法差不多，都是一次性操作，只不过参数一个是Callable，一个是Runnable。稍微分析下第三（scheduleAtFixedRate）、四个（scheduleWithFixedDelay）方法，加入initialDelay = 5，period/delay = 3，unit为秒。如果每个线程都是都运行非常良好不存在延迟的问题，那么这两个方法线程运行周期是5、8、11、14、17…….，但是如果存在延迟呢？比如第三个线程用了5秒钟，那么这两个方法的处理策略是怎样的？第三个方法（scheduleAtFixedRate）是周期固定，也就说它是不会受到这个延迟的影响的，每个线程的调度周期在初始化时就已经绝对了，是什么时候调度就是什么时候调度，它不会因为上一个线程的调度失效延迟而受到影响。但是第四个方法（scheduleWithFixedDelay），则不一样，它是每个线程的调度间隔固定，也就是说第一个线程与第二线程之间间隔delay，第二个与第三个间隔delay，以此类推。如果第二线程推迟了那么后面所有的线程调度都会推迟，例如，上面第二线程推迟了2秒，那么第三个就不再是11秒执行了，而是13秒执行。</p><p>查看着四个方法的源码，会发现其实他们的处理逻辑都差不多，所以我们就挑scheduleWithFixedDelay方法来分析，如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,                                                 <span class="hljs-keyword">long</span> initialDelay,                                                 <span class="hljs-keyword">long</span> delay,                                                 TimeUnit unit) &#123;    <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span> || unit == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();    ScheduledFutureTask&lt;Void&gt; sft =            <span class="hljs-keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command,                    <span class="hljs-keyword">null</span>,                    triggerTime(initialDelay, unit),                    unit.toNanos(-delay));    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);    sft.outerTask = t;    delayedExecute(t);    <span class="hljs-keyword">return</span> t;&#125;</code></pre></div><p>scheduleWithFixedDelay方法处理的逻辑如下：</p><ol><li>校验，如果参数不合法则抛出异常</li><li>构造一个task，该task为ScheduledFutureTask</li><li>调用delayedExecute()方法做后续相关处理</li></ol><p>这段代码涉及两个类ScheduledFutureTask和RunnableScheduledFuture，其中RunnableScheduledFuture不用多说，他继承RunnableFuture和ScheduledFuture两个接口，除了具备RunnableFuture和ScheduledFuture两类特性外，它还定义了一个方法isPeriodic() ，该方法用于判断执行的任务是否为定期任务，如果是则返回true。而ScheduledFutureTask作为ScheduledThreadPoolExecutor的内部类，它扮演着极其重要的作用，因为它的作用则是负责ScheduledThreadPoolExecutor中任务的调度。</p><p>ScheduledFutureTask内部继承FutureTask，实现RunnableScheduledFuture接口，它内部定义了三个比较重要的变量</p><div class="hljs"><pre><code class="hljs java">ScheduledFutureTask内部继承FutureTask，实现RunnableScheduledFuture接口，它内部定义了三个比较重要的变量<span class="hljs-comment">/** 任务被添加到ScheduledThreadPoolExecutor中的序号 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequenceNumber;<span class="hljs-comment">/** 任务要执行的具体时间 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> time;<span class="hljs-comment">/** 任务的间隔周期 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> period;</code></pre></div><p>这三个变量与任务的执行有着非常密切的关系，什么关系？先看ScheduledFutureTask的几个构造函数和核心方法：</p><div class="hljs"><pre><code class="hljs java">ScheduledFutureTask(Runnable r, V result, <span class="hljs-keyword">long</span> ns) &#123;    <span class="hljs-keyword">super</span>(r, result);    <span class="hljs-keyword">this</span>.time = ns;    <span class="hljs-keyword">this</span>.period = <span class="hljs-number">0</span>;    <span class="hljs-keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();&#125;ScheduledFutureTask(Runnable r, V result, <span class="hljs-keyword">long</span> ns, <span class="hljs-keyword">long</span> period) &#123;    <span class="hljs-keyword">super</span>(r, result);    <span class="hljs-keyword">this</span>.time = ns;    <span class="hljs-keyword">this</span>.period = period;    <span class="hljs-keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();&#125;ScheduledFutureTask(Callable&lt;V&gt; callable, <span class="hljs-keyword">long</span> ns) &#123;    <span class="hljs-keyword">super</span>(callable);    <span class="hljs-keyword">this</span>.time = ns;    <span class="hljs-keyword">this</span>.period = <span class="hljs-number">0</span>;    <span class="hljs-keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();&#125;ScheduledFutureTask(Callable&lt;V&gt; callable, <span class="hljs-keyword">long</span> ns) &#123;    <span class="hljs-keyword">super</span>(callable);    <span class="hljs-keyword">this</span>.time = ns;    <span class="hljs-keyword">this</span>.period = <span class="hljs-number">0</span>;    <span class="hljs-keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();&#125;</code></pre></div><p>ScheduledFutureTask 提供了四个构造方法，这些构造方法与上面三个参数是不是一一对应了？这些参数有什么用，如何用，则要看ScheduledFutureTask在那些方法使用了该方法，在ScheduledFutureTask中有一个compareTo()方法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Delayed other)</span> </span>&#123;    <span class="hljs-keyword">if</span> (other == <span class="hljs-keyword">this</span>) <span class="hljs-comment">// compare zero if same object</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (other <span class="hljs-keyword">instanceof</span> ScheduledFutureTask) &#123;        ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;        <span class="hljs-keyword">long</span> diff = time - x.time;        <span class="hljs-keyword">if</span> (diff &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">long</span> diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);    <span class="hljs-keyword">return</span> (diff &lt; <span class="hljs-number">0</span>) ? -<span class="hljs-number">1</span> : (diff &gt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;&#125;</code></pre></div><p>相信各位都知道该方法是干嘛用的，提供一个排序算法，该算法规则是：首先按照time排序，time小的排在前面，大的排在后面，如果time相同，则使用sequenceNumber排序，小的排在前面，大的排在后面。那么为什么在这个类里面提供compareTo()方法呢？在前面就介绍过ScheduledThreadPoolExecutor在构造方法中提供的是DelayedWorkQueue()队列中，也就是说ScheduledThreadPoolExecutor是把任务添加到DelayedWorkQueue中的，而DelayedWorkQueue则是类似于DelayQueue，内部维护着一个以时间为先后顺序的队列，所以compareTo()方法使用与DelayedWorkQueue队列对其元素ScheduledThreadPoolExecutor task进行排序的算法。</p><p>排序已经解决了，那么ScheduledThreadPoolExecutor 是如何对task任务进行调度和延迟的呢？任何线程的执行，都是通过run()方法执行，ScheduledThreadPoolExecutor 的run()方法如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">boolean</span> periodic = isPeriodic();    <span class="hljs-keyword">if</span> (!canRunInCurrentRunState(periodic))        cancel(<span class="hljs-keyword">false</span>);    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!periodic)        ScheduledFutureTask.<span class="hljs-keyword">super</span>.run();    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ScheduledFutureTask.<span class="hljs-keyword">super</span>.runAndReset()) &#123;        setNextRunTime();        reExecutePeriodic(outerTask);    &#125;&#125;</code></pre></div><ol><li>调用isPeriodic()获取该线程是否为周期性任务标志，然后调用canRunInCurrentRunState()方法判断该线程是否可以执行，如果不可以执行则调用cancel()取消任务。</li><li>如果当线程已经到达了执行点，则调用run()方法执行task，该run()方法是在FutureTask中定义的。</li><li>否则调用runAndReset()方法运行并充值，调用setNextRunTime()方法计算任务下次的执行时间，重新把任务添加到队列中，让该任务可以重复执行。</li></ol><p><strong>isPeriodic()</strong></p><p>该方法用于判断指定的任务是否为定期任务。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPeriodic</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> period != <span class="hljs-number">0</span>;&#125;</code></pre></div><p>canRunInCurrentRunState()判断任务是否可以取消，cancel()取消任务，这两个方法比较简单，而run()执行任务，runAndReset()运行并重置状态，牵涉比较广，我们放在FutureTask后面介绍。所以重点介绍setNextRunTime()和reExecutePeriodic()这两个涉及到延迟的方法。</p><p>setNextRunTime()</p><p>setNextRunTime()方法用于重新计算任务的下次执行时间。如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNextRunTime</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">long</span> p = period;    <span class="hljs-keyword">if</span> (p &gt; <span class="hljs-number">0</span>)        time += p;    <span class="hljs-keyword">else</span>        time = triggerTime(-p);&#125;</code></pre></div><p>该方法定义很简单，p &gt; 0 ,time += p ，否则调用triggerTime()方法重新计算time：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">triggerTime</span><span class="hljs-params">(<span class="hljs-keyword">long</span> delay)</span> </span>&#123;    <span class="hljs-keyword">return</span> now() + ((delay &lt; (Long.MAX_VALUE &gt;&gt; <span class="hljs-number">1</span>)) ? delay : overflowFree(delay));&#125;</code></pre></div><p>reExecutePeriodic</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reExecutePeriodic</span><span class="hljs-params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;    <span class="hljs-keyword">if</span> (canRunInCurrentRunState(<span class="hljs-keyword">true</span>)) &#123;        <span class="hljs-keyword">super</span>.getQueue().add(task);        <span class="hljs-keyword">if</span> (!canRunInCurrentRunState(<span class="hljs-keyword">true</span>) &amp;&amp; remove(task))            task.cancel(<span class="hljs-keyword">false</span>);        <span class="hljs-keyword">else</span>            ensurePrestart();    &#125;&#125;</code></pre></div><p>reExecutePeriodic重要的是调用super.getQueue().add(task);将任务task加入的队列DelayedWorkQueue中。ensurePrestart()在<a href="http://cmsblogs.com/?p=2448" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之线程池：ThreadPoolExecutor</a>已经做了详细介绍。</p><p>到这里ScheduledFutureTask已经介绍完了，ScheduledFutureTask在ScheduledThreadPoolExecutor扮演作用的重要性不言而喻。其实ScheduledThreadPoolExecutor的实现不是很复杂，因为有FutureTask和ThreadPoolExecutor的支撑，其实现就显得不是那么难了。</p><p><strong>总结</strong></p><p>我一向不喜欢写总结，因为我把所有需要表达的都写在正文中了，写小篇幅的总结并不能真正将话说清楚，本文的总结部分为准备面试的读者而写，希望能帮到面试者或者没有足够的时间看完全文的读者。</p><p>java 线程池有哪些关键属性？</p><p>corePoolSize，maximumPoolSize，workQueue，keepAliveTime，rejectedExecutionHandler</p><p>corePoolSize 到 maximumPoolSize 之间的线程会被回收，当然 corePoolSize 的线程也可以通过设置而得到回收（allowCoreThreadTimeOut(true)）。</p><p>workQueue 用于存放任务，添加任务的时候，如果当前线程数超过了 corePoolSize，那么往该队列中插入任务，线程池中的线程会负责到队列中拉取任务。</p><p>keepAliveTime 用于设置空闲时间，如果线程数超出了 corePoolSize，并且有些线程的空闲时间超过了这个值，会执行关闭这些线程的操作</p><p>rejectedExecutionHandler 用于处理当线程池不能执行此任务时的情况，默认有抛出 RejectedExecutionException 异常、忽略任务、使用提交任务的线程来执行此任务和将队列中等待最久的任务删除，然后提交此任务这四种策略，默认为抛出异常。</p><p>说说线程池中的线程创建时机？</p><p>如果当前线程数少于 corePoolSize，那么提交任务的时候创建一个新的线程，并由这个线程执行这个任务；</p><p>如果当前线程数已经达到 corePoolSize，那么将提交的任务添加到队列中，等待线程池中的线程去队列中取任务；</p><p>如果队列已满，那么创建新的线程来执行任务，需要保证池中的线程数不会超过 maximumPoolSize，如果此时线程数超过了 maximumPoolSize，那么执行拒绝策略。</p><p>注意：如果将队列设置为无界队列，那么线程数达到 corePoolSize 后，其实线程数就不会再增长了。</p><p>Executors.newFixedThreadPool(…) 和 Executors.newCachedThreadPool() 构造出来的线程池有什么差别？</p><p>细说太长，往上滑一点点，在 Executors 的小节进行了详尽的描述。</p><p>任务执行过程中发生异常怎么处理？</p><p>如果某个任务执行出现异常，那么执行任务的线程会被关闭，而不是继续接收其他任务。然后会启动一个新的线程来代替它。</p><p>什么时候会执行拒绝策略？</p><p>workers 的数量达到了 corePoolSize（任务此时需要进入任务队列），任务入队成功，与此同时线程池被关闭了，而且关闭线程池并没有将这个任务出队，那么执行拒绝策略。这里说的是非常边界的问题，入队和关闭线程池并发执行，读者仔细看看 execute 方法是怎么进到第一个 reject(command) 里面的。</p><p>workers 的数量大于等于 corePoolSize，将任务加入到任务队列，可是队列满了，任务入队失败，那么准备开启新的线程，可是线程数已经达到 maximumPoolSize，那么执行拒绝策略。</p>]]></content>
    
    
    <categories>
      
      <category>语言相关</category>
      
      <category>Java进阶</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal介绍</title>
    <link href="/2021/05/30/ThreadLocal%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/05/30/ThreadLocal%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="1、ThreadLocal是什么？"><a href="#1、ThreadLocal是什么？" class="headerlink" title="1、ThreadLocal是什么？"></a>1、ThreadLocal是什么？</h1><p>ThreadLocal是啥？以前面试别人时就喜欢问这个，有些伙伴喜欢把它和线程同步机制混为一谈，事实上ThreadLocal与线程同步无关。ThreadLocal虽然提供了一种解决多线程环境下成员变量的问题，但是它并不是解决多线程共享变量的问题。那么ThreadLocal到底是什么呢？</p><p>API是这样介绍它的：</p><p>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其get 或 set方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。</p><p>所以<strong>ThreadLocal与线程同步机制不同，线程同步机制是多个线程共享同一个变量，而**</strong>ThreadLocal是为每一个线程创建一个单独的变量副本，故而每个线程都可以独立地改变自己所拥有的变量副本，而不会影响其他线程所对应的副本**。可以说ThreadLocal为多线程环境下变量问题提供了另外一种解决思路。</p><p>ThreadLocal定义了四个方法：</p><p>1、get()：返回此线程局部变量的当前线程副本中的值；</p><p>2、initialValue()：返回此线程局部变量的当前线程的“初始值”；</p><p>3、remove()：移除此线程局部变量中当前线程的值；</p><p>4、set(T value)：将此线程局部变量的当前线程副本中的值设置为指定值。</p><p>除了这四个方法，ThreadLocal内部还有一个静态内部类<strong>ThreadLocalMap**</strong>，该内部类才是实现线程隔离机制的关键，get()、set()、remove()都是基于该内部类操作<strong>。</strong>ThreadLocalMap提供了一种用<strong><strong>键值对方式</strong></strong>存储每一个线程的变量副本的方法，<strong>**key为当前ThreadLocal对象，value则是对应线程的变量副本</strong>。</p><p>对于ThreadLocal需要注意的有两点：</p><ol><li><p>ThreadLocal实例本身是不存储值，它只是提供了一个在当前线程中找到副本值的key；</p></li><li><p>是ThreadLocal包含在Thread中，而不是Thread包含在ThreadLocal中，有些小伙伴会弄错他们的关系。</p></li></ol><p>下图是Thread、ThreadLocal、ThreadLocalMap的关系：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530205942.png" srcset="/img/loading.gif" alt="image-20210530205942564"></p><h1 id="2、ThreadLocal使用示例"><a href="#2、ThreadLocal使用示例" class="headerlink" title="2、ThreadLocal使用示例"></a>2、ThreadLocal使用示例</h1><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SeqCount</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Integer&gt; seqCount = <span class="hljs-keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;                <span class="hljs-comment">// 实现initialValue</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">initialValue</span><span class="hljs-params">()</span></span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                &#125;        &#125;;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextSeq</span><span class="hljs-params">()</span></span>&#123;                seqCount.set(seqCount.get() + <span class="hljs-number">1</span>);                <span class="hljs-keyword">return</span> seqCount.get();        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;                SeqCount seqCount = <span class="hljs-keyword">new</span> SeqCount();                SeqThread thread1 = <span class="hljs-keyword">new</span> SeqThread(seqCount);                SeqThread thread2 = <span class="hljs-keyword">new</span> SeqThread(seqCount);                SeqThread thread3 = <span class="hljs-keyword">new</span> SeqThread(seqCount);                SeqThread thread4 = <span class="hljs-keyword">new</span> SeqThread(seqCount);                thread1.start();                thread2.start();                thread3.start();                thread4.start();        &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SeqThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;        <span class="hljs-keyword">private</span> SeqCount seqCount;        SeqThread(SeqCount seqCount) &#123;                <span class="hljs-keyword">this</span>.seqCount = seqCount;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" seqCount :"</span> + seqCount.nextSeq());                &#125;        &#125;&#125;</code></pre></div><p>运行结果：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530210029.png" srcset="/img/loading.gif" alt="image-20210530210029320"></p><p>从运行结果可以看出，ThreadLocal确实是可以达到线程隔离机制，确保变量的安全性。这里我们想一个问题，在上面的代码中ThreadLocal的initialValue()方法返回的是0，假如该方法返回的是一个对象呢，会产生什么后果呢？例如：</p><div class="hljs"><pre><code class="hljs java">A a = <span class="hljs-keyword">new</span> A();<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;A&gt; seqCount = <span class="hljs-keyword">new</span> ThreadLocal&lt;A&gt;()&#123;<span class="hljs-comment">// 实现initialValue()</span><span class="hljs-function"><span class="hljs-keyword">public</span> A <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> a;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<span class="hljs-comment">// ....</span>&#125;</code></pre></div><ul><li>具体过程请参考：<a href="http://www.jianshu.com/p/ee8c9dccc953" target="_blank" rel="noopener">对ThreadLocal实现原理的一点思考</a></li></ul><h1 id="3、ThreadLocal源码分析"><a href="#3、ThreadLocal源码分析" class="headerlink" title="3、ThreadLocal源码分析"></a>3、ThreadLocal源码分析</h1><p>ThreadLocal虽然解决了这个多线程变量的复杂问题，但是它的源码实现却是比较简单的。ThreadLocalMap是实现ThreadLocal的关键，我们先从它入手。</p><h2 id="3-1、ThreadLocalMap"><a href="#3-1、ThreadLocalMap" class="headerlink" title="3.1、ThreadLocalMap"></a>3.1、ThreadLocalMap</h2><p>ThreadLocalMap是ThreadLocal中的一个静态内部类。ThreadLocalMap其内部利用Entry来实现key-value的存储，如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocal</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<span class="hljs-comment">// ... 其他方法 </span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalMap</span> </span>&#123;<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&gt; </span>&#123;<span class="hljs-comment">/** The value associated with this ThreadLocal. */</span>Object value;Entry(ThreadLocal k, Object v) &#123;<span class="hljs-keyword">super</span>(k);value = v;&#125;&#125;<span class="hljs-comment">// ...其他方法</span>&#125;<span class="hljs-comment">// ...其他方法</span>&#125;</code></pre></div><p>从上面代码中可以看出<strong>Entry的key就是ThreadLocal</strong>，而value就是值。同时，<strong>Entry也继承WeakReference，所以说Entry所对应key（ThreadLocal实例）的引用为一个弱引用</strong>（关于弱引用这里就不多说了，感兴趣的可以关注这篇博客：<a href="https://www.ibm.com/developerworks/cn/java/j-jtp11225/" target="_blank" rel="noopener">Java 理论与实践: 用弱引用堵住内存泄漏</a>）。</p><p>ThreadLocalMap的源码稍微多了点，我们就看两个最核心的方法getEntry()、set(ThreadLocal&gt; key, Object value)方法。</p><p><strong>3.1.1、getEntry()</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Entry <span class="hljs-title">getEntry</span><span class="hljs-params">(ThreadLocal key)</span> </span>&#123;<span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);Entry e = table[i];<span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span> &amp;&amp; e.get() == key)<span class="hljs-keyword">return</span> e;<span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);&#125;</code></pre></div><p>由于采用了开放地址法，所以当前key的散列值和元素在数组的索引并不是完全对应的，首先取一个探测数（key的散列值），如果所对应的key就是我们所要找的元素，则返回，否则调用getEntryAfterMiss()，如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Entry <span class="hljs-title">getEntryAfterMiss</span><span class="hljs-params">(ThreadLocal key, <span class="hljs-keyword">int</span> i, Entry e)</span> </span>&#123;Entry[] tab = table;<span class="hljs-keyword">int</span> len = tab.length;<span class="hljs-keyword">while</span> (e != <span class="hljs-keyword">null</span>) &#123;ThreadLocal k = e.get();<span class="hljs-keyword">if</span> (k == key)<span class="hljs-keyword">return</span> e;<span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span>)expungeStaleEntry(i);<span class="hljs-keyword">else</span>i = nextIndex(i, len);e = tab[i];&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p>这里有一个重要的地方，当key == null时，调用了expungeStaleEntry()方法，该方法用于处理key == null，有利于GC回收，能够有效地避免内存泄漏。</p><p><strong>3.1.2、set(ThreadLocal&gt; key, Object value)</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;ThreadLocal.ThreadLocalMap.Entry[] tab = table;<span class="hljs-keyword">int</span> len = tab.length;<span class="hljs-comment">// 根据 ThreadLocal 的散列值，查找对应元素在数组中的位置</span><span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<span class="hljs-comment">// 采用“线性探测法”，寻找合适位置</span><span class="hljs-keyword">for</span> (ThreadLocal.ThreadLocalMap.Entry e = tab[i]; e != <span class="hljs-keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;ThreadLocal&lt;?&gt; k = e.get();<span class="hljs-comment">// key 存在，直接覆盖</span><span class="hljs-keyword">if</span> (k == key) &#123;e.value = value;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">// key == null，但是存在值（因为此处的e != null），说明之前的ThreadLocal对象已经被回收了</span><span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 用新元素替换陈旧的元素</span>replaceStaleEntry(key, value, i);<span class="hljs-keyword">return</span>;&#125;&#125;<span class="hljs-comment">// ThreadLocal对应的key实例不存在也没有陈旧元素，new 一个</span>tab[i] = <span class="hljs-keyword">new</span> ThreadLocal.ThreadLocalMap.Entry(key, value);<span class="hljs-keyword">int</span> sz = ++size;<span class="hljs-comment">// cleanSomeSlots 清除陈旧的Entry（key == null）</span><span class="hljs-comment">// 如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash</span><span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)rehash();&#125;</code></pre></div><p>这个set()操作和我们在集合了解的put()方式有点儿不一样，虽然他们都是key-value结构，不同在于他们解决散列冲突的方式不同。集合Map的put()采用的是拉链法，而<strong>ThreadLocalMap的set()则是采用开放地址法</strong>（具体请参考<a href="http://www.nowamagic.net/academy/detail/3008015" target="_blank" rel="noopener">散列冲突处理系列博客</a>）。掌握了开放地址法该方法就一目了然了。</p><p><strong>set()操作除了存储元素外，还有一个很重要的作用，就是replaceStaleEntry()和cleanSomeSlots()，这两个方法可以清除掉key == null 的实例，防止内存泄漏</strong>。在set()方法中还有一个变量很重要：threadLocalHashCode，定义如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threadLocalHashCode = nextHashCode();</code></pre></div><p>从名字上面我们可以看出threadLocalHashCode应该是ThreadLocal的散列值，定义为final，表示ThreadLocal一旦创建其散列值就已经确定了，生成过程则是调用nextHashCode()：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicInteger nextHashCode = <span class="hljs-keyword">new</span> AtomicInteger();<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HASH_INCREMENT = <span class="hljs-number">0x61c88647</span>;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextHashCode</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);&#125;</code></pre></div><p>nextHashCode表示分配下一个ThreadLocal实例的threadLocalHashCode的值，HASH_INCREMENT则表示分配两个ThradLocal实例的threadLocalHashCode的增量，从nextHashCode就可以看出他们的定义。</p><p>上面的两个方法都是静态内部类ThreadLocalMap中的方法，下面让我们看看ThreadLocal中的其他方法。</p><h2 id="3-2、get"><a href="#3-2、get" class="headerlink" title="3.2、get()"></a>3.2、get()</h2><p>返回此线程局部变量的当前线程副本中的值。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 获取当前线程</span>Thread t = Thread.currentThread();<span class="hljs-comment">// 获取当前线程的成员变量 threadLocal</span>ThreadLocalMap map = getMap(t);<span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 从当前线程的ThreadLocalMap获取相对应的Entry</span>ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);<span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)<span class="hljs-comment">// 获取目标值 </span>T result = (T)e.value;<span class="hljs-keyword">return</span> result;&#125;&#125;<span class="hljs-keyword">return</span> setInitialValue();&#125;</code></pre></div><p>首先通过当前线程获取所对应的成员变量ThreadLocalMap，然后通过ThreadLocalMap获取当前ThreadLocal的Entry，最后通过所获取的Entry获取目标值result。</p><p>getMap()方法可以获取当前线程所对应的ThreadLocalMap，如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function">ThreadLocalMap <span class="hljs-title">getMap</span><span class="hljs-params">(Thread t)</span> </span>&#123;     <span class="hljs-keyword">return</span> t.threadLocals; &#125;</code></pre></div><h2 id="3-3、set-T-value"><a href="#3-3、set-T-value" class="headerlink" title="3.3、set(T value)"></a>3.3、set(T value)</h2><p>将此线程局部变量的当前线程副本中的值设置为指定值。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;Thread t = Thread.currentThread(); <span class="hljs-comment">// 获取当前线程</span>ThreadLocalMap map = getMap(t); <span class="hljs-comment">// 获取当前线程所对应的ThreadLocalMap</span><span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)map.set(<span class="hljs-keyword">this</span>, value); <span class="hljs-comment">// ThreadLocalMap不为空时，调用ThreadLocalMap的set()方法</span><span class="hljs-keyword">else</span>createMap(t, value); <span class="hljs-comment">// ThreadLocalMap为空时，调用createMap()方法新建一个ThreadLocalMap</span>&#125;</code></pre></div><p>首先获取当前线程所对应的ThreadLocalMap，如果不为空，则调用ThreadLocalMap的set()方法，key就是当前ThreadLocal；如果不存在，则调用createMap()方法新建一个ThreadLocalMap，key为当前线程，值为指定的value。如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>&#123;t.threadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);&#125;</code></pre></div><h2 id="3-4、initialValue"><a href="#3-4、initialValue" class="headerlink" title="3.4、initialValue()"></a>3.4、initialValue()</h2><p>返回此线程局部变量的当前线程的“初始值”；</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> T <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p>该方法定义为protected级别且返回为null，很明显是要子类实现它的，所以我们在使用ThreadLocal的时候一般都应该覆盖该方法。该方法不能显示调用，只有在第一次调用get()或者set()方法时才会被执行，并且仅执行1次。</p><h2 id="3-5、remove"><a href="#3-5、remove" class="headerlink" title="3.5、remove()"></a>3.5、remove()</h2><p>将当前线程局部变量的值移除。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 获取当前线程的ThreadLocalMap</span>ThreadLocalMap m = getMap(Thread.currentThread()); <span class="hljs-keyword">if</span> (m != <span class="hljs-keyword">null</span>)m.remove(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// 如果当前线程的ThreadLocalMap不为空，则移除</span>&#125;</code></pre></div><h1 id="4、ThreadLocal为什么会内存泄漏"><a href="#4、ThreadLocal为什么会内存泄漏" class="headerlink" title="4、ThreadLocal为什么会内存泄漏"></a>4、ThreadLocal为什么会内存泄漏</h1><p>先看这样一个小案例：</p><p>在JAVA里面，存在强引用、弱引用、软引用、虚引用。这里主要谈一下强引用和弱引用。</p><p>强引用类似于：</p><div class="hljs"><pre><code class="hljs ebnf"><span class="hljs-attribute">A a</span> = new A();<span class="hljs-attribute">B b</span> = new B();</code></pre></div><p>现在考虑这种情况：</p><div class="hljs"><pre><code class="hljs ebnf"><span class="hljs-attribute">C c</span> = new C(b);<span class="hljs-attribute">b</span> = null;</code></pre></div><p>考虑下GC的情况。要知道b被置为null，那么是否意味着一段时间后GC工作可以回收b所分配的内存空间呢？</p><p>答案是否定的，因为即便b被置为null，但是c仍然持有对b的引用，而且还是强引用，所以GC不会回收b原先所分配的空间！既不能回收利用，又不能使用，这就造成了内存泄露。</p><p>那么如何处理呢？</p><p>可以使c = null;也可以使用弱引用！（WeakReference w = new WeakReference(b);）</p><p>下面就来看看ThreadLocal的内存泄露是怎么一回事：</p><p>前面提到每个Thread都有一个ThreadLocal.ThreadLocalMap的map，该map的key为ThreadLocal实例，它为一个弱引用，我们知道弱引用有利于GC回收。当ThreadLocal的key == null时，GC就会回收这部分空间，但是value却不一定能够被回收，因为他还与Current Thread存在一个强引用关系，如下图所示：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530210510.png" srcset="/img/loading.gif" alt="image-20210530210510395"></p><p>由于存在这个强引用关系，会导致value无法回收。如果这个线程对象不会销毁，那么这个强引用关系则会一直存在，就会出现内存泄漏情况。所以说只要这个线程对象能够及时被GC回收，就不会出现内存泄漏。如果碰到线程池，那就更坑了。</p><p>那么要怎么避免这个问题呢？</p><p>在前面提过，在ThreadLocalMap中的setEntry()、getEntry()，<strong>如果遇到key == null的情况，会对value设置为null</strong>。当然我们也可以<strong>显示调用ThreadLocal的remove()方法进行处理</strong>。</p><h1 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h1><p><strong>下面对ThreadLocal进行简单的总结：</strong></p><p>1、ThreadLocal 不是用于解决共享变量的问题的，也不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。这点至关重要；</p><p>2、每个Thread内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量，该成员变量用来存储实际的ThreadLocal变量副本；</p><p>3、ThreadLocal并不是为线程保存对象的副本，它仅仅只起到一个<strong>索引</strong>的作用。它的主要目的是<strong>为每一个线程隔离一个类的实例，这个实例的作用范围仅限于线程内部。</strong></p>]]></content>
    
    
    <categories>
      
      <category>语言相关</category>
      
      <category>Java进阶</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConcurrentHashMap</title>
    <link href="/2021/05/30/ConcurrentHashMap/"/>
    <url>/2021/05/30/ConcurrentHashMap/</url>
    
    <content type="html"><![CDATA[<p>首先推荐下几篇不错的文章：</p><p><a href="https://blog.csdn.net/pcwl1206/article/details/85040309" target="_blank" rel="noopener"><strong>1、Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析</strong></a></p><p>这篇文章要好好读一读，全文主要包括四个部分：Java7中的HashMap和ConcurrentHashMap以及Java8中的HashMap和ConcurrentHashMap，能够很清晰的认识到HashMap和ConcurrentHashMap之间的区别、Java8在哪些地方做出了改进。</p><p><a href="https://mp.weixin.qq.com/s/2ychUuTwmhNgRJXtR6k3Tg" target="_blank" rel="noopener"><strong>2、ConcurrentHashMap源码分析</strong></a></p><p>这篇文章也是本文主要参考的文章，全文分析了Java7中主要ConcurrentHashMap部分。</p><p>本文主要偏重于讲ConcurrentHashMap的源码分析，至于它和HashMap的对比，后面复习Java基础集合容器时会专门的再进行讲解。这里不再做过多的赘述，但是这两者之间的对比是很重要的。另外会再写文章对Java1.7中的ConcurrentHashMap和Java1.8中的ConcurrentHashMap的区别进行讲解：<a href="https://blog.csdn.net/pcwl1206/article/details/85040309" target="_blank" rel="noopener"><strong>Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析</strong></a></p><p><strong>1、为什么要使用ConcurrentHashMap？</strong></p><p>在并发编程中使用HashMap可能导致程序死循环。而使用线程安全的HashTable效率又非常低下，基于以上两个原因，便有了ConcurrentHashMap的登场机会。</p><ul><li><strong>1、线程不安全的HashMap</strong></li></ul><p>HashMap在并发执行put操作时会发生死循环，是因为多线程会导致HashMap的Entry链表形成环型数据结构，一旦形成环型数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。</p><ul><li><strong>2、效率低下的HashTable</strong></li></ul><p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率会非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或者轮询状态。如线程1使用put进行元素的添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p><ul><li><strong>3、ConcurrentHashMap的锁分段机制可有效提高并发访问率</strong></li></ul><p>HashTable容器在竞争激烈的情况下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，假如<strong>容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问</strong>。</p><p><strong>2、ConcurrentHashMap的实现</strong></p><p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成的。</p><p>Segment在ConcurrentHashMap中扮演锁的角色是一种可重入锁（ReentranLock）。</p><p>HashEntry则用于存储键值对数据。</p><p>一个ConcurrentHashMap包含一个Segment数组，其结构是：数组+链表的形式。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素。每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530205150.png" srcset="/img/loading.gif" alt="image-20210530205150301"></p><p>看下ConcurrentHashMap源码中（JDK1.7）主要的成员变量、方法和内部类：</p><p><strong>2.1、ConcurrentHashMap中主要的成员变量、成员方法和内部类</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentHashMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;</span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">ConcurrentMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;, <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">// 默认初始化容量</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">16</span>;    <span class="hljs-comment">// 默认加载因子</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;    <span class="hljs-comment">// 默认并发级别</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="hljs-number">16</span>;    <span class="hljs-comment">// 集合最大容量</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;    <span class="hljs-comment">// 分段锁的最小数量</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="hljs-number">2</span>;    <span class="hljs-comment">// 分段锁的最大数量</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_SEGMENTS = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">16</span>;    <span class="hljs-comment">// 加锁前的重试次数</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RETRIES_BEFORE_LOCK = <span class="hljs-number">2</span>;    <span class="hljs-comment">// 分段锁的掩码值</span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> segmentMask;    <span class="hljs-comment">// 分段锁的移位值</span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> segmentShift;    <span class="hljs-comment">// 分段锁数组</span>    <span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Holder</span> </span>&#123;           <span class="hljs-comment">// ...</span>    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashEntry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;           <span class="hljs-comment">// ... </span>    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Segment</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;        <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;          <span class="hljs-comment">// ...</span>    &#125;    <span class="hljs-comment">// 获取ConcurrentHashMap中元素的个数</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-comment">// 获取元素</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;&#125;    <span class="hljs-comment">// 设置元素</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;&#125;         <span class="hljs-comment">// ...</span>&#125;</code></pre></div><p>其中Segment数组代表分段锁集合；并发级别则代表分段锁的数量(也意味有多少线程可以同时操作)；初始化容量代表整个容器的容量；加载因子代表容器元素可以达到多满的一种程度。</p><p><strong>2.2、分段锁的内部结构</strong></p><p>Segment是ConcurrentHashMap的内部类，它继承了ReentrantLock。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentHashMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">ConcurrentMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;, <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">// 分段锁</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Segment</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;        <span class="hljs-comment">// 自旋最大次数</span>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_SCAN_RETRIES = Runtime.getRuntime().availableProcessors() &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">64</span> : <span class="hljs-number">1</span>;        <span class="hljs-comment">// 哈希表</span>        <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;        <span class="hljs-comment">// 元素总数</span>        <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> count;        <span class="hljs-comment">// 修改次数</span>        <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;        <span class="hljs-comment">// 元素阀值</span>        <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> threshold;        <span class="hljs-comment">// 加载因子</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;        <span class="hljs-comment">// 构造函数</span>        Segment(<span class="hljs-keyword">float</span> lf, <span class="hljs-keyword">int</span> threshold, HashEntry&lt;K,V&gt;[] tab) &#123;            <span class="hljs-keyword">this</span>.loadFactor = lf;            <span class="hljs-keyword">this</span>.threshold = threshold;            <span class="hljs-keyword">this</span>.table = tab;        &#125;<span class="hljs-comment">// 省略以下内容</span>...    &#125;&#125;</code></pre></div><p>Segment是ConcurrentHashMap的静态内部类，可以看到它继承自ReentrantLock，因此它在<strong>本质上是一个锁</strong>。它在内部持有一个HashEntry数组(哈希表)，并且保证所有对该数组的增删改查方法都是线程安全的，具体是怎样实现的后面会讲到。</p><p><strong>所有对ConcurrentHashMap的增删改查操作都可以委托Segment来进行，因此ConcurrentHashMap能够保证在多线程环境下是安全的。又因为不同的Segment是不同的锁，所以多线程可以同时操作不同的Segment，也就意味着多线程可以同时操作ConcurrentHashMap，这样就能避免HashTable的缺陷，从而极大的提高性能。</strong></p><p><strong>2.3、ConcurrentHashMap的初始化</strong></p><p>ConcurrentHashMap初始化方法是通过 initialCapacity、loadFactor 和 concurrencyLevel等几个参数来初始化 segment数组、段偏移量segmentShift、段掩码 segmentMask 和每个 segment 里的 HashEntry 数组。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 核心构造器</span><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor, <span class="hljs-keyword">int</span> concurrencyLevel)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!(loadFactor &gt; <span class="hljs-number">0</span>) || initialCapacity &lt; <span class="hljs-number">0</span> || concurrencyLevel &lt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();    &#125;    <span class="hljs-comment">// 确保并发级别不大于限定值</span>    <span class="hljs-keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS) &#123;        concurrencyLevel = MAX_SEGMENTS;    &#125;    <span class="hljs-keyword">int</span> sshift = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> ssize = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 保证ssize为2的幂, 且是最接近的大于等于并发级别的数</span>    <span class="hljs-keyword">while</span> (ssize &lt; concurrencyLevel) &#123;        ++sshift;        ssize &lt;&lt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 计算分段锁的移位值</span>    <span class="hljs-keyword">this</span>.segmentShift = <span class="hljs-number">32</span> - sshift;    <span class="hljs-comment">// 计算分段锁的掩码值</span>    <span class="hljs-keyword">this</span>.segmentMask = ssize - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 总的初始容量不能大于限定值</span>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY) &#123;        initialCapacity = MAXIMUM_CAPACITY;    &#125;    <span class="hljs-comment">// 获取每个分段锁的初始容量</span>    <span class="hljs-keyword">int</span> c = initialCapacity / ssize;    <span class="hljs-comment">// 分段锁容量总和不小于初始总容量</span>    <span class="hljs-keyword">if</span> (c * ssize &lt; initialCapacity) &#123;        ++c;    &#125;    <span class="hljs-keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;    <span class="hljs-comment">// 保证cap为2的幂, 且是最接近的大于等于c的数</span>    <span class="hljs-keyword">while</span> (cap &lt; c) &#123;        cap &lt;&lt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 新建一个Segment对象模版</span>    Segment&lt;K,V&gt; s0 = <span class="hljs-keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="hljs-keyword">int</span>)(cap * loadFactor), (HashEntry&lt;K,V&gt;[])<span class="hljs-keyword">new</span> HashEntry[cap]);    <span class="hljs-comment">// 新建指定大小的分段锁数组</span>    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Segment[ssize];    <span class="hljs-comment">// 使用UnSafe给数组第0个元素赋值</span>    UNSAFE.putOrderedObject(ss, SBASE, s0);    <span class="hljs-keyword">this</span>.segments = ss;&#125;</code></pre></div><p><strong>2.4、如何定位Segment(锁)和元素</strong></p><p>主要通过segmentForHash方法获取分段锁的位置，再根据entryForHash方法获取元素的位置。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 根据哈希码获取分段锁</span><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)<span class="hljs-function"><span class="hljs-keyword">private</span> Segment&lt;K,V&gt; <span class="hljs-title">segmentForHash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h)</span> </span>&#123;    <span class="hljs-keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;    <span class="hljs-keyword">return</span> (Segment&lt;K,V&gt;) UNSAFE.getObjectVolatile(segments, u);&#125;<span class="hljs-comment">// 根据哈希码获取元素</span><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-function">HashEntry&lt;K,V&gt; <span class="hljs-title">entryForHash</span><span class="hljs-params">(Segment&lt;K,V&gt; seg, <span class="hljs-keyword">int</span> h)</span> </span>&#123;    HashEntry&lt;K,V&gt;[] tab;    <span class="hljs-keyword">return</span> (seg == <span class="hljs-keyword">null</span> || (tab = seg.table) == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> :            (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile(tab, ((<span class="hljs-keyword">long</span>)(((tab.length - <span class="hljs-number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);&#125;</code></pre></div><p>在JDK1.7中是通过UnSafe来获取数组元素的，因此这里比JDK1.6多了些计算数组元素偏移量的代码，这些代码我们暂时不关注，现在我们只需知道下面这两点：</p><p>a. 通过哈希码计算分段锁在数组中的下标：(h &gt;&gt;&gt; segmentShift) &amp; segmentMask。</p><p>b. 通过哈希码计算元素在数组中的下标：(tab.length - 1) &amp; h。</p><p>现在我们假设传给构造器的两个参数为initialCapacity=128, concurrencyLevel=16。根据计算可以得到ssize=16, sshift=4，segmentShift=28，segmentMask=15。</p><p>同样，算得每个分段锁内的HashEntry数组的长度为8，所以tab.length-1=7。根据这些值，我们通过下图来解释如何根据同一个哈希码来定位分段锁和元素。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530205351.png" srcset="/img/loading.gif" alt="image-20210530205351699"></p><p>可以看到<strong>分段锁和元素的定位都是通过元素的哈希码来决定的</strong>。<strong>定位分段锁是取哈希码的高位值(从32位处取起)，定位元素是取的哈希码的低位值</strong>。现在有个问题，它们一个从32位的左端取起，一个从32位的右端取起，那么会在某个时刻产生冲突吗？</p><p>我们在成员变量里可以找到MAXIMUM_CAPACITY = 1 &lt;&lt; 30，MAX_SEGMENTS = 1 &lt;&lt; 16，这说明定位分段锁和定位元素使用的总的位数不超过30，并且定位分段锁使用的位数不超过16，所以至少还隔着2位的空余，因此是不会产生冲突的。</p><p><strong>2.5、查找元素get操作</strong></p><p>Segment的get操作实现非常简单高效。先经过一次散列，然后使用这个散列值通过散列运算定位到Segment，再通过散列算法定位到元素。共需要两次散列运算。</p><p>get操作的高效在于整个get过程都不用加锁，除非读到的值是空才会加锁重读。get方法中使用的共享变量都定义成了volatile类型。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 根据key获取value</span><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;    Segment&lt;K,V&gt; s;    HashEntry&lt;K,V&gt;[] tab;    <span class="hljs-comment">// 使用哈希函数计算哈希码</span>    <span class="hljs-keyword">int</span> h = hash(key);    <span class="hljs-comment">// 根据哈希码计算分段锁的索引</span>    <span class="hljs-keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;    <span class="hljs-comment">// 获取分段锁和对应的哈希表</span>    <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="hljs-keyword">null</span> &amp;&amp; (tab = s.table) != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 根据哈希码获取链表头节点, 再对链表进行遍历</span>        <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile                (tab, ((<span class="hljs-keyword">long</span>)(((tab.length - <span class="hljs-number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);             e != <span class="hljs-keyword">null</span>; e = e.next) &#123;            K k;            <span class="hljs-comment">// 根据key和hash找到对应元素后返回value值</span>            <span class="hljs-keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k))) &#123;                <span class="hljs-keyword">return</span> e.value;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p>在JDK1.6中分段锁的get方法是通过下标来访问数组元素的，而在JDK1.7中是通过UnSafe的getObjectVolatile方法来读取数组中的元素。</p><p><strong>为什么要这样做？</strong></p><p>我们知道虽然Segment对象持有的HashEntry数组引用是volatile类型的，但是数组内的元素引用不是volatile类型的，因此多线程对数组元素的修改是不安全的，可能会在数组中读取到尚未构造完成的对象。</p><p>在JDK1.6中是通过第二次加锁读取来保证安全的，而JDK1.7中通过UnSafe的getObjectVolatile方法来读取同样也是为了保证这一点。使用getObjectVolatile方法读取数组元素需要先获得元素在数组中的偏移量，在这里<strong>根据哈希码计算得到分段锁在数组中的偏移量为u，然后通过偏移量u来尝试读取分段锁</strong>。由于分段锁数组在构造时没进行初始化，因此可能读出来一个空值，所以需要先进行判断。</p><p><strong>在确定分段锁和它内部的哈希表都不为空之后，再通过哈希码读取HashEntry数组的元素</strong>，根据上面的结构图可以看到，这时获得的是链表的头结点。之后再从头到尾的对链表进行遍历查找，如果找到对应的值就将其返回，否则就返回null。以上就是整个查找元素的过程。</p><p><strong>2.6、插入元素put操作</strong></p><p>由于put方法里需要对共享变量进行写操作，所以为了线程安全，在操作共享变量时必须加锁。put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤：</p><p>1、判断是否需要对Segment里的HashEntry数组进行扩容；</p><p>2、定位添加元素的位置，然后将其放在HashEntry数组中。</p><ul><li><strong>是否需要扩容？</strong></li></ul><p>在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold），如果超过阈值，则对数组进行扩容。值得一提的是，Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断是否已经到达容量的，如果达到了就进行扩容，但是很有可能扩容之后没有新元素再插入，这时HashMap就进行了一次无效的扩容。</p><ul><li><strong>如何扩容？</strong>       </li></ul><p>在扩容的时候，首先会创建一个容量是原来容量两倍的数组，然后将原来数组里的元素进行再散列后插入到新的数组里。为了高效，ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment扩容。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 向集合中添加键值对(若存在则替换)</span><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;    Segment&lt;K,V&gt; s;    <span class="hljs-comment">// 传入的value不能为空</span>    <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-comment">// 使用哈希函数计算哈希码</span>    <span class="hljs-keyword">int</span> hash = hash(key);    <span class="hljs-comment">// 根据哈希码计算分段锁的下标</span>    <span class="hljs-keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;    <span class="hljs-comment">// 根据下标去尝试获取分段锁</span>    <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject(segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 获得的分段锁为空就去构造一个</span>        s = ensureSegment(j);    &#125;    <span class="hljs-comment">// 调用分段锁的put方法</span>    <span class="hljs-keyword">return</span> s.put(key, hash, value, <span class="hljs-keyword">false</span>);&#125;<span class="hljs-comment">// 向集合添加键值对(不存在才添加)</span><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">putIfAbsent</span><span class="hljs-params">(K key, V value)</span> </span>&#123;    Segment&lt;K,V&gt; s;    <span class="hljs-comment">// 传入的value不能为空</span>    <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-comment">// 使用哈希函数计算哈希码</span>    <span class="hljs-keyword">int</span> hash = hash(key);    <span class="hljs-comment">// 根据哈希码计算分段锁的下标</span>    <span class="hljs-keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;    <span class="hljs-comment">// 根据下标去尝试获取分段锁</span>    <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject(segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 获得的分段锁为空就去构造一个</span>        s = ensureSegment(j);    &#125;    <span class="hljs-comment">// 调用分段锁的put方法</span>    <span class="hljs-keyword">return</span> s.put(key, hash, value, <span class="hljs-keyword">true</span>);&#125;</code></pre></div><p>ConcurrentHashMap中有两个添加键值对的方法，通<strong>过put方法添加时如果存在则会进行覆盖，通过putIfAbsent方法添加时如果存在则不进行覆盖，这两个方法都是调用分段锁的put方法来完成操作，只是传入的最后一个参数不同而已</strong>。在上面代码中我们可以看到首先是根据key的哈希码来计算出分段锁在数组中的下标，然后根据下标使用UnSafe类getObject方法来读取分段锁。</p><p>由于在构造ConcurrentHashMap时没有对Segment数组中的元素初始化，所以可能读到一个空值，这时会先通过ensureSegment方法新建一个分段锁。获取到分段锁之后再调用它的put方法完成添加操作，下面我们来看看具体是怎样操作的。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 添加键值对</span><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, <span class="hljs-keyword">int</span> hash, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;    <span class="hljs-comment">// 尝试获取锁, 若失败则进行自旋</span>    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="hljs-keyword">null</span> : scanAndLockForPut(key, hash, value);    V oldValue;    <span class="hljs-keyword">try</span> &#123;        HashEntry&lt;K,V&gt;[] tab = table;        <span class="hljs-comment">// 计算元素在数组中的下标</span>        <span class="hljs-keyword">int</span> index = (tab.length - <span class="hljs-number">1</span>) &amp; hash;        <span class="hljs-comment">// 根据下标获取链表头结点</span>        HashEntry&lt;K,V&gt; first = entryAt(tab, index);        <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;            <span class="hljs-comment">// 遍历链表寻找该元素, 找到则进行替换</span>            <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;                K k;                <span class="hljs-keyword">if</span> ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123;                    oldValue = e.value;                    <span class="hljs-comment">// 根据参数决定是否替换旧值</span>                    <span class="hljs-keyword">if</span> (!onlyIfAbsent) &#123;                        e.value = value;                        ++modCount;                    &#125;                    <span class="hljs-keyword">break</span>;                &#125;                e = e.next;            <span class="hljs-comment">// 没找到则在链表添加一个结点</span>            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 将node结点插入链表头部</span>                <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>) &#123;                    node.setNext(first);                &#125; <span class="hljs-keyword">else</span> &#123;                    node = <span class="hljs-keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);                &#125;                <span class="hljs-comment">// 插入结点后将元素总是加1</span>                <span class="hljs-keyword">int</span> c = count + <span class="hljs-number">1</span>;                <span class="hljs-comment">// 元素超过阀值则进行扩容</span>                <span class="hljs-keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) &#123;                    rehash(node);                <span class="hljs-comment">// 否则就将哈希表指定下标替换为node结点</span>                &#125; <span class="hljs-keyword">else</span> &#123;                    setEntryAt(tab, index, node);                &#125;                ++modCount;                count = c;                oldValue = <span class="hljs-keyword">null</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        unlock();    &#125;    <span class="hljs-keyword">return</span> oldValue;&#125;</code></pre></div><p>为保证线程安全，分段锁中的put操作是需要进行加锁的，所以线程一开始就会去获取锁，如果获取成功就继续执行，若获取失败则调用scanAndLockForPut方法进行自旋，在自旋过程中会先去扫描哈希表去查找指定的key，如果key不存在就会新建一个HashEntry返回，这样在获取到锁之后就不必再去新建了，为的是在等待锁的过程中顺便做些事情，不至于白白浪费时间，可见作者的良苦用心。</p><p>具体自旋方法我们后面再细讲，现在先把关注点拉回来，线程在成功获取到锁之后会根据计算到的下标，获取指定下标的元素。此时获取到的是链表的头结点，如果头结点不为空就对链表进行遍历查找，找到之后再根据onlyIfAbsent参数的值决定是否进行替换。</p><p>如果遍历没找到就会新建一个HashEntry指向头结点，此时如果自旋时创建了HashEntry，则直接将它的next指向当前头结点，如果自旋时没有创建就在这里新建一个HashEntry并指向头结点。</p><p>在向链表添加元素之后检查元素总数是否超过阀值，如果超过就调用rehash进行扩容，没超过的话就直接将数组对应下标的元素引用指向新添加的node。setEntryAt方法内部是通过调用UnSafe的putOrderedObject方法来更改数组元素引用的，这样就保证了其他线程在读取时可以读到最新的值。</p><p><strong>2.7、删除元素的操作</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 删除指定元素(找到对应元素后直接删除)</span><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span><span class="hljs-params">(Object key)</span> </span>&#123;    <span class="hljs-comment">// 使用哈希函数计算哈希码</span>    <span class="hljs-keyword">int</span> hash = hash(key);    <span class="hljs-comment">// 根据哈希码获取分段锁的索引</span>    Segment&lt;K,V&gt; s = segmentForHash(hash);    <span class="hljs-comment">// 调用分段锁的remove方法</span>    <span class="hljs-keyword">return</span> s == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : s.remove(key, hash, <span class="hljs-keyword">null</span>);&#125;<span class="hljs-comment">// 删除指定元素(查找值等于给定值才删除)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object key, Object value)</span> </span>&#123;    <span class="hljs-comment">// 使用哈希函数计算哈希码</span>    <span class="hljs-keyword">int</span> hash = hash(key);    Segment&lt;K,V&gt; s;    <span class="hljs-comment">// 确保分段锁不为空才调用remove方法</span>    <span class="hljs-keyword">return</span> value != <span class="hljs-keyword">null</span> &amp;&amp; (s = segmentForHash(hash)) != <span class="hljs-keyword">null</span> &amp;&amp; s.remove(key, hash, value) != <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p>ConcurrentHashMap提供了两种删除操作，<strong>一种是找到后直接删除，一种是找到后先比较再删除</strong>。<strong>这两种删除方法都是先根据key的哈希码找到对应的分段锁后，再通过调用分段锁的remove方法完成删除操作</strong>。下面我们来看看分段锁的remove方法。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 删除指定元素</span><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">remove</span><span class="hljs-params">(Object key, <span class="hljs-keyword">int</span> hash, Object value)</span> </span>&#123;    <span class="hljs-comment">// 尝试获取锁, 若失败则进行自旋</span>    <span class="hljs-keyword">if</span> (!tryLock()) &#123;        scanAndLock(key, hash);    &#125;    V oldValue = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        HashEntry&lt;K,V&gt;[] tab = table;        <span class="hljs-comment">// 计算元素在数组中的下标</span>        <span class="hljs-keyword">int</span> index = (tab.length - <span class="hljs-number">1</span>) &amp; hash;        <span class="hljs-comment">// 根据下标取得数组元素(链表头结点)</span>        HashEntry&lt;K,V&gt; e = entryAt(tab, index);        HashEntry&lt;K,V&gt; pred = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 遍历链表寻找要删除的元素</span>        <span class="hljs-keyword">while</span> (e != <span class="hljs-keyword">null</span>) &#123;            K k;            <span class="hljs-comment">// next指向当前结点的后继结点</span>            HashEntry&lt;K,V&gt; next = e.next;            <span class="hljs-comment">// 根据key和hash寻找对应结点</span>            <span class="hljs-keyword">if</span> ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123;                V v = e.value;                <span class="hljs-comment">// 传入的value不等于v就跳过, 其他情况就进行删除操作</span>                <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span> || value == v || value.equals(v)) &#123;                    <span class="hljs-comment">// 如果pred为空则代表要删除的结点为头结点</span>                    <span class="hljs-keyword">if</span> (pred == <span class="hljs-keyword">null</span>) &#123;                        <span class="hljs-comment">// 重新设置链表头结点</span>                        setEntryAt(tab, index, next);                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-comment">// 设置pred结点的后继为next结点</span>                        pred.setNext(next);                    &#125;                    ++modCount;                    --count;                    <span class="hljs-comment">// 记录元素删除之前的值</span>                    oldValue = v;                &#125;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-comment">// 若e不是要找的结点就将pred引用指向它</span>            pred = e;            <span class="hljs-comment">// 检查下一个结点</span>            e = next;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        unlock();    &#125;    <span class="hljs-keyword">return</span> oldValue;&#125;</code></pre></div><p><strong>2.8、替换元素的操作</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 替换指定元素(CAS操作)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">replace</span><span class="hljs-params">(K key, V oldValue, V newValue)</span> </span>&#123;    <span class="hljs-comment">// 使用哈希函数计算哈希码</span>    <span class="hljs-keyword">int</span> hash = hash(key);    <span class="hljs-comment">// 保证oldValue和newValue不为空</span>    <span class="hljs-keyword">if</span> (oldValue == <span class="hljs-keyword">null</span> || newValue == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-comment">// 根据哈希码获取分段锁的索引</span>    Segment&lt;K,V&gt; s = segmentForHash(hash);    <span class="hljs-comment">// 调用分段锁的replace方法</span>    <span class="hljs-keyword">return</span> s != <span class="hljs-keyword">null</span> &amp;&amp; s.replace(key, hash, oldValue, newValue);&#125;<span class="hljs-comment">// 替换元素操作(CAS操作)</span><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">replace</span><span class="hljs-params">(K key, <span class="hljs-keyword">int</span> hash, V oldValue, V newValue)</span> </span>&#123;    <span class="hljs-comment">// 尝试获取锁, 若失败则进行自旋</span>    <span class="hljs-keyword">if</span> (!tryLock()) &#123;        scanAndLock(key, hash);    &#125;    <span class="hljs-keyword">boolean</span> replaced = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">try</span> &#123;        HashEntry&lt;K,V&gt; e;        <span class="hljs-comment">// 通过hash直接找到头结点然后对链表遍历</span>        <span class="hljs-keyword">for</span> (e = entryForHash(<span class="hljs-keyword">this</span>, hash); e != <span class="hljs-keyword">null</span>; e = e.next) &#123;            K k;            <span class="hljs-comment">// 根据key和hash找到要替换的结点</span>            <span class="hljs-keyword">if</span> ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123;                <span class="hljs-comment">// 如果指定的当前值正确则进行替换</span>                <span class="hljs-keyword">if</span> (oldValue.equals(e.value)) &#123;                    e.value = newValue;                    ++modCount;                    replaced = <span class="hljs-keyword">true</span>;                &#125;                <span class="hljs-comment">// 否则不进行任何操作直接返回</span>                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        unlock();    &#125;    <span class="hljs-keyword">return</span> replaced;&#125;</code></pre></div><p>ConcurrentHashMap同样提供了两种替换操作，一种是找到后直接替换，另一种是找到后先比较再替换(CAS操作)。这两种操作的实现大致是相同的，只是CAS操作在替换前多了一层比较操作，因此我们只需简单了解其中一种操作即可。</p><p>这里拿CAS操作进行分析，还是老套路，首先根据key的哈希码找到对应的分段锁，然后调用它的replace方法。进入分段锁中的replace方法后需要先去获取锁，如果获取失败则进行自旋，如果获取成功则进行下一步。</p><p>首先根据hash码获取链表头结点，然后根据key和hash进行遍历查找，找到了对应的元素之后，比较给定的oldValue是否是当前值，如果不是则放弃修改，如果是则用新值进行替换。由于HashEntry对象的value域是volatile类型的，因此可以直接替换。</p><p><strong>2.9、自旋操作</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 自旋等待获取锁(put操作)</span><span class="hljs-function"><span class="hljs-keyword">private</span> HashEntry&lt;K,V&gt; <span class="hljs-title">scanAndLockForPut</span><span class="hljs-params">(K key, <span class="hljs-keyword">int</span> hash, V value)</span> </span>&#123;    <span class="hljs-comment">// 根据哈希码获取头结点</span>    HashEntry&lt;K,V&gt; first = entryForHash(<span class="hljs-keyword">this</span>, hash);    HashEntry&lt;K,V&gt; e = first;    HashEntry&lt;K,V&gt; node = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">int</span> retries = -<span class="hljs-number">1</span>;    <span class="hljs-comment">// 在while循环内自旋</span>    <span class="hljs-keyword">while</span> (!tryLock()) &#123;        HashEntry&lt;K,V&gt; f;        <span class="hljs-keyword">if</span> (retries &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 如果头结点为空就新建一个node</span>            <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;                    node = <span class="hljs-keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>);                &#125;                retries = <span class="hljs-number">0</span>;            <span class="hljs-comment">// 否则就遍历链表定位该结点</span>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.equals(e.key)) &#123;                retries = <span class="hljs-number">0</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                e = e.next;            &#125;        <span class="hljs-comment">// retries每次在这加1, 并判断是否超过最大值</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;            lock();            <span class="hljs-keyword">break</span>;        <span class="hljs-comment">// retries为偶数时去判断first有没有改变</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((retries &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> &amp;&amp; (f = entryForHash(<span class="hljs-keyword">this</span>, hash)) != first) &#123;            e = first = f;            retries = -<span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> node;&#125;<span class="hljs-comment">// 自旋等待获取锁(remove和replace操作)</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scanAndLock</span><span class="hljs-params">(Object key, <span class="hljs-keyword">int</span> hash)</span> </span>&#123;    <span class="hljs-comment">// 根据哈希码获取链表头结点</span>    HashEntry&lt;K,V&gt; first = entryForHash(<span class="hljs-keyword">this</span>, hash);    HashEntry&lt;K,V&gt; e = first;    <span class="hljs-keyword">int</span> retries = -<span class="hljs-number">1</span>;    <span class="hljs-comment">// 在while循环里自旋</span>    <span class="hljs-keyword">while</span> (!tryLock()) &#123;        HashEntry&lt;K,V&gt; f;        <span class="hljs-keyword">if</span> (retries &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 遍历链表定位到该结点</span>            <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span> || key.equals(e.key)) &#123;                retries = <span class="hljs-number">0</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                e = e.next;            &#125;        <span class="hljs-comment">// retries每次在这加1, 并判断是否超过最大值</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;            lock();            <span class="hljs-keyword">break</span>;        <span class="hljs-comment">// retries为偶数时去判断first有没有改变</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((retries &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> &amp;&amp; (f = entryForHash(<span class="hljs-keyword">this</span>, hash)) != first) &#123;            e = first = f;            retries = -<span class="hljs-number">1</span>;        &#125;    &#125;&#125;</code></pre></div><p><strong>2.10、哈希表的扩容操作</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 再哈希</span><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rehash</span><span class="hljs-params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;    <span class="hljs-comment">// 获取旧哈希表的引用</span>    HashEntry&lt;K,V&gt;[] oldTable = table;    <span class="hljs-comment">// 获取旧哈希表的容量</span>    <span class="hljs-keyword">int</span> oldCapacity = oldTable.length;    <span class="hljs-comment">// 计算新哈希表的容量(为旧哈希表的2倍)</span>    <span class="hljs-keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="hljs-number">1</span>;    <span class="hljs-comment">// 计算新的元素阀值</span>    threshold = (<span class="hljs-keyword">int</span>)(newCapacity * loadFactor);    <span class="hljs-comment">// 新建一个HashEntry数组</span>    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) <span class="hljs-keyword">new</span> HashEntry[newCapacity];    <span class="hljs-comment">// 生成新的掩码值</span>    <span class="hljs-keyword">int</span> sizeMask = newCapacity - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 遍历旧表的所有元素</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; oldCapacity ; i++) &#123;        <span class="hljs-comment">// 取得链表头结点</span>        HashEntry&lt;K,V&gt; e = oldTable[i];        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;            HashEntry&lt;K,V&gt; next = e.next;            <span class="hljs-comment">// 计算元素在新表中的索引</span>            <span class="hljs-keyword">int</span> idx = e.hash &amp; sizeMask;            <span class="hljs-comment">// next为空表明链表只有一个结点</span>            <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// 直接把该结点放到新表中</span>                newTable[idx] = e;            &#125;<span class="hljs-keyword">else</span> &#123;                HashEntry&lt;K,V&gt; lastRun = e;                <span class="hljs-keyword">int</span> lastIdx = idx;                <span class="hljs-comment">// 定位lastRun结点, 将lastRun之后的结点直接放到新表中</span>                <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; last = next; last != <span class="hljs-keyword">null</span>; last = last.next) &#123;                    <span class="hljs-keyword">int</span> k = last.hash &amp; sizeMask;                    <span class="hljs-keyword">if</span> (k != lastIdx) &#123;                        lastIdx = k;                        lastRun = last;                    &#125;                &#125;                newTable[lastIdx] = lastRun;                <span class="hljs-comment">// 遍历在链表lastRun结点之前的元素, 将它们依次复制到新表中</span>                <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;                    V v = p.value;                    <span class="hljs-keyword">int</span> h = p.hash;                    <span class="hljs-keyword">int</span> k = h &amp; sizeMask;                    HashEntry&lt;K,V&gt; n = newTable[k];                    newTable[k] = <span class="hljs-keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-comment">// 计算传入结点在新表中的下标</span>    <span class="hljs-keyword">int</span> nodeIndex = node.hash &amp; sizeMask;    <span class="hljs-comment">// 将传入结点添加到链表头结点</span>    node.setNext(newTable[nodeIndex]);    <span class="hljs-comment">// 将新表指定下标元素换成传入结点</span>    newTable[nodeIndex] = node;    <span class="hljs-comment">// 将哈希表引用指向新表</span>    table = newTable;&#125;</code></pre></div><p>rehash方法在put方法中被调用，我们知道在put方法时会新建元素并添加到哈希数组中，随着元素的增多发生哈希冲突的可能性越大，哈希表的性能也会随之下降。因此每次put操作时都会检查元素总数是否超过阀值，如果超过则调用rehash方法进行扩容。因为数组长度一旦确定则不能再被改变，因此需要新建一个数组来替换原先的数组。</p><p>从代码中可以知道新创建的数组长度为原数组的2倍(oldCapacity &lt;&lt; 1)。创建好新数组后需要将旧数组中的所有元素移到新数组中，因此需要计算每个元素在新数组中的下标。计算新下标的过程如下图所示。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530205709.png" srcset="/img/loading.gif" alt="image-20210530205709518"></p><p>我们知道下标直接取的是哈希码的后几位，由于新数组的容量是直接用旧数组容量右移1位得来的，因此掩码位数向右增加1位，取到的哈希码位数也向右增加1位。如上图，若旧的掩码值为111，则元素下标为101，扩容后新的掩码值为1111，则计算出元素的新下标为0101。</p><p>由于同一条链表上的元素下标是相同的，现在假设链表所有元素的下标为101，在扩容后该链表元素的新下标只有0101或1101这两种情况，因此数组扩容会打乱原先的链表并将链表元素分成两批。</p><p>在计算出新下标后需要将元素移动到新数组中，在HashMap中通过直接修改next引用导致了多线程的死锁。虽然在ConcurrentHashMap中通过加锁避免了这种情况，但是我们知道next域是volatile类型的，它的改动能立马被读线程读取到，因此为保证线程安全采用复制元素来迁移数组。</p><p>但是对链表中每个元素都进行复制有点影响性能，作者发现链表尾部有许多元素的next是不变的，它们在新数组中的下标是相同的，因此可以考虑整体移动这部分元素。具统计实际操作中只有1/6的元素是必须复制的，所以整体移动链表尾部元素(lastRun后面的元素)是可以提升一定性能的。</p>]]></content>
    
    
    <categories>
      
      <category>语言相关</category>
      
      <category>Java进阶</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Happens-Before原则</title>
    <link href="/2021/05/30/Happens-Before%E5%8E%9F%E5%88%99/"/>
    <url>/2021/05/30/Happens-Before%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="1、JMM的设计"><a href="#1、JMM的设计" class="headerlink" title="1、JMM的设计"></a>1、JMM的设计</h1><p>JMM设计时一方面要为程序员提供足够强的内存可见性保证；另一方面对编译器和处理器的限制要尽可能的放松，设计JMM时需要进行平衡。</p><p>【案例1】</p><p>double pi = 3.14; // A </p><p>double r = 1.0; // B </p><p>double area = pi * r *r; // C </p><p>上面计算圆的面积的示例代码存在3个happens-before关系，如下所示：</p><p>1、A happens-before B；</p><p>2、B happens-before C；</p><p>3、A happens-before C。</p><p>上面的3个happens-before关系，2和3是必须的，但是1不是必须的。因此，JMM把happens- before要求禁止的重排序分为了下面两类：</p><p>1、会改变程序执行结果的重排序；</p><p>2、不会改变程序执行结果的重排序。</p><p>JMM的设计示意图如下所示：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530204646.png" srcset="/img/loading.gif" alt="image-20210530204646272"></p><p>从上图可以看出两点：</p><ul><li>JMM向程序员提供的happens-before规则能满足程序员的需求。JMM的happens-before规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的A     happens-before B）。</li><li>JMM对编译器和处理器的束缚已经尽可能的少。从上面的分析我们可以看出，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。比如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再比如，如果编译器经过细致的分析后，认定一个volatile变量仅仅只会被单个线程访问，那么编译器可以把这个volatile变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</li></ul><h1 id="2、happens-before的定义"><a href="#2、happens-before的定义" class="headerlink" title="2、happens-before的定义"></a>2、happens-before的定义</h1><p>JSR使用happens-before的概念来指定两个操作之间的执行顺序。由于这两个操作可以在一个线程之内，也可以在不同的线程之间。因此，JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证（如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见）。</p><p><strong>happens-before定义：</strong></p><p>1、如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前；</p><p>2、两个操作之间存在 happens-before关系，并不意味着Java平台的具体实现必须要按照 happens-before关系指定的顺序执行。<strong>只要重排序的执行结果与按照 happens-before执行的结果一致，那么JMM允许这种重排序。</strong></p><p>第一点是JMM对程序员的承诺，第二点是JMM对编译器和处理器重排序的约束原则。</p><h1 id="3、happens-before规则"><a href="#3、happens-before规则" class="headerlink" title="3、happens-before规则"></a>3、happens-before规则</h1><p>1、<strong>程序顺序原则：</strong>即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行；</p><p>2、<strong>锁规则：</strong>解锁(unlock)操作发生在后续的同一个锁的加锁(lock)之前。也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)；</p><p>3、<strong>volatile规则：</strong>volatile变量的“写”先发生于“读”，这保证了volatile变量的可见性。简单的理解就是：volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值；而当该变量值发生变化时，又会强迫将最新的值刷新到主内存中。因此，任何时刻，不同的线程总是能够看到该变量的最新值；</p><p>4、<strong>线程启动规则：</strong>线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B是可见的；</p><p>5、<strong>传递性：</strong>A先于B ，B先于C ，那么A必然先于C；</p><p>6、<strong>线程终止规则</strong>：线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。</p><p>7、<strong>线程中断规则：</strong>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</p><p>8、<strong>对象终结规则</strong>：对象的构造函数执行（对象的初始化），结束先于finalize()方法；</p><p>这里从中挑几种讲解下：</p><p><strong>volatile规则</strong></p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530204723.png" srcset="/img/loading.gif" alt="image-20210530204722998"></p><ul><li>1 happens-before 2 和 3 happens-before 4由程序的顺序规则产生；</li><li>2 happens-before 3 是由volatile规则产生；</li><li>1 happens-before 4 是由传递性规则产生的。</li></ul><p><strong>线程启动规则</strong></p><p>假设线程A在执行过程中，通过执行ThreadB.start()来启动线程B；同时，假设线程A在执行ThreadB.start()之前修改了一些共享变量，线程B在开始执行后会读这些共享变量。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530204817.png" srcset="/img/loading.gif" alt="image-20210530204817864"></p><ul><li>1 happens-before 2     由程序顺序规则产生；</li><li>2 happens-before 4     由start()规则产生；</li><li>1 happens-before 4     由传递性产生。</li></ul><p>这就意味着，线程A在执行ThreadB.start()之前对共享变量所做的修改，接下来在线程B开始执行后都将确保对线程B可见。</p><p><strong>线程终止规则 / join()</strong> </p><p>假设线程A在执行过程中，通过执行ThreadB.join()来等待线程B的终止；同时，假设线程B在终止之前修改了一些共享变量，线程A从ThreadB.join()返回后读这些共享变量。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530204849.png" srcset="/img/loading.gif" alt="image-20210530204849355"></p><ul><li>2      happens-before 4：join()规则产生；</li><li>4      happens-before 5：程序顺序规则产生；</li><li>2      happens-before 5：传递性规则产生。</li></ul><p>这也就意味着，线程A执行操作ThreadB.join()并成功返回后，线程B中的任意操纵都将对线程A可见。</p>]]></content>
    
    
    <categories>
      
      <category>语言相关</category>
      
      <category>Java进阶</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fork/Join框架</title>
    <link href="/2021/05/30/Fork-Join%E6%A1%86%E6%9E%B6/"/>
    <url>/2021/05/30/Fork-Join%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p><strong>1. 简介</strong></p><p>Fork/Join并行方式是获取良好的并行计算性能的一种最简单同时也是最有效的设计技术。Fork/Join并行算法是我们所熟悉的<strong>分治算法的并行版本</strong>，典型的用法如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function">Result <span class="hljs-title">solve</span><span class="hljs-params">(Problem problem)</span> </span>&#123;    <span class="hljs-keyword">if</span> (problem is small) &#123;        directly solve problem    &#125; <span class="hljs-keyword">else</span> &#123;        split problem into independent parts        fork <span class="hljs-keyword">new</span> subtasks to solve each part        join all subtasks        compose result from subresults    &#125;&#125;</code></pre></div><p>fork操作将会启动一个新的并行Fork/Join子任务。join操作会一直等待直到所有的子任务都结束。Fork/Join算法，如同其他分治算法一样，总是会递归的、反复的划分子任务，直到这些子任务可以用足够简单的、短小的顺序方法来执行。</p><p><strong>2. 工作窃取算法</strong></p><p>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530204028.png" srcset="/img/loading.gif" alt="image-20210530204028621"></p><p>那么为什么需要使用工作窃取算法呢？假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p><p>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p><p><strong>3. Fork/Join框架的介绍</strong></p><p>我们已经很清楚Fork/Join框架的需求了，那么我们可以思考一下，如果让我们来设计一个Fork/Join框架，该如何设计？这个思考有助于你理解Fork/Join框架的设计。</p><p><strong>第一步分割任务。</strong></p><p>首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停的分割，直到分割出的子任务足够小。</p><p><strong>第二步执行任务并合并结果。</strong></p><p>分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</p><p>Fork/Join使用两个类来完成以上两件事情：</p><p>ForkJoinTask：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制，通常情况下我们不需要直接继承ForkJoinTask类，而只需要继承它的子类，Fork/Join框架提供了以下两个子类：</p><ul><li>RecursiveAction：用于没有返回结果的任务。</li><li>RecursiveTask     ：用于有返回结果的任务。</li></ul><p>ForkJoinPool ：ForkJoinTask需要通过ForkJoinPool来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</p><p><strong>4. 使用Fork/Join框架</strong></p><p>让我们通过一个简单的需求来使用下Fork／Join框架，需求是：计算1+2+3+4的结果。</p><p>使用Fork／Join框架首先要考虑到的是如何分割任务，如果我们希望每个子任务最多执行两个数的相加，那么我们设置分割的阈值是2，由于是4个数字相加，所以Fork／Join框架会把这个任务fork成两个子任务，子任务一负责计算1+2，子任务二负责计算3+4，然后再join两个子任务的结果。</p><p>因为是有结果的任务，所以必须继承RecursiveTask，实现代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<span class="hljs-keyword">import</span> java.util.concurrent.ForkJoinPool;<span class="hljs-keyword">import</span> java.util.concurrent.Future;<span class="hljs-keyword">import</span> java.util.concurrent.RecursiveTask;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> THRESHOLD = <span class="hljs-number">2</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> start;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> end;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CountTask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start,<span class="hljs-keyword">int</span> end)</span> </span>&#123;        <span class="hljs-keyword">this</span>.start= start;        <span class="hljs-keyword">this</span>.end= end;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Integer <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-comment">//如果任务足够小就计算任务</span>        <span class="hljs-keyword">boolean</span> canCompute = (end - start) &lt;= THRESHOLD;        <span class="hljs-keyword">if</span> (canCompute) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt;= end; i++) &#123;                sum += i;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//如果任务大于阀值，就分裂成两个子任务计算</span>            <span class="hljs-keyword">int</span> middle = (start + end) / <span class="hljs-number">2</span>;            CountTask leftTask = <span class="hljs-keyword">new</span> CountTask(start, middle);            CountTask rightTask = <span class="hljs-keyword">new</span> CountTask(middle + <span class="hljs-number">1</span>, end);            <span class="hljs-comment">//执行子任务</span>            leftTask.fork();            rightTask.fork();            <span class="hljs-comment">//等待子任务执行完，并得到其结果</span>            <span class="hljs-keyword">int</span> leftResult = (<span class="hljs-keyword">int</span>) leftTask.join();            <span class="hljs-keyword">int</span> rightResult = (<span class="hljs-keyword">int</span>) rightTask.join();            <span class="hljs-comment">//合并子任务</span>            sum = leftResult + rightResult;        &#125;        <span class="hljs-keyword">return</span> sum;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ForkJoinPool forkJoinPool = <span class="hljs-keyword">new</span> ForkJoinPool();        <span class="hljs-comment">//生成一个计算任务，负责计算1+2+3+4</span>        CountTask task = <span class="hljs-keyword">new</span> CountTask(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);        <span class="hljs-comment">//执行一个任务</span>        Future result = forkJoinPool.submit(task);        <span class="hljs-keyword">try</span>&#123;            System.out.println(result.get());        &#125;<span class="hljs-keyword">catch</span>(InterruptedException e) &#123;        &#125;<span class="hljs-keyword">catch</span>(ExecutionException e) &#123;        &#125;    &#125;&#125;</code></pre></div><p>通过这个例子让我们再来进一步了解ForkJoinTask，ForkJoinTask与一般的任务的主要区别在于它需要实现compute方法，在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果不足够小，就必须分割成两个子任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成小任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完并得到其结果。</p><p><strong>5. Fork/Join框架的异常处理</strong></p><p>ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常。使用如下代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(task.isCompletedAbnormally())&#123;System.out.println(task.getException());&#125;</code></pre></div><p>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。</p><p><strong>6. Fork/Join框架的实现原理</strong></p><p>ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，ForkJoinTask数组负责存放程序提交给ForkJoinPool的任务，而ForkJoinWorkerThread数组负责执行这些任务。</p><p>ForkJoinTask的fork方法实现原理。当我们调用ForkJoinTask的fork方法时，程序会调用ForkJoinWorkerThread的pushTask方法异步的执行这个任务，然后立即返回结果。代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ForkJoinTask <span class="hljs-title">fork</span><span class="hljs-params">()</span> </span>&#123;    ((ForkJoinWorkerThread) Thread.currentThread()).pushTask(<span class="hljs-keyword">this</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;</code></pre></div><p>pushTask方法把当前任务存放在ForkJoinTask 数组queue里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushTask</span><span class="hljs-params">(ForkJoinTask t)</span> </span>&#123;    ForkJoinTask[] q; <span class="hljs-keyword">int</span> s, m;    <span class="hljs-keyword">if</span> ((q = queue) != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-comment">// ignore if queue removed</span>        <span class="hljs-keyword">long</span> u = (((s = queueTop) &amp; (m = q.length - <span class="hljs-number">1</span>)) &lt;&lt; ASHIFT) + ABASE;        UNSAFE.putOrderedObject(q, u, t);        queueTop = s + <span class="hljs-number">1</span>;         <span class="hljs-comment">// or use putOrderedInt</span>        <span class="hljs-keyword">if</span> ((s -= queueBase) &lt;= <span class="hljs-number">2</span>)        pool.signalWork();        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == m)        growQueue();    &#125;&#125;</code></pre></div><p>ForkJoinTask的join方法实现原理。Join方法的主要作用是阻塞当前线程并等待获取结果。让我们一起看看ForkJoinTask的join方法的实现，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">join</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (doJoin() != NORMAL)        <span class="hljs-keyword">return</span> reportResult();    <span class="hljs-keyword">else</span>       <span class="hljs-keyword">return</span> getRawResult();&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> V <span class="hljs-title">reportResult</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> s; Throwable ex;    <span class="hljs-keyword">if</span> ((s = status) == CANCELLED)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CancellationException();    <span class="hljs-keyword">if</span> (s == EXCEPTIONAL &amp;&amp; (ex = getThrowableException()) != <span class="hljs-keyword">null</span>)        UNSAFE.throwException(ex);    <span class="hljs-keyword">return</span> getRawResult();&#125;</code></pre></div><p>首先，它调用了doJoin()方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有四种：已完成（NORMAL），被取消（CANCELLED），信号（SIGNAL）和出现异常（EXCEPTIONAL）。</p><ul><li>如果任务状态是已完成，则直接返回任务结果。</li><li>如果任务状态是被取消，则直接抛出CancellationException。</li><li>如果任务状态是抛出异常，则直接抛出对应的异常。</li></ul><p>让我们再来分析下doJoin()方法的实现代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doJoin</span><span class="hljs-params">()</span> </span>&#123;    Thread t;    ForkJoinWorkerThread w;    <span class="hljs-keyword">int</span> s;    <span class="hljs-keyword">boolean</span> completed;    <span class="hljs-keyword">if</span> ((t = Thread.currentThread()) <span class="hljs-keyword">instanceof</span> ForkJoinWorkerThread) &#123;        <span class="hljs-keyword">if</span> ((s = status) &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> s;        &#125;        <span class="hljs-keyword">if</span> ((w = (ForkJoinWorkerThread) t).unpushTask(<span class="hljs-keyword">this</span>)) &#123;            <span class="hljs-keyword">try</span> &#123;                completed = exec();            &#125; <span class="hljs-keyword">catch</span> (Throwable rex) &#123;                <span class="hljs-keyword">return</span> setExceptionalCompletion(rex);            &#125;            <span class="hljs-keyword">if</span> (completed) &#123;                <span class="hljs-keyword">return</span> setCompletion(NORMAL);            &#125;        &#125;        <span class="hljs-keyword">return</span> w.joinTask(<span class="hljs-keyword">this</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> externalAwaitDone();    &#125;&#125;</code></pre></div><p>在doJoin()方法里，首先通过查看任务的状态，看任务是否已经执行完了，如果执行完了，则直接返回任务状态，如果没有执行完，则从任务数组里取出任务并执行。如果任务顺利执行完成了，则设置任务状态为NORMAL，如果出现异常，则记录异常，并将任务状态设置为EXCEPTIONAL。</p><p><strong>7. Fork/Join源码剖析与算法解析</strong></p><p>我们在大学算法课本上，学过的一种基本算法就是：分治。其基本思路就是：把一个大的任务分成若干个子任务，这些子任务分别计算，最后再Merge出最终结果。这个过程通常都会用到递归。</p><p>而Fork/Join其实就是一种利用多线程来实现“分治算法”的并行框架。</p><p>另外一方面，可以把Fori/Join看作一个单机版的Map/Reduce，只不过这里的并行不是多台机器并行计算，而是多个线程并行计算。</p><p>下面看2个简单例子：</p><p>例子1： 快排 </p><p>我们都知道，快排有2个步骤： </p><ul><li>第1步，拿数组的第1个元素，把元素划分成2半，左边的比该元素小，右边的比该元素大； </li><li>第2步，对左右的2个子数组，分别排序。</li></ul><p>可以看出，这里左右2个子数组，可以相互独立的，并行计算。因此可以利用ForkJoin框架， 代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//定义一个Task，基础自RecursiveAction，实现其compute方法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveAction</span> </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span>[] array;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> lo;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hi;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> THRESHOLD = <span class="hljs-number">0</span>; <span class="hljs-comment">//For demo only</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SortTask</span><span class="hljs-params">(<span class="hljs-keyword">long</span>[] array)</span> </span>&#123;        <span class="hljs-keyword">this</span>.array = array;        <span class="hljs-keyword">this</span>.lo = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.hi = array.length - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SortTask</span><span class="hljs-params">(<span class="hljs-keyword">long</span>[] array, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span> </span>&#123;        <span class="hljs-keyword">this</span>.array = array;        <span class="hljs-keyword">this</span>.lo = lo;        <span class="hljs-keyword">this</span>.hi = hi;    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (hi - lo &lt; THRESHOLD)            sequentiallySort(array, lo, hi);        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">int</span> pivot = partition(array, lo, hi); <span class="hljs-comment">//划分</span>            coInvoke(<span class="hljs-keyword">new</span> SortTask(array, lo, pivot - <span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> SortTask(array,                    pivot + <span class="hljs-number">1</span>, hi)); <span class="hljs-comment">//递归调，左右2个子数组</span>        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">long</span>[] array, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span> </span>&#123;        <span class="hljs-keyword">long</span> x = array[hi];        <span class="hljs-keyword">int</span> i = lo - <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = lo; j &lt; hi; j++) &#123;            <span class="hljs-keyword">if</span> (array[j] &lt;= x) &#123;                i++;                swap(array, i, j);            &#125;        &#125;        swap(array, i + <span class="hljs-number">1</span>, hi);        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">long</span>[] array, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">if</span> (i != j) &#123;            <span class="hljs-keyword">long</span> temp = array[i];            array[i] = array[j];            array[j] = temp;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sequentiallySort</span><span class="hljs-params">(<span class="hljs-keyword">long</span>[] array, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span> </span>&#123;        Arrays.sort(array, lo, hi + <span class="hljs-number">1</span>);    &#125;&#125;<span class="hljs-comment">//测试函数</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSort</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    ForkJoinTask sort = <span class="hljs-keyword">new</span> SortTask(array); <span class="hljs-comment">//1个任务</span>    ForkJoinPool fjpool = <span class="hljs-keyword">new</span> ForkJoinPool(); <span class="hljs-comment">//1个ForkJoinPool</span>    fjpool.submit(sort); <span class="hljs-comment">//提交任务</span>    fjpool.shutdown(); <span class="hljs-comment">//结束。ForkJoinPool内部会开多个线程，并行上面的子任务</span>    fjpool.awaitTermination(<span class="hljs-number">30</span>, TimeUnit.SECONDS);&#125;</code></pre></div><p>例子2：求1到n个数的和</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//定义一个Task，基础自RecursiveTask，实现其commpute方法</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SumTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">Long</span>&gt;</span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> THRESHOLD = <span class="hljs-number">10</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> start;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> end;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SumTask</span><span class="hljs-params">(<span class="hljs-keyword">long</span> n)</span> </span>&#123;        <span class="hljs-keyword">this</span>(<span class="hljs-number">1</span>,n);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SumTask</span><span class="hljs-params">(<span class="hljs-keyword">long</span> start, <span class="hljs-keyword">long</span> end)</span> </span>&#123;        <span class="hljs-keyword">this</span>.start = start;        <span class="hljs-keyword">this</span>.end = end;    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">//有返回值</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Long <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>((end - start) &lt;= THRESHOLD)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> l = start; l &lt;= end; l++)&#123;                sum += l;            &#125;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">long</span> mid = (start + end) &gt;&gt;&gt; <span class="hljs-number">1</span>;            SumTask left = <span class="hljs-keyword">new</span> SumTask(start, mid); <span class="hljs-comment">//分治，递归</span>            SumTask right = <span class="hljs-keyword">new</span> SumTask(mid + <span class="hljs-number">1</span>, end);            left.fork();            right.fork();            sum = left.join() + right.join();        &#125;        <span class="hljs-keyword">return</span> sum;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;&#125;<span class="hljs-comment">//测试函数</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSum</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    SumTask sum = <span class="hljs-keyword">new</span> SumTask(<span class="hljs-number">100</span>); <span class="hljs-comment">//1个任务</span>    ForkJoinPool fjpool = <span class="hljs-keyword">new</span> ForkJoinPool(); <span class="hljs-comment">//1个ForkJoinPool</span>    Future&lt;Long&gt; future = fjpool.submit(sum); <span class="hljs-comment">//提交任务</span>    Long r = future.get(); <span class="hljs-comment">//获取返回值</span>    fjpool.shutdown();&#125;</code></pre></div><p><strong>8. 与ThreadPool的区别</strong></p><p>通过上面例子，我们可以看出，它在使用上，和ThreadPool有共同的地方，也有区别点： </p><p>（1） ThreadPool只有“外部任务”，也就是调用者放到队列里的任务。 ForkJoinPool有“外部任务”，还有“内部任务”，也就是任务自身在执行过程中，分裂出”子任务“，递归，再次放入队列。 </p><p>（2）ForkJoinPool里面的任务通常有2类，RecusiveAction/RecusiveTask，这2个都是继承自FutureTask。在使用的时候，重写其compute算法。</p><p><strong>9. 工作窃取算法</strong></p><p>上面提到，ForkJoinPool里有”外部任务“，也有“内部任务”。其中外部任务，是放在ForkJoinPool的全局队列里面，而每个Worker线程，也有一个自己的队列，用于存放内部任务。</p><p>窃取的基本思路就是：当worker自己的任务队列里面没有任务时，就去scan别的线程的队列，把别人的任务拿过来执行。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//ForkJoinPool的成员变量</span>ForkJoinWorkerThread[] workers; <span class="hljs-comment">//worker thread集合</span><span class="hljs-keyword">private</span> ForkJoinTask&lt;?&gt;[] submissionQueue; <span class="hljs-comment">//外部任务队列</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock submissionLock;<span class="hljs-comment">//ForkJoinWorkerThread的成员变量</span>ForkJoinTask&lt;?&gt;[] queue; <span class="hljs-comment">//每个worker线程自己的内部任务队列</span><span class="hljs-comment">//提交任务</span><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">ForkJoinTask&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(ForkJoinTask&lt;T&gt; task)</span> </span>&#123;    <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    forkOrSubmit(task);    <span class="hljs-keyword">return</span> task;&#125;<span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">forkOrSubmit</span><span class="hljs-params">(ForkJoinTask&lt;T&gt; task)</span> </span>&#123;    ForkJoinWorkerThread w;    Thread t = Thread.currentThread();    <span class="hljs-keyword">if</span> (shutdown)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException();<span class="hljs-comment">//如果当前是worker线程提交的任务，也就是worker执行过程中，</span><span class="hljs-comment">//分裂出来的子任务，放入worker自己的内部任务队列</span>    <span class="hljs-keyword">if</span> ((t <span class="hljs-keyword">instanceof</span> ForkJoinWorkerThread) &amp;&amp;            (w = (ForkJoinWorkerThread)t).pool == <span class="hljs-keyword">this</span>)        w.pushTask(task);    <span class="hljs-keyword">else</span>        addSubmission(task); <span class="hljs-comment">//外部任务，放入pool的全局队列</span>&#125;<span class="hljs-comment">//worker的run方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    Throwable exception = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        onStart();        pool.work(<span class="hljs-keyword">this</span>);    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;        exception = ex;    &#125; <span class="hljs-keyword">finally</span> &#123;        onTermination(exception);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">(ForkJoinWorkerThread w)</span> </span>&#123;    <span class="hljs-keyword">boolean</span> swept = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// true on empty scans </span>    <span class="hljs-keyword">long</span> c;    <span class="hljs-keyword">while</span> (!w.terminate &amp;&amp; (<span class="hljs-keyword">int</span>)(c = ctl) &gt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">int</span> a; <span class="hljs-comment">// active count </span>        <span class="hljs-keyword">if</span> (!swept &amp;&amp; (a = (<span class="hljs-keyword">int</span>)(c &gt;&gt; AC_SHIFT)) &lt;= <span class="hljs-number">0</span>)            swept = scan(w, a); <span class="hljs-comment">//核心代码都在这个scan函数里面</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tryAwaitWork(w, c))            swept = <span class="hljs-keyword">false</span>;    &#125;&#125;<span class="hljs-comment">//scan的基本思路：从别人的任务队列里面抢，没有，再到pool的全局的任务队列里面去取。</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">scan</span><span class="hljs-params">(ForkJoinWorkerThread w, <span class="hljs-keyword">int</span> a)</span> </span>&#123;    <span class="hljs-keyword">int</span> g = scanGuard;    <span class="hljs-keyword">int</span> m = (parallelism == <span class="hljs-number">1</span> - a &amp;&amp; blockedCount == <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : g &amp; SMASK;    ForkJoinWorkerThread[] ws = workers;    <span class="hljs-keyword">if</span> (ws == <span class="hljs-keyword">null</span> || ws.length &lt;= m) <span class="hljs-comment">// 过期检测 </span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = w.seed, k = r, j = -(m + m); j &lt;= m + m; ++j) &#123;        ForkJoinTask&lt;?&gt; t; ForkJoinTask&lt;?&gt;[] q; <span class="hljs-keyword">int</span> b, i;        <span class="hljs-comment">//随机选出一个牺牲者(工作线程)。 </span>        ForkJoinWorkerThread v = ws[k &amp; m];        <span class="hljs-comment">//一系列检查... </span>        <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span> &amp;&amp; (b = v.queueBase) != v.queueTop &amp;&amp;                (q = v.queue) != <span class="hljs-keyword">null</span> &amp;&amp; (i = (q.length - <span class="hljs-number">1</span>) &amp; b) &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//如果这个牺牲者的任务队列中还有任务，尝试窃取这个任务。 </span>            <span class="hljs-keyword">long</span> u = (i &lt;&lt; ASHIFT) + ABASE;            <span class="hljs-keyword">if</span> ((t = q[i]) != <span class="hljs-keyword">null</span> &amp;&amp; v.queueBase == b &amp;&amp;                    UNSAFE.compareAndSwapObject(q, u, t, <span class="hljs-keyword">null</span>)) &#123;                <span class="hljs-comment">//窃取成功后，调整queueBase </span>                <span class="hljs-keyword">int</span> d = (v.queueBase = b + <span class="hljs-number">1</span>) - v.queueTop;                <span class="hljs-comment">//将牺牲者的stealHint设置为当前工作线程在pool中的下标。 </span>                v.stealHint = w.poolIndex;                <span class="hljs-keyword">if</span> (d != <span class="hljs-number">0</span>)                    signalWork(); <span class="hljs-comment">// 如果牺牲者的任务队列还有任务，继续唤醒(或创建)线程。 </span>                w.execTask(t); <span class="hljs-comment">//执行窃取的任务。 </span>            &#125;            <span class="hljs-comment">//计算出下一个随机种子。 </span>            r ^= r &lt;&lt; <span class="hljs-number">13</span>; r ^= r &gt;&gt;&gt; <span class="hljs-number">17</span>; w.seed = r ^ (r &lt;&lt; <span class="hljs-number">5</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 返回false，表示不是一个空扫描。 </span>        &#125;        <span class="hljs-comment">//前2*m次，随机扫描。 </span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// xorshift </span>            r ^= r &lt;&lt; <span class="hljs-number">13</span>; r ^= r &gt;&gt;&gt; <span class="hljs-number">17</span>; k = r ^= r &lt;&lt; <span class="hljs-number">5</span>;        &#125;        <span class="hljs-comment">//后2*m次，顺序扫描。 </span>        <span class="hljs-keyword">else</span>            ++k;    &#125;    <span class="hljs-keyword">if</span> (scanGuard != g) <span class="hljs-comment">// staleness check </span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//如果扫描完毕后没找到可窃取的任务，那么从Pool的提交任务队列中取一个任务来执行。 </span>        ForkJoinTask&lt;?&gt; t; ForkJoinTask&lt;?&gt;[] q; <span class="hljs-keyword">int</span> b, i;        <span class="hljs-keyword">if</span> ((b = queueBase) != queueTop &amp;&amp;                (q = submissionQueue) != <span class="hljs-keyword">null</span> &amp;&amp;                (i = (q.length - <span class="hljs-number">1</span>) &amp; b) &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">long</span> u = (i &lt;&lt; ASHIFT) + ABASE;            <span class="hljs-keyword">if</span> ((t = q[i]) != <span class="hljs-keyword">null</span> &amp;&amp; queueBase == b &amp;&amp;                    UNSAFE.compareAndSwapObject(q, u, t, <span class="hljs-keyword">null</span>)) &#123;                queueBase = b + <span class="hljs-number">1</span>;                w.execTask(t);            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 如果所有的队列(工作线程的任务队列和pool的任务队列)都是空的，返回true。 </span>    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>语言相关</category>
      
      <category>Java进阶</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Executor框架</title>
    <link href="/2021/05/30/Executor%E6%A1%86%E6%9E%B6/"/>
    <url>/2021/05/30/Executor%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>Java中的线程即是工作单元也是执行机制，从JDK 5后，工作单元与执行机制被分离。工作单元包括Runnable和Callable，执行机制由JDK 5中增加的java.util.concurrent包中Executor框架提供。</p><h1 id="1、Executor-框架简介"><a href="#1、Executor-框架简介" class="headerlink" title="1、Executor 框架简介"></a>1、Executor 框架简介</h1><h2 id="1-1、Executor-框架的两级调度模型"><a href="#1-1、Executor-框架的两级调度模型" class="headerlink" title="1.1、Executor 框架的两级调度模型"></a>1.1、Executor 框架的两级调度模型</h2><p>在 HotSpot VM 的线程模型中，Java线程（java.lang.Thread）被一对一映射为本地操作系统线程。Java线程启动时会创建一个本地操作系统线程；当该Java线程终止时，这个操作系统线程也被回收。操作系统会调度所有线程并将它们分配给可用的CPU。</p><p>在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定的数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。这两级的调度模型的示意图如下所示：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530202212.png" srcset="/img/loading.gif" alt="image-20210530202212035"></p><p>从图中可以看出，应用程序通过 Executor 框架控制上层的调度；而下层的调度由操作系统内核控制，下层的调度不受应用程序的控制。</p><h2 id="1-2、Executor-框架的结构与成员"><a href="#1-2、Executor-框架的结构与成员" class="headerlink" title="1.2、Executor 框架的结构与成员"></a>1.2、Executor 框架的结构与成员</h2><p><strong>1.2.1、Executor 框架的结构</strong></p><p>Executor 框架主要由3大部分组成如下：</p><p>1、任务：包括被执行任务需要实现的接口：Runnable 接口或 Callable 接口；</p><p>2、任务的执行：包括任务执行机制的核心接口Executor，以及继承自 Executor 的 ExecutorService 接口。Executor 框架有两个关键类实现了 ExecutorService 接口，即：ThreadPoolExecutor 和 ScheduledThreadPoolExecutor；</p><p>3、异步计算的结果：包括接口 Future 和实现 Future 接口的 FutureTask 类。</p><p>Executor 框架包含的主要类和接口如下图所示：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530202253.png" srcset="/img/loading.gif" alt="image-20210530202253095"></p><p>1、Executor：是一个接口，它是 Executor 框架的基础，它将任务的提交与任务的执行分离开来；</p><p>2、ThreadPoolExecutor：是线程池的核心实现类，用来执行被提交的任务；</p><p>3、ScheduledThreadPoolExecutor：是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。ScheduledThreadPoolExecutor 比 Timer 更加灵活，功能更强大；</p><p>4、Future 接口和实现 Future 接口的 FutureTask 类，代表异步计算的结果；</p><p>5、Runnable 接口和 Callable 接口的实现类，都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。</p><p>Executor 框架的使用示意图如下图所示：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530202322.png" srcset="/img/loading.gif" alt="image-20210530202322127"></p><ul><li>主线程首先要创建实现Runnable或者Callable接口的任务对象。工具类Executors可以把一个Runnable对象封装为一个Callable对象（Executors.callable(Runnable      task) 或 Executors.callable(Runnable task, Object result)）。</li><li>然后可以把Runnbale对象直接交给     ExecutorService 执行（ExecutorService.execute(Runnable      command)）；或者也可以把Runnable或者Callable对象提交给 ExecutorService     执行（ExecutorService.submit(Runnable task) 或 ExcutorService.submit(Callable<T>      task)）。</li><li>如果执行ExecutorService.submit(     … )，ExecutorService 将返回一个实现 Future 接口的对象。由于 FutureTask 实现了     Runnable，程序员也可以创建 FutureTask，然后直接交给 ExecutorService 执行。</li><li>最后，主线程可以执行     FutureTask.get() 方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel(boolean      mayInterruptIfRunning) 来取消此任务的执行。</li></ul><p><strong>1.2.2、Executor 框架的成员</strong></p><p>Executor 框架的主要成员包括：ThreadPoolExecutor、ScheduledThreadPoolExecutor、Future接口、Runnable接口、Callable接口和Executors。</p><p><strong>1、ThreadPoolExecutor</strong></p><p>ThreadPoolExecutor 通常使用工厂类 Executors 来创建。Executors 可以创建3种类型的 ThreadPoolExecutor：SingleThreadExecutor、FixedThreadPool 和 CachedThreadPool。</p><p><strong>2、ScheduledThreadPoolExecutor</strong></p><p>ScheduledThreadPoolExecutor 通常使用工厂类 Executors 来创建。Executors可以创建2种类型的 ScheduledThreadPoolExecutor，如下：</p><ul><li>ScheduledThreadPoolExecutor：包含若干个线程的ScheduledThreadPoolExecutor；</li><li>SingleThreadScheduledExecutor：包含一个线程的ScheduledThreadPoolExecutor。</li></ul><p><strong>3、Future接口</strong></p><p>Future 接口和实现 Future 接口的 FutureTask 类用来表示异步计算的结果。当我们把 Runnable 接口或 Callable 接口的实现类提交（submit）给 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 时，ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 会向我们返回一个 FutureTask 对象。</p><p><strong>4、Runnable 接口和 Callable 接口</strong></p><p>Runnable 接口和 Callable 接口的实现类，都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。它们之间的区别是 Runnable 不会返回结果，而 Callable 可以返回结果。</p><h1 id="2、ThreadPoolExecutor-详解"><a href="#2、ThreadPoolExecutor-详解" class="headerlink" title="2、ThreadPoolExecutor 详解"></a>2、ThreadPoolExecutor 详解</h1><p>其实关于 ThreadPoolExecutor 在上一篇文章：Java中的线程池详解已经进行了源码讲解，这里仅介绍下它的3种类型：SingleThreadExecutor、FixedThreadPool 和 CachedThreadPool。</p><h2 id="2-1、FixedThreadPool"><a href="#2-1、FixedThreadPool" class="headerlink" title="2.1、FixedThreadPool"></a>2.1、FixedThreadPool</h2><p>创建固定长度的线程池，每次提交任务创建一个线程，直到达到线程池的最大数量，线程池的大小不再变化。</p><p>这个线程池可以创建固定线程数的线程池。特点就是可以重用固定数量线程的线程池。它的构造源码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads,nThreads,                                  <span class="hljs-number">0L</span>,                                  TimeUnit.MILLISECONDS,                                  <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());&#125;</code></pre></div><p>FixedThreadPool的corePoolSize和maxiumPoolSize都被设置为创建FixedThreadPool时指定的参数nThreads；</p><p>0L则表示当线程池中的线程数量操作核心线程的数量时，多余的线程将被立即停止；</p><p>最后一个参数表示FixedThreadPool使用了无界队列LinkedBlockingQueue作为线程池的做工队列，由于是无界的，当线程池的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池的线程数量不会超过corePoolSize，同时maxiumPoolSize也就变成了一个无效的参数，并且运行中的线程池并不会拒绝任务。</p><p>FixedThreadPool运行图如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530202413.png" srcset="/img/loading.gif" alt="image-20210530202413593"></p><p>执行过程如下：</p><p>1.如果当前工作中的线程数量少于corePool的数量，就创建新的线程来执行任务。</p><p>2.当线程池的工作中的线程数量达到了corePool，则将任务加入LinkedBlockingQueue。</p><p>3.线程执行完1中的任务后会从队列中去任务。</p><p>注意：LinkedBlockingQueue是无界队列，所以可以一直添加新任务到线程池。</p><h2 id="2-2、SingleThreadExecutor"><a href="#2-2、SingleThreadExecutor" class="headerlink" title="2.2、SingleThreadExecutor"></a>2.2、SingleThreadExecutor</h2><p>SingleThreadExecutor是使用单个worker线程的Executor。特点是使用单个工作线程执行任务。它的构造源码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService            (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,                                    <span class="hljs-number">0L</span>,                                    TimeUnit.MILLISECONDS,                                    <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));&#125;</code></pre></div><p>SingleThreadExecutor 的 corePoolSize 和 maxiumPoolSize 都被设置1。其他参数均与 FixedThreadPool 相同，其运行图如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530202529.png" srcset="/img/loading.gif" alt="image-20210530202529591"></p><p>执行过程如下：</p><p>1.如果当前工作中的线程数量少于corePool的数量，就创建一个新的线程来执行任务。</p><p>2.当线程池的工作中的线程数量达到了corePool，则将任务加入LinkedBlockingQueue。</p><p>3.线程执行完1中的任务后会从队列中去任务。</p><p>注意：由于在线程池中只有一个工作线程，所以任务可以按照添加顺序执行。</p><h2 id="2-3、CachedThreadPool"><a href="#2-3、CachedThreadPool" class="headerlink" title="2. 3、CachedThreadPool"></a>2. 3、CachedThreadPool</h2><p> CachedThreadPool是一个”无限“容量的线程池，它会根据需要创建新线程。特点是可以根据需要来创建新的线程执行任务，没有特定的corePool。下面是它的构造方法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>,Integer.MAX_VALUE,                                  <span class="hljs-number">60L</span>,                                  TimeUnit.SECONDS,                                  <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());&#125;</code></pre></div><p>CachedThreadPool的corePoolSize被设置为0，即corePool为空；maximumPoolSize被设置为Integer.MAX_VALUE，即maximum是无界的。这里keepAliveTime设置为60秒，意味着空闲的线程最多可以等待任务60秒，否则将被回收。</p><p>CachedThreadPool使用没有容量的SynchronousQueue作为主线程池的工作队列，它是一个没有容量的阻塞队列。每个插入操作必须等待另一个线程的对应移除操作。这意味着，如果主线程提交任务的速度高于线程池中处理任务的速度时，CachedThreadPool会不断创建新线程。极端情况下，CachedThreadPool会因为创建过多线程而耗尽CPU资源。其运行图如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530202625.png" srcset="/img/loading.gif" alt="image-20210530202625591"></p><p>执行过程如下：</p><p>1.首先执行SynchronousQueue.offer(Runnable task)。如果在当前的线程池中有空闲的线程正在执行SynchronousQueue.poll()，那么主线程执行的offer操作与空闲线程执行的poll操作配对成功，主线程把任务交给空闲线程执行。，execute()方法执行成功，否则执行步骤2；</p><p>2.当线程池为空(初始maximumPool为空)或没有空闲线程时，配对失败，将没有线程执行SynchronousQueue.poll操作。这种情况下，线程池会创建一个新的线程执行任务；</p><p>3.在创建完新的线程以后，将会执行poll操作。当步骤2的线程执行完成后，将等待60秒，如果此时主线程提交了一个新任务，那么这个空闲线程将执行新任务，否则被回收。因此长时间不提交任务的CachedThreadPool不会占用系统资源。</p><p>SynchronousQueue是一个不存储元素阻塞队列，每次要进行offer操作时必须等待poll操作，否则不能继续添加元素。</p><h2 id="2-4、具体应用案例"><a href="#2-4、具体应用案例" class="headerlink" title="2.4、具体应用案例"></a>2.4、具体应用案例</h2><p><strong>1、newCachedThreadPool</strong></p><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。示例代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(index * <span class="hljs-number">1000</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            cachedThreadPool.execute(<span class="hljs-keyword">new</span> Runnable()&#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                    System.out.println(index);                &#125;            &#125;);        &#125;    &#125;&#125;</code></pre></div><p>线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。</p><p><strong>2、newFixedThreadPool</strong></p><p>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。示例代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;            fixedThreadPool.execute(<span class="hljs-keyword">new</span> Runnable()&#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-keyword">try</span> &#123;                        System.out.println(index);                        Thread.sleep(<span class="hljs-number">2000</span>);                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;);        &#125;    &#125;&#125;</code></pre></div><p>因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()。可参考PreloadDataCache。</p><p><strong>3、newScheduledThreadPool</strong></p><p>创建一个定长线程池，支持定时及周期性任务执行。延迟执行示例代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="hljs-number">5</span>);        scheduledThreadPool.schedule(<span class="hljs-keyword">new</span> Runnable()&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                System.out.println(<span class="hljs-string">"延迟3秒"</span>);            &#125;        &#125;, <span class="hljs-number">3</span>, TimeUnit.SECONDS);    &#125;&#125;</code></pre></div><p>表示延迟3秒执行。定期执行示例代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="hljs-number">5</span>);        scheduledThreadPool.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable()&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                System.out.println(<span class="hljs-string">"延迟1秒，每3秒执行1次"</span>);            &#125;        &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS);    &#125;&#125;</code></pre></div><p>表示延迟1秒后每3秒执行一次。ScheduledExecutorService比Timer更安全，功能更强大，后面会有一篇单独进行对比。</p><p><strong>4、newSingleThreadExecutor</strong></p><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。示例代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;            singleThreadExecutor.execute(<span class="hljs-keyword">new</span> Runnable()&#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-keyword">try</span> &#123;                        System.out.println(index);                        Thread.sleep(<span class="hljs-number">2000</span>);                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;);        &#125;    &#125;&#125;</code></pre></div><p>结果依次输出，相当于顺序执行各个任务。现行大多数GUI程序都是单线程的。Android中单线程可用于<a href="http://www.trinea.cn/android/database-performance/" target="_blank" rel="noopener">数据库操作</a>，文件操作，应用批量安装，应用批量删除等不适合并发但可能IO阻塞性及影响UI线程响应的操作。</p><p><strong>3、ScheduledThreadPoolExecutor 详解</strong></p><p>我们知道Timer与TimerTask虽然可以实现线程的周期和延迟调度，但是Timer与TimerTask存在一些缺陷，所以对于这种定期、周期执行任务的调度策略，我们一般都是推荐ScheduledThreadPoolExecutor来实现。下面就深入分析ScheduledThreadPoolExecutor是如何来实现线程的周期、延迟调度的。</p><p>ScheduledThreadPoolExecutor，继承ThreadPoolExecutor且实现了ScheduledExecutorService接口，它就相当于提供了“延迟”和“周期执行”功能的ThreadPoolExecutor。在JDK API中是这样定义它的：ScheduledThreadPoolExecutor，它可另行安排在给定的延迟后运行命令，或者定期执行命令。需要多个辅助线程时，或者要求 ScheduledThreadPoolExecutor具有额外的灵活性或功能时，此类要优于 Timer。 一旦启用已延迟的任务就执行它，但是有关何时启用，启用后何时执行则没有任何实时保证。按照提交的先进先出 (FIFO) 顺序来启用那些被安排在同一执行时间的任务。</p><p><strong>3.1、ScheduledThreadPoolExecutor 的运行机制</strong></p><p>ScheduledThreadPoolExecutor 的执行示意图如下图所示：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530202849.png" srcset="/img/loading.gif" alt="image-20210530202849399"></p><p>DelayQueue 是一个无界队列，所以 ThreadPoolExecutor 的 maximumPoolSize 在 ScheduledThreadPoolExecutor 中没有什么意义。</p><p>ScheduledThreadPoolExecutor 的执行主要分为两大部分：</p><p>1、当调用 ScheduledThreadPoolExecutor 的 scheduleAtFixedRate() 方法或者 scheduledWithFixedDelay() 方法时，会向 ScheduledThreadPoolExecutor 的 DelayQueue 添加一个实现了 RunnableScheduledFuture 接口的 ScheduledFutureTask。</p><p>2、线程池中的线程从 DelayQueue 中获取 ScheduledFutureTask，然后执行任务。</p><p>ScheduledThreadPoolExecutor 为了实现周期性的执行任务，对 ThreadPoolExecutor 做了如下的修改：</p><p>1、使用 DelayQueue 作为任务队列；</p><p>2、获取任务的方式不同（后文会讲解到）；</p><p>3、执行周期任务后，增加了额外的处理（后文会讲解到）。</p><p><strong>3.2、ScheduledThreadPoolExecutor 的实现</strong></p><p>先来看下ScheduledThreadPoolExecutor类中的主要结构：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadPoolExecutor</span></span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">ScheduledExecutorService</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicLong sequencer = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>);    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledFutureTask</span>&lt;<span class="hljs-title">V</span>&gt;</span><span class="hljs-class">            <span class="hljs-keyword">extends</span> <span class="hljs-title">FutureTask</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">RunnableScheduledFuture</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;...    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delayedExecute</span><span class="hljs-params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123; ... &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reExecutePeriodic</span><span class="hljs-params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123; ... &#125;    <span class="hljs-keyword">protected</span> &lt;V&gt; <span class="hljs-function">RunnableScheduledFuture&lt;V&gt; <span class="hljs-title">decorateTask</span><span class="hljs-params">(...)</span></span>&#123;...&#125;    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,                                       <span class="hljs-keyword">long</span> delay,                                       TimeUnit unit) &#123;...&#125;    <span class="hljs-keyword">public</span> &lt;V&gt; <span class="hljs-function">ScheduledFuture&lt;V&gt; <span class="hljs-title">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable,</span></span><span class="hljs-function"><span class="hljs-params">                                           <span class="hljs-keyword">long</span> delay,</span></span><span class="hljs-function"><span class="hljs-params">                                           TimeUnit unit)</span> </span>&#123;...&#125;    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,                                                  <span class="hljs-keyword">long</span> initialDelay,                                                  <span class="hljs-keyword">long</span> period,                                                  TimeUnit unit) &#123;...&#125;    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,                                                     <span class="hljs-keyword">long</span> initialDelay,                                                     <span class="hljs-keyword">long</span> delay,                                                     TimeUnit unit) &#123;...&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;...&#125;    <span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;...&#125;    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Runnable task, T result)</span> </span>&#123;...&#125;    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> </span>&#123;...&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;...&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span> </span>&#123;...&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> BlockingQueue&lt;Runnable&gt; <span class="hljs-title">getQueue</span><span class="hljs-params">()</span> </span>&#123;...&#125;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayedWorkQueue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">Runnable</span>&gt;</span><span class="hljs-class">            <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">Runnable</span>&gt; </span>&#123;...&#125;<span class="hljs-comment">//......</span>&#125;</code></pre></div><p>ScheduledThreadPoolExecutor 会把调度的任务（ScheduledFutureTask）放到一个DelayQueue中。下面来看下ScheduledFutureTask主要包含的3个成员变量：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledFutureTask</span>&lt;<span class="hljs-title">V</span>&gt;</span><span class="hljs-class">        <span class="hljs-keyword">extends</span> <span class="hljs-title">FutureTask</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">RunnableScheduledFuture</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequenceNumber;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> time;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> period;...&#125;</code></pre></div><p>1、long型成员变量time：表示这个任务将要执行的具体时间；</p><p>2、long型成员变量sequenceNumber，表示这个任务被添加到ScheduledThreadPoolExecutor中的序号；</p><p>3、long型成员变量period，表示任务执行的间隔周期。</p><p>DelayQueue 封装了一个 PriorityQueue，这个 PriorityQueue 会对队列中的 ScheduledEutureTask 进行排序。排序时，time 小的排在前面（时间早的任务将被先执行）。如果两个 ScheduledFutureTask 的 time 相同，就比较 sequenceNumber，sequenceNumber 小的排在前面，也就是说，如果两个任务的执行时间相同，那么先执行提交早的任务。</p><p>下图所示的是：ScheduledThreadPoolExecutor 中的线程1执行某个周期任务的4个步骤：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530203014.png" srcset="/img/loading.gif" alt="image-20210530203014524"></p><p>1、线程1从 DelayQueue 中获取已到期的 ScheduledFutureTask（DealyQueue.take()）。到其任务是指 ScheduledFutureTask 的 time 大于等于当前时间；</p><p>2、线程1执行这个 ScheduledFutureTask；</p><p>3、线程1修改 ScheduledFutureTask 的 time 变量为下次将要被执行的时间；</p><p>4、线程1把这个修改 time 之后的 ScheduledFutureTask 放回 DelayQueue 中（DelayQueue.add()）。</p><p>下面就看下DelayQueue.take()方法的源代码实现：【在源代码中：DelayQueue 就是 DelayedWorkQueue】</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayedWorkQueue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">Runnable</span>&gt;<span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">Runnable</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> RunnableScheduledFuture <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">// 获取lock</span>        <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;        lock.lockInterruptibly();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span> (;;) &#123;                RunnableScheduledFuture first = queue[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 获取任务</span>                <span class="hljs-keyword">if</span> (first == <span class="hljs-keyword">null</span>)                    available.await(); <span class="hljs-comment">// 如果队列为空，则等待</span>                <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">long</span> delay = first.getDelay(TimeUnit.NANOSECONDS);                    <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>)                        <span class="hljs-keyword">return</span> finishPoll(first);                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (leader != <span class="hljs-keyword">null</span>)                        available.await();                    <span class="hljs-keyword">else</span> &#123;                        Thread thisThread = Thread.currentThread();                        leader = thisThread;                        <span class="hljs-keyword">try</span> &#123;                            available.awaitNanos(delay);                        &#125; <span class="hljs-keyword">finally</span> &#123;                            <span class="hljs-keyword">if</span> (leader == thisThread)                                leader = <span class="hljs-keyword">null</span>;                        &#125;                    &#125;                &#125;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (leader == <span class="hljs-keyword">null</span> &amp;&amp; queue[<span class="hljs-number">0</span>] != <span class="hljs-keyword">null</span>)                available.signal();            lock.unlock();        &#125;    &#125;&#125;</code></pre></div><p>DelayQueue.take()的执行示意图如下所示：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530203108.png" srcset="/img/loading.gif" alt="image-20210530203108451"></p><p>如上图所示的过程，大致可以分为3个步骤：</p><p>1、获取Lock；</p><p>2、获取周期任务；</p><ul><li>2.1、如果     PriorityQueue 为空，当前线程到 Condition 中等待，否则执行下面的2.2；</li><li>2.2、如果     PriorityQueue 的头元素的 time 时间比当前时间大，到 Condition 中等待到 time 时间，否则执行2.3；</li><li>2.3、获取     PriorityQueue 的头元素，如果 PriorityQueue 不为空，则唤醒在 Condition 中等待的所有线程。</li></ul><p>3、释放Lock。</p><p>ScheduledThreadFutureTask 在一个循环中执行步骤2，直到线程从 PriorityQueue 获取到一个元素之后，才会退出无限循环。</p><p>下面看下 ScheduledThreadFutureTask 中的线程把 ScheduledFutureTask 放入 DelayQueue 中的过程。下面是 DelayQueue.add() 的源代码实现：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayedWorkQueue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">Runnable</span>&gt;<span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">Runnable</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(Runnable x)</span> </span>&#123;        <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        RunnableScheduledFuture e = (RunnableScheduledFuture)x;        <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">int</span> i = size;            <span class="hljs-keyword">if</span> (i &gt;= queue.length)                grow();            size = i + <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;                queue[<span class="hljs-number">0</span>] = e;                setIndex(e, <span class="hljs-number">0</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                siftUp(i, e);            &#125;            <span class="hljs-keyword">if</span> (queue[<span class="hljs-number">0</span>] == e) &#123;                leader = <span class="hljs-keyword">null</span>;                available.signal();            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;......&#125;</code></pre></div><p>下图是 DelayQueue.add() 的执行示意图：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530203204.png" srcset="/img/loading.gif" alt="image-20210530203204118"></p><p>如上图所示，添加任务分为3大步骤：</p><p>1、获取 Lock；</p><p>2、添加任务；</p><ul><li>2.1、向     PriorityQueue 添加任务；</li><li>2.2、如果在上面2.1     中添加的任务是 PriorityQueue 的头元素，则唤醒在 Conditon 中等待的所有线程；</li></ul><p>3、释放 Lock。</p><p><strong>4、FutureTask 详解</strong></p><p>Future 接口和实现 Future 接口的 FutureTask 类，代表异步计算的结果。</p><p><strong>4.1、FutureTask 简介</strong></p><p>FutureTask 除了实现了 Future 接口外，还实现了 Runnable接口。那么我们就先看下这两个接口的内部结构。</p><p><strong>Future 接口的内部结构</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">cancel</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> mayInterruptIfRunning)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCancelled</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;&#125;</code></pre></div><p><strong>Runnable 接口的内部结构</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;  &#125;</code></pre></div><p><strong>1、未启动：</strong>FutureTask.run()方法还没有被执行之前，FutureTask 处于未启动状态。当创建一个 FutureTask，且没有执行 FutureTask.run() 方法之前，这个 FutureTask 处于未启动状态；</p><p><strong>2、已启动：</strong>FutureTask.run()方法被执行的过程中，FutureTask 处于已启动状态；</p><p><strong>3、已完成：</strong>FutureTask.run()方法执行完成后正常结束，或被取消（FutureTask.cancel(…)），或执行FutureTask.run()方法时抛出异常而异常结束，FutureTask 处于已完成状态。</p><p>FutureTask 的状态迁移的示意图如下所示：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530203308.png" srcset="/img/loading.gif" alt="image-20210530203308304"></p><p>FutureTask 的 get 和 cancel 的执行示意图如下所示：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530203414.png" srcset="/img/loading.gif" alt="image-20210530203414523"></p><p><strong>4.2、FutureTask 的实现</strong></p><p>先看下 FutureTask 的内部结构：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FutureTask</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">RunnableFuture</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;    <span class="hljs-comment">// 构造函数1 Callable</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FutureTask</span><span class="hljs-params">(Callable&lt;V&gt; callable)</span> </span>&#123;        <span class="hljs-keyword">if</span> (callable == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        sync = <span class="hljs-keyword">new</span> Sync(callable);    &#125;    <span class="hljs-comment">// 构造函数2 Runnable</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> </span>&#123;        sync = <span class="hljs-keyword">new</span> Sync(Executors.callable(runnable, result));    &#125;    <span class="hljs-comment">// 调用的是sync中的innerCancel方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">cancel</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;        <span class="hljs-keyword">return</span> sync.innerCancel(mayInterruptIfRunning);    &#125;    <span class="hljs-comment">// 调用的是sync中的innerGet方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException </span>&#123;        <span class="hljs-keyword">return</span> sync.innerGet();    &#125;    <span class="hljs-comment">// 调用的是sync中的innerGet方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;<span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;            <span class="hljs-keyword">return</span> sync.innerGet(unit.toNanos(timeout));        &#125;        <span class="hljs-comment">// 调用的是sync中的innerRun方法</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span> <span class="hljs-params">()</span> </span>&#123;            sync.innerRun();        &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;...        &#125;        <span class="hljs-comment">// .......</span>    &#125;&#125;</code></pre></div><p>从 FutureTask 的源码中可以看出来，它的实现是基于 AbstractQueuedSynchronizer 。AQS 是一个同步框架，它提供通用机制来原子性管理同步状态、阻塞和唤醒线程，以及维护被阻塞线程的队列。基于 AQS 实现的同步器包括：ReentrantLock、Semaphore、ReentrantReadWriteLock、CountDownLatch 和 FutureTask。</p><p>每一个基于 AQS 实现的同步器都会包含两种类型的操作，如下：</p><p>1、至少一个 acquire 操作：这个操作阻塞调用线程，除非 / 直到 AQS 的状态允许这个线程继续执行。 FutureTask 的 acquire 操作为 get() / get(long timeout, TimeUnit unit)方法调用；</p><p>2、至少一个 release 操作：这个操作改变 AQS 的状态，改变后的状态可允许一个或多个阻塞线程被解除阻塞。FutureTask 的 release 操作包括 run() 方法和 cancel(…) 方法。</p><p>基于“复合优先继承”的原则，FutureTask 声明了一个内部私有的继承于 AQS 的子类 Sync，对 FutureTask 所有公有方法的调用都会委托给这个内部子类。</p><p>AQS 被作为“模板方法模式”的基础类提供给 FutureTask 的内部子类 Sync，这个内部子类只需要实现状态检测和状态更新的方法即可，这些方法将控制 FutureTask 的获取和释放操作。具体来说，Sync实现了 AQS 的 tryAcquireShared(int)方法和 tryReleaseShared(int)方法，Sync 通过这两个方法来检查和更新同步状态。</p><p>FutureTask 的设计示意图如下图所示：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530203513.png" srcset="/img/loading.gif" alt="image-20210530203513078"></p><p>如图所示，Sync 是 FutureTask 的内部私有类，它继承自 AQS。创建 FutureTask 时会创建内部私有的成员对象 Sync，FutureTask 所有的公有方法都直接委托给了内部私有的 Sync。</p><p>下面对 FutureTask 中主要的几个方法进行调用过程分析：</p><p><strong>4.2.1、FutureTask.get() 方法</strong> </p><p>第1步：调用 FutureTask 中的 get() 方法</p><div class="hljs"><pre><code class="hljs javascript">public V <span class="hljs-keyword">get</span>() throws  InterruptedException, ExecutionException &#123;<span class="hljs-keyword">return</span> sync.innerGet();&#125;</code></pre></div><p>从源码中很清楚的看到 get() 方法内部是由 sync 的 innerGet()方法实现的。 </p><p>第2步：调用 Sync 中的 innerGet()方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function">V <span class="hljs-title">innerGet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException </span>&#123;    acquireSharedInterruptibly(<span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (getState() == CANCELLED)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CancellationException();    <span class="hljs-keyword">if</span> (exception != <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ExecutionException(exception);    <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>第3步：调用 AQS.acquireSharedInterruptibly(int args)方法。 </p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">if</span> (Thread.interrupted())        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)        doAcquireSharedInterruptibly(arg);&#125;</code></pre></div><p>第4步：调用Sync.tryAcquireShared方法</p><p>第5步：调用 AQS.doAcquireSharedIntrruptibly方法</p><p>这个方法首先会在子类 Sync 中实现的 tryAcquireShared()方法来判断 acquire 操作是否可以成功，acquire 操作可以成功的条件为：state 为执行完成状态RAN 或取消状态 CANCELLED，且 runner 不为null。</p><p>【至于tryAcquireShared和doAcquireSharedIntrruptibly方法，这里不再做源码分析了，前面文章已经分析过多次了】</p><p>如果成功则立即返回，如果失败则到线程等待队列中去等待其他线程执行 release 操作。</p><p>当其他线程执行 release 操作（比如：FutureTask.run() 或 FutureTask.cancel(…)）唤醒当前线程后，当前线程再次执行 tryAcquiredShared() 将返回正值 1，当前线程将离开线程等待队列，并唤醒它的后继节点线程。</p><p>最后返回计算的结果或者抛出异常。</p><p><strong>4.2.2、FutureTask.run() 方法</strong></p><p>第1步：调用了 FutureTask.run() 方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;sync.innerRun();&#125;</code></pre></div><p>第2步：调用 Sync.innerRun() 方法 </p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">innerRun</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (!compareAndSetState(READY, RUNNING))        <span class="hljs-keyword">return</span>;    runner = Thread.currentThread();    <span class="hljs-keyword">if</span> (getState() == RUNNING) &#123; <span class="hljs-comment">// recheck after setting thread</span>        V result;        <span class="hljs-keyword">try</span> &#123;            result = callable.call();        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;            setException(ex);            <span class="hljs-keyword">return</span>;        &#125;        set(result);    &#125; <span class="hljs-keyword">else</span> &#123;        releaseShared(<span class="hljs-number">0</span>); <span class="hljs-comment">// cancel</span>    &#125;&#125;</code></pre></div><p>第3步：调用AQS.releaseShared(int args)方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;        doReleaseShared();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre></div><p>AQS.releaseShared(int args)首先会回调子类 Sync 中实现的 tryReleaseShared(int args)方法来执行 release操作。</p><p>第4步：调用 Sync.tryReleaseShared(int args) 方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ignore)</span> </span>&#123;runner = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre></div><p>设置允许任务线程 runner 为 null，然后返回 true。</p><p>第5步：调用AQS.doReleaseShared() 方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (;;) &#123;        Node h = head;        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;            <span class="hljs-keyword">int</span> ws = h.waitStatus;            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))                    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop to recheck cases</span>                unparkSuccessor(h);            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;                    !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))                <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop on failed CAS</span>        &#125;        <span class="hljs-keyword">if</span> (h == head) <span class="hljs-comment">// loop if head changed</span>            <span class="hljs-keyword">break</span>;    &#125;&#125;</code></pre></div><p>唤醒线程等待队列中的第一个线程。</p>]]></content>
    
    
    <categories>
      
      <category>语言相关</category>
      
      <category>Java进阶</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发知识点</title>
    <link href="/2021/05/30/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2021/05/30/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="一、线程状态转换"><a href="#一、线程状态转换" class="headerlink" title="一、线程状态转换"></a>一、线程状态转换</h1><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530180609.png" srcset="/img/loading.gif" alt="image-20210530180609150"></p><p><strong>新建（New）</strong></p><p>创建后尚未启动，等到线程的<code>start()</code>方法调用时，才表示线程开始执行。</p><p><strong>可运行（Runnable）</strong></p><p>表明线程所需要的一切资源都已经准备好了，但此时线程可能正在运行，也可能正在等待<code>CPU</code>时间片。</p><p>包含了操作系统线程状态中的 <code>Running</code>和<code>Ready</code>。</p><p><strong>阻塞（Blocked）</strong></p><p>等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</p><p><strong>无限期等待（Waiting）</strong></p><p>等待其它线程显式地唤醒，否则不会被分配<code>CPU</code>时间片。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530180640.png" srcset="/img/loading.gif" alt="image-20210530180640413"></p><p><strong>限期等待（Timed_Waiting）</strong></p><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><p>调用<code>Thread.sleep()</code>方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。</p><p>调用 <code>Object.wait()</code>方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</p><p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p><p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，它们分别通过调用<code>Object.wait()</code>和<code>Thread.sleep()</code>等方法进入。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530180711.png" srcset="/img/loading.gif" alt="image-20210530180710818"></p><p>通过<code>wait()</code>方法等待的线程在等待<code>notify()</code>方法，而通过<code>join()</code>方法等待的线程则会等待目标线程的终止。</p><p><strong>死亡（Terminated）</strong></p><p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p><p><strong>进程和线程之间的关系：</strong></p><ul><li><p>进程是系统进行资源分配和任务调度的基本单位，是操作系统结构的基础；</p></li><li><p>线程就是轻量级进程，是程序执行的最小单位。</p></li></ul><h1 id="二、使用线程"><a href="#二、使用线程" class="headerlink" title="二、使用线程"></a>二、使用线程</h1><p><strong>有三种使用线程的方法：</strong></p><ul><li>实现 Runnable 接口；</li><li>实现 Callable 接口；</li><li>继承 Thread 类。</li></ul><p>实现 <code>Runnable</code> 和 <code>Callable</code>接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过<code>Thread</code>来调用。可以说任务是通过线程驱动从而执行的。</p><p><strong>实现 Runnable 接口</strong></p><p>需要实现<code>run()</code> 方法。</p><p>通过<code>Thread</code> 调用 <code>start()</code>方法来启动线程。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// ...</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    MyRunnable instance = <span class="hljs-keyword">new</span> MyRunnable();    Thread thread = <span class="hljs-keyword">new</span> Thread(instance);    thread.start();&#125;</code></pre></div><p><strong>实现 Callable 接口</strong></p><p>与 <code>Runnable</code>相比，<code>Callable</code>可以有返回值，返回值通过 <code>FutureTask</code>进行封装。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;    MyCallable mc = <span class="hljs-keyword">new</span> MyCallable();    FutureTask&lt;Integer&gt; ft = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(mc);    Thread thread = <span class="hljs-keyword">new</span> Thread(ft);    thread.start();    System.out.println(ft.get());&#125;</code></pre></div><p><strong>继承 Thread 类</strong></p><p>同样也是需要实现 <code>run()</code>方法，因为 <code>Thread</code>类也实现了<code>Runable</code>接口。</p><p>当调用<code>start()</code>方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的<code>run()</code>方法。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// ...</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    MyThread mt = <span class="hljs-keyword">new</span> MyThread();    mt.start();&#125;</code></pre></div><p><strong>实现接口 VS 继承 Thread</strong></p><p><strong>实现接口会更好一些，因为：</strong></p><ul><li><code>Java</code> 不支持多重继承，因此继承了 <code>Thread</code>类就无法继承其它类，但是可以实现多个接口；</li><li>类可能只要求可执行就行，继承整个 <code>Thread</code>类开销过大。</li></ul><h1 id="三、基础线程机制"><a href="#三、基础线程机制" class="headerlink" title="三、基础线程机制"></a>三、基础线程机制</h1><p><strong>Daemon</strong></p><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p><p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p><p>main() 属于非守护线程。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyRunnable());    thread.setDaemon(<span class="hljs-keyword">true</span>);&#125;</code></pre></div><p><strong>sleep()</strong></p><p><code>Thread.sleep(millisec)</code>方法会<strong>休眠</strong>当前正在执行的线程，<code>millisec</code>单位为毫秒。</p><p><code>sleep()</code>可能会抛出<code>InterruptedException</code>，因为异常不能跨线程传播回 <code>main()</code>中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        Thread.sleep(<span class="hljs-number">3000</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre></div><p><strong>yield()</strong> </p><p>对静态方法 <code>Thread.yield()</code> 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;  Thread.yield();&#125;</code></pre></div><p><strong>sleep、yield、join、wait的比较</strong></p><ol><li><code>Thread.sleep(long millis)</code>，一定是当前线程调用此方法，当前线程进入阻塞，但不释放对象锁，millis后线程自动苏醒进入可运行状态。作用：给其它线程执行机会的最佳方式。</li><li><code>Thread.yield()</code>，一定是当前线程调用此方法，当前线程放弃获取的cpu时间片，由运行状态变会可运行状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。</li><li><code>t.join()/t.join(long millis)</code>，让调用该方法的线程在执行完<code>run()</code>方法后，再执行<code>join</code>方法后面的代码。具体而言，可以通过线程t的join()方法来等待线程t的结束，或者使用线程t的<code>join(millis)</code>方法来等待线程t的结束，但最多只等待2ms。</li><li><code>obj.wait()</code>，当前线程调用对象的<code>wait()</code>方法，当前线程释放对象锁，进入等待队列。依靠<code>notify()</code>/<code>notifyAll()</code>唤醒或者<code>wait(long timeout)</code>，<code>timeout</code>时间到自动唤醒。</li><li><code>obj.notify()</code>唤醒在此对象监视器上等待的单个线程，选择是任意性的。<code>notifyAll()</code>唤醒在此对象监视器上等待的所有线程。</li></ol><h1 id="四、中断"><a href="#四、中断" class="headerlink" title="四、中断"></a>四、中断</h1><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p><p><strong>InterruptedException</strong></p><p>通过调用一个线程的<code>interrupt()</code>来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 <code>InterruptedException</code>，从而提前结束该线程。但是不能中断 I/O 阻塞和<code>synchronized</code>锁阻塞。</p><p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了<code>Thread.sleep()</code>方法，因此会抛出一个<code>InterruptedException</code>，从而提前结束线程，不执行之后的语句。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterruptExample</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">2000</span>);                System.out.println(<span class="hljs-string">"Thread run"</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Thread thread1 = <span class="hljs-keyword">new</span> MyThread1();    thread1.start();    thread1.interrupt();    System.out.println(<span class="hljs-string">"Main run"</span>);&#125;</code></pre></div><div class="hljs"><pre><code class="hljs oxygene">Main runjava.lang.InterruptedException: sleep interruptedat java.lang.Thread.sleep(Native <span class="hljs-function"><span class="hljs-keyword">Method</span>)</span><span class="hljs-function"><span class="hljs-title">at</span> <span class="hljs-title">InterruptExample</span>.<span class="hljs-title">lambda</span>$<span class="hljs-title">main</span>$0<span class="hljs-params">(InterruptExample.java:5)</span></span><span class="hljs-function"><span class="hljs-title">at</span> <span class="hljs-title">InterruptExample</span>$$<span class="hljs-title">Lambda</span>$1/713338599.<span class="hljs-title">run</span><span class="hljs-params">(Unknown Source)</span></span><span class="hljs-function"><span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Thread</span>.<span class="hljs-title">run</span><span class="hljs-params">(Thread.java:745)</span></span></code></pre></div><p><strong>interrupt()、interrupted()、isInterrupted()区别</strong></p><ul><li><code>interrupt()</code>方法：用于中断线程的，<strong>调用该方法的线程的状态将被置为”中断”状态</strong>。注意：线程中断仅仅是设置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态并做处理。支持线程中断的方法（也就是线程中断后会抛出<code>InterruptedException</code>的方法，比如<code>Thread.sleep</code>，以及<code>Object.wait</code>等方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常,并将线程的中断状态为设置为false。</li><li><code>interrupted()</code>：返回线程是否处于已中断状态并<strong>清除</strong>中断状态</li><li><code>isInterrupted()</code>：返回线程是否处于已中断状态</li></ul><p><strong>interrupted()</strong></p><p>如果一个线程的<code>run()</code>方法执行一个无限循环，并且没有执行<code>sleep()</code>等会抛出<code>InterruptedException</code>的操作，那么调用线程的 <code>interrupt()</code>方法就无法使线程提前结束。</p><p>但是调用 <code>interrupt()</code>方法会设置线程的中断标记，此时调用 <code>interrupted()</code>方法会返回<code>true</code>。因此可以在循环体中使用 <code>interrupted()</code>方法来判断线程是否处于中断状态，从而提前结束线程。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterruptExample</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">while</span> (!interrupted()) &#123;                <span class="hljs-comment">// ..</span>            &#125;            System.out.println(<span class="hljs-string">"Thread end"</span>);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Thread thread2 = <span class="hljs-keyword">new</span> MyThread2();    thread2.start();    thread2.interrupt();&#125;</code></pre></div><div class="hljs"><pre><code class="hljs ada">Thread <span class="hljs-keyword">end</span></code></pre></div><p><strong>Executor 的中断操作</strong></p><p>调用 <code>Executor</code>的<code>shutdown()</code>方法会等待线程都执行完毕之后再关闭，但是如果调用的是 <code>shutdownNow()</code>方法，则相当于调用每个线程的 <code>interrupt()</code>方法。</p><p>以下使用 <code>Lambda</code>创建线程，相当于创建了一个匿名内部线程。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    ExecutorService executorService = Executors.newCachedThreadPool();    executorService.execute(() -&gt; &#123;        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">2000</span>);            System.out.println(<span class="hljs-string">"Thread run"</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;);    executorService.shutdownNow();    System.out.println(<span class="hljs-string">"Main run"</span>);&#125;</code></pre></div><div class="hljs"><pre><code class="hljs reasonml">Main runjava.lang.InterruptedException: sleep interruptedat java.lang.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(Native Method)at <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ExecutorInterruptExample</span>.</span></span>lambda<span class="hljs-constructor">$main$0(ExecutorInterruptExample.<span class="hljs-params">java</span>:9)</span>at ExecutorInterruptExample$$Lambda$<span class="hljs-number">1</span>/<span class="hljs-number">1160460865.</span>run(Unknown Source)at java.util.concurrent.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ThreadPoolExecutor</span>.</span></span>run<span class="hljs-constructor">Worker(ThreadPoolExecutor.<span class="hljs-params">java</span>:1142)</span>at java.util.concurrent.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ThreadPoolExecutor$Worker</span>.</span></span>run(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ThreadPoolExecutor</span>.</span></span>java:<span class="hljs-number">617</span>)at java.lang.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>run(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>java:<span class="hljs-number">745</span>)</code></pre></div><p>如果只想中断 Executor 中的一个线程，可以通过使用<code>submit()</code>方法来提交一个线程，它会返回一个<code>Future&lt;?&gt;</code> 对象，通过调用该对象的 <code>cancel(true)</code>方法就可以中断线程。</p><div class="hljs"><pre><code class="hljs java">Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;    <span class="hljs-comment">// ..</span>&#125;);future.cancel(<span class="hljs-keyword">true</span>);</code></pre></div><h1 id="五、互斥同步"><a href="#五、互斥同步" class="headerlink" title="五、互斥同步"></a>五、互斥同步</h1><p><code>Java</code> 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是<code>JVM</code>实现的<code>synchronized</code>，而另一个是<code>JDK</code>实现的 <code>ReentrantLock</code>。</p><p><strong>synchronized</strong></p><p><strong>1. 同步一个代码块</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;        <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre></div><p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p><p>对于以下代码，使用<code>ExecutorService</code>执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedExample</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;System.out.print(i + <span class="hljs-string">" "</span>);&#125;&#125;&#125;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;SynchronizedExample e1 = <span class="hljs-keyword">new</span> SynchronizedExample();ExecutorService executorService = Executors.newCachedThreadPool();executorService.execute(() -&gt; e1.func1());executorService.execute(() -&gt; e1.func1());&#125;</code></pre></div><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span></code></pre></div><p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;SynchronizedExample e1 = <span class="hljs-keyword">new</span> SynchronizedExample();SynchronizedExample e2 = <span class="hljs-keyword">new</span> SynchronizedExample();ExecutorService executorService = Executors.newCachedThreadPool();executorService.execute(() -&gt; e1.func1());executorService.execute(() -&gt; e2.func1());&#125;</code></pre></div><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">9</span></code></pre></div><p><strong>2. 同步一个方法</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span> <span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// ...</span>&#125;</code></pre></div><p>它和同步代码块一样，作用于同一个对象。</p><p><strong>3. 同步一个类</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (SynchronizedExample<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;    <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre></div><p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedExample</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">synchronized</span> (SynchronizedExample<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;System.out.print(i + <span class="hljs-string">" "</span>);&#125;&#125;&#125;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;SynchronizedExample e1 = <span class="hljs-keyword">new</span> SynchronizedExample();SynchronizedExample e2 = <span class="hljs-keyword">new</span> SynchronizedExample();ExecutorService executorService = Executors.newCachedThreadPool();executorService.execute(() -&gt; e1.func2());executorService.execute(() -&gt; e2.func2());&#125;</code></pre></div><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span></code></pre></div><p><strong>4. 同步一个静态方法</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// ... &#125;</span></code></pre></div><p>作用于整个类。</p><p><strong>ReentrantLock</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockExample</span> </span>&#123;<span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;lock.lock();<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;System.out.print(i + <span class="hljs-string">" "</span>);&#125;&#125; <span class="hljs-keyword">finally</span> &#123;lock.unlock(); <span class="hljs-comment">// 确保释放锁，从而避免发生死锁。</span>&#125;&#125;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;LockExample lockExample = <span class="hljs-keyword">new</span> LockExample();ExecutorService executorService = Executors.newCachedThreadPool();executorService.execute(() -&gt; lockExample.func());executorService.execute(() -&gt; lockExample.func());&#125;</code></pre></div><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span></code></pre></div><p><strong>比较</strong></p><p><strong>1. 锁的实现</strong></p><p><code>synchronized</code> 是 JVM 实现的，而<code>ReentrantLock</code>是 JDK 实现的。</p><p><strong>2. 性能</strong></p><p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p><p><strong>3. 等待可中断</strong></p><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p><p>ReentrantLock 可中断，而 synchronized 不行。</p><p><strong>4. 公平锁</strong></p><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p><p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p><p><strong>5. 锁绑定多个条件</strong></p><p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p><p><strong>使用选择</strong></p><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p><p><strong>六、线程之间的协作</strong></p><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p><p><strong>join()</strong></p><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p><p>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinExample</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"A"</span>);&#125;&#125; <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<span class="hljs-keyword">private</span> A a;B(A a) &#123;<span class="hljs-keyword">this</span>.a = a;&#125; <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">try</span> &#123;a.join();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; System.out.println(<span class="hljs-string">"B"</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;A a = <span class="hljs-keyword">new</span> A();B b = <span class="hljs-keyword">new</span> B(a);b.start();a.start();&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;JoinExample example = <span class="hljs-keyword">new</span> JoinExample();example.test();&#125;</code></pre></div><div class="hljs"><pre><code class="hljs dns"><span class="hljs-keyword">A</span> B</code></pre></div><p><strong>wait() notify() notifyAll()</strong></p><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p><p>它们都属于 Object 的一部分，而不属于 Thread。</p><p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。</p><p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitNotifyExample</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"before"</span>);notifyAll();&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">try</span> &#123;wait();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; System.out.println(<span class="hljs-string">"after"</span>);&#125;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ExecutorService executorService = Executors.newCachedThreadPool();WaitNotifyExample example = <span class="hljs-keyword">new</span> WaitNotifyExample();executorService.execute(() -&gt; example.after());executorService.execute(() -&gt; example.before());&#125;</code></pre></div><div class="hljs"><pre><code class="hljs applescript"><span class="hljs-keyword">before</span> <span class="hljs-keyword">after</span></code></pre></div><p><strong>wait() 和 sleep() 的区别</strong></p><ul><li>wait()     是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li><li>wait() 会释放锁，sleep() 不会。</li></ul><p><strong>await() signal() signalAll()</strong></p><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p><p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p><p>使用 Lock 来获取一个 Condition 对象。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AwaitSignalExample</span> </span>&#123;<span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-keyword">private</span> Condition condition = lock.newCondition();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;lock.lock();<span class="hljs-keyword">try</span> &#123;System.out.println(<span class="hljs-string">"before"</span>);condition.signalAll();&#125; <span class="hljs-keyword">finally</span> &#123;lock.unlock();&#125;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;lock.lock();<span class="hljs-keyword">try</span> &#123;condition.await();System.out.println(<span class="hljs-string">"after"</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;lock.unlock();&#125;&#125;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ExecutorService executorService = Executors.newCachedThreadPool();AwaitSignalExample example = <span class="hljs-keyword">new</span> AwaitSignalExample();executorService.execute(() -&gt; example.after());executorService.execute(() -&gt; example.before());&#125;</code></pre></div><div class="hljs"><pre><code class="hljs pgsql"><span class="hljs-keyword">Before</span><span class="hljs-keyword">after</span></code></pre></div><h1 id="八、J-U-C-其它组件"><a href="#八、J-U-C-其它组件" class="headerlink" title="八、J.U.C - 其它组件"></a>八、J.U.C - 其它组件</h1><p><strong>FutureTask</strong></p><p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FutureTask</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">RunnableFuture</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">RunnableFuture</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Runnable</span>, <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt;</span></code></pre></div><p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FutureTaskExample</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;Integer&gt;(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;Thread.sleep(<span class="hljs-number">10</span>);result += i;&#125; <span class="hljs-keyword">return</span> result;&#125;&#125;);Thread computeThread = <span class="hljs-keyword">new</span> Thread(futureTask);computeThread.start();Thread otherThread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;System.out.println(<span class="hljs-string">"other task is running..."</span>);<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;);otherThread.start();System.out.println(futureTask.get());&#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs ada">other <span class="hljs-keyword">task</span> <span class="hljs-keyword">is</span> running...<span class="hljs-number">4950</span></code></pre></div><p><strong>BlockingQueue</strong></p><p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：</p><ul><li>FIFO 队列：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）</li><li>优先级队列：PriorityBlockingQueue</li></ul><p>提供了阻塞的 take() 和 put() 方法：</p><ul><li>如果队列为空 take() 将阻塞，直到队列中有内容；</li><li>如果队列为满 put() 将阻塞，直到队列有空闲位置。</li></ul><p><strong>使用 BlockingQueue 实现生产者消费者问题</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerConsumer</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BlockingQueue&lt;String&gt; queue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">5</span>);<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">try</span> &#123;queue.put(<span class="hljs-string">"product"</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; System.out.print(<span class="hljs-string">"produce.."</span>);&#125;&#125; <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">try</span> &#123;String product = queue.take();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; System.out.print(<span class="hljs-string">"consume.."</span>); &#125;  &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;Producer producer = <span class="hljs-keyword">new</span> Producer();producer.start();&#125; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;Consumer consumer = <span class="hljs-keyword">new</span> Consumer();consumer.start();&#125; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;Producer producer = <span class="hljs-keyword">new</span> Producer();producer.start();&#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs routeros">produce<span class="hljs-built_in">..</span>produce<span class="hljs-built_in">..</span>consume<span class="hljs-built_in">..</span>consume<span class="hljs-built_in">..</span>produce<span class="hljs-built_in">..</span>consume<span class="hljs-built_in">..</span>produce<span class="hljs-built_in">..</span>consume<span class="hljs-built_in">..</span>produce<span class="hljs-built_in">..</span>consume<span class="hljs-built_in">..</span></code></pre></div><h1 id="九、线程不安全示例"><a href="#九、线程不安全示例" class="headerlink" title="九、线程不安全示例"></a>九、线程不安全示例</h1><p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</p><p>以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadUnsafeExample</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;cnt++;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> cnt;&#125;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threadSize = <span class="hljs-number">1000</span>;ThreadUnsafeExample example = <span class="hljs-keyword">new</span> ThreadUnsafeExample();<span class="hljs-keyword">final</span> CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(threadSize);ExecutorService executorService = Executors.newCachedThreadPool();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadSize; i++) &#123;executorService.execute(() -&gt; &#123;example.add();countDownLatch.countDown();&#125;);&#125; countDownLatch.await();executorService.shutdown();System.out.println(example.get());&#125;</code></pre></div><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">997</span></code></pre></div><h1 id="十一、线程安全"><a href="#十一、线程安全" class="headerlink" title="十一、线程安全"></a>十一、线程安全</h1><p>多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。</p><p>线程安全有以下几种实现方式：</p><p>不可变</p><p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p><p>不可变的类型：</p><ul><li>final 关键字修饰的基本数据类型</li><li>String</li><li>枚举类型</li><li>Number 部分子类，如 Long 和 Double     等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为Number 的原子类 AtomicInteger 和     AtomicLong 则是可变的。</li></ul><p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImmutableExample</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);unmodifiableMap.put(<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>);&#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs reasonml">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"main"</span> java.lang.UnsupportedOperationExceptionat java.util.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collections$UnmodifiableMap</span>.</span></span>put(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collections</span>.</span></span>java:<span class="hljs-number">1457</span>)at <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ImmutableExample</span>.</span></span>main(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ImmutableExample</span>.</span></span>java:<span class="hljs-number">9</span>)</code></pre></div><p>Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();&#125;</code></pre></div><p><strong>互斥同步</strong></p><p>synchronized 和 ReentrantLock。</p><p><strong>非阻塞同步</strong></p><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p><p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p><p><strong>1. CAS</strong></p><p>随着硬件指令集的发展，我们可以使用基于<strong>冲突检测</strong>的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取<strong>补偿</strong>措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p><p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是<strong>内存地址 V</strong>、<strong>旧的预期值 A</strong> 和<strong>新值 B</strong>。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p><p><strong>2. AtomicInteger</strong></p><p>J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。</p><p>以下代码使用了 AtomicInteger 执行了自增的操作。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">incrementAndGet</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-keyword">this</span>, valueOffset, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;&#125;</code></pre></div><p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt()来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</p><p>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, <span class="hljs-keyword">int</span> var4)</span> </span>&#123;<span class="hljs-keyword">int</span> var5;<span class="hljs-keyword">do</span> &#123;var5 = <span class="hljs-keyword">this</span>.getIntVolatile(var1, var2);&#125; <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<span class="hljs-keyword">return</span> var5;&#125;</code></pre></div><p><strong>3. ABA</strong></p><p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p><p>J.U.C 包提供了一个带有标记的原子引用类 <strong>AtomicStampedReference</strong> 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p><p><strong>无同步方案</strong></p><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p><p><strong>1. 栈封闭</strong></p><p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackClosedExample</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add100</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;cnt++;&#125; System.out.println(cnt);&#125;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;StackClosedExample example = <span class="hljs-keyword">new</span> StackClosedExample();ExecutorService executorService = Executors.newCachedThreadPool();executorService.execute(() -&gt; example.add100());executorService.execute(() -&gt; example.add100());executorService.shutdown();&#125;</code></pre></div><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">100</span><span class="hljs-number">100</span></code></pre></div><p><strong>2. 线程本地存储（Thread Local Storage）</strong></p><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。</p><p>如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p><p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p><p>可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p><p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalExample</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ThreadLocal threadLocal = <span class="hljs-keyword">new</span> ThreadLocal();Thread thread1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;threadLocal.set(<span class="hljs-number">1</span>);<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; System.out.println(threadLocal.get());threadLocal.remove();&#125;);Thread thread2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;threadLocal.set(<span class="hljs-number">2</span>);threadLocal.remove();&#125;);thread1.start();thread2.start();&#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">1</span></code></pre></div><p>为了理解 ThreadLocal，先看以下代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalExample1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ThreadLocal threadLocal1 = <span class="hljs-keyword">new</span> ThreadLocal();ThreadLocal threadLocal2 = <span class="hljs-keyword">new</span> ThreadLocal();Thread thread1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;threadLocal1.set(<span class="hljs-number">1</span>);threadLocal2.set(<span class="hljs-number">1</span>);&#125;);Thread thread2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;threadLocal1.set(<span class="hljs-number">2</span>);threadLocal2.set(<span class="hljs-number">2</span>);&#125;);thread1.start();thread2.start();&#125;&#125;</code></pre></div><p>它所对应的底层结构图为：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530182151.png" srcset="/img/loading.gif" alt="image-20210530182151726"></p><p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。</p><p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;Thread t = Thread.currentThread();ThreadLocalMap map = getMap(t);<span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)map.set(<span class="hljs-keyword">this</span>, value);<span class="hljs-keyword">else</span>createMap(t, value);&#125;</code></pre></div><p>get() 方法类似。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;Thread t = Thread.currentThread();ThreadLocalMap map = getMap(t);<span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);<span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)T result = (T)e.value;<span class="hljs-keyword">return</span> result;&#125;&#125; <span class="hljs-keyword">return</span> setInitialValue();&#125;</code></pre></div><p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p><p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。</p><p><strong>3. 可重入代码（Reentrant Code）</strong></p><p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p><p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p><h1 id="十二、锁优化"><a href="#十二、锁优化" class="headerlink" title="十二、锁优化"></a>十二、锁优化</h1><p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p><p><strong>自旋锁</strong></p><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p><p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p><p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p><p><strong>锁消除</strong></p><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p><p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p><p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">concatString</span><span class="hljs-params">(String s1, String s2, String s3)</span> </span>&#123;<span class="hljs-keyword">return</span> s1 + s2 + s3;&#125;</code></pre></div><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">concatString</span><span class="hljs-params">(String s1, String s2, String s3)</span> </span>&#123; StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(); sb.append(s1); sb.append(s2); sb.append(s3); <span class="hljs-keyword">return</span> sb.toString(); &#125;</code></pre></div><p>每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString()方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</p><p><strong>锁粗化</strong></p><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p><p>上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p><p><strong>轻量级锁</strong></p><p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p><p>以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530182401.png" srcset="/img/loading.gif" alt="image-20210530182401426"></p><p>下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530182426.png" srcset="/img/loading.gif" alt="image-20210530182426302"></p><p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p><p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530182459.png" srcset="/img/loading.gif" alt="image-20210530182459404"></p><p>如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p><p><strong>偏向锁</strong></p><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS操作也不再需要。</p><p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530182523.png" srcset="/img/loading.gif" alt="image-20210530182522807"></p><h1 id="十三、多线程开发良好的实践"><a href="#十三、多线程开发良好的实践" class="headerlink" title="十三、多线程开发良好的实践"></a>十三、多线程开发良好的实践</h1><ul><li><p>给线程起个有意义的名字，这样可以方便找 Bug。</p></li><li><p>缩小同步范围，从而减少锁争用。例如对于     synchronized，应该尽量使用同步块而不是同步方法。</p></li><li><p>多用同步工具少用 wait()     和 notify()。首先，CountDownLatch,     CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify()     很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。</p></li><li><p>使用 BlockingQueue 实现生产者消费者问题。</p></li><li><p>多用并发集合少用同步集合，例如应该使用     ConcurrentHashMap 而不是 Hashtable。</p></li><li><p>使用本地变量和不可变类来保证线程安全。</p></li><li><p>使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>语言有关</category>
      
      <category>Java进阶</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring中用到的设计模式</title>
    <link href="/2021/05/30/Spring%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/05/30/Spring%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>控制反转(IoC)和依赖注入(DI)</strong></p><p><strong>IoC(Inversion of Control,控制翻转)</strong> 是Spring 中一个非常非常重要的概念，它不是什么技术，而是一种解耦的设计思想。它的主要目的是借助于“第三方”(Spring 中的 IOC 容器) 实现具有依赖关系的对象之间的解耦(IOC容易管理对象，你只管使用即可)，从而降低代码之间的耦合度。<strong>IOC 是一个原则，而不是一个模式，以下模式（但不限于）实现了IoC原则。</strong></p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530161158.png" srcset="/img/loading.gif" alt="image-20210530161157870"></p><p><strong>Spring IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong> IOC 容器负责创建对象，将对象连接在一起，配置这些对象，并从创建中处理这些对象的整个生命周期，直到它们被完全销毁。</p><p><strong>控制反转怎么理解呢?</strong> 举个例子：”对象a 依赖了对象 b，当对象 a 需要使用对象 b的时候必须自己去创建。但是当系统引入了 IOC 容器后， 对象a 和对象 b 之间就失去了直接的联系。这个时候，当对象 a 需要使用 对象 b的时候， 我们可以指定 IOC 容器去创建一个对象b注入到对象 a 中”。 对象 a 获得依赖对象 b 的过程,由主动行为变为了被动行为，控制权翻转，这就是控制反转名字的由来。</p><p><strong>DI(Dependecy Inject,依赖注入)是实现控制反转的一种设计模式，依赖注入就是将实例变量传入到一个对象中去。</strong></p><p><strong>工厂设计模式</strong></p><p>Spring使用工厂模式可以通过 BeanFactory 或 ApplicationContext 创建 bean 对象。</p><p><strong>两者对比：</strong></p><ul><li>BeanFactory ：延迟注入(使用到某个     bean 的时候才会注入),相比于ApplicationContext来说会占用更少的内存，程序启动速度更快。</li><li>ApplicationContext ：容器启动的时候，不管你用没用到，一次性创建所有     bean 。BeanFactory 仅提供了最基本的依赖注入支持，ApplicationContext 扩展了 BeanFactory ,除了有BeanFactory的功能还有额外更多功能，所以一般开发人员使用ApplicationContext会更多。</li></ul><p>ApplicationContext的三个实现类：</p><ol><li>ClassPathXmlApplication：把上下文文件当成类路径资源。</li><li>FileSystemXmlApplication：从文件系统中的 XML     文件载入上下文定义信息。</li><li>XmlWebApplicationContext：从Web系统中的XML文件载入上下文定义信息。</li></ol><p>Example:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ApplicationContext context = <span class="hljs-keyword">new</span> FileSystemXmlApplicationContext(                <span class="hljs-string">"C:/work/IOC Containers/springframework.applicationcontext/"</span>                +<span class="hljs-string">"src/main/resources/bean-factory-config.xml"</span>);        HelloApplicationContext obj =         (HelloApplicationContext) context.getBean(<span class="hljs-string">"helloApplicationContext"</span>);        obj.getMsg();    &#125;&#125;</code></pre></div><p><strong>单例设计模式</strong></p><p>在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。</p><p><strong>使用单例模式的好处:</strong></p><ul><li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li><li>由于 new     操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li></ul><p><strong>Spring 中 bean 的默认作用域就是 singleton(单例)的。</strong> 除了 singleton 作用域，Spring 中 bean 还有下面几种作用域：</p><ul><li>prototype : 每次请求都会创建一个新的 bean 实例。</li><li>request :     每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li><li>session : 每一次HTTP请求都会产生一个新的     bean，该bean仅在当前 HTTP session 内有效。</li><li>global-session：     全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java     Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet     都有不同的会话。</li></ul><p><strong>Spring 实现单例的方式：</strong></p><ul><li>xml:<bean     id="userService" class="top.snailclimb.UserService"     scope="singleton"/></li><li>注解：@Scope(value =     “singleton”)</li></ul><p>Spring 通过 ConcurrentHashMap 实现单例注册表的特殊方式实现单例模式。Spring 实现单例的核心代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; singletonObjects =         <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="hljs-number">64</span>);<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getSingleton</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;        Assert.notNull(beanName, <span class="hljs-string">"'beanName' must not be null"</span>);        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) &#123;            <span class="hljs-comment">// 检查缓存中是否存在实例  </span>            Object singletonObject = <span class="hljs-keyword">this</span>.singletonObjects.get(beanName);            <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//...省略了很多代码</span>                <span class="hljs-keyword">try</span> &#123;                    singletonObject = singletonFactory.getObject();                &#125;                <span class="hljs-comment">//...省略了很多代码</span>                <span class="hljs-comment">// 如果实例对象在不存在，我们注册到单例注册表中。</span>                addSingleton(beanName, singletonObject);            &#125;            <span class="hljs-keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="hljs-keyword">null</span>);        &#125;    &#125;    <span class="hljs-comment">//将对象添加到单例注册表</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addSingleton</span><span class="hljs-params">(String beanName, Object singletonObject)</span> </span>&#123;            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) &#123;                <span class="hljs-keyword">this</span>.singletonObjects.put(beanName,                 (singletonObject != <span class="hljs-keyword">null</span> ? singletonObject : NULL_OBJECT));            &#125;        &#125;&#125;</code></pre></div><p><strong>代理模式在 AOP 中的应用</strong></p><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p><strong>Spring AOP 就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530161410.png" srcset="/img/loading.gif" alt="image-20210530161409894"></p><p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p><p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p><p><strong>Spring AOP 和 AspectJ AOP 有什么区别?</strong></p><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p><p><strong>模板方法</strong></p><p>模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530161448.png" srcset="/img/loading.gif" alt="image-20210530161447930"></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Template</span> </span>&#123;    <span class="hljs-comment">//这是我们的模板方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TemplateMethod</span><span class="hljs-params">()</span></span>&#123;        PrimitiveOperation1();          PrimitiveOperation2();        PrimitiveOperation3();    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">PrimitiveOperation1</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//当前类实现</span>    &#125;    <span class="hljs-comment">//被子类实现的方法</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrimitiveOperation2</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrimitiveOperation3</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Template</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrimitiveOperation2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//当前类实现</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrimitiveOperation3</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//当前类实现</span>    &#125;&#125;</code></pre></div><p>Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。</p><p><strong>观察者模式</strong></p><p>观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。</p><p><strong>Spring 事件驱动模型中的三种角色</strong></p><p><strong>事件角色</strong></p><p>ApplicationEvent (org.springframework.context包下)充当事件的角色,这是一个抽象类，它继承了java.util.EventObject并实现了 java.io.Serializable接口。</p><p>Spring 中默认存在以下事件，他们都是对 ApplicationContextEvent 的实现(继承自ApplicationContextEvent)：</p><ul><li><p>ContextStartedEvent：ApplicationContext 启动后触发的事件;</p></li><li><p>ContextStoppedEvent：ApplicationContext 停止后触发的事件;</p></li><li><p>ContextRefreshedEvent：ApplicationContext 初始化或刷新完成后触发的事件;</p></li><li><p>ContextClosedEvent：ApplicationContext 关闭后触发的事件。</p><p><strong>事件监听者角色</strong></p></li></ul><p>ApplicationListener 充当了事件监听者角色，它是一个接口，里面只定义了一个 onApplicationEvent（）方法来处理ApplicationEvent。ApplicationListener接口类源码如下，可以看出接口中的事件只要实现了 ApplicationEvent就可以了。所以，在 Spring中我们只要实现 ApplicationListener 接口中的 onApplicationEvent() 方法即可完成监听事件。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApplicationEvent</span>&gt; </span><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">EventListener</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(E var1)</span></span>;&#125;事件发布者角色ApplicationEventPublisher 充当了事件的发布者，它也是一个接口。<span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApplicationEventPublisher</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publishEvent</span><span class="hljs-params">(ApplicationEvent event)</span> </span>&#123;        <span class="hljs-keyword">this</span>.publishEvent((Object)event);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">publishEvent</span><span class="hljs-params">(Object var1)</span></span>;&#125;</code></pre></div><p>ApplicationEventPublisher 接口的publishEvent（）这个方法在AbstractApplicationContext类中被实现，阅读这个方法的实现，你会发现实际上事件真正是通过ApplicationEventMulticaster来广播出去的。具体内容过多，就不在这里分析了，后面可能会单独写一篇文章提到。</p><p><strong>Spring 的事件流程总结</strong></p><ol><li>定义一个事件:     实现一个继承自 ApplicationEvent，并且写相应的构造函数；</li><li>定义一个事件监听者：实现 ApplicationListener 接口，重写 onApplicationEvent() 方法；</li><li>使用事件发布者发布消息: 可以通过ApplicationEventPublisher 的publishEvent（）方法发布消息。</li></ol><p>Example:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 定义一个事件,继承自ApplicationEvent并且写相应的构造函数</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApplicationEvent</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-keyword">private</span> String message;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DemoEvent</span><span class="hljs-params">(Object source,String message)</span></span>&#123;        <span class="hljs-keyword">super</span>(source);        <span class="hljs-keyword">this</span>.message = message;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMessage</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">return</span> message;   &#125;<span class="hljs-comment">// 定义一个事件监听者,实现ApplicationListener接口，重写onApplicationEvent()方法；</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">DemoEvent</span>&gt;</span>&#123;    <span class="hljs-comment">//使用onApplicationEvent接收消息</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(DemoEvent event)</span> </span>&#123;        String msg = event.getMessage();        System.out.println(<span class="hljs-string">"接收到的信息是："</span>+msg);    &#125;&#125;<span class="hljs-comment">// 发布事件，可以通过ApplicationEventPublisher 的 publishEvent() 方法发布消息。</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoPublisher</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    ApplicationContext applicationContext;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publish</span><span class="hljs-params">(String message)</span></span>&#123;        <span class="hljs-comment">//发布事件</span>        applicationContext.publishEvent(<span class="hljs-keyword">new</span> DemoEvent(<span class="hljs-keyword">this</span>, message));    &#125;&#125;</code></pre></div><p>当调用 DemoPublisher 的 publish() 方法的时候，比如 demoPublisher.publish(“你好”) ，控制台就会打印出:接收到的信息是：你好 。</p><p><strong>适配器模式</strong></p><p>适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</p><p><strong>spring AOP中的适配器模式</strong></p><p>我们知道 Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是AdvisorAdapter 。Advice 常用的类型有：BeforeAdvice（目标方法调用前,前置通知）、AfterAdvice（目标方法调用后,后置通知）、AfterReturningAdvice(目标方法执行结束后，return之前)等等。每个类型Advice（通知）都有对应的拦截器：MethodBeforeAdviceInterceptor、AfterReturningAdviceAdapter、AfterReturningAdviceInterceptor。Spring预定义的通知要通过对应的适配器，适配成 MethodInterceptor接口(方法拦截器)类型的对象（如：MethodBeforeAdviceInterceptor 负责适配 MethodBeforeAdvice）。</p><p><strong>spring MVC中的适配器模式</strong></p><p>在Spring MVC中，DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由HandlerAdapter 适配器处理。HandlerAdapter 作为期望接口，具体的适配器实现类用于对目标类进行适配，Controller 作为需要适配的类。</p><p><strong>为什么要在 Spring MVC 中使用适配器模式？</strong> Spring MVC 中的 Controller 种类众多，不同类型的 Controller 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，DispatcherServlet 直接获取对应类型的 Controller，需要的自行来判断，像下面这段代码一样：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(mappedHandler.getHandler() <span class="hljs-keyword">instanceof</span> MultiActionController)&#123;     ((MultiActionController)mappedHandler.getHandler()).xxx  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mappedHandler.getHandler() <span class="hljs-keyword">instanceof</span> XXX)&#123;      ...  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(...)&#123;     ...  &#125;</code></pre></div><p>假如我们再增加一个 Controller类型就要在上面代码中再加入一行判断语句，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。</p><p><strong>装饰者模式</strong></p><p>装饰者模式可以动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 InputStream家族，InputStream 类下有 FileInputStream (读取文件)、BufferedInputStream (增加缓存,使读取文件速度大大提升)等子类都在不修改InputStream 代码的情况下扩展了它的功能。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530161702.png" srcset="/img/loading.gif" alt="image-20210530161702392"></p><p>Spring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式。Spring 中用到的包装器模式在类名上含有 Wrapper或者 Decorator。这些类基本上都是动态地给一个对象添加一些额外的职责。</p><p><strong>总结</strong></p><p>Spring 框架中用到了哪些设计模式：</p><ul><li><strong>工厂设计模式</strong> <strong>:     Spring使用工厂模式通过</strong> <strong>BeanFactory、ApplicationContext 创建bean 对象。</strong></li><li><strong>代理设计模式</strong> <strong>:     Spring AOP 功能的实现。</strong></li><li><strong>单例设计模式</strong> <strong>:     Spring 中的 Bean 默认都是单例的。</strong></li><li><strong>模板方法模式</strong> <strong>:     Spring 中</strong> <strong>jdbcTemplate</strong>、<strong>hibernateTemplate</strong> <strong>等以Template 结尾的对数据库操作的类，它们就使用到了模板模式。</strong></li><li><strong>包装器设计模式</strong> :     <strong>我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</strong></li><li><strong>观察者模式:</strong> <strong>Spring事件驱动模型就是观察者模式很经典的一个应用。</strong></li><li><strong>适配器模式</strong> <strong>:Spring  AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller</strong>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用指令</title>
    <link href="/2021/05/30/Git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2021/05/30/Git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>创建版本库：</p><ul><li>mkdir：创建文件夹</li><li>cd：进入当前目录</li><li>pwd：用于显示当前目录</li><li>git init：将这个目录变成git可以管理的仓库</li><li>git add 文件名：将这个文件添加到暂存区</li><li>git commit -m ‘注释信息’：把文件提交到仓库</li></ul><p>版本回退：</p><ul><li>git log：显示从最近到最远的提交日志</li><li>git log –pretty=oneline：显示提交日志的简版</li><li>git reset –hard HEAD^：回退到上一个版本</li><li>git reset –hard 版本号：回退到指定版本</li><li>git reflog：查询历史命令（里面包含版本号）</li></ul><p>工作区和暂存区：</p><ul><li><p>git diff 文件名：查看文件中哪些内容被修改了</p></li><li><p>git diff HEAD –文件名：查看工作区和版本库里面最新版本的区别</p></li><li><p>git status：查看工作区状态，检查是否还有文件未提交</p></li></ul><p>撤销修改：</p><ul><li>git checkout – 文件名：让这个文件回到最近一次git commit或git add时的状态。（注意空格）</li></ul><p>删除文件：</p><ul><li>git rm 文件名：删除文件（类似于git add 文件名），此时有两个选择：从版本库中删除该文件执行git commit；误删执行</li><li>git checkout – 文件名</li></ul><p>远程仓库：</p><ul><li>git remote add origin GitHub账户名/仓库名.git：关联远程仓库</li><li>git push -u origin master：将当前分支master推送到远程</li><li>git push origin master：把本地master分支的最新修改推送至GitHub</li><li>git clone <a href="mailto:git@github.com">git@github.com</a>:GitHub账户名/仓库名.git：从远程仓库中克隆到本地仓库</li></ul><p>分支管理：</p><ul><li>创建与合并分支</li><li>git checkout dev：创建dev分支</li><li>git checkout -b dev：创建dev分支并<strong>切换</strong>到分支</li><li>git branch：查看当前分支</li><li>git merge dev：将dev分支上的工作成果合并到当前分支上</li><li>git branch -d dev：删除dev分支</li><li>git switch -c dev：创建并切换到dev分支</li><li>git switch master：切换到已有的master分支</li></ul><p>分支管理策略</p><ul><li>git merge –no-ff -m “merge with no-ff” dev：合并分支并禁用Fast Forward</li></ul><p>Bug分支</p><ul><li>git stash：将当前工作现场“隐藏”起来，用于工作没有完成，但需要先解决bug的情况</li><li>git stash list：查看隐藏起来的工作现场</li><li>git stash apply：恢复工作现场，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；</li><li>git stash pop：恢复的同时把stash内容也删了</li><li>在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;版本号&gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</li></ul><p>Feature分支</p><ul><li>git branch -D &lt;分支名&gt;：强行丢弃一个没有被合并过的分支。</li></ul><p>多人协作</p><ul><li>git remote：查看远程仓库的信息</li><li>git remote -v：查看远程仓库更详细的信息</li><li>git push origin master：将本地仓库的master分支推送到远程仓库中</li><li>git rebase：把本地未push的分叉提交历史整理成直线</li></ul><p>标签管理</p><p>创建标签</p><ul><li>git tag &lt;name&gt;：在需要打标签的分支上打出标签</li><li>git tag：查看所有标签</li><li>git tag &lt;name&gt; &lt;commit&gt;：根据版本号进行打标签（补签）</li><li>git show &lt;tagname&gt;：查看标签信息</li><li>git tag -a &lt;tagname&gt; -m “说明文字” &lt;commit&gt;：创建带有说明的标签，用-a指定标签名，-m指定说明文字</li></ul><p>操作标签</p><ul><li>git tag -d &lt;tagname&gt;：删除标签</li><li>git push origin &lt;tagname&gt;：推送某个标签到远程</li><li>git push origin –tags：一次性推送全部尚未推送到远程的本地标签</li><li>删除远程标签：先要删除本地标签git tag -d v0.9，然后再删除远程标签git push origin :refs/tags/v0.9</li></ul><p>使用Gitee</p><ul><li>git remote rm origin：删除已有的GitHub远程库</li></ul>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式中间件技术实战篇</title>
    <link href="/2021/05/30/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98%E7%AF%87/"/>
    <url>/2021/05/30/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="第1章：走进分布式中间件"><a href="#第1章：走进分布式中间件" class="headerlink" title="第1章：走进分布式中间件"></a>第1章：走进分布式中间件</h1><p>分布式概念：多个程序运行在不同的机器上，共同完成一个功能，而用户感知不到集群的存在。</p><p> 发展历程：</p><p>1、单点集中式Web应用–数据库、War包以及文件等都在同一个机器上</p><p>2、应用与文件服务及数据库单独拆分</p><p>3、引入缓存与集群–Redis、Nginx+Lvs，多台应用服务器构成负载均衡</p><p>4、数据库读写分离，并提供反向代理及CDN加速访问服务–抢票高峰，静态资源放到CDN中，加入反向代理的配置，减少访问网站时直接去服务器读取静态数据</p><p>5、分布式文件系统与分布式数据库–减少DB的压力，进行分库分表，根据业务来拆分数据库</p><h1 id="第2章：搭建微服务项目"><a href="#第2章：搭建微服务项目" class="headerlink" title="第2章：搭建微服务项目"></a>第2章：搭建微服务项目</h1><p>Spring Boot项目搭建规范：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530100950.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>依赖层级关系：server依赖model，model依赖api</p><p>Spring Boot项目搭建流程：</p><ol><li><p>File-New Project</p></li><li><p>Maven-选择SDK-Next</p></li><li><p>GroupId为包名，ArtifactId为项目名称</p></li><li><p>选择路径，不要出现中文或特殊符号路径</p></li><li><p>pom.xml文件：父模块的依赖配置文件，指定项目资源的编码以及JDK版本</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.debug.middleware<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>middleware<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>api<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>model<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>server<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-comment">&lt;!--定义项目整体资源的编码为UTF-8，JDK的版本为1.8--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>$&#123;java.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>$&#123;java.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div></li><li><p>创建子模块api以及相关依赖配置（整个项目都共用的依赖配置）</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>middleware<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.debug.middleware<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">lombok.version</span>&gt;</span>1.16.10<span class="hljs-tag">&lt;/<span class="hljs-name">lombok.version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">jackson-annotations-version</span>&gt;</span>2.6.5<span class="hljs-tag">&lt;/<span class="hljs-name">jackson-annotations-version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!--Lombok--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!--jackson--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-annotations<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;jackson-annotations-version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div></li><li><p>创建子模块model，添加api子模块以及Spring-MyBatis依赖</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>middleware<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.debug.middleware<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>model<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mybatis-spring-boot.version</span>&gt;</span>1.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">mybatis-spring-boot.version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mybatis-pagehelper.version</span>&gt;</span>4.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">mybatis-pagehelper.version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!--api--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.debug.middleware<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.parent.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!--spring-mybatis--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mybatis-spring-boot.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div></li><li><p>创建子模块server，添加Spring Boot依赖，日志log4j及MySQL，Druid等依赖</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>middleware<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.debug.middleware<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">start-class</span>&gt;</span>com.debug.middleware.server.MainApplication<span class="hljs-tag">&lt;/<span class="hljs-name">start-class</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">spring-boot.version</span>&gt;</span>1.5.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring-boot.version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">spring-session.version</span>&gt;</span>1.2.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring-session.version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mysql.version</span>&gt;</span>5.1.37<span class="hljs-tag">&lt;/<span class="hljs-name">mysql.version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">druid.version</span>&gt;</span>1.0.16<span class="hljs-tag">&lt;/<span class="hljs-name">druid.version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">guava.version</span>&gt;</span>19.0<span class="hljs-tag">&lt;/<span class="hljs-name">guava.version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">skipTests</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">skipTests</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 依赖管理 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!--日志--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!--model--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.debug.middleware<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>model<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.parent.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!--guava--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;guava.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!--mysql--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!--druid--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!--spring--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- redis --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!--rabbitmq--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!--zookeeper--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.10.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.10.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!--redisson--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.10.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!--由于redisson底层是采用基于nio的netty框架进行通信，故而需要加入依赖--&gt;</span>        <span class="hljs-comment">&lt;!--&lt;dependency&gt;</span><span class="hljs-comment">            &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><span class="hljs-comment">            &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><span class="hljs-comment">            &lt;version&gt;4.1.32.Final&lt;/version&gt;</span><span class="hljs-comment">        &lt;/dependency&gt;--&gt;</span>        <span class="hljs-comment">&lt;!--for test--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-comment">&lt;!--&lt;scope&gt;test&lt;/scope&gt;--&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>book_middleware_$&#123;project.parent.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>repackage<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>                        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-war-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">failOnMissingWebXml</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">failOnMissingWebXml</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div></li><li><p>对MainApplication进行修改</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@MapperScan</span>(basePackages = <span class="hljs-string">"com.debug.middleware.model"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SpringBootServletInitializer</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> SpringApplicationBuilder <span class="hljs-title">configure</span><span class="hljs-params">(SpringApplicationBuilder builder)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.configure(builder);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(MainApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div></li><li><p>application.properties配置文件</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment">#profile</span><span class="hljs-comment">#spring.profiles.active=productions</span><span class="hljs-comment">#spring.profiles.active=local</span><span class="hljs-comment">#指定应用访问的上下文及端口</span><span class="hljs-meta">server.context-path</span>=<span class="hljs-string">/middleware</span><span class="hljs-meta">server.port</span>=<span class="hljs-string">8087</span><span class="hljs-comment">#logging日志配置</span><span class="hljs-meta">logging.path</span>=<span class="hljs-string">/srv/dubbo/middleware/logs</span><span class="hljs-meta">logging.file</span>=<span class="hljs-string">middleware</span><span class="hljs-meta">logging.level.org.springframework</span>=<span class="hljs-string">info</span><span class="hljs-meta">logging.level.com.fasterxml.jackson</span>=<span class="hljs-string">info</span><span class="hljs-meta">logging.level.debug.middleware</span>=<span class="hljs-string">debug</span><span class="hljs-comment">#json日期格式化</span><span class="hljs-meta">spring.jackson.date-format</span>=<span class="hljs-string">yyyy-mm-dd HH:mm:ss</span><span class="hljs-meta">spring.jackson.time-zone</span>=<span class="hljs-string">GMT+8;</span><span class="hljs-meta">spring.datasource.initialize</span>=<span class="hljs-string">false</span><span class="hljs-meta">spring.jmx.enabled</span>=<span class="hljs-string">false</span><span class="hljs-comment">#数据库访问配置</span><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/db_middleware?useUnicode=true&amp;amp;characterEncoding=utf-8</span><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">root</span><span class="hljs-comment">#MyBatis配置</span><span class="hljs-meta">mybatis.config-location</span>=<span class="hljs-string">classpath:mybatis-config.xml</span><span class="hljs-meta">mybatis.check-config-location</span>=<span class="hljs-string">true</span><span class="hljs-meta">mybatis.mapper-locations</span>=<span class="hljs-string">classpath:mappers/*.xml</span><span class="hljs-comment">#Redis连接配置</span><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">127.0.0.1</span><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span></code></pre></div></li><li><p>mybatis配置文件mybatis-config.xml</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><span class="hljs-meta">        <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>        <span class="hljs-comment">&lt;!--允许使用缓存配置--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cacheEnabled"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span>        <span class="hljs-comment">&lt;!--SQL执行语句的默认响应超时时间--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"defaultStatementTimeout"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"3000"</span>/&gt;</span>        <span class="hljs-comment">&lt;!--允许驼峰命令的配置--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mapUnderscoreToCamelCase"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span>        <span class="hljs-comment">&lt;!--允许执行完SQL插入语句后返回主键配置--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"useGeneratedKeys"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span>        <span class="hljs-comment">&lt;!--设置控制台打印SQL--&gt;</span>        <span class="hljs-comment">&lt;!--&lt;setting name="logImpl" value="stdout_logging"/&gt;--&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div></li><li><p>日志配置文件log4j.properties</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment">#Console Log</span><span class="hljs-meta">log4j.rootLogger</span>=<span class="hljs-string">INFO,console,debug.info,warn,error</span><span class="hljs-attr">LOG_PATTERN</span>=<span class="hljs-string">[%d&#123;yyyy-MM-dd HH:mm:ss.sss&#125;] boot%X&#123;context&#125; - %5p [%t] ---%c&#123;1&#125;: %m%n</span><span class="hljs-comment">#打印日志到Console</span><span class="hljs-meta">log4j.appender.console</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span><span class="hljs-meta">log4j.appender.console.Threshold</span>=<span class="hljs-string">DEBUG</span><span class="hljs-meta">log4j.appender.console.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="hljs-string">$&#123;LOG_PATTERN&#125;</span><span class="hljs-meta">log4j.appender.info</span>=<span class="hljs-string">org.apache.log4jDailyRollingFileAppender</span><span class="hljs-meta">log4j.appender.info.Threshold</span>=<span class="hljs-string">INFO</span><span class="hljs-meta">log4j.appender.info.File</span>=<span class="hljs-string">$&#123;LOG_PATH&#125;/$&#123;LOG_FILE&#125;_info.log</span><span class="hljs-meta">log4j.appender.info.DatePattern</span>=<span class="hljs-string">'.'yyyy-MM-dd</span><span class="hljs-meta">log4j.appender.info.layout</span>=<span class="hljs-string">org.apache.lgo4j.PatternLayout</span><span class="hljs-meta">log4j.appender.info.layout.ConversionPattern</span>=<span class="hljs-string">$&#123;LOG_PATTERN&#125;</span><span class="hljs-meta">log4j.appender.error</span>=<span class="hljs-string">org.apache.log4j.DailyRollingFileAppender</span><span class="hljs-meta">log4j.appender.error.Threshold</span>=<span class="hljs-string">ERROR</span><span class="hljs-meta">log4j.appender.error.File</span>=<span class="hljs-string">$&#123;LOG_PATH&#125;/$&#123;LOG_FILE&#125;error.log</span><span class="hljs-meta">log4j.appender.error.DatePattern</span>=<span class="hljs-string">'.'yyyy-MM-dd</span><span class="hljs-meta">log4j.appender.error.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-meta">log4j.appender.error.layout.ConversionPattern</span>=<span class="hljs-string">$&#123;LOG_PATTERN&#125;</span><span class="hljs-meta">log4j.appender.debug</span>=<span class="hljs-string">org.apache.log4j.DailyRollingFileAppender</span><span class="hljs-meta">log4j.appender.debug.Threshold</span>=<span class="hljs-string">DEBUG</span><span class="hljs-meta">log4j.appender.debug.File</span>=<span class="hljs-string">$&#123;LOG_PATH&#125;/$&#123;LOG_FILE&#125;debug.log</span><span class="hljs-meta">log4j.appender.debug.DatePattern</span>=<span class="hljs-string">'.'yyyy-MM-dd</span><span class="hljs-meta">log4j.appender.debug.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-meta">log4j.appender.debug.layout.ConversionPattern</span>=<span class="hljs-string">$&#123;LOG_PATTERN&#125;</span><span class="hljs-meta">log4j.appender.warn</span>=<span class="hljs-string">org.apache.log4j.DailyRollingFileAppender</span><span class="hljs-meta">log4j.appender.warn.Threshold</span>=<span class="hljs-string">WARN</span><span class="hljs-meta">log4j.appender.warn.File</span>=<span class="hljs-string">$&#123;LOG_PATH&#125;/$&#123;LOG_FILE&#125;warn.log</span><span class="hljs-meta">log4j.appender.warn.DatePattern</span>=<span class="hljs-string">'.'yyyy-MM-dd</span><span class="hljs-meta">log4j.appender.warn.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-meta">log4j.appender.warn.layout.ConversionPattern</span>=<span class="hljs-string">$&#123;LOG_PATTERN&#125;</span></code></pre></div></li></ol><ol start="13"><li>最终结构</li></ol><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530101042.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>Hello World小试牛刀</p><p>在server模块创建controller包和entity包</p><p>controller包下新建一个BookController类，用于处理请求，entity包下新建Book类，封装书的字段信息</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer bookNo;    <span class="hljs-keyword">private</span> String name;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/book"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookController</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(BookController<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/***获取书籍对象信息*/</span>    <span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"info"</span>,method = RequestMethod.GET)    <span class="hljs-function"><span class="hljs-keyword">public</span> Book <span class="hljs-title">info</span><span class="hljs-params">(Integer bookNo,String bookName)</span></span>&#123;        Book book = <span class="hljs-keyword">new</span> Book();        book.setBookNo(bookNo);        book.setName(bookName);        <span class="hljs-keyword">return</span> book;    &#125;&#125;</code></pre></div><p>运行程序</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530101153.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="第3章：缓存中间件Redis"><a href="#第3章：缓存中间件Redis" class="headerlink" title="第3章：缓存中间件Redis"></a>第3章：缓存中间件Redis</h1><p>Windows下启动Redis：双击redis-server.exe</p><p>Windows下运行Redis命令行窗口：双击redis-cli.exe</p><p>常用命令：</p><ul><li>查看Redis缓存中存储的所有Key：key *</li><li>缓存中创建一个名为redis:order:no:10011，值为10011的key：set redis:order:no:10011 10011</li><li>查看缓存中指定key的值：get redis:order:no:10011</li><li>删除缓存中指定的key：del redis:order:no:10011</li></ul><h2 id="Spring-Boot整合Redis"><a href="#Spring-Boot整合Redis" class="headerlink" title="Spring Boot整合Redis"></a>Spring Boot整合Redis</h2><p>1、加入Redis的依赖jar</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- redis --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>2、在配置文件application.properties中加入Redis的连接配置</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment">#Redis连接配置</span><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">127.0.0.1</span><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span></code></pre></div><p>Redis自定义注入Bean组件配置</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//com.coding.fight.server.config.CommonConfig</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommonConfig</span> </span>&#123;    <span class="hljs-comment">/**redis链接工厂*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisConnectionFactory redisConnectionFactory;    <span class="hljs-comment">/**缓存操作组件RedisTemplate的自定义配置*/</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String,Object&gt;redisTemplate()&#123;        <span class="hljs-comment">//定义RedisTemplate实例</span>        RedisTemplate&lt;String,Object&gt;redisTemplate = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();        <span class="hljs-comment">//设置Redis的链接工厂</span>        redisTemplate.setConnectionFactory(redisConnectionFactory);        <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span>指定大key序列化策略为String序列化，value为JDK自带的序列化策略</span>        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());        redisTemplate.setValueSerializer(<span class="hljs-keyword">new</span> JdkSerializationRedisSerializer());        <span class="hljs-comment">//TODO：指定hashKey序列化策略为String序列化-针对hash散列存储</span>        redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());        <span class="hljs-keyword">return</span> redisTemplate;    &#125;    <span class="hljs-comment">/**缓存操作组件StringRedisTemplate*/</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title">stringRedisTemplate</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//采用默认配置即可，后续有自定义配置时则在此处添加即可</span>        StringRedisTemplate stringRedisTemplate = <span class="hljs-keyword">new</span> StringRedisTemplate();        stringRedisTemplate.setConnectionFactory(redisConnectionFactory);        <span class="hljs-keyword">return</span> stringRedisTemplate;    &#125;&#125;</code></pre></div><h2 id="RedisTemplate实战"><a href="#RedisTemplate实战" class="headerlink" title="RedisTemplate实战"></a>RedisTemplate实战</h2><p>目标一：采用RedisTemplate将字符串写入缓存中，并读取出来展示到控制台上</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">SpringBootTest</span></span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">RedisTest</span> </span>&#123;    <span class="hljs-comment">//定义日志</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(RedisTest<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">//定义RedisTemplate操作组件</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;    <span class="hljs-comment">//定义JSON序列化和反序列化框架类</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">one</span><span class="hljs-params">()</span> </span>&#123;        log.info(<span class="hljs-string">"---开始RedisTemplate操作组件实战---"</span>);        <span class="hljs-comment">//定义字符串内容及存入缓存的key</span>        <span class="hljs-keyword">final</span> String content = <span class="hljs-string">"RedisTemplate实战字符串信息"</span>;        <span class="hljs-keyword">final</span> String key = <span class="hljs-string">"redis:template:one:string"</span>;        <span class="hljs-comment">//Redis通用的操作组件</span>        ValueOperations valueOperations = redisTemplate.opsForValue();        <span class="hljs-comment">//将字符串信息写入缓存中</span>        log.info(<span class="hljs-string">"写入缓存中的内容：&#123;&#125;"</span>, content);        valueOperations.set(key, content);        <span class="hljs-comment">//从缓存中读取内容</span>        Object result = valueOperations.get(key);        log.info(<span class="hljs-string">"读取出来的内容：&#123;&#125;"</span>, result);    &#125;&#125;</code></pre></div><p>效果：</p><div class="hljs"><pre><code class="hljs angelscript">[<span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-30</span> <span class="hljs-number">23</span>:<span class="hljs-number">38</span>:<span class="hljs-number">29.029</span>] boot -  INFO [main] ---RedisTest: ---开始RedisTemplate操作组件实战---[<span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-30</span> <span class="hljs-number">23</span>:<span class="hljs-number">38</span>:<span class="hljs-number">29.029</span>] boot -  INFO [main] ---RedisTest: 写入缓存中的内容：RedisTemplate实战字符串信息[<span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-30</span> <span class="hljs-number">23</span>:<span class="hljs-number">38</span>:<span class="hljs-number">29.029</span>] boot -  INFO [main] ---RedisTest: 读取出来的内容：RedisTemplate实战字符串信息</code></pre></div><p>目标二：采用RedisTemplate将对象信息序列化为JSON格式的字符串后写入缓存中，然后将其读取出来，最后反序列化解析其中的内容并展示在控制台</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">two</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        log.info(<span class="hljs-string">"-----开始RedisTemplate操作组件实战----"</span>);        <span class="hljs-comment">//构造对象信息</span>        User user = <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">"debug"</span>, <span class="hljs-string">"阿修罗"</span>);        <span class="hljs-comment">//Redis通用的操作组件</span>        ValueOperations valueOperations = redisTemplate.opsForValue();        <span class="hljs-comment">//将序列化后的信息写入缓存中</span>        <span class="hljs-keyword">final</span> String key = <span class="hljs-string">"redis:template:two:object"</span>;        <span class="hljs-keyword">final</span> String content = objectMapper.writeValueAsString(user);        valueOperations.set(key, content);        log.info(<span class="hljs-string">"写入缓存对象的信息：&#123;&#125;"</span>, user);        <span class="hljs-comment">//从缓存中读取内容</span>        Object result = valueOperations.get(key);        <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;            User resultUser = objectMapper.readValue(result.toString(),User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            log.info(<span class="hljs-string">"读取缓存内容并反序列化后的结果：&#123;&#125;"</span>,resultUser);        &#125;    &#125;</code></pre></div><p>效果：</p><div class="hljs"><pre><code class="hljs angelscript">[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-03</span> <span class="hljs-number">15</span>:<span class="hljs-number">05</span>:<span class="hljs-number">14.014</span>] boot -  INFO [main] ---RedisTest: -----开始RedisTemplate操作组件实战----[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-03</span> <span class="hljs-number">15</span>:<span class="hljs-number">05</span>:<span class="hljs-number">15.015</span>] boot -  INFO [main] ---RedisTest: 写入缓存对象的信息：User(id=<span class="hljs-number">1</span>, userName=debug, name=阿修罗)[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-03</span> <span class="hljs-number">15</span>:<span class="hljs-number">05</span>:<span class="hljs-number">15.015</span>] boot -  INFO [main] ---RedisTest: 读取缓存内容并反序列化后的结果：User(id=<span class="hljs-number">1</span>, userName=debug, name=阿修罗)</code></pre></div><h2 id="Redis常见数据结构实战"><a href="#Redis常见数据结构实战" class="headerlink" title="Redis常见数据结构实战"></a>Redis常见数据结构实战</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>业务场景：将用户个人信息存储至缓存中，实现每次前端请求获取用户个人详情时直接从缓存中读取</p><p>Person类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String userName;    <span class="hljs-keyword">private</span> String location;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(Integer id, Integer age, String name, String userName, String location)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;        <span class="hljs-keyword">this</span>.age = age;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.userName = userName;        <span class="hljs-keyword">this</span>.location = location;    &#125;&#125;</code></pre></div><p>测试类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">SpringBootTest</span></span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">RedisTest2</span> </span>&#123;    <span class="hljs-comment">//定义日志</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(RedisTest2<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">//定义RedisTemplate操作组件</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;    <span class="hljs-comment">//JSON序列化与反序列化框架类</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-comment">//单元测试方法</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">one</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//构造用户个人实体对象</span>        Person p = <span class="hljs-keyword">new</span> Person(<span class="hljs-number">10013</span>, <span class="hljs-number">23</span>, <span class="hljs-string">"修罗"</span>, <span class="hljs-string">"debug"</span>, <span class="hljs-string">"火星"</span>);        <span class="hljs-comment">//定义key与即将存入缓存中的value</span>        <span class="hljs-keyword">final</span> String key = <span class="hljs-string">"redis:test:1"</span>;        String value = objectMapper.writeValueAsString(p);        <span class="hljs-comment">//写入缓存中</span>        log.info(<span class="hljs-string">"存入缓存中的用户实体对象信息为：&#123;&#125;"</span>, p);        redisTemplate.opsForValue().set(key, value);        <span class="hljs-comment">//从缓存中获取用户实体信息</span>        Object res = redisTemplate.opsForValue().get(key);        <span class="hljs-keyword">if</span> (res != <span class="hljs-keyword">null</span>) &#123;            Person resP = objectMapper.readValue(res.toString(), Person<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            log.info(<span class="hljs-string">"从缓存中读取信息：&#123;&#125;"</span>, resP);        &#125;    &#125;&#125;</code></pre></div><p>效果</p><div class="hljs"><pre><code class="hljs routeros">[2021-01-03 17:59:55.055] boot -  <span class="hljs-builtin-name">INFO</span> [main] ---RedisTest2: 存入缓存中的用户实体对象信息为：Person(<span class="hljs-attribute">id</span>=10013, <span class="hljs-attribute">age</span>=23, <span class="hljs-attribute">name</span>=修罗, <span class="hljs-attribute">userName</span>=debug, <span class="hljs-attribute">location</span>=火星)[2021-01-03 17:59:55.055] boot -  <span class="hljs-builtin-name">INFO</span> [main] ---RedisTest2: 从缓存中读取信息：Person(<span class="hljs-attribute">id</span>=10013, <span class="hljs-attribute">age</span>=23, <span class="hljs-attribute">name</span>=修罗, <span class="hljs-attribute">userName</span>=debug, <span class="hljs-attribute">location</span>=火星)</code></pre></div><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>案例：将一组已经排好序的用户对象列表存储在缓存中，按照排名的先后顺序获取出来并输出打印到控制台</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">two</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//构造已经排好序的用户对象列表</span>    List&lt;Person&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>, <span class="hljs-string">"修罗"</span>, <span class="hljs-string">"debug"</span>, <span class="hljs-string">"火星"</span>));    list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">2</span>, <span class="hljs-number">22</span>, <span class="hljs-string">"大圣"</span>, <span class="hljs-string">"jack"</span>, <span class="hljs-string">"水帘洞"</span>));    list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">3</span>, <span class="hljs-number">23</span>, <span class="hljs-string">"盘古"</span>, <span class="hljs-string">"Lee"</span>, <span class="hljs-string">"上古"</span>));    log.info(<span class="hljs-string">"构造已经排好序的用户对象列表：&#123;&#125;"</span>, list);    <span class="hljs-comment">//将列表数据存储至Redis的List中</span>    <span class="hljs-keyword">final</span> String key = <span class="hljs-string">"redis:test:2"</span>;    ListOperations listOperations = redisTemplate.opsForList();    <span class="hljs-keyword">for</span> (Person p : list) &#123;        <span class="hljs-comment">//往列表中添加数据-从队尾中添加</span>        listOperations.leftPush(key, p);    &#125;    <span class="hljs-comment">//获取Redis中List的数据-从队头中遍历获取，直到没有元素为止</span>    log.info(<span class="hljs-string">"--获取Redis中List的数据-从队头中获取---"</span>);    Object res = listOperations.rightPop(key);    Person resP;    <span class="hljs-keyword">while</span> (res != <span class="hljs-keyword">null</span>) &#123;        resP = (Person) res;        log.info(<span class="hljs-string">"当前数据：&#123;&#125;"</span>, resP);        res = listOperations.rightPop(key);    &#125;&#125;</code></pre></div><p>效果</p><div class="hljs"><pre><code class="hljs routeros">[2021-01-03 18:23:53.053] boot -  <span class="hljs-builtin-name">INFO</span> [main] ---RedisTest2: 构造已经排好序的用户对象列表：[Person(<span class="hljs-attribute">id</span>=1, <span class="hljs-attribute">age</span>=21, <span class="hljs-attribute">name</span>=修罗, <span class="hljs-attribute">userName</span>=debug, <span class="hljs-attribute">location</span>=火星), Person(<span class="hljs-attribute">id</span>=2, <span class="hljs-attribute">age</span>=22, <span class="hljs-attribute">name</span>=大圣, <span class="hljs-attribute">userName</span>=jack, <span class="hljs-attribute">location</span>=水帘洞), Person(<span class="hljs-attribute">id</span>=3, <span class="hljs-attribute">age</span>=23, <span class="hljs-attribute">name</span>=盘古, <span class="hljs-attribute">userName</span>=Lee, <span class="hljs-attribute">location</span>=上古)][2021-01-03 18:23:53.053] boot -  <span class="hljs-builtin-name">INFO</span> [main] ---RedisTest2: --获取Redis中List的数据-从队头中获取---[2021-01-03 18:23:53.053] boot -  <span class="hljs-builtin-name">INFO</span> [main] ---RedisTest2: 当前数据：Person(<span class="hljs-attribute">id</span>=1, <span class="hljs-attribute">age</span>=21, <span class="hljs-attribute">name</span>=修罗, <span class="hljs-attribute">userName</span>=debug, <span class="hljs-attribute">location</span>=火星)[2021-01-03 18:23:53.053] boot -  <span class="hljs-builtin-name">INFO</span> [main] ---RedisTest2: 当前数据：Person(<span class="hljs-attribute">id</span>=2, <span class="hljs-attribute">age</span>=22, <span class="hljs-attribute">name</span>=大圣, <span class="hljs-attribute">userName</span>=jack, <span class="hljs-attribute">location</span>=水帘洞)[2021-01-03 18:23:53.053] boot -  <span class="hljs-builtin-name">INFO</span> [main] ---RedisTest2: 当前数据：Person(<span class="hljs-attribute">id</span>=3, <span class="hljs-attribute">age</span>=23, <span class="hljs-attribute">name</span>=盘古, <span class="hljs-attribute">userName</span>=Lee, <span class="hljs-attribute">location</span>=上古)</code></pre></div><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>用于存储具有相同类型或特征的不重复的数据</p><p>需求：给定一组用户姓名列表，要求剔除具有相同姓名的人员并组成新的集合，存放至缓存中并用于前端访问</p><p>核心代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">three</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//构造一组用户姓名列表</span>        List&lt;String&gt; userList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        userList.add(<span class="hljs-string">"debug"</span>);        userList.add(<span class="hljs-string">"jack"</span>);        userList.add(<span class="hljs-string">"修罗"</span>);        userList.add(<span class="hljs-string">"大圣"</span>);        userList.add(<span class="hljs-string">"debug"</span>);        userList.add(<span class="hljs-string">"jack"</span>);        userList.add(<span class="hljs-string">"steadyheart"</span>);        userList.add(<span class="hljs-string">"修罗"</span>);        userList.add(<span class="hljs-string">"大圣"</span>);        log.info(<span class="hljs-string">"待处理的用户姓名列表：&#123;&#125;"</span>, userList);        <span class="hljs-comment">//遍历访问，剔除相同姓名的用户并塞入集合中，最终存入缓存中</span>        <span class="hljs-keyword">final</span> String key = <span class="hljs-string">"redis:test:3"</span>;        SetOperations setOperations = redisTemplate.opsForSet();        <span class="hljs-keyword">for</span> (String s : userList) &#123;            setOperations.add(key,s);        &#125;        <span class="hljs-comment">//从缓存中获取用户对象集合</span>        Object res = setOperations.pop(key);        <span class="hljs-keyword">while</span> (res != <span class="hljs-keyword">null</span>) &#123;            log.info(<span class="hljs-string">"从缓存中获取的用户集合-当前用户：&#123;&#125;"</span>, res);            res = setOperations.pop(key);        &#125;    &#125;</code></pre></div><p>效果：</p><div class="hljs"><pre><code class="hljs angelscript">[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span> <span class="hljs-number">13</span>:<span class="hljs-number">02</span>:<span class="hljs-number">05.005</span>] boot -  INFO [main] ---RedisTest2: 待处理的用户姓名列表：[debug, jack, 修罗, 大圣, debug, jack, steadyheart, 修罗, 大圣][<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span> <span class="hljs-number">13</span>:<span class="hljs-number">02</span>:<span class="hljs-number">05.005</span>] boot -  INFO [main] ---RedisTest2: 从缓存中获取的用户集合-当前用户：大圣[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span> <span class="hljs-number">13</span>:<span class="hljs-number">02</span>:<span class="hljs-number">05.005</span>] boot -  INFO [main] ---RedisTest2: 从缓存中获取的用户集合-当前用户：steadyheart[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span> <span class="hljs-number">13</span>:<span class="hljs-number">02</span>:<span class="hljs-number">05.005</span>] boot -  INFO [main] ---RedisTest2: 从缓存中获取的用户集合-当前用户：debug[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span> <span class="hljs-number">13</span>:<span class="hljs-number">02</span>:<span class="hljs-number">05.005</span>] boot -  INFO [main] ---RedisTest2: 从缓存中获取的用户集合-当前用户：jack[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span> <span class="hljs-number">13</span>:<span class="hljs-number">02</span>:<span class="hljs-number">05.005</span>] boot -  INFO [main] ---RedisTest2: 从缓存中获取的用户集合-当前用户：修罗</code></pre></div><h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><p>与sort 的不同之处在于可以通过底层的Score值对数据进行排序</p><p>需求：找出一个星期内手机话费单次金额前6名的用户列表，并要求按照金额从大到小进行排序</p><p>代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhoneUser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> String phone;    <span class="hljs-keyword">private</span> Double fare;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PhoneUser</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PhoneUser</span><span class="hljs-params">(String phone, Double fare)</span> </span>&#123;        <span class="hljs-keyword">this</span>.phone = phone;        <span class="hljs-keyword">this</span>.fare = fare;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 手机号相同，代表充值记录重复，所以需要重写equals和hashCode方法</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        PhoneUser phoneUser = (PhoneUser) o;        <span class="hljs-keyword">return</span> phone != <span class="hljs-keyword">null</span> ? phone.equals(phoneUser.phone) : phoneUser.phone == <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> phone != <span class="hljs-keyword">null</span> ? phone.hashCode() : <span class="hljs-number">0</span>;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">four</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//构造一组无序的用户手机充值对象列表</span>        List&lt;PhoneUser&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        list.add(<span class="hljs-keyword">new</span> PhoneUser(<span class="hljs-string">"103"</span>, <span class="hljs-number">130.0</span>));        list.add(<span class="hljs-keyword">new</span> PhoneUser(<span class="hljs-string">"101"</span>, <span class="hljs-number">120.0</span>));        list.add(<span class="hljs-keyword">new</span> PhoneUser(<span class="hljs-string">"105"</span>, <span class="hljs-number">110.0</span>));        list.add(<span class="hljs-keyword">new</span> PhoneUser(<span class="hljs-string">"104"</span>, <span class="hljs-number">100.0</span>));        list.add(<span class="hljs-keyword">new</span> PhoneUser(<span class="hljs-string">"106"</span>, <span class="hljs-number">150.0</span>));        list.add(<span class="hljs-keyword">new</span> PhoneUser(<span class="hljs-string">"102"</span>, <span class="hljs-number">160.0</span>));        log.info(<span class="hljs-string">"构造一组无序的用户手机充值对象列表：&#123;&#125;"</span>, list);        <span class="hljs-comment">//遍历访问充值对象雷暴，将信息塞入Redis的有序集合中</span>        <span class="hljs-keyword">final</span> String key = <span class="hljs-string">"redis:test:4"</span>;        <span class="hljs-comment">//因为zSet在add元素进入缓存后，下次就不能进行更新了，因而为了测试方便，进入操作之前先清空该缓存</span>        redisTemplate.delete(key);        <span class="hljs-comment">//获取有序集合SortedSet操作组件zSetOperations</span>        ZSetOperations zSetOperations = redisTemplate.opsForZSet();        <span class="hljs-keyword">for</span> (PhoneUser user : list) &#123;            zSetOperations.add(key, user, user.getFare());        &#125;        <span class="hljs-comment">//前端获取访问充值排名靠前的用户列表</span>        Long size = zSetOperations.size(key);        <span class="hljs-comment">//从小到大排序</span>        <span class="hljs-comment">//Set&lt;PhoneUser&gt; resSet = zSetOperations.range(key,0L,size);</span>        <span class="hljs-comment">//从大到小排序</span>        Set&lt;PhoneUser&gt; resSet = zSetOperations.reverseRange(key, <span class="hljs-number">0L</span>, size);        <span class="hljs-comment">//遍历获取有序集合中的元素</span>        <span class="hljs-keyword">for</span> (PhoneUser u : resSet) &#123;            log.info(<span class="hljs-string">"从缓存中读取手机充值记录排序列表，当前记录：&#123;&#125;"</span>, u);        &#125;    &#125;</code></pre></div><p>效果：</p><div class="hljs"><pre><code class="hljs angelscript">[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span> <span class="hljs-number">13</span>:<span class="hljs-number">24</span>:<span class="hljs-number">38.038</span>] boot -  INFO [main] ---RedisTest2: 构造一组无序的用户手机充值对象列表：[PhoneUser(phone=<span class="hljs-number">103</span>, fare=<span class="hljs-number">130.0</span>), PhoneUser(phone=<span class="hljs-number">101</span>, fare=<span class="hljs-number">120.0</span>), PhoneUser(phone=<span class="hljs-number">105</span>, fare=<span class="hljs-number">110.0</span>), PhoneUser(phone=<span class="hljs-number">104</span>, fare=<span class="hljs-number">100.0</span>), PhoneUser(phone=<span class="hljs-number">106</span>, fare=<span class="hljs-number">150.0</span>), PhoneUser(phone=<span class="hljs-number">102</span>, fare=<span class="hljs-number">160.0</span>)][<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span> <span class="hljs-number">13</span>:<span class="hljs-number">24</span>:<span class="hljs-number">38.038</span>] boot -  INFO [main] ---RedisTest2: 从缓存中读取手机充值记录排序列表，当前记录：PhoneUser(phone=<span class="hljs-number">102</span>, fare=<span class="hljs-number">160.0</span>)[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span> <span class="hljs-number">13</span>:<span class="hljs-number">24</span>:<span class="hljs-number">38.038</span>] boot -  INFO [main] ---RedisTest2: 从缓存中读取手机充值记录排序列表，当前记录：PhoneUser(phone=<span class="hljs-number">106</span>, fare=<span class="hljs-number">150.0</span>)[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span> <span class="hljs-number">13</span>:<span class="hljs-number">24</span>:<span class="hljs-number">38.038</span>] boot -  INFO [main] ---RedisTest2: 从缓存中读取手机充值记录排序列表，当前记录：PhoneUser(phone=<span class="hljs-number">103</span>, fare=<span class="hljs-number">130.0</span>)[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span> <span class="hljs-number">13</span>:<span class="hljs-number">24</span>:<span class="hljs-number">38.038</span>] boot -  INFO [main] ---RedisTest2: 从缓存中读取手机充值记录排序列表，当前记录：PhoneUser(phone=<span class="hljs-number">101</span>, fare=<span class="hljs-number">120.0</span>)[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span> <span class="hljs-number">13</span>:<span class="hljs-number">24</span>:<span class="hljs-number">38.038</span>] boot -  INFO [main] ---RedisTest2: 从缓存中读取手机充值记录排序列表，当前记录：PhoneUser(phone=<span class="hljs-number">105</span>, fare=<span class="hljs-number">110.0</span>)[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span> <span class="hljs-number">13</span>:<span class="hljs-number">24</span>:<span class="hljs-number">38.038</span>] boot -  INFO [main] ---RedisTest2: 从缓存中读取手机充值记录排序列表，当前记录：PhoneUser(phone=<span class="hljs-number">104</span>, fare=<span class="hljs-number">100.0</span>)</code></pre></div><h3 id="哈希Hash存储"><a href="#哈希Hash存储" class="headerlink" title="哈希Hash存储"></a>哈希Hash存储</h3><p>Redis的哈希存储底层数据结构是由Key-value组成的映射表，value由Filed-Value对构成</p><p>需求：对学生对象列表和水果对象列表进行存储</p><p>核心代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-keyword">private</span> String userName;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String id, String userName, String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;        <span class="hljs-keyword">this</span>.userName = userName;        <span class="hljs-keyword">this</span>.name = name;    &#125;&#125;<span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fruit</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String color;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Fruit</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Fruit</span><span class="hljs-params">(String name, String color)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.color = color;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">five</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//构造学生对象和水果对象列表</span>    List&lt;Student&gt; students = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    List&lt;Fruit&gt; fruits = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-comment">//往学生集合中添加学生对象</span>    students.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">"10010"</span>, <span class="hljs-string">"debug"</span>, <span class="hljs-string">"大圣"</span>));    students.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">"10011"</span>, <span class="hljs-string">"jack"</span>, <span class="hljs-string">"修罗"</span>));    students.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">"10012"</span>, <span class="hljs-string">"sam"</span>, <span class="hljs-string">"上古"</span>));    <span class="hljs-comment">//往水果集合中添加水果对象</span>    fruits.add(<span class="hljs-keyword">new</span> Fruit(<span class="hljs-string">"apple"</span>, <span class="hljs-string">"红色"</span>));    fruits.add(<span class="hljs-keyword">new</span> Fruit(<span class="hljs-string">"orange"</span>, <span class="hljs-string">"橙色"</span>));    fruits.add(<span class="hljs-keyword">new</span> Fruit(<span class="hljs-string">"banana"</span>, <span class="hljs-string">"黄色"</span>));    <span class="hljs-comment">//分别遍历不同的对象列表，并采用Hash存储至缓存中</span>    <span class="hljs-keyword">final</span> String sKey = <span class="hljs-string">"redis:test:5"</span>;    <span class="hljs-keyword">final</span> String fKey = <span class="hljs-string">"redis:test:6"</span>;    <span class="hljs-comment">//获取Hash存储操作组件HashOperations，遍历获取集合中的对象并添加进缓存中</span>    HashOperations hashOperations = redisTemplate.opsForHash();    <span class="hljs-keyword">for</span> (Student student : students) &#123;        hashOperations.put(sKey, student.getId(), student);    &#125;    <span class="hljs-keyword">for</span> (Fruit fruit : fruits) &#123;        hashOperations.put(fKey, fruit.getName(), fruit);    &#125;    <span class="hljs-comment">//获取学生对象列表与水果对象列表</span>    Map&lt;String, Student&gt; sMap = hashOperations.entries(sKey);    log.info(<span class="hljs-string">"获取学生对象列表：&#123;&#125;"</span>, sMap);    Map&lt;String, Fruit&gt; fMap = hashOperations.entries(fKey);    log.info(<span class="hljs-string">"获取水果对象列表：&#123;&#125;"</span>, fMap);    <span class="hljs-comment">//获取指定的学生对象</span>    String SField = <span class="hljs-string">"10012"</span>;    Student s = (Student) hashOperations.get(sKey, SField);    log.info(<span class="hljs-string">"获取指定的学生对象：&#123;&#125; -&gt; &#123;&#125;"</span>, SField, s);    <span class="hljs-comment">//获取指定的水果对象</span>    String fField = <span class="hljs-string">"orange"</span>;    Fruit f = (Fruit) hashOperations.get(fKey, fField);    log.info(<span class="hljs-string">"获取指定的水果对象：&#123;&#125; -&gt; &#123;&#125;"</span>, fField, f);&#125;</code></pre></div><p>效果</p><div class="hljs"><pre><code class="hljs routeros">[2021-01-04 13:50:14.014] boot -  <span class="hljs-builtin-name">INFO</span> [main] ---RedisTest2: 获取学生对象列表：&#123;<span class="hljs-attribute">10010</span>=Student(id=10010, <span class="hljs-attribute">userName</span>=debug, <span class="hljs-attribute">name</span>=大圣), <span class="hljs-attribute">10011</span>=Student(id=10011, <span class="hljs-attribute">userName</span>=jack, <span class="hljs-attribute">name</span>=修罗), <span class="hljs-attribute">10012</span>=Student(id=10012, <span class="hljs-attribute">userName</span>=sam, <span class="hljs-attribute">name</span>=上古)&#125;[2021-01-04 13:50:14.014] boot -  <span class="hljs-builtin-name">INFO</span> [main] ---RedisTest2: 获取水果对象列表：&#123;<span class="hljs-attribute">apple</span>=Fruit(name=apple, <span class="hljs-attribute">color</span>=红色), <span class="hljs-attribute">banana</span>=Fruit(name=banana, <span class="hljs-attribute">color</span>=黄色), <span class="hljs-attribute">orange</span>=Fruit(name=orange, <span class="hljs-attribute">color</span>=橙色)&#125;[2021-01-04 13:50:14.014] boot -  <span class="hljs-builtin-name">INFO</span> [main] ---RedisTest2: 获取指定的学生对象：10012 -&gt; Student(<span class="hljs-attribute">id</span>=10012, <span class="hljs-attribute">userName</span>=sam, <span class="hljs-attribute">name</span>=上古)[2021-01-04 13:50:14.014] boot -  <span class="hljs-builtin-name">INFO</span> [main] ---RedisTest2: 获取指定的水果对象：orange -&gt; Fruit(<span class="hljs-attribute">name</span>=orange, <span class="hljs-attribute">color</span>=橙色)</code></pre></div><h3 id="Key失效与判断是否存在"><a href="#Key失效与判断是否存在" class="headerlink" title="Key失效与判断是否存在"></a>Key失效与判断是否存在</h3><p>在Redis缓存体系中，Delete与Expire操作都可以用于清理缓存中的Key，Delete需要手动触发，Expire只需提供一个TTL（过期时间），就能实现Key的自动失效。</p><p>下面代码演示如何使缓存中的Key失效：</p><p>方法一：调用SETEX方法中指定Key的过期时间</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">six</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;     <span class="hljs-comment">//构造key与Redis操作组件ValueOperations</span>     <span class="hljs-keyword">final</span> String key1 = <span class="hljs-string">"redis:test:6"</span>;     ValueOperations valueOperations = redisTemplate.opsForValue();     <span class="hljs-comment">//第一种方法：在往缓存中set数据时，提供一个TTL，表示ttl时间一到，缓存中的key将自动失效，即被清理</span>     valueOperations.set(key1, <span class="hljs-string">"expire操作"</span>, <span class="hljs-number">10L</span>, TimeUnit.SECONDS);     <span class="hljs-comment">//等待5秒-判断key是否还存在</span>     Thread.sleep(<span class="hljs-number">5000</span>);     Boolean expireKey1 = redisTemplate.hasKey(key1);     Object value = valueOperations.get(key1);     log.info(<span class="hljs-string">"等待5秒-判断key是否还存在：&#123;&#125;对应的值：&#123;&#125;"</span>, expireKey1, value);     <span class="hljs-comment">//再等待5秒，判断key是否还存在</span>     Thread.sleep(<span class="hljs-number">5000</span>);     expireKey1 = redisTemplate.hasKey(key1);     value = valueOperations.get(key1);     log.info(<span class="hljs-string">"再等待5秒-再判断key是否还存在：&#123;&#125;对应的值：&#123;&#125;"</span>, expireKey1, value); &#125;</code></pre></div><p>效果</p><div class="hljs"><pre><code class="hljs angelscript">[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span> <span class="hljs-number">14</span>:<span class="hljs-number">02</span>:<span class="hljs-number">16.016</span>] boot -  INFO [main] ---RedisTest2: 等待<span class="hljs-number">5</span>秒-判断key是否还存在：<span class="hljs-literal">true</span>对应的值：expire操作[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span> <span class="hljs-number">14</span>:<span class="hljs-number">02</span>:<span class="hljs-number">21.021</span>] boot -  INFO [main] ---RedisTest2: 再等待<span class="hljs-number">5</span>秒-再判断key是否还存在：<span class="hljs-literal">false</span>对应的值：<span class="hljs-literal">null</span></code></pre></div><p>方法二：采用RedisTemplate操作组件的Expire()方法指定失效的Key</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">seven</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;      <span class="hljs-comment">//构造key和redis操作组件</span>      <span class="hljs-keyword">final</span> String key2 = <span class="hljs-string">"redis:test：7"</span>;      ValueOperations valueOperations = redisTemplate.opsForValue();      <span class="hljs-comment">//第二种方法：在往缓存中set数据后，采用redisTemplate的expire方法使该key失效</span>      valueOperations.set(key2,<span class="hljs-string">"expire操作-2"</span>);      redisTemplate.expire(key2,<span class="hljs-number">10L</span>,TimeUnit.SECONDS);      <span class="hljs-comment">//等待5秒-判断key是否还存在</span>      Thread.sleep(<span class="hljs-number">5000</span>);      Boolean expireKey = redisTemplate.hasKey(key2);      Object value = valueOperations.get(key2);      log.info(<span class="hljs-string">"等待5秒-判断key是否还存在：&#123;&#125;对应的值：&#123;&#125;"</span>, expireKey, value);      <span class="hljs-comment">//再等待5秒，判断key是否还存在</span>      Thread.sleep(<span class="hljs-number">5000</span>);      expireKey = redisTemplate.hasKey(key2);      value = valueOperations.get(key2);      log.info(<span class="hljs-string">"再等待5秒-再判断key是否还存在：&#123;&#125;对应的值：&#123;&#125;"</span>, expireKey, value);  &#125;</code></pre></div><p>通过RedisTemplate.hasKey()方法来判断缓存中的Key是否存在。</p><h2 id="Redis实战场景之缓存穿透"><a href="#Redis实战场景之缓存穿透" class="headerlink" title="Redis实战场景之缓存穿透"></a>Redis实战场景之缓存穿透</h2><p>缓存穿透：前端频繁请求数据库中不存在的数据</p><p>解决方案：当查询数据库时如果没有查询到数据，则将Null返回给前端用户，同时将该Null 数据塞入缓存中，并对对应的Key设置一定的过期时间。</p><p>实战：以”商城用户访问某个热销的商品“为案例</p><ol><li><p>在数据库中建立数据库表，命令为item</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`item`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`item`</span> (  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,  <span class="hljs-string">`code`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'商品编号'</span>,  <span class="hljs-string">`name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8mb4 <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'商品名称'</span>,  <span class="hljs-string">`create_time`</span> datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">2</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8 <span class="hljs-keyword">COMMENT</span>=<span class="hljs-string">'商品信息表'</span>;</code></pre></div><p>在数据库表创建一条记录，code取值为“book_10010”，name取值为”分布式中间件实战“，create_time取值为当前时间。</p></li><li><p>采用MyBatis的逆向工程生成该实体类对应的Model，Mapper和Mapper.xml，并将这三个文件存放至model模块下不同的目录中</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Item</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String code;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@JsonFormat</span>(pattern = <span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>,timezone = <span class="hljs-string">"GMT+8"</span>)    <span class="hljs-keyword">private</span> Date createTime;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> code;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCode</span><span class="hljs-params">(String code)</span> </span>&#123;        <span class="hljs-keyword">this</span>.code = code;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getCreateTime</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> createTime;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCreateTime</span><span class="hljs-params">(Date createTime)</span> </span>&#123;        <span class="hljs-keyword">this</span>.createTime = createTime;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ItemMapper</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 此为MyBatis逆向工程自动生成的方法-增、删、改、查</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteByPrimaryKey</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Item record)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertSelective</span><span class="hljs-params">(Item record)</span></span>;    <span class="hljs-function">Item <span class="hljs-title">selectByPrimaryKey</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKeySelective</span><span class="hljs-params">(Item record)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKey</span><span class="hljs-params">(Item record)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据商品编码，查询商品详情</span><span class="hljs-comment">     */</span>    <span class="hljs-function">Item <span class="hljs-title">selectByCode</span><span class="hljs-params">(@Param(<span class="hljs-string">"code"</span>)</span> String code)</span>;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.debug.middleware.model.mapper.ItemMapper"</span> &gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"BaseResultMap"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.debug.middleware.model.entity.Item"</span> &gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"INTEGER"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"code"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"code"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"VARCHAR"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"VARCHAR"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"create_time"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"createTime"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"TIMESTAMP"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"Base_Column_List"</span> &gt;</span>        id, code, name, create_time    <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectByPrimaryKey"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"BaseResultMap"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"java.lang.Integer"</span> &gt;</span>        select        <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">"Base_Column_List"</span> /&gt;</span>        from item        where id = #&#123;id,jdbcType=INTEGER&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"deleteByPrimaryKey"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"java.lang.Integer"</span> &gt;</span>        delete from item        where id = #&#123;id,jdbcType=INTEGER&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"insert"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.debug.middleware.model.entity.Item"</span> &gt;</span>        insert into item (id, code, name,                          create_time)        values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;code,jdbcType=VARCHAR&#125;, #&#123;name,jdbcType=VARCHAR&#125;,                #&#123;createTime,jdbcType=TIMESTAMP&#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"insertSelective"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.debug.middleware.model.entity.Item"</span> &gt;</span>        insert into item        <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"("</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">")"</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">","</span> &gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"id != null"</span> &gt;</span>                id,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"code != null"</span> &gt;</span>                code,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"name != null"</span> &gt;</span>                name,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"createTime != null"</span> &gt;</span>                create_time,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"values ("</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">")"</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">","</span> &gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"id != null"</span> &gt;</span>                #&#123;id,jdbcType=INTEGER&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"code != null"</span> &gt;</span>                #&#123;code,jdbcType=VARCHAR&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"name != null"</span> &gt;</span>                #&#123;name,jdbcType=VARCHAR&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"createTime != null"</span> &gt;</span>                #&#123;createTime,jdbcType=TIMESTAMP&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"updateByPrimaryKeySelective"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.debug.middleware.model.entity.Item"</span> &gt;</span>        update item        <span class="hljs-tag">&lt;<span class="hljs-name">set</span> &gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"code != null"</span> &gt;</span>                code = #&#123;code,jdbcType=VARCHAR&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"name != null"</span> &gt;</span>                name = #&#123;name,jdbcType=VARCHAR&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"createTime != null"</span> &gt;</span>                create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>        where id = #&#123;id,jdbcType=INTEGER&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"updateByPrimaryKey"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.debug.middleware.model.entity.Item"</span> &gt;</span>        update item        set code = #&#123;code,jdbcType=VARCHAR&#125;,            name = #&#123;name,jdbcType=VARCHAR&#125;,            create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;        where id = #&#123;id,jdbcType=INTEGER&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>    <span class="hljs-comment">&lt;!--根据商品编码查询--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectByCode"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"com.debug.middleware.model.entity.Item"</span>&gt;</span>        select        <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">"Base_Column_List"</span> /&gt;</span>        from item        where code = #&#123;code&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div></li><li><p>在启动类MainApplication加上@MapperScan注解，用于扫描MyBatis动态SQL对应的Mapper接口所在的包。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan</span>(basePackages = <span class="hljs-string">"com.debug.middleware.model"</span>)</code></pre></div></li><li><p>建立对应的控制层Controller与实际业务逻辑处理层Service</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CachePassController</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(CachePassController<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String prefix = <span class="hljs-string">"cache/pass"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义缓存穿透处理服务类</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> CachePassService cachePassService;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取热销商品信息</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@RequestMapping</span>(value = prefix + <span class="hljs-string">"/item/info"</span>, method = RequestMethod.GET)    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">getItem</span><span class="hljs-params">(@RequestParam String itemCode)</span> </span>&#123;        <span class="hljs-comment">//定义接口返回的格式，主要包括code，msg和data</span>        Map&lt;String, Object&gt; resMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        resMap.put(<span class="hljs-string">"code"</span>, <span class="hljs-number">0</span>);        resMap.put(<span class="hljs-string">"msg"</span>, <span class="hljs-string">"成功"</span>);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//调用缓存穿透处理服务类得到返回结果，并将其添加进结果Map中</span>            resMap.put(<span class="hljs-string">"data"</span>, cachePassService.getItemInfo(itemCode));        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            resMap.put(<span class="hljs-string">"code"</span>, -<span class="hljs-number">1</span>);            resMap.put(<span class="hljs-string">"msg"</span>, <span class="hljs-string">"失败"</span> + e.getMessage());        &#125;        <span class="hljs-keyword">return</span> resMap;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CachePassService</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(CachePassService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义Mapper</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ItemMapper itemMapper;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义Redis操作组件RedisTemplate</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义JSON序列化与反序列化框架</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义缓存中key命名的前缀</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String keyPrefix = <span class="hljs-string">"item:"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取商品详情，如果缓存有，则从缓存中取，如果没有，则从数据库中查询，并将查询结果塞入缓存中</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Item <span class="hljs-title">getItemInfo</span><span class="hljs-params">(String itemCode)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//定义商品对象</span>        Item item = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">//定义缓存中真正的key：由前缀和商品编码组成</span>        <span class="hljs-keyword">final</span> String key = keyPrefix + itemCode;        <span class="hljs-comment">//定义Redis的操作组件ValueOperations</span>        ValueOperations valueOperations = redisTemplate.opsForValue();        <span class="hljs-keyword">if</span> (redisTemplate.hasKey(key)) &#123;            log.info(<span class="hljs-string">"---获取商品详情-缓存中存在该商品---商品编号为：&#123;&#125;"</span>, itemCode);            <span class="hljs-comment">//从缓存中查询该商品详情</span>            Object res = valueOperations.get(key);            <span class="hljs-keyword">if</span> (res != <span class="hljs-keyword">null</span> &amp;&amp; !Strings.isNullOrEmpty(res.toString())) &#123;                <span class="hljs-comment">//如果可以找到该商品，则进行JSON反序列化解析</span>                item = objectMapper.readValue(res.toString(), Item<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            &#125;        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//如果缓存中没有找到该商品</span>            log.info(<span class="hljs-string">"---获取商品详情-缓存中不存在该商品-从数据库中查询---商品编号为“&#123;&#125;"</span>, itemCode);            <span class="hljs-comment">//从数据库中获取该商品详情</span>            item = itemMapper.selectByCode(itemCode);            <span class="hljs-keyword">if</span> (item != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//如果数据库中查得到该商品，则将其序列化后写入缓存中</span>                valueOperations.set(key, objectMapper.writeValueAsString(item));            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//过期失效时间TTL设置为30分钟，“ ”很关键</span>                valueOperations.set(key, <span class="hljs-string">" "</span>, <span class="hljs-number">30L</span>, TimeUnit.MINUTES);            &#125;        &#125;        <span class="hljs-keyword">return</span> item;    &#125;&#125;</code></pre></div></li><li><p>运行</p><p>这里出现异常，原因是数据库依赖版本与实际数据库不一致，这里进行如下修改：</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment">#数据库访问配置</span><span class="hljs-comment">#spring.datasource.url=jdbc:mysql://localhost:3306/db_middleware?useUnicode=true&amp;amp;characterEncoding=utf-8</span><span class="hljs-meta">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/db_middleware?useUnicode=true&amp;characterEncoding=utf-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC</span></code></pre></div><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mysql.version</span>&gt;</span>8.0.19<span class="hljs-tag">&lt;/<span class="hljs-name">mysql.version</span>&gt;</span></code></pre></div><p>最终效果：在浏览器中输入<a href="http://localhost:8087/middleware/cache/pass/item/info?itemCode=book_10010，运行窗口第一次打印数据是从数据库中查询得到，第二次是从缓存中获取。" target="_blank" rel="noopener">http://localhost:8087/middleware/cache/pass/item/info?itemCode=book_10010，运行窗口第一次打印数据是从数据库中查询得到，第二次是从缓存中获取。</a></p><div class="hljs"><pre><code class="hljs angelscript">[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-05</span> <span class="hljs-number">11</span>:<span class="hljs-number">19</span>:<span class="hljs-number">15.015</span>] boot -  INFO [http-nio<span class="hljs-number">-8087</span>-exec<span class="hljs-number">-1</span>] ---CachePassService: ---获取商品详情-缓存中不存在该商品-从数据库中查询---商品编号为“book_10010[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-05</span> <span class="hljs-number">11</span>:<span class="hljs-number">19</span>:<span class="hljs-number">23.023</span>] boot -  INFO [http-nio<span class="hljs-number">-8087</span>-exec<span class="hljs-number">-2</span>] ---CachePassService: ---获取商品详情-缓存中存在该商品---商品编号为：book_10010</code></pre></div><p>如果查找一个不存在的商品，第一次会从数据库中查询，后面都是从缓存中查询</p><div class="hljs"><pre><code class="hljs angelscript">[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-05</span> <span class="hljs-number">11</span>:<span class="hljs-number">29</span>:<span class="hljs-number">50.050</span>] boot -  INFO [http-nio<span class="hljs-number">-8087</span>-exec<span class="hljs-number">-1</span>] ---CachePassService: ---获取商品详情-缓存中不存在该商品-从数据库中查询---商品编号为“book_10012[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-05</span> <span class="hljs-number">11</span>:<span class="hljs-number">29</span>:<span class="hljs-number">56.056</span>] boot -  INFO [http-nio<span class="hljs-number">-8087</span>-exec<span class="hljs-number">-2</span>] ---CachePassService: ---获取商品详情-缓存中存在该商品---商品编号为：book_10012[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-05</span> <span class="hljs-number">11</span>:<span class="hljs-number">30</span>:<span class="hljs-number">00.000</span>] boot -  INFO [http-nio<span class="hljs-number">-8087</span>-exec<span class="hljs-number">-3</span>] ---CachePassService: ---获取商品详情-缓存中存在该商品---商品编号为：book_10012</code></pre></div></li></ol><h3 id="其他典型问题介绍"><a href="#其他典型问题介绍" class="headerlink" title="其他典型问题介绍"></a>其他典型问题介绍</h3><p>缓存雪崩：缓存中的Key集体失效，解决办法：为这些Key设置不同的，随机的过期时间</p><p>缓存击穿：热点事件，解决办法：让这个Key永不失效</p><h1 id="第4章：Redis典型应用场景实战之抢红包系统"><a href="#第4章：Redis典型应用场景实战之抢红包系统" class="headerlink" title="第4章：Redis典型应用场景实战之抢红包系统"></a>第4章：Redis典型应用场景实战之抢红包系统</h1><h2 id="4-1-整体业务流程介绍"><a href="#4-1-整体业务流程介绍" class="headerlink" title="4.1 整体业务流程介绍"></a>4.1 整体业务流程介绍</h2><p>系统整体业务流程主要由两大业务组成：发红包和抢红包，其中抢红包可以分为用户点红包和用户拆红包。</p><p>抢红包系统整体业务模块划分：</p><ul><li>发红包模块：主要包括接受并处理用户发红包请求的逻辑处理</li><li>抢红包模块：主要包括用户点红包和拆红包请求的逻辑处理</li><li>数据操作DB模块：主要包括系统整体业务逻辑处理过程中的数据记录</li><li>缓存中间件Redis模块：主要用于缓存红包个数以及红包随机金额</li></ul><h2 id="4-2-数据库表设计与环境搭建"><a href="#4-2-数据库表设计与环境搭建" class="headerlink" title="4.2 数据库表设计与环境搭建"></a>4.2 数据库表设计与环境搭建</h2><h3 id="4-2-1-数据库表设计"><a href="#4-2-1-数据库表设计" class="headerlink" title="4.2.1 数据库表设计"></a>4.2.1 数据库表设计</h3><p>发红包记录表</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`red_record`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`red_record`</span> (  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,  <span class="hljs-string">`user_id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'用户id'</span>,  <span class="hljs-string">`red_packet`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8mb4 <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'红包全局唯一标识串'</span>,  <span class="hljs-string">`total`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'人数'</span>,  <span class="hljs-string">`amount`</span> <span class="hljs-built_in">decimal</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'总金额（单位为分）'</span>,  <span class="hljs-string">`is_active`</span> <span class="hljs-built_in">tinyint</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'1'</span>,  <span class="hljs-string">`create_time`</span> datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">16</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8 <span class="hljs-keyword">COMMENT</span>=<span class="hljs-string">'发红包记录'</span>;</code></pre></div><p>红包随机金额明细表</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`red_detail`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`red_detail`</span> (  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,  <span class="hljs-string">`record_id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'红包记录id'</span>,  <span class="hljs-string">`amount`</span> <span class="hljs-built_in">decimal</span>(<span class="hljs-number">8</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'金额（单位为分）'</span>,  <span class="hljs-string">`is_active`</span> <span class="hljs-built_in">tinyint</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'1'</span>,  <span class="hljs-string">`create_time`</span> datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">133</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8 <span class="hljs-keyword">COMMENT</span>=<span class="hljs-string">'红包明细金额'</span>;</code></pre></div><p>抢红包记录表</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`red_rob_record`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`red_rob_record`</span> (  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,  <span class="hljs-string">`user_id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'用户账号'</span>,  <span class="hljs-string">`red_packet`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8mb4 <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'红包标识串'</span>,  <span class="hljs-string">`amount`</span> <span class="hljs-built_in">decimal</span>(<span class="hljs-number">8</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'红包金额（单位为分）'</span>,  <span class="hljs-string">`rob_time`</span> datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'时间'</span>,  <span class="hljs-string">`is_active`</span> <span class="hljs-built_in">tinyint</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'1'</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">118</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8 <span class="hljs-keyword">COMMENT</span>=<span class="hljs-string">'抢红包记录'</span>;</code></pre></div><h3 id="4-2-2-开发环境搭建"><a href="#4-2-2-开发环境搭建" class="headerlink" title="4.2.2 开发环境搭建"></a>4.2.2 开发环境搭建</h3><p>1、开发三个实体类</p><p>发红包记录实体类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedRecord</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> Integer userId;    <span class="hljs-keyword">private</span> String redPacket;    <span class="hljs-keyword">private</span> Integer total;    <span class="hljs-keyword">private</span> BigDecimal amount;    <span class="hljs-keyword">private</span> Byte isActive;    <span class="hljs-keyword">private</span> Date createTime;&#125;</code></pre></div><p>红包金额明细实体类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedDetail</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> Integer recordId;    <span class="hljs-keyword">private</span> BigDecimal amount;    <span class="hljs-keyword">private</span> Byte isActive;    <span class="hljs-keyword">private</span> Date createTime;&#125;</code></pre></div><p>抢到红包时金额等相关信息记录表</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedRobRecord</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> Integer userId;    <span class="hljs-keyword">private</span> String redPacket;    <span class="hljs-keyword">private</span> BigDecimal amount;    <span class="hljs-keyword">private</span> Date robTime;    <span class="hljs-keyword">private</span> Byte isActive;&#125;</code></pre></div><p>2、开发3个Mapper接口</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RedRecordMapper</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据主键id删除</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteByPrimaryKey</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 插入数据记录</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(RedRecord record)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 插入数据记录</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertSelective</span><span class="hljs-params">(RedRecord record)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据主键id查询记录</span><span class="hljs-comment">     */</span>    <span class="hljs-function">RedRecord <span class="hljs-title">selectByPrimaryKey</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 更新数据记录</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKeySelective</span><span class="hljs-params">(RedRecord record)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 更新数据记录</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKey</span><span class="hljs-params">(RedRecord record)</span></span>;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RedDetailMapper</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteByPrimaryKey</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(RedDetail record)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertSelective</span><span class="hljs-params">(RedDetail record)</span></span>;    <span class="hljs-function">RedDetail <span class="hljs-title">selectByPrimaryKey</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKeySelective</span><span class="hljs-params">(RedDetail record)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKey</span><span class="hljs-params">(RedDetail record)</span></span>;&#125;</code></pre></div><h3 id="4-2-3-开发流程介绍"><a href="#4-2-3-开发流程介绍" class="headerlink" title="4.2.3 开发流程介绍"></a>4.2.3 开发流程介绍</h3><p>发红包：系统后端根据用户输入金额和个数生成对应的红包随机金额列表，并将红包的总个数以及对应的随机金额列表缓存至Redis中，同时将红包的总金额、随机金额列表和红包全局唯一标识串等信息异步记录到相应的数据库中。</p><p>抢红包：先对用户身份进行验证，然后处理用户“点红包”的逻辑，主要是从缓存中获取当前剩余红包个数，如果剩余红包个数大于0，则执行拆红包的逻辑。</p><p>为了保证系统开发了流程的规范性、可扩展性以及接口的健壮性，这里约定了处理用户请求信息后将返回统一的响应格式。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span>  StatusCode &#123;    Success(<span class="hljs-number">0</span>,<span class="hljs-string">"成功"</span>),    Fail(-<span class="hljs-number">1</span>,<span class="hljs-string">"失败"</span>),    InvalidParams(<span class="hljs-number">201</span>,<span class="hljs-string">"非法的参数！"</span>),    InvalidGrantType(<span class="hljs-number">202</span>,<span class="hljs-string">"非法的授权类型"</span>);        <span class="hljs-keyword">private</span> Integer code;    <span class="hljs-keyword">private</span> String msg;    StatusCode(Integer code,String msg)&#123;        <span class="hljs-keyword">this</span>.code = code;        <span class="hljs-keyword">this</span>.msg = msg;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getCode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> code;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCode</span><span class="hljs-params">(Integer code)</span> </span>&#123;        <span class="hljs-keyword">this</span>.code = code;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMsg</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> msg;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMsg</span><span class="hljs-params">(String msg)</span> </span>&#123;        <span class="hljs-keyword">this</span>.msg = msg;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseResponse</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> Integer code;    <span class="hljs-keyword">private</span> String msg;    <span class="hljs-keyword">private</span> T data;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaseResponse</span><span class="hljs-params">(Integer code, String msg)</span> </span>&#123;        <span class="hljs-keyword">this</span>.code = code;        <span class="hljs-keyword">this</span>.msg = msg;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaseResponse</span><span class="hljs-params">(StatusCode statusCode)</span></span>&#123;        <span class="hljs-keyword">this</span>.code = statusCode.getCode();        <span class="hljs-keyword">this</span>.msg = statusCode.getMsg();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaseResponse</span><span class="hljs-params">(Integer code, String msg, T data)</span> </span>&#123;        <span class="hljs-keyword">this</span>.code = code;        <span class="hljs-keyword">this</span>.msg = msg;        <span class="hljs-keyword">this</span>.data = data;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getCode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> code;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCode</span><span class="hljs-params">(Integer code)</span> </span>&#123;        <span class="hljs-keyword">this</span>.code = code;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMsg</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> msg;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMsg</span><span class="hljs-params">(String msg)</span> </span>&#123;        <span class="hljs-keyword">this</span>.msg = msg;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> data;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(T data)</span> </span>&#123;        <span class="hljs-keyword">this</span>.data = data;    &#125;&#125;</code></pre></div><h2 id="4-3-“红包金额”随机生成算法实战"><a href="#4-3-“红包金额”随机生成算法实战" class="headerlink" title="4.3 “红包金额”随机生成算法实战"></a>4.3 “红包金额”随机生成算法实战</h2><p>执行逻辑在于不断地更新总金额M和剩余人数N，并根据M和N组成一个随机区间，并在这个区间内产生一个随机金额，如此不断的进行循环迭代，直至N-1为0，此时剩余的金额即为最后一个随机金额。</p><p>源代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.debug.middleware.server.utils;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: gavin</span><span class="hljs-comment"> * <span class="hljs-doctag">@GitHub</span>: https://github.com/gavin-yyj</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: Created in 14:04 2021/1/6</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 二倍均值法的代码实战-封装成工具类</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedPacketUtil</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发红包算法，金额参数以分为单位</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> totalAmount    红包总金额-单位为分</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> totalPeopleNum 总人数</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title">divideRedPackage</span><span class="hljs-params">(Integer totalAmount, Integer totalPeopleNum)</span> </span>&#123;        <span class="hljs-comment">//用于存储每次产生的小红包随机金额List -金额单位为分</span>        List&lt;Integer&gt; amountList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">//判断总金额和总个数参数的合法性</span>        <span class="hljs-keyword">if</span> (totalAmount &gt; <span class="hljs-number">0</span> &amp;&amp; totalPeopleNum &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//记录剩余的总金额-初始化时即为红包的总金额</span>            Integer restAmount = totalAmount;            <span class="hljs-comment">//记录剩余的总人数-初始化即为指定的总人数</span>            Integer restPeopleNum = totalPeopleNum;            <span class="hljs-comment">//定义产生随机数的实例对象</span>            Random random = <span class="hljs-keyword">new</span> Random();            <span class="hljs-comment">//不断循环遍历，迭代更新地产生随机金额，直到N-1&gt;0</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; totalPeopleNum-<span class="hljs-number">1</span>; i++) &#123;                <span class="hljs-comment">//随机范围：[1，剩余人均金额的两倍),左闭右开-amount即为产生的随机金额R-单位为分</span>                <span class="hljs-keyword">int</span> amount = random.nextInt(restAmount / restPeopleNum * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;                <span class="hljs-comment">//更新剩余的总金额M=M-R</span>                restAmount -= amount;                <span class="hljs-comment">//更新剩余的总人数N=N-1</span>                restPeopleNum--;                <span class="hljs-comment">//将产生的随机金额添加进列表List中</span>                amountList.add(amount);            &#125;            <span class="hljs-comment">//循环完毕，剩余的金额即为最后一个随机金额，也需要将其添加进列表中</span>            amountList.add(restAmount);        &#125;        <span class="hljs-comment">//将最终产生的随机金额列表返回</span>        <span class="hljs-keyword">return</span> amountList;    &#125;&#125;</code></pre></div><p>测试：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">RedPacketTest</span> </span>&#123;    <span class="hljs-comment">//定义日志</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(RedPacketTest<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">//二倍均值法自测方法</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">one</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//总金额单位为分，在这里假设总金额为1000分，即10元</span>        Integer amout = <span class="hljs-number">1000</span>;        <span class="hljs-comment">//总人数即红包总个数，在这里假设为10个</span>        Integer total = <span class="hljs-number">10</span>;        <span class="hljs-comment">//调用二倍均值法工具类产生随机金额列表的方法得到小红包随机金额列表</span>        List&lt;Integer&gt; list = RedPacketUtil.divideRedPackage(amout, total);        log.info(<span class="hljs-string">"总金额=&#123;&#125;分，总人数=&#123;&#125;个"</span>, amout, total);        <span class="hljs-comment">//用于统计生成的随机金额之和是否等于总金额</span>        Integer sum = <span class="hljs-number">0</span>;        <span class="hljs-comment">//遍历输出每个随机金额</span>        <span class="hljs-keyword">for</span> (Integer i : list) &#123;            <span class="hljs-comment">//输出随机金额时包括单位为分和单位为元的信息</span>            log.info(<span class="hljs-string">"随机金额为：&#123;&#125;分，即&#123;&#125;元"</span>, i,<span class="hljs-keyword">new</span> BigDecimal(i.toString()).divide(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>)));            sum += i;        &#125;        log.info(<span class="hljs-string">"所有随机金额叠加之和=&#123;&#125;分"</span>, sum);    &#125;&#125;</code></pre></div><p>效果：（代码有误，因此这里有11份红包，已更正）</p><div class="hljs"><pre><code class="hljs angelscript">[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-25</span> <span class="hljs-number">10</span>:<span class="hljs-number">17</span>:<span class="hljs-number">24.024</span>] boot -  INFO [main] ---RedPacketTest: 总金额=<span class="hljs-number">1000</span>分，总人数=<span class="hljs-number">10</span>个[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-25</span> <span class="hljs-number">10</span>:<span class="hljs-number">17</span>:<span class="hljs-number">24.024</span>] boot -  INFO [main] ---RedPacketTest: 随机金额为：<span class="hljs-number">164</span>分，即<span class="hljs-number">1.64</span>元[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-25</span> <span class="hljs-number">10</span>:<span class="hljs-number">17</span>:<span class="hljs-number">24.024</span>] boot -  INFO [main] ---RedPacketTest: 随机金额为：<span class="hljs-number">23</span>分，即<span class="hljs-number">0.23</span>元[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-25</span> <span class="hljs-number">10</span>:<span class="hljs-number">17</span>:<span class="hljs-number">24.024</span>] boot -  INFO [main] ---RedPacketTest: 随机金额为：<span class="hljs-number">196</span>分，即<span class="hljs-number">1.96</span>元[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-25</span> <span class="hljs-number">10</span>:<span class="hljs-number">17</span>:<span class="hljs-number">24.024</span>] boot -  INFO [main] ---RedPacketTest: 随机金额为：<span class="hljs-number">119</span>分，即<span class="hljs-number">1.19</span>元[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-25</span> <span class="hljs-number">10</span>:<span class="hljs-number">17</span>:<span class="hljs-number">24.024</span>] boot -  INFO [main] ---RedPacketTest: 随机金额为：<span class="hljs-number">49</span>分，即<span class="hljs-number">0.49</span>元[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-25</span> <span class="hljs-number">10</span>:<span class="hljs-number">17</span>:<span class="hljs-number">24.024</span>] boot -  INFO [main] ---RedPacketTest: 随机金额为：<span class="hljs-number">94</span>分，即<span class="hljs-number">0.94</span>元[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-25</span> <span class="hljs-number">10</span>:<span class="hljs-number">17</span>:<span class="hljs-number">24.024</span>] boot -  INFO [main] ---RedPacketTest: 随机金额为：<span class="hljs-number">18</span>分，即<span class="hljs-number">0.18</span>元[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-25</span> <span class="hljs-number">10</span>:<span class="hljs-number">17</span>:<span class="hljs-number">24.024</span>] boot -  INFO [main] ---RedPacketTest: 随机金额为：<span class="hljs-number">186</span>分，即<span class="hljs-number">1.86</span>元[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-25</span> <span class="hljs-number">10</span>:<span class="hljs-number">17</span>:<span class="hljs-number">24.024</span>] boot -  INFO [main] ---RedPacketTest: 随机金额为：<span class="hljs-number">105</span>分，即<span class="hljs-number">1.05</span>元[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-25</span> <span class="hljs-number">10</span>:<span class="hljs-number">17</span>:<span class="hljs-number">24.024</span>] boot -  INFO [main] ---RedPacketTest: 随机金额为：<span class="hljs-number">35</span>分，即<span class="hljs-number">0.35</span>元[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-25</span> <span class="hljs-number">10</span>:<span class="hljs-number">17</span>:<span class="hljs-number">24.024</span>] boot -  INFO [main] ---RedPacketTest: 随机金额为：<span class="hljs-number">11</span>分，即<span class="hljs-number">0.11</span>元[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-25</span> <span class="hljs-number">10</span>:<span class="hljs-number">17</span>:<span class="hljs-number">24.024</span>] boot -  INFO [main] ---RedPacketTest: 所有随机金额叠加之和=<span class="hljs-number">1000</span>分</code></pre></div><h2 id="4-4-“发红包”模块实战"><a href="#4-4-“发红包”模块实战" class="headerlink" title="4.4 “发红包”模块实战"></a>4.4 “发红包”模块实战</h2><p>系统后端接口需要根据红包个数N和总金额M采用二倍均值法拆分成多个随机金额，并生成红包的全局唯一标识串返回给前端，前端用户发起抢红包请求时将带上这个标识串参数，从而实现后续的“点红包”“拆红包”流程。</p><h3 id="4-4-1-业务模块分析"><a href="#4-4-1-业务模块分析" class="headerlink" title="4.4.1 业务模块分析"></a>4.4.1 业务模块分析</h3><p>后端接口在接收到前端用户发红包的请求时，将采用当前的时间戳（纳秒级别）作为红包全局唯一标识串，并将这一标识串返回给前端，后续用户发起“抢红包”的请求时，将会带上这一参数，目的是为了给发出的红包打标记，并根据这一标记去缓存中查询红包个数和随机金额列表等数据。</p><p>在处理“发红包”的请求时，后端接口需要接收红包总金额和总个数等参数，因而将其封装成实体对象RedPacketDto，源代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedPacketDto</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer userId;    <span class="hljs-meta">@NotNull</span>    <span class="hljs-keyword">private</span> Integer total;    <span class="hljs-meta">@NotNull</span>    <span class="hljs-keyword">private</span> Integer amount;&#125;</code></pre></div><p>本系统采用MVCM模式进行开发，最后的M指Middleware（中间件层，即采用中间件辅助处理业务逻辑的服务类）</p><h3 id="4-4-2-整体流程实战"><a href="#4-4-2-整体流程实战" class="headerlink" title="4.4.2 整体流程实战"></a>4.4.2 整体流程实战</h3><p>1、处理发红包请求的RedPacketController，主要用于接收前端用户请求的参数并执行响应的判断处理逻辑，源代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedPacketController</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(RedPacketController<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义请求路径的前缀</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String prefix = <span class="hljs-string">"red/packet"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 注入红包业务逻辑处理接口服务</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> IRedPacketService redPacketService;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发红包请求-请求方法为post，请求参数采用JSON格式进行交互</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@RequestMapping</span>(value = prefix + <span class="hljs-string">"/hand/out"</span>, method = RequestMethod.POST,            consumes = MediaType.APPLICATION_JSON_UTF8_VALUE)    <span class="hljs-function"><span class="hljs-keyword">public</span> BaseResponse <span class="hljs-title">handOut</span><span class="hljs-params">(@Validated @RequestBody RedPacketDto dto, BindingResult result)</span> </span>&#123;        <span class="hljs-comment">//参数校验</span>        <span class="hljs-keyword">if</span> (result.hasErrors()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BaseResponse(StatusCode.InvalidParams);        &#125;        BaseResponse response = <span class="hljs-keyword">new</span> BaseResponse(StatusCode.Success);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//核心业务逻辑处理服务-最终返回红包全局唯一标识串</span>            String redId = redPacketService.handOut(dto);            <span class="hljs-comment">//将红包全局唯一标识串返回给前端</span>            response.setData(redId);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-comment">//如果报异常则打印日志并返回相应的错误信息</span>            log.error(<span class="hljs-string">"发红包发生异常：dto=&#123;&#125;"</span>, dto, e.fillInStackTrace());            response = <span class="hljs-keyword">new</span> BaseResponse(StatusCode.Fail.getCode(), e.getMessage());        &#125;        <span class="hljs-keyword">return</span> response;    &#125;&#125;</code></pre></div><p>2、IRedPacketService为红包业务逻辑处理接口，主要包括对“发红包”与“抢红包”逻辑的处理，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IRedPacketService</span> </span>&#123;    <span class="hljs-comment">/**发红包核心业务逻辑的实现*/</span>    <span class="hljs-function">String <span class="hljs-title">handOut</span><span class="hljs-params">(RedPacketDto dto)</span></span>;    <span class="hljs-comment">/**抢红包*/</span>    <span class="hljs-function">BigDecimal <span class="hljs-title">rob</span><span class="hljs-params">(Integer userId,String redId)</span></span>;&#125;</code></pre></div><p>IRedPacketService的实现类RedPacketService主要用于处理真正的业务逻辑，源代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedPacketService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IRedPacketService</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(RedPacketService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 存储至缓存系统Redis时定义的Key前缀</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String keyPrefix = <span class="hljs-string">"redis:red:packet:"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义Redis操作Bean组件</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 自动注入红包业务逻辑处理过程数据记录接口服务</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> IRedService redService;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发红包</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handOut</span><span class="hljs-params">(RedPacketDto dto)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//判断参数的合法性</span>        <span class="hljs-keyword">if</span> (dto.getTotal() &gt; <span class="hljs-number">0</span> &amp;&amp; dto.getAmount() &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//采用二倍均值法生成随机金额列表，在上一节已经采用代码实现了二倍均值法</span>            List&lt;Integer&gt; list = RedPacketUtil.divideRedPackage(dto.getAmount(), dto.getTotal());            <span class="hljs-comment">//生成红包全局唯一标识串</span>            String timestamp = String.valueOf(System.nanoTime());            <span class="hljs-comment">//根据缓存key的前缀与其他信息拼接成一个新的用于存储随机金额列表的Key</span>            String redId = <span class="hljs-keyword">new</span> StringBuffer(keyPrefix).append(dto.getUserId()).append(<span class="hljs-string">":"</span>).append(timestamp).toString();            <span class="hljs-comment">//将随机金额列表存入缓存List中</span>            redisTemplate.opsForList().leftPushAll(redId, list);            <span class="hljs-comment">//根据缓存Key的前缀与其他信息拼接成一个新的用于存储红包总数的Key</span>            String redTotalKey = redId + <span class="hljs-string">":total"</span>;            <span class="hljs-comment">//将红包总数存入缓存中</span>            redisTemplate.opsForValue().set(redTotalKey, dto.getTotal());            <span class="hljs-comment">//异步记录红包的全局唯一标识串，红包个数与随机金额列表信息至数据库中</span>            redService.recordRedPacket(dto, redId, list);            <span class="hljs-comment">//将红包的全局唯一标识串返回给前端</span>            <span class="hljs-keyword">return</span> redId;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"系统异常-分发红包-参数不合法！"</span>);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 抢红包处理逻辑</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">rob</span><span class="hljs-params">(Integer userId, String redId)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div><p>3、“红包业务逻辑处理过程数据记录接口”服务IRedService，主要用于将发红包时红包的相关信息与抢红包时用户抢到的红包金额等信息记入数据库中，源代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IRedService</span> </span>&#123;    <span class="hljs-comment">/**记录发红包时的全局唯一标识串，随机金额列表和个数等信息入数据库*/</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recordRedPacket</span><span class="hljs-params">(RedPacketDto dto, String redId, List&lt;Integer&gt; list)</span></span>;        <span class="hljs-comment">/**记录抢红包时用户抢到的红包金额等信息入数据库*/</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recordRobRedPacket</span><span class="hljs-params">(Integer userId, String redId, BigDecimal amount)</span></span>;&#125;</code></pre></div><p>实现类RedService源代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-meta">@EnableAsync</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IRedService</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(RedService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/**发红包时红包全局唯一标识串等信息操作接口Mapper*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedRecordMapper redRecordMapper;    <span class="hljs-comment">/**发红包时随机数算法生成的随机金额列表等信息操作接口Mapper*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedDetailMapper redDetailMapper;    <span class="hljs-comment">/**抢红包时相关数据信息操作接口Mapper*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedRobRecordMapper redRobRecordMapper;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发红包记录-异步方式</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dto 红包总金额+个数</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> redId 红包全局唯一标识串</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> list 红包随机金额列表</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@Async</span>    <span class="hljs-meta">@Transactional</span>(rollbackFor = Exception<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">recordRedPacket</span>(<span class="hljs-title">RedPacketDto</span> <span class="hljs-title">dto</span>, <span class="hljs-title">String</span> <span class="hljs-title">redId</span>, <span class="hljs-title">List</span>&lt;<span class="hljs-title">Integer</span>&gt; <span class="hljs-title">list</span>) </span>&#123;        <span class="hljs-comment">//定义实体类对象</span>        RedRecord redRecord = <span class="hljs-keyword">new</span> RedRecord();        <span class="hljs-comment">//设置字段的取值信息</span>        redRecord.setUserId(dto.getUserId());        redRecord.setRedPacket(redId);        redRecord.setTotal(dto.getTotal());        redRecord.setAmount(BigDecimal.valueOf(dto.getAmount()));        redRecord.setCreateTime(<span class="hljs-keyword">new</span> Date());        <span class="hljs-comment">//将对象信息插入数据库</span>        redRecordMapper.insertSelective(redRecord);        <span class="hljs-comment">//定义红包随机金额明细实体类对象</span>        RedDetail detail;        <span class="hljs-comment">//遍历随机金额列表，将金额等信息设置到相应的字段中</span>        <span class="hljs-keyword">for</span> (Integer i : list) &#123;            detail = <span class="hljs-keyword">new</span> RedDetail();            detail.setRecordId(redRecord.getId());            detail.setAmount(BigDecimal.valueOf(i));            detail.setCreateTime(<span class="hljs-keyword">new</span> Date());            <span class="hljs-comment">//将对象信息插入数据库</span>            redDetailMapper.insertSelective(detail);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 抢红包记录</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userId</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> redId</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> amount</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recordRobRedPacket</span><span class="hljs-params">(Integer userId, String redId, BigDecimal amount)</span> </span>&#123;        &#125;&#125;</code></pre></div><h3 id="4-4-3-业务模块自测"><a href="#4-4-3-业务模块自测" class="headerlink" title="4.4.3 业务模块自测"></a>4.4.3 业务模块自测</h3><p>使用Postman工具测试抢红包系统发红包业务的整体流程，打开Postman，在地址栏中输入“发红包”请求对应的链接，即<a href="http://127.0.0.1:8087/middleware/red/packet/hand/out，选择请求方式Post，并在请求体中输入请求参数，如下：" target="_blank" rel="noopener">http://127.0.0.1:8087/middleware/red/packet/hand/out，选择请求方式Post，并在请求体中输入请求参数，如下：</a></p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"userId"</span>:<span class="hljs-number">10010</span>,    <span class="hljs-attr">"total"</span>:<span class="hljs-number">10</span>,    <span class="hljs-attr">"amount"</span>:<span class="hljs-number">1000</span>&#125;</code></pre></div><h2 id="4-5-“抢红包”模块实战"><a href="#4-5-“抢红包”模块实战" class="headerlink" title="4.5 “抢红包”模块实战"></a>4.5 “抢红包”模块实战</h2><h3 id="4-5-1-业务模块分析"><a href="#4-5-1-业务模块分析" class="headerlink" title="4.5.1 业务模块分析"></a>4.5.1 业务模块分析</h3><ul><li>业务角度：点红包+拆红包</li><li>系统架构：低耦合和服务的高内聚</li><li>技术角度：抢红包业务模块对应的后端接口需要频繁访问缓存系统Redis，用于获取红包剩余个数和随机金额列表，进而判断用户点红包、拆红包是否成功。用户每次成功抢到红包之后，后端进行数据更新，并将相应的信息记入数据库中。</li></ul><p>前端用户发起抢红包请求，需要带上红包全局唯一标识串resId和当前用户账户Id到系统后端接口。</p><h3 id="4-5-2-整体流程"><a href="#4-5-2-整体流程" class="headerlink" title="4.5.2 整体流程"></a>4.5.2 整体流程</h3><p>在RedPacketController类中添加一个处理抢红包请求的方法，源代码:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 处理抢红包请求；接受当前用户账号id和红包全局唯一标识串参数</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@RequestMapping</span>(value = prefix+<span class="hljs-string">"/rob"</span>,method = RequestMethod.GET)    <span class="hljs-function"><span class="hljs-keyword">public</span> BaseResponse <span class="hljs-title">rob</span><span class="hljs-params">(@RequestParam Integer userId,@RequestParam String redId)</span></span>&#123;        <span class="hljs-comment">//定义响应对象</span>        BaseResponse response = <span class="hljs-keyword">new</span> BaseResponse(StatusCode.Success);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//调用红包业务逻辑处理接口中的抢红包方法，最终返回抢到的红包金额，单位为元（Null表示抢完了）</span>            BigDecimal result = redPacketService.rob(userId, redId);            <span class="hljs-keyword">if</span>(result != <span class="hljs-keyword">null</span>)&#123;                <span class="hljs-comment">//将抢到的红包金额返回到前端</span>                response.setData(result);            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-comment">//没有抢到红包，即已经被抢完了</span>                response = <span class="hljs-keyword">new</span> BaseResponse(StatusCode.Fail.getCode(),<span class="hljs-string">"红包已被抢完！"</span>);            &#125;        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            <span class="hljs-comment">//处理过程发生异常，则打印异常信息并返回给前端</span>            log.error(<span class="hljs-string">"抢红包发生异常：userId=&#123;&#125; redId=&#123;&#125;"</span>,userId,redId,e.fillInStackTrace());            response = <span class="hljs-keyword">new</span> BaseResponse(StatusCode.Fail.getCode(),e.getMessage());        &#125;        <span class="hljs-comment">//返回处理结果给前端</span>        <span class="hljs-keyword">return</span> response;    &#125;</code></pre></div><p>抢红包方法rob()：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 抢红包实际业务逻辑处理</span><span class="hljs-comment">    * <span class="hljs-doctag">@param </span>userId 当前用户id-抢红包者</span><span class="hljs-comment">    * <span class="hljs-doctag">@param </span>redId 红包全局唯一标识串</span><span class="hljs-comment">    * <span class="hljs-doctag">@return </span>返回抢到的红包金额或者抢不到红包金额的Null</span><span class="hljs-comment">    */</span>   @Override   public BigDecimal rob(Integer userId, <span class="hljs-built_in">String</span> redId) throws Exception &#123;       <span class="hljs-comment">//定义Redis操作组件的值操作方法</span>       ValueOperations valueOperations = redisTemplate.opsForValue();       <span class="hljs-comment">//在处理用户抢红包之前，需要先判断一下当前用户是否已经抢过该红包</span>       <span class="hljs-comment">//如果抢过，则直接返回红包金额，并在前端显示出来</span>       <span class="hljs-built_in">Object</span> obj = valueOperations.get(redId + userId + <span class="hljs-string">":rob"</span>);       <span class="hljs-keyword">if</span>(obj!=<span class="hljs-literal">null</span>)&#123;           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BigDecimal(obj.toString());       &#125;       <span class="hljs-comment">//"点红包"业务逻辑-主要用于判断缓存系统中是否仍然有红包，即剩余红包个数是否大于0</span>       <span class="hljs-built_in">Boolean</span> res = click(redId);       <span class="hljs-keyword">if</span>(res)&#123;           <span class="hljs-comment">//res为true，则可以进入“拆红包”业务逻辑的处理，从小红包随机金额列表中弹出一个随机金额</span>           <span class="hljs-built_in">Object</span> value = redisTemplate.opsForList().rightPop(redId);           <span class="hljs-keyword">if</span>(value != <span class="hljs-literal">null</span>)&#123;               <span class="hljs-comment">//当前用户抢到一个红包，则进入后续的更新缓存，并将信息记入数据库</span>               <span class="hljs-built_in">String</span> redTotalKey = redId + <span class="hljs-string">":total"</span>;               <span class="hljs-comment">//更新缓存系统中剩余的红包个数，即红包个数减1</span>               Integer currTotal = valueOperations.get(redTotalKey)!=<span class="hljs-literal">null</span>?                       (Integer)valueOperations.get(redTotalKey):<span class="hljs-number">0</span>;               <span class="hljs-comment">//将红包金额返回给用户前，这里金额的单位设置为“元”</span>               <span class="hljs-comment">//如果你不想设置，则可以直接返回value，但是前端需要作除以100的操作</span>               BigDecimal result = <span class="hljs-keyword">new</span> BigDecimal(value.toString()).divide(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>));               <span class="hljs-comment">//将抢到红包时用户的账号信息以及抢到的金额等信息记入数据库</span>               redService.recordRobRedPacket(userId,redId,<span class="hljs-keyword">new</span> BigDecimal(value.toString()));               <span class="hljs-comment">//将当前抢到红包的用户设置进缓存系统中，用于表示当前用户已经抢过红包了</span>               valueOperations.set(redId+userId+<span class="hljs-string">":rob"</span>,result,<span class="hljs-number">24</span>L, TimeUnit.HOURS);               <span class="hljs-comment">//打印当前用户抢到红包的记录信息</span>               log.info(<span class="hljs-string">"当前用户抢到红包了：userId=&#123;&#125; key=&#123;&#125; 金额=&#123;&#125;"</span>,userId,redId,result);               <span class="hljs-keyword">return</span> result;           &#125;           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;       &#125;   &#125;   private <span class="hljs-built_in">Boolean</span> click(<span class="hljs-built_in">String</span> redId) &#123;       <span class="hljs-comment">//定义Redis的Bean操作组件-值操作组件</span>       ValueOperations valueOperations = redisTemplate.opsForValue();       <span class="hljs-comment">//定义用于查询缓存系统中红包剩余个数的Key</span>       <span class="hljs-comment">//这在发红包业务模块中已经指定过了</span>       <span class="hljs-built_in">String</span> redTotalKey = redId + <span class="hljs-string">":total"</span>;       <span class="hljs-comment">//获取缓存系统Redis中农红包剩余个数</span>       <span class="hljs-built_in">Object</span> total = valueOperations.get(redTotalKey);       <span class="hljs-comment">//判断红包剩余个数total是否大于0，如果大于0，则返回true，代表还有红包</span>       <span class="hljs-keyword">if</span>(total!=<span class="hljs-literal">null</span> &amp;&amp; Integer.valueOf(total.toString())&gt;<span class="hljs-number">0</span>)&#123;           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;       &#125;       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   &#125;</code></pre></div><p>去缓存系统中查询红包剩余个数Total和随机金额列表时需要提供Key，这些Key 是在“发红包”业务模块代码中定义的。</p><p>3、当用户抢到红包后，需要将当前用户的账号信息及抢到的金额等信息记入数据库中，这一实现逻辑是通过调用redService实现类的recordRobRedPacket（）方法实现的，源代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 抢红包记录</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> userId</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> redId</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> amount</span><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">    */</span>   <span class="hljs-meta">@Override</span>   <span class="hljs-meta">@Async</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recordRobRedPacket</span><span class="hljs-params">(Integer userId, String redId, BigDecimal amount)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;       RedRobRecord redRobRecord=<span class="hljs-keyword">new</span> RedRobRecord();       redRobRecord.setUserId(userId);       redRobRecord.setRedPacket(redId);       redRobRecord.setAmount(amount);       redRobRecord.setRobTime(<span class="hljs-keyword">new</span> Date());       <span class="hljs-comment">//将实体对象信息插入数据库中</span>       redRobRecordMapper.insertSelective(redRobRecord);   &#125;</code></pre></div><h3 id="4-5-3-业务模块自测"><a href="#4-5-3-业务模块自测" class="headerlink" title="4.5.3 业务模块自测"></a>4.5.3 业务模块自测</h3><p>以“发红包”业务模块自测中发出的红包作为测试数据，redId取值为redis:red:packet:10010:371054244610400</p><p>1、打开Postman，在地址栏中输入<a href="http://127.0.0.1:8087/middleware/red/packet/rob?userId=10010&amp;redId=redis:red:packet:10010:371054244610400，查看控制台输出结果" target="_blank" rel="noopener">http://127.0.0.1:8087/middleware/red/packet/rob?userId=10010&amp;redId=redis:red:packet:10010:371054244610400，查看控制台输出结果</a></p><div class="hljs"><pre><code class="hljs angelscript">[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-26</span> <span class="hljs-number">19</span>:<span class="hljs-number">35</span>:<span class="hljs-number">06.006</span>] boot -  INFO [http-nio<span class="hljs-number">-8087</span>-exec<span class="hljs-number">-1</span>] ---RedPacketService: 当前用户抢到红包了：userId=<span class="hljs-number">10010</span> key=redis:red:packet:<span class="hljs-number">10010</span>:<span class="hljs-number">371054244610400</span> 金额=<span class="hljs-number">0.76</span></code></pre></div><p>2、对同一个链接进行多次发送，系统并不会处理该请求</p><h2 id="4-6-Jmeter压力测试高并发抢红包"><a href="#4-6-Jmeter压力测试高并发抢红包" class="headerlink" title="4.6 Jmeter压力测试高并发抢红包"></a>4.6 Jmeter压力测试高并发抢红包</h2><p>Apache Jmeter是基于Java的压力测试工具，能够模拟实际生产环境中高并发产生的巨大负载，从而对应用服务器，网络或对象整体性能进行测试，并对产生的测试结果进行分析和反馈。</p><p>下载测试工具包：<a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">http://jmeter.apache.org/download_jmeter.cgi</a></p><p>找到bin文件目录，然后双击jmeter.sh文件</p><p>右击“文件”选项，新建一个测试计划，然后在该测试计划下新建线程组，最后在线程组下新建“HTTP请求””CSV数据文件设置”“查看结果树”</p><p>打开Postman，发起发红包请求，参数如下：</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"userId"</span>:<span class="hljs-number">10030</span>,    <span class="hljs-attr">"total"</span>:<span class="hljs-number">10</span>,    <span class="hljs-attr">"amount"</span>:<span class="hljs-number">500</span>&#125;</code></pre></div><p>抢红包请求设置如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530101300.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>用户抢红包账号等设置如下：共有10030~10035六个用户</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530101312.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>运行后查看结果树：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530102015.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>运行栏数据：</p><div class="hljs"><pre><code class="hljs angelscript">[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-27</span> <span class="hljs-number">09</span>:<span class="hljs-number">45</span>:<span class="hljs-number">43.043</span>] boot -  INFO [http-nio<span class="hljs-number">-8087</span>-exec<span class="hljs-number">-90</span>] ---RedPacketService: 当前用户抢到红包了：userId=<span class="hljs-number">10031</span> key=redis:red:packet:<span class="hljs-number">10030</span>:<span class="hljs-number">426373717637600</span> 金额=<span class="hljs-number">0.28</span>[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-27</span> <span class="hljs-number">09</span>:<span class="hljs-number">45</span>:<span class="hljs-number">43.043</span>] boot -  INFO [http-nio<span class="hljs-number">-8087</span>-exec<span class="hljs-number">-212</span>] ---RedPacketService: 当前用户抢到红包了：userId=<span class="hljs-number">10031</span> key=redis:red:packet:<span class="hljs-number">10030</span>:<span class="hljs-number">426373717637600</span> 金额=<span class="hljs-number">0.57</span>[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-27</span> <span class="hljs-number">09</span>:<span class="hljs-number">45</span>:<span class="hljs-number">43.043</span>] boot -  INFO [http-nio<span class="hljs-number">-8087</span>-exec<span class="hljs-number">-33</span>] ---RedPacketService: 当前用户抢到红包了：userId=<span class="hljs-number">10030</span> key=redis:red:packet:<span class="hljs-number">10030</span>:<span class="hljs-number">426373717637600</span> 金额=<span class="hljs-number">0.79</span>[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-27</span> <span class="hljs-number">09</span>:<span class="hljs-number">45</span>:<span class="hljs-number">43.043</span>] boot -  INFO [http-nio<span class="hljs-number">-8087</span>-exec<span class="hljs-number">-74</span>] ---RedPacketService: 当前用户抢到红包了：userId=<span class="hljs-number">10033</span> key=redis:red:packet:<span class="hljs-number">10030</span>:<span class="hljs-number">426373717637600</span> 金额=<span class="hljs-number">0.82</span>[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-27</span> <span class="hljs-number">09</span>:<span class="hljs-number">45</span>:<span class="hljs-number">43.043</span>] boot -  INFO [http-nio<span class="hljs-number">-8087</span>-exec<span class="hljs-number">-223</span>] ---RedPacketService: 当前用户抢到红包了：userId=<span class="hljs-number">10035</span> key=redis:red:packet:<span class="hljs-number">10030</span>:<span class="hljs-number">426373717637600</span> 金额=<span class="hljs-number">0.54</span>[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-27</span> <span class="hljs-number">09</span>:<span class="hljs-number">45</span>:<span class="hljs-number">43.043</span>] boot -  INFO [http-nio<span class="hljs-number">-8087</span>-exec<span class="hljs-number">-204</span>] ---RedPacketService: 当前用户抢到红包了：userId=<span class="hljs-number">10035</span> key=redis:red:packet:<span class="hljs-number">10030</span>:<span class="hljs-number">426373717637600</span> 金额=<span class="hljs-number">0.44</span>[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-27</span> <span class="hljs-number">09</span>:<span class="hljs-number">45</span>:<span class="hljs-number">43.043</span>] boot -  INFO [http-nio<span class="hljs-number">-8087</span>-exec<span class="hljs-number">-210</span>] ---RedPacketService: 当前用户抢到红包了：userId=<span class="hljs-number">10030</span> key=redis:red:packet:<span class="hljs-number">10030</span>:<span class="hljs-number">426373717637600</span> 金额=<span class="hljs-number">0.08</span>[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-27</span> <span class="hljs-number">09</span>:<span class="hljs-number">45</span>:<span class="hljs-number">43.043</span>] boot -  INFO [http-nio<span class="hljs-number">-8087</span>-exec<span class="hljs-number">-215</span>] ---RedPacketService: 当前用户抢到红包了：userId=<span class="hljs-number">10031</span> key=redis:red:packet:<span class="hljs-number">10030</span>:<span class="hljs-number">426373717637600</span> 金额=<span class="hljs-number">0.02</span>[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-27</span> <span class="hljs-number">09</span>:<span class="hljs-number">45</span>:<span class="hljs-number">43.043</span>] boot -  INFO [http-nio<span class="hljs-number">-8087</span>-exec<span class="hljs-number">-195</span>] ---RedPacketService: 当前用户抢到红包了：userId=<span class="hljs-number">10032</span> key=redis:red:packet:<span class="hljs-number">10030</span>:<span class="hljs-number">426373717637600</span> 金额=<span class="hljs-number">0.67</span>[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-27</span> <span class="hljs-number">09</span>:<span class="hljs-number">45</span>:<span class="hljs-number">43.043</span>] boot -  INFO [http-nio<span class="hljs-number">-8087</span>-exec<span class="hljs-number">-211</span>] ---RedPacketService: 当前用户抢到红包了：userId=<span class="hljs-number">10033</span> key=redis:red:packet:<span class="hljs-number">10030</span>:<span class="hljs-number">426373717637600</span> 金额=<span class="hljs-number">0.79</span></code></pre></div><p>异常现象：有用户抢到多个红包！！！</p><h2 id="4-7-问题分析与优化方案"><a href="#4-7-问题分析与优化方案" class="headerlink" title="4.7 问题分析与优化方案"></a>4.7 问题分析与优化方案</h2><p>问题所在：同一时刻多个并发的线程对共享资源进行了访问操作。</p><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><p>传统方案：在核心业务逻辑代码中加锁操作（Synchronized）。在分布式系统架构下的服务一般部署在不同的节点（服务器）下，从而当出现高并发请求时，Synchronized无法解决。</p><p>主流方案：分布式锁</p><h3 id="Redis分布式锁实战"><a href="#Redis分布式锁实战" class="headerlink" title="Redis分布式锁实战"></a>Redis分布式锁实战</h3><p>通过Redis的院子操作selfAbsent()方法对该业务逻辑加分布式锁，表示“如果当前的Key不存在于缓存中，则设置其对应的Value，该方法的操作结果返回true；如果当前的Key已经存在于缓存中，则设置其对应的Value失败，即该方法的操作结果将返回false，由于该方法具备原子性，故当多个并发的线程同一时刻调用该方法时Redis的底层会将线程加入”队列“排队处理。</p><p>改造后的rob()方法如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">rob</span><span class="hljs-params">(Integer userId, String redId)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//定义Redis操作组件的值操作方法</span>        ValueOperations valueOperations = redisTemplate.opsForValue();        <span class="hljs-comment">//在处理用户抢红包之前，需要先判断一下当前用户是否已经抢过该红包</span>        <span class="hljs-comment">//如果抢过，则直接返回红包金额，并在前端显示出来</span>        Object obj = valueOperations.get(redId + userId + <span class="hljs-string">":rob"</span>);        <span class="hljs-keyword">if</span>(obj!=<span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BigDecimal(obj.toString());        &#125;        <span class="hljs-comment">//"点红包"业务逻辑-主要用于判断缓存系统中是否仍然有红包，即剩余红包个数是否大于0</span>        Boolean res = click(redId);        <span class="hljs-keyword">if</span>(res)&#123;            <span class="hljs-comment">//上分布式锁，一个红包每个人只能抢到一次随机金额，即要永远保证一对一的关系</span>            <span class="hljs-comment">//构造缓存中的key</span>            <span class="hljs-keyword">final</span> String lockKey = redId + userId + <span class="hljs-string">"-lock"</span>;            <span class="hljs-comment">//调用setIfAbsent()方法，其实就是间接实现了分布式锁</span>            Boolean lock = valueOperations.setIfAbsent(lockKey, redId);            <span class="hljs-comment">//设定该分布式锁的过期时间为24小时</span>            redisTemplate.expire(lockKey,<span class="hljs-number">24L</span>,TimeUnit.HOURS);            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//表示当前线程获取到了该分布式锁</span>                <span class="hljs-keyword">if</span>(lock)&#123;</code></pre></div><p>效果：</p><div class="hljs"><pre><code class="hljs angelscript">[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-27</span> <span class="hljs-number">10</span>:<span class="hljs-number">50</span>:<span class="hljs-number">30.030</span>] boot -  INFO [http-nio<span class="hljs-number">-8087</span>-exec<span class="hljs-number">-10</span>] ---RedPacketService: 当前用户抢到红包了：userId=<span class="hljs-number">10033</span> key=redis:red:packet:<span class="hljs-number">10050</span>:<span class="hljs-number">430694037472700</span> 金额=<span class="hljs-number">1.71</span>[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-27</span> <span class="hljs-number">10</span>:<span class="hljs-number">50</span>:<span class="hljs-number">30.030</span>] boot -  INFO [http-nio<span class="hljs-number">-8087</span>-exec<span class="hljs-number">-2</span>] ---RedPacketService: 当前用户抢到红包了：userId=<span class="hljs-number">10034</span> key=redis:red:packet:<span class="hljs-number">10050</span>:<span class="hljs-number">430694037472700</span> 金额=<span class="hljs-number">0.03</span>[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-27</span> <span class="hljs-number">10</span>:<span class="hljs-number">50</span>:<span class="hljs-number">30.030</span>] boot -  INFO [http-nio<span class="hljs-number">-8087</span>-exec<span class="hljs-number">-7</span>] ---RedPacketService: 当前用户抢到红包了：userId=<span class="hljs-number">10030</span> key=redis:red:packet:<span class="hljs-number">10050</span>:<span class="hljs-number">430694037472700</span> 金额=<span class="hljs-number">0.67</span>[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-27</span> <span class="hljs-number">10</span>:<span class="hljs-number">50</span>:<span class="hljs-number">30.030</span>] boot -  INFO [http-nio<span class="hljs-number">-8087</span>-exec<span class="hljs-number">-5</span>] ---RedPacketService: 当前用户抢到红包了：userId=<span class="hljs-number">10032</span> key=redis:red:packet:<span class="hljs-number">10050</span>:<span class="hljs-number">430694037472700</span> 金额=<span class="hljs-number">1.29</span>[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-27</span> <span class="hljs-number">10</span>:<span class="hljs-number">50</span>:<span class="hljs-number">30.030</span>] boot -  INFO [http-nio<span class="hljs-number">-8087</span>-exec<span class="hljs-number">-6</span>] ---RedPacketService: 当前用户抢到红包了：userId=<span class="hljs-number">10035</span> key=redis:red:packet:<span class="hljs-number">10050</span>:<span class="hljs-number">430694037472700</span> 金额=<span class="hljs-number">0.55</span>[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-27</span> <span class="hljs-number">10</span>:<span class="hljs-number">50</span>:<span class="hljs-number">30.030</span>] boot -  INFO [http-nio<span class="hljs-number">-8087</span>-exec<span class="hljs-number">-9</span>] ---RedPacketService: 当前用户抢到红包了：userId=<span class="hljs-number">10031</span> key=redis:red:packet:<span class="hljs-number">10050</span>:<span class="hljs-number">430694037472700</span> 金额=<span class="hljs-number">1.46</span></code></pre></div><h1 id="第5章-消息中间件RabbitMQ"><a href="#第5章-消息中间件RabbitMQ" class="headerlink" title="第5章 消息中间件RabbitMQ"></a>第5章 消息中间件RabbitMQ</h1><p>问题：传统应用在系统接口和服务处理模块层面仍然沿用“高耦合”和“同步”的处理方式，导致接口由于线程阻塞而延长了整体响应时间，即所谓的“高延迟”。</p><h2 id="5-1-RabbitMQ简介"><a href="#5-1-RabbitMQ简介" class="headerlink" title="5.1 RabbitMQ简介"></a>5.1 RabbitMQ简介</h2><p>RabbitMQ的作用：异步通信、服务解耦、接口限流、消息分发、延迟处理</p><h3 id="5-1-3-RabbitMQ后端控制台介绍"><a href="#5-1-3-RabbitMQ后端控制台介绍" class="headerlink" title="5.1.3 RabbitMQ后端控制台介绍"></a>5.1.3 RabbitMQ后端控制台介绍</h3><p>安装Erlang以及去官网下载RabbitMQ安装包，安装完成后在浏览器中输入<a href="http://127.0.0.1:15672" target="_blank" rel="noopener">http://127.0.0.1:15672</a></p><h3 id="5-1-4-基于Spring的事件驱动模型实战"><a href="#5-1-4-基于Spring的事件驱动模型实战" class="headerlink" title="5.1.4 基于Spring的事件驱动模型实战"></a>5.1.4 基于Spring的事件驱动模型实战</h3><p>Spring事件驱动模型主要由3部分组成，包括发送消息的生产者、消息（或事件）和监听消息的消费者</p><p>用户登录成功后的事件实体类LoginEvent</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApplicationEvent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> String userName;    <span class="hljs-keyword">private</span> String loginTime;    <span class="hljs-keyword">private</span> String ip;    <span class="hljs-comment">/**构造方法一*/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoginEvent</span><span class="hljs-params">(Object source)</span> </span>&#123;        <span class="hljs-keyword">super</span>(source);    &#125;    <span class="hljs-comment">/**构造方法二*/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoginEvent</span><span class="hljs-params">(Object source,String userName,String loginTime,String ip)</span> </span>&#123;        <span class="hljs-keyword">super</span>(source);        <span class="hljs-keyword">this</span>.userName = userName;        <span class="hljs-keyword">this</span>.loginTime = loginTime;        <span class="hljs-keyword">this</span>.ip = ip;    &#125;&#125;</code></pre></div><p>开发监听消息的消费者Consumer类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@EnableAsync</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">LoginEvent</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(Consumer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 监听消费信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> loginEvent</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@Async</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(LoginEvent loginEvent)</span> </span>&#123;        <span class="hljs-comment">//打印日志信息</span>        log.info(<span class="hljs-string">"Spring事件驱动模型-接收消息：&#123;&#125;"</span>,loginEvent);    &#125;&#125;</code></pre></div><p>用于发送消息或产生事件的生产者Producter</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Publisher</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(Publisher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ApplicationEventPublisher publisher;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发送消息的方法</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//构造登录成功后用户的实体信息</span>        LoginEvent event = <span class="hljs-keyword">new</span> LoginEvent(<span class="hljs-keyword">this</span>, <span class="hljs-string">"debug"</span>, <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>).format(<span class="hljs-keyword">new</span> Date()), <span class="hljs-string">"127.0.0.1"</span>);        <span class="hljs-comment">//发送消息</span>        publisher.publishEvent(event);        log.info(<span class="hljs-string">"Spring事件驱动模型-发送消息：&#123;&#125;"</span>, event);    &#125;&#125;</code></pre></div><p>测试类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">SpringBootTest</span></span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">EventTest</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Publisher publisher;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;        publisher.sendMsg();    &#125;&#125;</code></pre></div><p>效果：</p><div class="hljs"><pre><code class="hljs angelscript">[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-28</span> <span class="hljs-number">16</span>:<span class="hljs-number">33</span>:<span class="hljs-number">32.032</span>] boot -  INFO [SimpleAsyncTaskExecutor<span class="hljs-number">-1</span>] ---Consumer: Spring事件驱动模型-接收消息：LoginEvent(userName=debug, loginTime=<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-28</span> <span class="hljs-number">16</span>:<span class="hljs-number">33</span>:<span class="hljs-number">32</span>, ip=<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>)[<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-28</span> <span class="hljs-number">16</span>:<span class="hljs-number">33</span>:<span class="hljs-number">32.032</span>] boot -  INFO [main] ---Publisher: Spring事件驱动模型-发送消息：LoginEvent(userName=debug, loginTime=<span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-28</span> <span class="hljs-number">16</span>:<span class="hljs-number">33</span>:<span class="hljs-number">32</span>, ip=<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>)</code></pre></div><h2 id="5-2-SpringBoot项目整合RabbitMQ"><a href="#5-2-SpringBoot项目整合RabbitMQ" class="headerlink" title="5.2 SpringBoot项目整合RabbitMQ"></a>5.2 SpringBoot项目整合RabbitMQ</h2><h3 id="5-2-1-RabbitMQ相关词汇介绍"><a href="#5-2-1-RabbitMQ相关词汇介绍" class="headerlink" title="5.2.1 RabbitMQ相关词汇介绍"></a>5.2.1 RabbitMQ相关词汇介绍</h3><ul><li>生产者</li><li>消费者</li><li>消息</li><li>队列：消息的暂存区或者是存储区</li><li>交换机：消息的中转站，用于首次接收和分发消息</li><li>路由：相当于秘钥、地址或者“第三者”，将消息路由到指定的队列</li></ul><h3 id="5-2-2-Spring-Boot项目整合RabbitMQ"><a href="#5-2-2-Spring-Boot项目整合RabbitMQ" class="headerlink" title="5.2.2 Spring Boot项目整合RabbitMQ"></a>5.2.2 Spring Boot项目整合RabbitMQ</h3><p>1、加入RabbitMQ依赖</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--rabbitmq--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>2、加入RabbitMQ相关配置，包括RabbitMQ服务器所在的Host、端口号、用户名和密码等配置</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment">#RabbitMQ配置</span><span class="hljs-meta">spring.rabbitmq.virtual-host</span>=<span class="hljs-string">/</span><span class="hljs-comment">#RabbitMQ服务器所在的host，这里连接本地即可</span><span class="hljs-meta">spring.rabbitmq.host</span>=<span class="hljs-string">127.0.0.1</span><span class="hljs-comment">#5672为RabbitMQ提供服务时的端口</span><span class="hljs-meta">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><span class="hljs-comment">#guest和guest为连接到RabbitMQ服务器的账号名和密码</span><span class="hljs-meta">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><span class="hljs-meta">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><span class="hljs-comment">#这里是自定义变量，表示本地开发环境</span><span class="hljs-meta">mq.env</span>=<span class="hljs-string">local</span></code></pre></div><h3 id="5-2-3-自定义注入配置Bean相关组件"><a href="#5-2-3-自定义注入配置Bean相关组件" class="headerlink" title="5.2.3 自定义注入配置Bean相关组件"></a>5.2.3 自定义注入配置Bean相关组件</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitmqConfig</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(RabbitmqConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/**自动装配RabbitMQ的链接工厂实例*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> CachingConnectionFactory connectionFactory;    <span class="hljs-comment">/**自动装配消息监听器所在的容器工厂配置类实例*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SimpleRabbitListenerContainerFactoryConfigurer factoryConfigurer;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 为单一消费者实例的配置</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"singleListenerContainer"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> SimpleRabbitListenerContainerFactory <span class="hljs-title">listenerContainer</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//定义消息监听器所在的容器工厂</span>        SimpleRabbitListenerContainerFactory factory = <span class="hljs-keyword">new</span> SimpleRabbitListenerContainerFactory();        <span class="hljs-comment">//设置容器工厂所用的实例</span>        factory.setConnectionFactory(connectionFactory);        <span class="hljs-comment">//设置消息在传输中的格式，在这里采用JSON格式进行传输</span>        factory.setMessageConverter(<span class="hljs-keyword">new</span> Jackson2JsonMessageConverter());        <span class="hljs-comment">//设置并发消费者实例的初始数量，这里为1个</span>        factory.setConcurrentConsumers(<span class="hljs-number">1</span>);        <span class="hljs-comment">//设置并发消费者实例的最大数量，这里为1个</span>        factory.setMaxConcurrentConsumers(<span class="hljs-number">1</span>);        <span class="hljs-comment">//设置并发消费者实例中每个实例拉取的消息数量-在这里为1个</span>        factory.setPrefetchCount(<span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> factory;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 多个消费者实例的配置，主要针对高并发业务场景的配置</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"multiListenerContainer"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> SimpleRabbitListenerContainerFactory <span class="hljs-title">multiListenerContainer</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//定义消息监听器所在的容器工厂</span>        SimpleRabbitListenerContainerFactory factory = <span class="hljs-keyword">new</span> SimpleRabbitListenerContainerFactory();        <span class="hljs-comment">//设置容器工厂所用的实例</span>        factoryConfigurer.configure(factory,connectionFactory);        <span class="hljs-comment">//设置消息在传输中的格式，在这里采用JSON格式进行传输</span>        factory.setMessageConverter(<span class="hljs-keyword">new</span> Jackson2JsonMessageConverter());        <span class="hljs-comment">//设置消息的确认消费模式，在这里为NONE，表示不需要确认消费</span>        factory.setAcknowledgeMode(AcknowledgeMode.NONE);        <span class="hljs-comment">//设置并发消费者实例的初始数量，这里为10个</span>        factory.setConcurrentConsumers(<span class="hljs-number">10</span>);        <span class="hljs-comment">//设置并发消费者实例的最大数量，这里为15个</span>        factory.setMaxConcurrentConsumers(<span class="hljs-number">15</span>);        <span class="hljs-comment">//设置并发消费者实例中每个实例拉取的消息数量-在这里为10个</span>        factory.setPrefetchCount(<span class="hljs-number">10</span>);        <span class="hljs-keyword">return</span> factory;    &#125;    <span class="hljs-comment">/**自定义配置RabbitMQ发送消息的操作组件RabbitTemplate*/</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RabbitTemplate <span class="hljs-title">rabbitTemplate</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//设置“发送消息后进行确认”</span>        connectionFactory.setPublisherConfirms(<span class="hljs-keyword">true</span>);        <span class="hljs-comment">//设置"发送消息后返回确认信息"</span>        connectionFactory.setPublisherReturns(<span class="hljs-keyword">true</span>);        <span class="hljs-comment">//构造发送消息组件实例对象</span>        RabbitTemplate rabbitTemplate = <span class="hljs-keyword">new</span> RabbitTemplate(connectionFactory);        rabbitTemplate.setMandatory(<span class="hljs-keyword">true</span>);        <span class="hljs-comment">//发送消息后，如果发送成功，则输出“消息发送成功”的反馈信息</span>        rabbitTemplate.setConfirmCallback(<span class="hljs-keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">confirm</span><span class="hljs-params">(CorrelationData correlationData, <span class="hljs-keyword">boolean</span> ack, String cause)</span> </span>&#123;                log.info(<span class="hljs-string">"消息发送成功：correlationData(&#123;&#125;),ack(&#123;&#125;),cause(&#123;&#125;)"</span>,correlationData,ack,cause);            &#125;        &#125;);        <span class="hljs-comment">//发送消息后，如果发送失败，则输出"消息发送失败-消息丢失"的反馈信息</span>        rabbitTemplate.setReturnCallback(<span class="hljs-keyword">new</span> RabbitTemplate.ReturnCallback() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">returnedMessage</span><span class="hljs-params">(Message message, <span class="hljs-keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;                log.info(<span class="hljs-string">"“消息丢失：exchange(&#123;&#125;),route(&#123;&#125;),replyCode(&#123;&#125;),replyText(&#123;&#125;),message:&#123;&#125;"</span>,exchange,routingKey,replyCode,replyText,message);            &#125;        &#125;);        <span class="hljs-comment">//最终返回RabbitMQ的操作组件实例RabbitTemplate</span>        <span class="hljs-keyword">return</span> rabbitTemplate;    &#125;&#125;</code></pre></div><p>当RabbitMQ需要处理高并发业务场景时，可以通过配置“多消费实例”的方式来实现；而在正常情况下，对消息不需要并发监听消费处理时，则只需要配置“单一消费者实例”的容器工厂即可。</p><h3 id="5-2-4-RabbitMQ发送、接收消息实战"><a href="#5-2-4-RabbitMQ发送、接收消息实战" class="headerlink" title="5.2.4 RabbitMQ发送、接收消息实战"></a>5.2.4 RabbitMQ发送、接收消息实战</h3><p>以“生产者发送一串简单的字符串信息到基本的消息模型中，并由消费者进行监听消费处理”为案例进行代码演练</p><p>1、在RabbitmqConfig类中创建队列，交换机，路由及其绑定</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 定义读取配置文件的环境变量实例</span><span class="hljs-comment">*/</span><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> Environment env;<span class="hljs-comment">/**创建简单消息模型：队列、交换机和路由 **/</span><span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"basicQueue"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">basicQueue</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(env.getProperty(<span class="hljs-string">"mq.basic.info.queue.name"</span>),<span class="hljs-keyword">true</span>);&#125;<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title">basicExchange</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(env.getProperty(<span class="hljs-string">"mq.basic.info.exchange.name"</span>),<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>);&#125;<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">basicBinding</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> BindingBuilder.bind(basicQueue()).to(basicExchange())    .with(env.getProperty(<span class="hljs-string">"mq.basic.info.routing.key.name"</span>));&#125;</code></pre></div><p>其中，环境变量实例env读取的相关变量是在配置文件application.properties</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment">#定义基本消息模型中队列、交换机和路由的名称</span><span class="hljs-meta">mq.basic.info.queue.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.mq.basic.info.queue</span><span class="hljs-meta">mq.basic.info.exchange.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.mq.basic.info.exchange</span><span class="hljs-meta">mq.basic.info.routing.key.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.mq.basic.info.routing.key</span></code></pre></div><p>2、开发发送消息的生产者BasicPublisher，在这里指定待发送的消息为一串字符串值，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicPublisher</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(BasicPublisher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义JSON序列化和反序列化实例</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义RabbitMQ消息操作组件RabbitTemplate</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义环境变量读取实例</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Environment env;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发送消息</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 待发送的消息，即一串字符串值</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(String message)</span> </span>&#123;        <span class="hljs-comment">//判断字符串值是否为空</span>        <span class="hljs-keyword">if</span> (!Strings.isNullOrEmpty(message)) &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//定义消息传输的格式为JSON字符串格式</span>                rabbitTemplate.setMessageConverter(<span class="hljs-keyword">new</span> Jackson2JsonMessageConverter());                <span class="hljs-comment">//指定消息模型中的交换机</span>                rabbitTemplate.setExchange(env.getProperty(<span class="hljs-string">"mq.basic.info.exchange.name"</span>));                <span class="hljs-comment">//指定消息模型中的路由</span>                rabbitTemplate.setRoutingKey(env.getProperty(<span class="hljs-string">"mq.basic.info.routing.key.name"</span>));                <span class="hljs-comment">//将字符串值转化为待发送的消息，即一串二进制的数据流</span>                Message msg = MessageBuilder.withBody(message.getBytes(<span class="hljs-string">"utf-8"</span>)).build();                <span class="hljs-comment">//转化并发消息</span>                rabbitTemplate.convertAndSend(msg);                <span class="hljs-comment">//打印日志信息</span>                log.info(<span class="hljs-string">"基本消息模型-生产者-发送消息：&#123;&#125;"</span>, message);            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                log.error(<span class="hljs-string">"基本消息模型-生产者-发送消息发生异常：&#123;&#125;"</span>, message, e.fillInStackTrace());            &#125;        &#125;    &#125;&#125;</code></pre></div><p>3、开发监听并接收消费处理信息的消费者实例BasicConsumer</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicConsumer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(BasicConsumer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义JSON序列化和反序列化实例</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 监听并接收消费队列中的消息-在这里采用单一容器工厂实例即可</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"$&#123;mq.basic.info.queue.name&#125;"</span>, containerFactory = <span class="hljs-string">"singleListenerContainer"</span>)    <span class="hljs-comment">/**由于消息本质上是一串二进制数据流，因而监听接收的消息采用字节数据接收*/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeMsg</span><span class="hljs-params">(@Payload <span class="hljs-keyword">byte</span>[] msg)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//将字节数组的消息转化为字符串并打印</span>            String message = <span class="hljs-keyword">new</span> String(msg, <span class="hljs-string">"utf-8"</span>);            log.info(<span class="hljs-string">"基本消息模型-消费者-监听消费到消息：&#123;&#125;"</span>, message);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            log.error(<span class="hljs-string">"基本消息模型-消费者-发生异常："</span>, e.fillInStackTrace());        &#125;    &#125;&#125;</code></pre></div><p>4、测试类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">SpringBootTest</span></span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">RabbitmqTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(RabbitmqTest<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/**定义JSON序列化和反序列化实例*/</span>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-comment">/**定义基本消息模型中发送消息的生产者*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> BasicPublisher basicPublisher;    <span class="hljs-comment">/**用于发送消息的测试方法*/</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        String msg = <span class="hljs-string">"~~~~这是一串字符串消息~~~"</span>;        basicPublisher.sendMsg(msg);    &#125;&#125;</code></pre></div><h3 id="5-2-5-其他发送接收消息方式实战"><a href="#5-2-5-其他发送接收消息方式实战" class="headerlink" title="5.2.5 其他发送接收消息方式实战"></a>5.2.5 其他发送接收消息方式实战</h3><p>RabbitMQ在实际的应用系统中，可以通过发送字节型（通过getBytes()方法或者序列化方法）的消息和采用@RabbitListener接收字节数组类型的消息之外，还可以通过发送、接收“对象类型”的方式实现消息的发送和接收。</p><p>1、在server模块下建立一个用于RabbitMQ操作的消息对应的对象实体包目录：com.debug.middleware.server.rabbitmq.entity，并在该包目录下建立Person类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String userName;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(Integer id, String name, String userName)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.userName = userName;    &#125;&#125;</code></pre></div><p>2、在RabbitmqConfig配置类中创建用于发送对象类型消息的队列、交换机、路由及其绑定：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**创建简单消息模型-对象类型：队列、交换机和路由*/</span>   <span class="hljs-meta">@Bean</span>(name=<span class="hljs-string">"objectQueue"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">objectQueue</span><span class="hljs-params">()</span></span>&#123;       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(env.getProperty(<span class="hljs-string">"mq.object.info.queue.name"</span>),<span class="hljs-keyword">true</span>);   &#125;   <span class="hljs-meta">@Bean</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title">objectExchange</span><span class="hljs-params">()</span></span>&#123;       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(env.getProperty(<span class="hljs-string">"mq.object.info.exchange.name"</span>),<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>);   &#125;   <span class="hljs-meta">@Bean</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">objectBinding</span><span class="hljs-params">()</span></span>&#123;       <span class="hljs-keyword">return</span> BindingBuilder.bind(objectQueue()).to(objectExchange())               .with(env.getProperty(<span class="hljs-string">"mq.object.info.routing.key.name"</span>));   &#125;</code></pre></div><p>参数配置</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment">#基本消息模型-对象消息</span><span class="hljs-meta">mq.object.info.queue.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.mq.object.info.queue</span><span class="hljs-meta">mq.object.info.exchange.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.mq.object.info.exchange</span><span class="hljs-meta">mq.object.info.routing.key.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.mq.object.info.routing.key</span></code></pre></div><p>3、生产者</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**发送对象类型的消息*/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendObjectMsg</span><span class="hljs-params">(Person p)</span></span>&#123;        <span class="hljs-comment">//判断对象是否为空</span>        <span class="hljs-keyword">if</span>(p != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//设置消息在传输过程中的格式，这里指定为JSON格式</span>                rabbitTemplate.setMessageConverter(<span class="hljs-keyword">new</span> Jackson2JsonMessageConverter());                <span class="hljs-comment">//指定发送消息时对应的交换机</span>                rabbitTemplate.setExchange(env.getProperty(<span class="hljs-string">"mq.object.info.exchange.name"</span>));                <span class="hljs-comment">//指定发送消息时对应的路由</span>                rabbitTemplate.setRoutingKey(env.getProperty(<span class="hljs-string">"mq.object.info.routing.key.name"</span>));                <span class="hljs-comment">//采用convertAndSend方法即可发送消息</span>                rabbitTemplate.convertAndSend(p, <span class="hljs-keyword">new</span> MessagePostProcessor() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> Message <span class="hljs-title">postProcessMessage</span><span class="hljs-params">(Message message)</span> <span class="hljs-keyword">throws</span> AmqpException </span>&#123;                        <span class="hljs-comment">//获取消息的属性</span>                        MessageProperties messageProperties = message.getMessageProperties();                        <span class="hljs-comment">//设置消息的持久化模式</span>                        messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);                        <span class="hljs-comment">//设置消息的类型，这里指定为Person类型</span>                        messageProperties.setHeader(AbstractJavaTypeMapper.DEFAULT_CONTENT_CLASSID_FIELD_NAME,Person<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;                        <span class="hljs-comment">//返回消息实例</span>                        <span class="hljs-keyword">return</span> message;                    &#125;                &#125;);                <span class="hljs-comment">//打印日志信息</span>                log.info(<span class="hljs-string">"基本消息模型-生产者-发送对象类型的消息：&#123;&#125;"</span>,p);            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;                log.error(<span class="hljs-string">"基本消息模型-生产者-发送对象类型的消息发生异常：&#123;&#125;"</span>,p,e.fillInStackTrace());            &#125;        &#125;</code></pre></div><p>如果需要发送对象类型的消息，则需要借助RabbitTemplate的convertAndSend方法，通过MessagePostProcessor的实现类直接指定待发送消息的类型。</p><p>4、开发用于监听消费处理消息的消费者功能</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"$&#123;mq.object.info.queue.name&#125;"</span>,containerFactory = <span class="hljs-string">"singleListenerContainer"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeObjectMsg</span><span class="hljs-params">(@Payload Person person)</span></span>&#123;       <span class="hljs-keyword">try</span> &#123;           log.info(<span class="hljs-string">"基本消息模型-监听消费处理对象信息-消费者-监听消费到消息：&#123;&#125;"</span>,person);       &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;           log.error(<span class="hljs-string">"基本消息模型-监听消费处理对象信息-消费者-发生异常："</span>,e.fillInStackTrace());       &#125;   &#125;</code></pre></div><p>5、测试</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;    Person p = <span class="hljs-keyword">new</span> Person(<span class="hljs-number">1</span>,<span class="hljs-string">"大圣"</span>,<span class="hljs-string">"debug"</span>);    basicPublisher.sendObjectMsg(p);&#125;</code></pre></div><h2 id="5-3-RabbitMQ多种消息模型实战"><a href="#5-3-RabbitMQ多种消息模型实战" class="headerlink" title="5.3 RabbitMQ多种消息模型实战"></a>5.3 RabbitMQ多种消息模型实战</h2><p>RabbitMQ的核心组件体系中，主要有4中典型的消息模型：即基于HeadersExchange的消息模型、基于fanoutExchange的消息模型、基于DirectExchange的消息模型以及基于TopicExchange的消息模型。</p><h3 id="5-3-1-基于FanoutExchange的消息模型实战"><a href="#5-3-1-基于FanoutExchange的消息模型实战" class="headerlink" title="5.3.1 基于FanoutExchange的消息模型实战"></a>5.3.1 基于FanoutExchange的消息模型实战</h3><p>交换机的一种，具有“广播消息”的作用，当消息进入交换机这个“中转站”时，交换机会检查哪个队列跟自己是绑定在一起的，找到相应的队列后，将消息传输到相应的绑定队列中，并最终由队列对应的消费者进行监听消费。</p><p>1、在RabbitmqConfig中创建交换机、多条队列及其绑定</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**创建消息模型-fanoutExchange*/</span>  <span class="hljs-meta">@Bean</span>(name=<span class="hljs-string">"fanoutQueueOne"</span>)  <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">fanoutQueueOne</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(env.getProperty(<span class="hljs-string">"mq.fanout.queue.one.name"</span>),<span class="hljs-keyword">true</span>);  &#125;  <span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"fanoutQueueTwo"</span>)  <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">fanoutQueueTwo</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(env.getProperty(<span class="hljs-string">"mq.fanout.queue.two.name"</span>),<span class="hljs-keyword">true</span>);  &#125;  <span class="hljs-meta">@Bean</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title">fanoutExchange</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FanoutExchange(env.getProperty(<span class="hljs-string">"mq.fanout.exchange.name"</span>),<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>);  &#125;  <span class="hljs-meta">@Bean</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">fanoutBindingOne</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-keyword">return</span> BindingBuilder.bind(fanoutQueueOne()).to(fanoutExchange());  &#125;  <span class="hljs-meta">@Bean</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">fanoutBindingTwo</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-keyword">return</span> BindingBuilder.bind(fanoutQueueTwo()).to(fanoutExchange());  &#125;</code></pre></div><p>环境变量实例env读取的变量所在配置文件</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment">#消息模型-fanoutExchange</span><span class="hljs-meta">mq.fanout.queue.one.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.mq.fanout.one.queue</span><span class="hljs-meta">mq.fanout.queue.two.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.mq.fanout.two.queue</span><span class="hljs-meta">mq.fanout.exchange.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.mq.fanout.exchange</span></code></pre></div><p>2、创建对象实体信息EventInfo</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventInfo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String <span class="hljs-keyword">module</span>;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String desc;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EventInfo</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EventInfo</span><span class="hljs-params">(Integer id, String <span class="hljs-keyword">module</span>, String name, String desc)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">module</span> = <span class="hljs-keyword">module</span>;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.desc = desc;    &#125;&#125;</code></pre></div><p>3、开发生产消息的生产者ModelPublisher类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModelPublisher</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(ModelPublisher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/**JSON序列化和反序列化组件*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-comment">/**定义发送消息的操作组件RabbitTemplate*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-comment">/**定义读取环境变量的实例*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Environment env;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(EventInfo info)</span></span>&#123;        <span class="hljs-keyword">if</span>(info != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//定义消息的传输格式为JSON</span>                rabbitTemplate.setMessageConverter(<span class="hljs-keyword">new</span> Jackson2JsonMessageConverter());                <span class="hljs-comment">//设置广播式交换机FanoutExchange</span>                rabbitTemplate.setExchange(env.getProperty(<span class="hljs-string">"mq.fanout.exchange.name"</span>));                <span class="hljs-comment">//创建消息实例</span>                Message msg = MessageBuilder.withBody(objectMapper.writeValueAsBytes(info)).build();                <span class="hljs-comment">//发送消息</span>                rabbitTemplate.convertAndSend(msg);                <span class="hljs-comment">//打印日志</span>                log.info(<span class="hljs-string">"消息模型fanoutExchange-生产者-发送消息：&#123;&#125;"</span>,info);            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                log.error(<span class="hljs-string">"消息模型fanoutExchange-生产者-发送消息发生异常：&#123;&#125;"</span>,info,e.fillInStackTrace());            &#125;        &#125;    &#125;&#125;</code></pre></div><p>4、开发用于监听接收消费处理消息的消费者ModelConsumer，开发两条队列分别对应的监听消费方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModelConsumer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(ModelConsumer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">public</span> ObjectMapper objectMapper;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 监听消费队列中的消息-fanoutExchange-one-这是第一条队列对应的消费者</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"$&#123;mq.fanout.queue.one.name&#125;"</span>,containerFactory = <span class="hljs-string">"singleListenerContainer"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeFanoutMsgOne</span><span class="hljs-params">(@Payload <span class="hljs-keyword">byte</span>[] msg)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//监听消费队列中的消息，并进行解析处理</span>            EventInfo info = objectMapper.readValue(msg, EventInfo<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            log.info(<span class="hljs-string">"消息模型fanoutExchange-one-消费者-监听消费到消息：&#123;&#125;"</span>,info);        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            log.error(<span class="hljs-string">"消息模型-消费者-发生异常:"</span>,e.fillInStackTrace());        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 监听消费队列中的消息-fanoutExchange-two-这是第二条队列对应的消费者</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"$&#123;mq.fanout.queue.two.name&#125;"</span>,containerFactory = <span class="hljs-string">"singleListenerContainer"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeFanoutMsgTwo</span><span class="hljs-params">(@Payload <span class="hljs-keyword">byte</span>[] msg)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//监听消费队列中的消息，并进行解析处理</span>            EventInfo info = objectMapper.readValue(msg, EventInfo<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            log.info(<span class="hljs-string">"消息模型fanoutExchange-two-消费者-监听消费到消息：&#123;&#125;"</span>,info);        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            log.error(<span class="hljs-string">"消息模型-消费者-发生异常:"</span>,e.fillInStackTrace());        &#125;    &#125;&#125;</code></pre></div><p>5、测试类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>   <span class="hljs-keyword">private</span> ModelPublisher modelPublisher;   <span class="hljs-meta">@Test</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;       <span class="hljs-comment">//创建对象实例</span>       EventInfo info = <span class="hljs-keyword">new</span> EventInfo(<span class="hljs-number">1</span>, <span class="hljs-string">"增删改查模块"</span>, <span class="hljs-string">"基于fanoutExchange的消息模型"</span>, <span class="hljs-string">"这是基于fanoutExchange的消息模型"</span>);       <span class="hljs-comment">//触发生产者发送消息</span>       modelPublisher.sendMsg(info);   &#125;</code></pre></div><p>效果：</p><div class="hljs"><pre><code class="hljs routeros">[2021-02-01 10:16:11.011] boot -  <span class="hljs-builtin-name">INFO</span> [SimpleAsyncTaskExecutor-1] ---ModelConsumer: 消息模型fanoutExchange-two-消费者-监听消费到消息：EventInfo(<span class="hljs-attribute">id</span>=1, <span class="hljs-attribute">module</span>=增删改查模块, <span class="hljs-attribute">name</span>=基于fanoutExchange的消息模型, <span class="hljs-attribute">desc</span>=这是基于fanoutExchange的消息模型)[2021-02-01 10:16:11.011] boot -  <span class="hljs-builtin-name">INFO</span> [SimpleAsyncTaskExecutor-1] ---ModelConsumer: 消息模型fanoutExchange-one-消费者-监听消费到消息：EventInfo(<span class="hljs-attribute">id</span>=1, <span class="hljs-attribute">module</span>=增删改查模块, <span class="hljs-attribute">name</span>=基于fanoutExchange的消息模型, <span class="hljs-attribute">desc</span>=这是基于fanoutExchange的消息模型)</code></pre></div><p>由于该FanoutExchange绑定了两条队列，因而两条队列分别对应的消费者将监听接收到相应的消息。</p><p>总结：</p><p>基于FanoutExchange消费模型主要的核心组件是交换机和队列，一个交换机可以对应并绑定多个队列，从而对应多个消费者！</p><p>此种消费模型适用于“业务数据需要广播传输”的场景，比如“用户操作写日志”。</p><h3 id="5-3-2-基于DirectExchange的消息模型实战"><a href="#5-3-2-基于DirectExchange的消息模型实战" class="headerlink" title="5.3.2 基于DirectExchange的消息模型实战"></a>5.3.2 基于DirectExchange的消息模型实战</h3><p>交换机，具有“直连传输消息”的作用，即当消息进入交换机这个“中转站”时，交换机会检查哪个路由跟自己绑定在一起，并根据生产者发送消息指定的路由进行匹配，如果能找到对应的绑定模型，则将消息直接路由传输到指定的队列，最终由队列对应的消费者进行监听消费。</p><p>业务场景：将实体对象信息当做消息，并发送到基于DirectExchange构成的消息模型中，根据绑定的路由，将消息路由至对应绑定的队列中，最终由对应的消费者进行监听消费处理。</p><p>1、在RabbitmqConfig配置文件中创建一个交换机、两个路由和对应绑定的两条队列。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**创建消息模型-DirectExchange*/</span>   <span class="hljs-meta">@Bean</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title">directExchange</span><span class="hljs-params">()</span></span>&#123;       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(env.getProperty(<span class="hljs-string">"mq.direct.exchange.name"</span>),<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>);   &#125;   <span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"directQueueOne"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">directQueueOne</span><span class="hljs-params">()</span></span>&#123;       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(env.getProperty(<span class="hljs-string">"mq.direct.queue.one.name"</span>),<span class="hljs-keyword">true</span>);   &#125;   <span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"directQueueTwo"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">directQueueTwo</span><span class="hljs-params">()</span></span>&#123;       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(env.getProperty(<span class="hljs-string">"mq.direct.queue.two.name"</span>),<span class="hljs-keyword">true</span>);   &#125;   <span class="hljs-meta">@Bean</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">directBindOne</span><span class="hljs-params">()</span></span>&#123;       <span class="hljs-keyword">return</span> BindingBuilder.bind(directQueueOne()).to(directExchange())               .with(env.getProperty(<span class="hljs-string">"mq.direct.routing.key.one.name"</span>));   &#125;   <span class="hljs-meta">@Bean</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">directBindTwo</span><span class="hljs-params">()</span></span>&#123;       <span class="hljs-keyword">return</span> BindingBuilder.bind(directQueueTwo()).to(directExchange())               .with(env.getProperty(<span class="hljs-string">"mq.direct.routing.key.two.name"</span>));   &#125;</code></pre></div><p>配置文件中变量取值如下：</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment">#消息模型DirectExchange</span><span class="hljs-meta">mq.direct.exchange.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.mq.direct.exchange</span><span class="hljs-meta">mq.direct.routing.key.one.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.mq.direct.routing.key.one</span><span class="hljs-meta">mq.direct.routing.key.two.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.mq.direct.routing.key.two</span><span class="hljs-meta">mq.direct.queue.one.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.mq.direct.one.queue</span><span class="hljs-meta">mq.direct.queue.two.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.mq.direct.two.queue</span></code></pre></div><p>2、生产者，开发两个用于发送消息的生产者方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 发送消息-基于DirectExchange消息模型-one</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsgDirectOne</span><span class="hljs-params">(EventInfo info)</span></span>&#123;        <span class="hljs-keyword">if</span>(info != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//设置消息传输的格式为JSON</span>                rabbitTemplate.setMessageConverter(<span class="hljs-keyword">new</span> Jackson2JsonMessageConverter());                <span class="hljs-comment">//设置交换机</span>                rabbitTemplate.setExchange(env.getProperty(<span class="hljs-string">"mq.direct.exchange.name"</span>));                <span class="hljs-comment">//设置路由1</span>                rabbitTemplate.setRoutingKey(env.getProperty(<span class="hljs-string">"mq.direct.routing.key.one.name"</span>));                <span class="hljs-comment">//创建消息</span>                Message msg = MessageBuilder.withBody(objectMapper.writeValueAsBytes(info)).build();                <span class="hljs-comment">//发送消息</span>                rabbitTemplate.convertAndSend(msg);                <span class="hljs-comment">//打印日志</span>                log.info(<span class="hljs-string">"消息模型DirectExchange-one-生产者-发送消息：&#123;&#125;"</span>,info);            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;                log.error(<span class="hljs-string">"消息模型DirectExchange-one-生产者-发送消息发生异常：&#123;&#125;"</span>,info,e.fillInStackTrace());            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发送消息-基于DirectExchange消息模型-two</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> info</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsgDirectTwo</span><span class="hljs-params">(EventInfo info)</span></span>&#123;        <span class="hljs-keyword">if</span> (info != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">try</span> &#123;                rabbitTemplate.setMessageConverter(<span class="hljs-keyword">new</span> Jackson2JsonMessageConverter());                rabbitTemplate.setExchange(env.getProperty(<span class="hljs-string">"mq.direct.exchange.name"</span>));                rabbitTemplate.setRoutingKey(env.getProperty(<span class="hljs-string">"mq.direct.routing.key.two.name"</span>));                Message msg = MessageBuilder.withBody(objectMapper.writeValueAsBytes(info)).build();                rabbitTemplate.convertAndSend(msg);                log.info(<span class="hljs-string">"消息模型DirectExchange-two-生产者-发送消息：&#123;&#125;"</span>,info);            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;                log.error(<span class="hljs-string">"消息模型DirectExchange-two-生产者-发送消息发生异常：&#123;&#125;"</span>,info,e.fillInStackTrace());            &#125;        &#125;    &#125;</code></pre></div><p>3、两个消费者方法，用于监听不同队列中的消息</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 第一个路由绑定的对应队列的消费者方法</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> msg</span><span class="hljs-comment">    */</span>   <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"$&#123;mq.direct.queue.one.name&#125;"</span>,containerFactory = <span class="hljs-string">"singleListenerContainer"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeDirectMsgOne</span><span class="hljs-params">(@Payload <span class="hljs-keyword">byte</span>[] msg)</span></span>&#123;       <span class="hljs-keyword">try</span> &#123;           <span class="hljs-comment">//监听消费信息并进行JSON反序列化解析</span>           EventInfo info = objectMapper.readValue(msg, EventInfo<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;           <span class="hljs-comment">//打印日志消息</span>           log.info(<span class="hljs-string">"消息模型DirectExchange-one-消费者-监听消费到消息：&#123;&#125;"</span>,info);       &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;           log.error(<span class="hljs-string">"消息模型DirectExchange-one-消费者-监听消费发生异常："</span>,e.fillInStackTrace());       &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 第二个路由绑定的对应队列的消费者方法</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> msg</span><span class="hljs-comment">    */</span>   <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"$&#123;mq.direct.queue.two.name&#125;"</span>,containerFactory = <span class="hljs-string">"singleListenerContainer"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeDirectMsgTwo</span><span class="hljs-params">(@Payload <span class="hljs-keyword">byte</span>[] msg)</span> </span>&#123;       <span class="hljs-keyword">try</span> &#123;           <span class="hljs-comment">//监听消费信息并进行JSON反序列化解析</span>           EventInfo info = objectMapper.readValue(msg, EventInfo<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;           <span class="hljs-comment">//打印日志消息</span>           log.info(<span class="hljs-string">"消息模型DirectExchange-two-消费者-监听消费到消息：&#123;&#125;"</span>, info);       &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;           log.error(<span class="hljs-string">"消息模型DirectExchange-two-消费者-监听消费发生异常："</span>, e.fillInStackTrace());       &#125;   &#125;</code></pre></div><p>4、测试类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span>&#123;       <span class="hljs-comment">//创建对象实例</span>       EventInfo info = <span class="hljs-keyword">new</span> EventInfo(               <span class="hljs-number">1</span>,               <span class="hljs-string">"增删改查模块-1"</span>,               <span class="hljs-string">"基于directExchange的消息模型-1"</span>,               <span class="hljs-string">"这是基于directExchange的消息模型-1"</span>);       <span class="hljs-comment">//触发生产者发送消息</span>       modelPublisher.sendMsgDirectOne(info);       info = <span class="hljs-keyword">new</span> EventInfo(               <span class="hljs-number">2</span>,               <span class="hljs-string">"增删改查模块-2"</span>,               <span class="hljs-string">"基于directExchange的消息模型-2"</span>,               <span class="hljs-string">"这是基于directExchange的消息模型-2"</span>);       modelPublisher.sendMsgDirectTwo(info);   &#125;</code></pre></div><p>效果：各自的消费者都监听消费到了各自的消息</p><h3 id="5-3-3-基于TopicExchange的消息模型实战"><a href="#5-3-3-基于TopicExchange的消息模型实战" class="headerlink" title="5.3.3 基于TopicExchange的消息模型实战"></a>5.3.3 基于TopicExchange的消息模型实战</h3><p>“发布-主题-订阅”式的交换机，可以通过为路由的名称指定特定的通配符“<em>”和“#”，从而绑定到不同的队列中。“\</em>“表示一个特定的单词，“#”表示任意的单词（可以是一个，多个，也可以没有）</p><p>业务场景：将一串字符串信息当做消息，并发送到基于TopicExchange构成的消息模型中，根据绑定的路由将消息路由至绑定的队列中，最终由对应的消费者进行监听消费处理。</p><p>1、在RabbitmqConfig配置文件中创建基于TopicExchange的消息模型，这里创建一个交换机、两个分别包含通配符“*”和“#”的路由及队列绑定</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**创建绑定-通配符为*的路由*/</span>   <span class="hljs-meta">@Bean</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">topicBindingOne</span><span class="hljs-params">()</span></span>&#123;       <span class="hljs-keyword">return</span> BindingBuilder.bind(topicQueueOne()).to(topicExchange())               .with(env.getProperty(<span class="hljs-string">"mq.topic.routing.key.one.name"</span>));   &#125;   <span class="hljs-comment">/**创建绑定-通配符为#的路由*/</span>   <span class="hljs-meta">@Bean</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">topicBindingTwo</span><span class="hljs-params">()</span></span>&#123;       <span class="hljs-keyword">return</span> BindingBuilder.bind(topicQueueTwo()).to(topicExchange())               .with(env.getProperty(<span class="hljs-string">"mq.topic.routing.key.two.name"</span>));   &#125;</code></pre></div><p>环境变量实例env读取的变量取值：</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment">#消息模型-TopicExchange</span><span class="hljs-meta">mq.topic.exchange.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.mq.topic.exchange</span><span class="hljs-meta">mq.topic.routing.key.one.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.mq.topic.routing.*.key</span><span class="hljs-meta">mq.topic.routing.key.two.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.mq.topic.routing.#.key</span><span class="hljs-meta">mq.topic.queue.one.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.mq.topic.one.queue</span><span class="hljs-meta">mq.topic.queue.two.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.mq.topic.two.queue</span></code></pre></div><p>2、生产者，这里将“路由”参数开放出来，供调用者调用时指定该参数值，目的是用于测试两个通配符所起的作用。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsgTopic</span><span class="hljs-params">(String msg,String routingKey)</span></span>&#123;       <span class="hljs-keyword">if</span>(!Strings.isNullOrEmpty(msg) &amp;&amp; !Strings.isNullOrEmpty(routingKey))&#123;           <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">//设置消息的传输格式为JSON</span>               rabbitTemplate.setMessageConverter(<span class="hljs-keyword">new</span> Jackson2JsonMessageConverter());               <span class="hljs-comment">//指定交换机</span>               rabbitTemplate.setExchange(env.getProperty(<span class="hljs-string">"mq.topic.exchange.name"</span>));               <span class="hljs-comment">//指定路由的实际取值，根据不同取值，RabbitMQ将自行进行匹配通配符，从而路由到不同的队列中</span>               rabbitTemplate.setRoutingKey(routingKey);               <span class="hljs-comment">//创建消息</span>               Message message = MessageBuilder.withBody(msg.getBytes(<span class="hljs-string">"UTF-8"</span>)).build();               <span class="hljs-comment">//发送消息</span>               rabbitTemplate.convertAndSend(message);               <span class="hljs-comment">//打印日志</span>               log.info(<span class="hljs-string">"消息模型TopicExchange-生产者-发送消息：&#123;&#125; 路由：&#123;&#125; "</span>,msg,routingKey);           &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;               log.error(<span class="hljs-string">"消息模型TopicExchange-生产者-发送消息发生异常：&#123;&#125;"</span>,msg,e.fillInStackTrace());           &#125;       &#125;</code></pre></div><p>3、开发用于监听消费消息的消费者</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 监听消费队列中的消息-TopicExchange-*通配符</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"$&#123;mq.topic.queue.one.name&#125;"</span>,containerFactory = <span class="hljs-string">"singleListenerContainer"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeTopicMsgOne</span><span class="hljs-params">(@Payload <span class="hljs-keyword">byte</span>[] msg)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            String message = <span class="hljs-keyword">new</span> String(msg, <span class="hljs-string">"utf-8"</span>);            log.info(<span class="hljs-string">"消息模型-TopicExchange-*-消费者-监听消费到消息：&#123;&#125;"</span>,message);        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            log.error(<span class="hljs-string">"消息模型-TopicExchange-*-消费者-监听消息发生异常："</span>,e.fillInStackTrace());        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 监听消费队列中的消息-TopicExchange-#通配符</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"$&#123;mq.topic.queue.two.name&#125;"</span>,containerFactory = <span class="hljs-string">"singleListenerContainer"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeTopicMsgTwo</span><span class="hljs-params">(@Payload <span class="hljs-keyword">byte</span>[] msg)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            String message = <span class="hljs-keyword">new</span> String(msg, <span class="hljs-string">"utf-8"</span>);            log.info(<span class="hljs-string">"消息模型-TopicExchange-#-消费者-监听消费到消息：&#123;&#125;"</span>,message);        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            log.error(<span class="hljs-string">"消息模型-TopicExchange-#-消费者-监听消息发生异常："</span>,e.fillInStackTrace());        &#125;    &#125;</code></pre></div><p>4、测试类：</p><div class="hljs"><pre><code class="hljs java">  <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span>&#123;        String msg = <span class="hljs-string">"这是TopicExchange消息模型的消息"</span>;        String routingKeyOne = <span class="hljs-string">"local.middleware.mq.topic.routing.java.key"</span>;        String routingKeyTwo = <span class="hljs-string">"local.middleware.mq.topic.routing.php.python.key"</span>;        String routingKeyThree = <span class="hljs-string">"local.middleware.mq.topic.routing.key"</span>;<span class="hljs-comment">//        modelPublisher.sendMsgTopic(msg,routingKeyOne);</span>        modelPublisher.sendMsgTopic(msg,routingKeyTwo);<span class="hljs-comment">//        modelPublisher.sendMsgTopic(msg,routingKeyThree);</span>    &#125;</code></pre></div><p>TopicExchange消息模型适用于“发布订阅主题式”的场景，具有普适性的特点。</p><h2 id="5-4-RabbitMQ确认消费机制"><a href="#5-4-RabbitMQ确认消费机制" class="headerlink" title="5.4 RabbitMQ确认消费机制"></a>5.4 RabbitMQ确认消费机制</h2><p>RabbitMQ在消息的发送、传输和接收过程中，可以保证消息成功发送、不会丢失，以及被确认消费。</p><h3 id="5-4-1-消息高可用和确认消费"><a href="#5-4-1-消息高可用和确认消费" class="headerlink" title="5.4.1 消息高可用和确认消费"></a>5.4.1 消息高可用和确认消费</h3><p>1、RabbitMQ会在生产者在发送完消息之后进行“发送确认”，当确认成功时即代表消息一经成功发送出去了，相关代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**自定义配置RabbitMQ发送消息的操作组件RabbitTemplate*/</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RabbitTemplate <span class="hljs-title">rabbitTemplate</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//设置“发送消息后进行确认”</span>        connectionFactory.setPublisherConfirms(<span class="hljs-keyword">true</span>);        <span class="hljs-comment">//设置"发送消息后返回确认信息"</span>        connectionFactory.setPublisherReturns(<span class="hljs-keyword">true</span>);        <span class="hljs-comment">//构造发送消息组件实例对象</span>        RabbitTemplate rabbitTemplate = <span class="hljs-keyword">new</span> RabbitTemplate(connectionFactory);        rabbitTemplate.setMandatory(<span class="hljs-keyword">true</span>);        <span class="hljs-comment">//发送消息后，如果发送成功，则输出“消息发送成功”的反馈信息</span>        rabbitTemplate.setConfirmCallback(<span class="hljs-keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">confirm</span><span class="hljs-params">(CorrelationData correlationData, <span class="hljs-keyword">boolean</span> ack, String cause)</span> </span>&#123;                log.info(<span class="hljs-string">"消息发送成功：correlationData(&#123;&#125;),ack(&#123;&#125;),cause(&#123;&#125;)"</span>,correlationData,ack,cause);            &#125;        &#125;);        <span class="hljs-comment">//发送消息后，如果发送失败，则输出"消息发送失败-消息丢失"的反馈信息</span>        rabbitTemplate.setReturnCallback(<span class="hljs-keyword">new</span> RabbitTemplate.ReturnCallback() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">returnedMessage</span><span class="hljs-params">(Message message, <span class="hljs-keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;                log.info(<span class="hljs-string">"“消息丢失：exchange(&#123;&#125;),route(&#123;&#125;),replyCode(&#123;&#125;),replyText(&#123;&#125;),message:&#123;&#125;"</span>,exchange,routingKey,replyCode,replyText,message);            &#125;        &#125;);        <span class="hljs-comment">//最终返回RabbitMQ的操作组件实例RabbitTemplate</span>        <span class="hljs-keyword">return</span> rabbitTemplate;    &#125;</code></pre></div><p>2、保证RabbitMQ队列中的消息“不丢失”，是在创建队列、交换机时设置其持久化参数为true，即durable参数取值为true。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530101930.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>在创建消息时，RabbitMQ要求设置消息的持久化模式为“持久化”，从而保证RabbitMQ服务器出现崩溃并执行重启操作之后，队列、交换机仍旧存在而且消息不会丢失。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Message <span class="hljs-title">postProcessMessage</span><span class="hljs-params">(Message message)</span> <span class="hljs-keyword">throws</span> AmqpException </span>&#123;                        <span class="hljs-comment">//获取消息的属性</span>                        MessageProperties messageProperties = message.getMessageProperties();                        <span class="hljs-comment">//设置消息的持久化模式</span>                        messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);                        <span class="hljs-comment">//设置消息的类型，这里指定为Person类型</span>                        messageProperties.setHeader(AbstractJavaTypeMapper.DEFAULT_CONTENT_CLASSID_FIELD_NAME,Person<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;                        <span class="hljs-comment">//返回消息实例</span>                        <span class="hljs-keyword">return</span> message;                    &#125;</code></pre></div><p>3、保证消息能够被准确消费、不重复消费，RabbitMQ提供了“消息确认机制”，只有当消息被确认消费后，消息才会从队列中被移除。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> AcknowledgeMode &#123;    NONE,    MANUAL,    AUTO;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">AcknowledgeMode</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isTransactionAllowed</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> == AUTO || <span class="hljs-keyword">this</span> == MANUAL;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAutoAck</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> == NONE;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isManual</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> == MANUAL;    &#125;&#125;</code></pre></div><h3 id="5-4-2-常见的确认消费模式介绍"><a href="#5-4-2-常见的确认消费模式介绍" class="headerlink" title="5.4.2 常见的确认消费模式介绍"></a>5.4.2 常见的确认消费模式介绍</h3><p>三种模式：NONE、AUTO、MANUAL</p><p>NONE：无需确认，即生产者将消息发送至队列，消费者监听到该消息时，无需发送任何反馈信息给RabbitMQ服务器。</p><p>AUTO：自动确认，即生产者将消息发送至队列，消费者监听到该消息时，需要发送一个AUTO ACK的反馈信息给RabbitMQ服务器，之后该消息将在RabbitMQ的队列中被移除。</p><p>MANUAL：人为手动确认消费，即生产者将消息发送至队列，消费者监听到该消息时需要手动地“以代码的形式”发送一个ACK的反馈信息给RabbitMQ服务器，之后该消息将在RabbitMQ的队列中被移除，同时告知生产者，消息已经成功发送并且成功被消费者监听消费了。</p><h3 id="5-4-3-基于自动确认消费模式实战"><a href="#5-4-3-基于自动确认消费模式实战" class="headerlink" title="5.4.3 基于自动确认消费模式实战"></a>5.4.3 基于自动确认消费模式实战</h3><p>1、KnowledgeInfo类充当“消息”进行传输</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KnowledeInfo</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String mode;    <span class="hljs-keyword">private</span> String code;&#125;</code></pre></div><p>2、在RabbitmqConfig配置类中创建相应的队列，交换机，路由及其绑定，同时再创建一个基于自动确认消费模式的“监听器容器工厂实例”，目的是用于指定特定的队列对应的消费者采用“自动确认消费”的模式。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**单一消费者-确认模式为AUTO*/</span>  <span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"singleListenerContainerAuto"</span>)  <span class="hljs-function"><span class="hljs-keyword">public</span> SimpleRabbitListenerContainerFactory <span class="hljs-title">listenerContainerAuto</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-comment">//创建消息监听器所在的容器工厂实例</span>      SimpleRabbitListenerContainerFactory factory = <span class="hljs-keyword">new</span> SimpleRabbitListenerContainerFactory();      <span class="hljs-comment">//容器工厂实例设置链接工厂</span>      factory.setConnectionFactory(connectionFactory);      <span class="hljs-comment">//设置消息在传输中的格式</span>      factory.setMessageConverter(<span class="hljs-keyword">new</span> Jackson2JsonMessageConverter());      <span class="hljs-comment">//设置消费者并发实例，在这里采用单一的模式</span>      factory.setConcurrentConsumers(<span class="hljs-number">1</span>);      <span class="hljs-comment">//设置消费者并发最大数量的实例</span>      factory.setMaxConcurrentConsumers(<span class="hljs-number">1</span>);      <span class="hljs-comment">//设置消费者每个并发的实例预拉取的消息数据量</span>      factory.setPrefetchCount(<span class="hljs-number">1</span>);      <span class="hljs-comment">//设置确认消费模式为自动确认消费AUTO</span>      factory.setAcknowledgeMode(AcknowledgeMode.AUTO);      <span class="hljs-comment">//返回监听器容器工厂实例</span>      <span class="hljs-keyword">return</span> factory;  &#125;  <span class="hljs-comment">/**创建队列*/</span>  <span class="hljs-meta">@Bean</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">autoQueue</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(env.getProperty(<span class="hljs-string">"mq.auto.knowledge.queue.name"</span>),<span class="hljs-keyword">true</span>);  &#125;  <span class="hljs-comment">/**创建交换机*/</span>  <span class="hljs-meta">@Bean</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title">autoExchange</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(env.getProperty(<span class="hljs-string">"mq.auto.knowledge.exchange.name"</span>),<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>);  &#125;  <span class="hljs-comment">/**创建绑定*/</span>  <span class="hljs-meta">@Bean</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">autoBinding</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-keyword">return</span> BindingBuilder.bind(autoQueue()).to(autoExchange())              .with(env.getProperty(<span class="hljs-string">"mq.auto.knowledge.routing.ken.name"</span>));  &#125;</code></pre></div><p>相关配置文件中的变量：</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment">#确认消费模式为自动确认机制</span><span class="hljs-meta">mq.auto.knowledge.queue.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.auto.knowledge.queue</span><span class="hljs-meta">mq.auto.knowledge.exchange.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.auto.knowledge.exchange</span><span class="hljs-meta">mq.auto.knowledge.routing.ken.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.auto.knowledge.routing.key</span></code></pre></div><p>3、生产者</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KnowledgePublisher</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(KnowledgePublisher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/**定义JSON序列化和反序列化组件实例*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-comment">/**定义读取环境变量的实例*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Environment env;    <span class="hljs-comment">/**定义RabbitMQ操作组件实例*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 基于AUTO机制-生产者发送消息</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendAutoMsg</span><span class="hljs-params">(KnowledgeInfo info)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span>(info != <span class="hljs-keyword">null</span>)&#123;                <span class="hljs-comment">//设置消息的传输格式</span>                rabbitTemplate.setMessageConverter(<span class="hljs-keyword">new</span> Jackson2JsonMessageConverter());                <span class="hljs-comment">//设置交换机</span>                rabbitTemplate.setExchange(env.getProperty(<span class="hljs-string">"mq.auto.knowledge.exchange.name"</span>));                <span class="hljs-comment">//设置路由</span>                rabbitTemplate.setRoutingKey(env.getProperty(<span class="hljs-string">"mq.auto.knowledge.routing.key.name"</span>));                <span class="hljs-comment">//创建消息，并对消息进行持久化策略设置</span>                Message message = MessageBuilder                        .withBody(objectMapper.writeValueAsBytes(info))                        .setDeliveryMode(MessageDeliveryMode.PERSISTENT)                        .build();                <span class="hljs-comment">//发送消息</span>                rabbitTemplate.convertAndSend(message);                log.info(<span class="hljs-string">"基于AUTO机制-生产者发送消息-内容为：&#123;&#125;"</span>,info);            &#125;        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            log.error(<span class="hljs-string">"基于AUTO机制-生产者发送消息-发生异常：&#123;&#125;"</span>,info,e.fillInStackTrace());        &#125;    &#125;&#125;</code></pre></div><p>4、开发用于监听消费消息的消费者：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KnowledgeConsumer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(KnowledgeConsumer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"$&#123;mq.auto.knowledge.queue.name&#125;"</span>,containerFactory = <span class="hljs-string">"singleListenerContainerAuto"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeAutoMsg</span><span class="hljs-params">(@Payload <span class="hljs-keyword">byte</span>[] msg)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//监听消费解析消息体</span>            KnowledgeInfo info = objectMapper.readValue(msg, KnowledgeInfo<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            log.info(<span class="hljs-string">"基于AUTO的确认消费模式-消费者监听消费信息-内容为：&#123;&#125;"</span>,info);        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            log.error(<span class="hljs-string">"基于AUTO的确认消费模式-消费者监听消费消息-发生异常："</span>,e.fillInStackTrace());        &#125;    &#125;&#125;</code></pre></div><p>5、测试方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">public</span> KnowledgePublisher knowledgePublisher;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span></span>&#123;        KnowledgeInfo info = <span class="hljs-keyword">new</span> KnowledgeInfo();        info.setId(<span class="hljs-number">10010</span>);        info.setCode(<span class="hljs-string">"auto"</span>);        info.setMode(<span class="hljs-string">"基于AUTO的消息确认消费模式"</span>);        knowledgePublisher.sendAutoMsg(info);    &#125;</code></pre></div><h3 id="5-4-4-基于手动确认消费模式实战"><a href="#5-4-4-基于手动确认消费模式实战" class="headerlink" title="5.4.4 基于手动确认消费模式实战"></a>5.4.4 基于手动确认消费模式实战</h3><p>1、在RabbitmqConfig配置类中创建相关组件，并创建“基于MANUAL手动确认消费模式”对应的消费者所在的监听器容器工厂实例。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 单一消费者-确认模式为MANUAL</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"manualQueue"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">manualQueue</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(env.getProperty(<span class="hljs-string">"mq.manual.knowledge.queue.name"</span>),<span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TopicExchange <span class="hljs-title">manualExchange</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TopicExchange(env.getProperty(<span class="hljs-string">"mq.manual.knowledge.exchange.name"</span>),<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">manualBinding</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(manualQueue()).to(manualExchange())                .with(env.getProperty(<span class="hljs-string">"mq.manual.knowledge.routing.key.name"</span>));    &#125;    <span class="hljs-comment">/**定义手动确认消费模式对应的消费者监听器实例*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> KnowledgeManualConsumer knowledgeManualConsumer;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建消费者监听器容器工厂实例-确认模式为MANUAL，并指定监听的队列和消费者</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"simpleContainerManual"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> SimpleMessageListenerContainer <span class="hljs-title">simpleMessageListenerContainer</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            @Qualifier(<span class="hljs-string">"manualQueue"</span>)</span> Queue manualQueue)</span>&#123;        <span class="hljs-comment">//创建消息监听器容器实例</span>        SimpleMessageListenerContainer container = <span class="hljs-keyword">new</span> SimpleMessageListenerContainer();        <span class="hljs-comment">//设置链接工厂</span>        container.setConnectionFactory(connectionFactory);        <span class="hljs-comment">//设置消息的传输格式-JSON</span>        container.setMessageConverter(<span class="hljs-keyword">new</span> Jackson2JsonMessageConverter());        <span class="hljs-comment">//单一消费者实例配置</span>        container.setConcurrentConsumers(<span class="hljs-number">1</span>);        container.setMaxConcurrentConsumers(<span class="hljs-number">1</span>);        container.setPrefetchCount(<span class="hljs-number">1</span>);        <span class="hljs-comment">//设置消息的确认模式，采用手动确认消费机制</span>        container.setAcknowledgeMode(AcknowledgeMode.MANUAL);        container.setQueues(manualQueue);        <span class="hljs-comment">//指定该容器中消息监听器，即消费者</span>        container.setMessageListener(knowledgeManualConsumer);        <span class="hljs-comment">//返回容器工厂实例</span>        <span class="hljs-keyword">return</span> container;    &#125;</code></pre></div><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment">#确认消费模式为手动确认机制</span><span class="hljs-meta">mq.manual.knowledge.queue.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.manual.knowledge.queue</span><span class="hljs-meta">mq.manual.knowledge.exchange.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.manual.knowledge.exchange</span><span class="hljs-meta">mq.manual.knowledge.routing.key.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.manual.knowledge.routing.key</span></code></pre></div><p>2、消费者，需要实现“RabbitMQ通道确认消息监听器“，即ChannelAwareMessageListener接口，并实现onMessage()方法。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>(<span class="hljs-string">"knowledgeManualConsumer"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KnowledgeManualConsumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ChannelAwareMessageListener</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(KnowledgeManualConsumer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 监听消费消息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 消息实体</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 通道实例</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//获取消息属性</span>        MessageProperties messageProperties = message.getMessageProperties();        <span class="hljs-comment">//获取消息分发时的全局唯一标识</span>        <span class="hljs-keyword">long</span> deliveryTag = messageProperties.getDeliveryTag();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//获得消息体</span>            <span class="hljs-keyword">byte</span>[] msg = message.getBody();            <span class="hljs-comment">//解析消息体</span>            KnowledgeInfo info = objectMapper.readValue(msg, KnowledgeInfo<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            log.info(<span class="hljs-string">"确认消费模式-人为手动确认消费-监听器监听消费消息-内容为：&#123;&#125;"</span>,info);            <span class="hljs-comment">//执行完业务逻辑后，手动进行确认消费，其中第一个参数为：消息的分发标识；第二个参数；是否允许批量确认消费</span>            channel.basicAck(deliveryTag,<span class="hljs-keyword">true</span>);        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            log.info(<span class="hljs-string">"确认消费模式-人为手动确认消费-监听器监听消费消息-发生异常："</span>,e.fillInStackTrace());            <span class="hljs-comment">//如果在处理消息的过程中发生了异常，则依旧需要人为手动确认消费掉该消息，</span>            <span class="hljs-comment">// 否则该消息将一直留在队列中，从而导致消息的重复消费</span>            channel.basicReject(deliveryTag,<span class="hljs-keyword">false</span>);        &#125;    &#125;&#125;</code></pre></div><p>3、生产者</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KnowLedgeManualPublisher</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(KnowLedgeManualPublisher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Environment env;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 基于MANUAL机制-生产者发送消费</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> info</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendAutoMsg</span><span class="hljs-params">(KnowledgeInfo info)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span>(info != <span class="hljs-keyword">null</span>)&#123;                rabbitTemplate.setMessageConverter(<span class="hljs-keyword">new</span> Jackson2JsonMessageConverter());                rabbitTemplate.setExchange(env.getProperty(<span class="hljs-string">"mq.manual.knowledge.exchange.name"</span>));                rabbitTemplate.setRoutingKey(env.getProperty(<span class="hljs-string">"mq.manual.knowledge.routing.key.name"</span>));                <span class="hljs-comment">//创建消息</span>                Message message = MessageBuilder.withBody(objectMapper.writeValueAsBytes(info))                        .setDeliveryMode(MessageDeliveryMode.PERSISTENT)                        .build();                rabbitTemplate.convertAndSend(message);                log.info(<span class="hljs-string">"基于MANUAL机制-生产者发送消息-内容为：&#123;&#125;"</span>,info);            &#125;        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            log.error(<span class="hljs-string">"基于MANUAL机制-生产者发送消息-发生异常：&#123;&#125;"</span>,info,e.fillInStackTrace());        &#125;    &#125;</code></pre></div><p>4、测试方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> KnowLedgeManualPublisher knowLedgeManualPublisher;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span></span>&#123;        KnowledgeInfo info = <span class="hljs-keyword">new</span> KnowledgeInfo();        info.setId(<span class="hljs-number">10011</span>);        info.setCode(<span class="hljs-string">"manual"</span>);        info.setMode(<span class="hljs-string">"基于MANUAL的消息确认消费模式"</span>);        knowLedgeManualPublisher.sendAutoMsg(info);    &#125;</code></pre></div><h2 id="5-5-典型应用场景实战之用户登录成功写日志"><a href="#5-5-典型应用场景实战之用户登录成功写日志" class="headerlink" title="5.5 典型应用场景实战之用户登录成功写日志"></a>5.5 典型应用场景实战之用户登录成功写日志</h2><h3 id="5-5-1-需求分析"><a href="#5-5-1-需求分析" class="headerlink" title="5.5.1 需求分析"></a>5.5.1 需求分析</h3><p>将每次用户登录成功之后的登录信息记入数据库，以便用于相关的日志分析</p><p>整体业务流程包含“登录模块”和“日志记录模块”。</p><h3 id="5-5-2-数据库表设计"><a href="#5-5-2-数据库表设计" class="headerlink" title="5.5.2 数据库表设计"></a>5.5.2 数据库表设计</h3><p>1、进行用户信息表的设计，主要包含用户id，用户名和登录密码等字段。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`user`</span>(  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'用户id'</span>,  <span class="hljs-string">`user_name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'用户名'</span>,  <span class="hljs-string">`password`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'密码'</span>,  <span class="hljs-string">`create_time`</span> datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'创建时间'</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),  <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">KEY</span> <span class="hljs-string">`idx_user_name`</span> (<span class="hljs-string">`user_name`</span>) <span class="hljs-keyword">USING</span> BTREE )<span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">4</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span> = utf8 <span class="hljs-keyword">COMMENT</span> = <span class="hljs-string">'用户信息表'</span>;</code></pre></div><p>2、日志记录表</p><div class="hljs"><pre><code class="hljs java">CREATE TABLE `sys_log`(  `id` <span class="hljs-keyword">int</span>(<span class="hljs-number">11</span>) NOT NULL AUTO_INCREMENT,  `user_id` <span class="hljs-keyword">int</span>(<span class="hljs-number">11</span>) DEFAULT <span class="hljs-string">'0'</span> COMMENT <span class="hljs-string">'用户id'</span>,  `<span class="hljs-keyword">module</span>` varchar(<span class="hljs-number">255</span>) DEFAULT NULL COMMENT <span class="hljs-string">'所属操作模块'</span>,  `data` varchar(<span class="hljs-number">5000</span>) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT <span class="hljs-string">'操作数据'</span>,  `memo` varchar(<span class="hljs-number">5000</span>) CHARACTER SET  utf8mb4 DEFAULT NULL COMMENT <span class="hljs-string">'备注'</span>,  `create_time` datetime DEFAULT NULL COMMENT <span class="hljs-string">'创建时间'</span>,  <span class="hljs-function">PRIMARY <span class="hljs-title">KEY</span> <span class="hljs-params">(`id`)</span></span><span class="hljs-function">)ENGINE</span>=InnoDB AUTO_INCREMENT=<span class="hljs-number">4</span> DEFAULT CHARSET = utf8 COMMENT = <span class="hljs-string">'日志记录表'</span>;</code></pre></div><p>3、对应的实体类，Mapper操作接口以及Mapper.xml</p><p>User类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String userName;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-keyword">private</span> Date createTime;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUserName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> userName;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserName</span><span class="hljs-params">(String userName)</span> </span>&#123;        <span class="hljs-keyword">this</span>.userName = userName == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : userName.trim();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> password;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPassword</span><span class="hljs-params">(String password)</span> </span>&#123;        <span class="hljs-keyword">this</span>.password = password == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : password.trim();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getCreateTime</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> createTime;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCreateTime</span><span class="hljs-params">(Date createTime)</span> </span>&#123;        <span class="hljs-keyword">this</span>.createTime = createTime;    &#125;&#125;</code></pre></div><p>SysLog类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysLog</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> Integer userId;    <span class="hljs-keyword">private</span> String <span class="hljs-keyword">module</span>;    <span class="hljs-keyword">private</span> String data;    <span class="hljs-keyword">private</span> String memo;    <span class="hljs-keyword">private</span> Date createTime;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getUserId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> userId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserId</span><span class="hljs-params">(Integer userId)</span> </span>&#123;        <span class="hljs-keyword">this</span>.userId = userId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getModule</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">module</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setModule</span><span class="hljs-params">(String <span class="hljs-keyword">module</span>)</span> </span>&#123;        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">module</span> = <span class="hljs-keyword">module</span> == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : <span class="hljs-keyword">module</span>.trim();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> data;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(String data)</span> </span>&#123;        <span class="hljs-keyword">this</span>.data = data == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : data.trim();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMemo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> memo;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMemo</span><span class="hljs-params">(String memo)</span> </span>&#123;        <span class="hljs-keyword">this</span>.memo = memo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : memo.trim();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getCreateTime</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> createTime;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCreateTime</span><span class="hljs-params">(Date createTime)</span> </span>&#123;        <span class="hljs-keyword">this</span>.createTime = createTime;    &#125;&#125;</code></pre></div><p>User类对应的Mapper接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteByPrimaryKey</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(User record)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertSelective</span><span class="hljs-params">(User record)</span></span>;    <span class="hljs-function">User <span class="hljs-title">selectByPrimaryKey</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKeySelective</span><span class="hljs-params">(User record)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKey</span><span class="hljs-params">(User record)</span></span>;    <span class="hljs-function">User <span class="hljs-title">selectByUserNamePassword</span><span class="hljs-params">(@Param(<span class="hljs-string">"userName"</span>)</span> String userName, @<span class="hljs-title">Param</span><span class="hljs-params">(<span class="hljs-string">"password"</span>)</span> String password)</span>;&#125;</code></pre></div><p>UserMapper.xml：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.debug.middleware.model.mapper.UserMapper"</span> &gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"BaseResultMap"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.debug.middleware.model.entity.User"</span> &gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"INTEGER"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"user_name"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userName"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"VARCHAR"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"VARCHAR"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"create_time"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"createTime"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"TIMESTAMP"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"Base_Column_List"</span> &gt;</span>        id, user_name, password, create_time    <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectByPrimaryKey"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"BaseResultMap"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"java.lang.Integer"</span> &gt;</span>        select        <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">"Base_Column_List"</span> /&gt;</span>        from user        where id = #&#123;id,jdbcType=INTEGER&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"deleteByPrimaryKey"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"java.lang.Integer"</span> &gt;</span>        delete from user        where id = #&#123;id,jdbcType=INTEGER&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"insert"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.debug.middleware.model.entity.User"</span> &gt;</span>        insert into user (id, user_name, password,                          create_time)        values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;userName,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;,                #&#123;createTime,jdbcType=TIMESTAMP&#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"insertSelective"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.debug.middleware.model.entity.User"</span> &gt;</span>        insert into user        <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"("</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">")"</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">","</span> &gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"id != null"</span> &gt;</span>                id,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"userName != null"</span> &gt;</span>                user_name,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"password != null"</span> &gt;</span>                password,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"createTime != null"</span> &gt;</span>                create_time,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"values ("</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">")"</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">","</span> &gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"id != null"</span> &gt;</span>                #&#123;id,jdbcType=INTEGER&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"userName != null"</span> &gt;</span>                #&#123;userName,jdbcType=VARCHAR&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"password != null"</span> &gt;</span>                #&#123;password,jdbcType=VARCHAR&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"createTime != null"</span> &gt;</span>                #&#123;createTime,jdbcType=TIMESTAMP&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"updateByPrimaryKeySelective"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.debug.middleware.model.entity.User"</span> &gt;</span>        update user        <span class="hljs-tag">&lt;<span class="hljs-name">set</span> &gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"userName != null"</span> &gt;</span>                user_name = #&#123;userName,jdbcType=VARCHAR&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"password != null"</span> &gt;</span>                password = #&#123;password,jdbcType=VARCHAR&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"createTime != null"</span> &gt;</span>                create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>        where id = #&#123;id,jdbcType=INTEGER&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"updateByPrimaryKey"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.debug.middleware.model.entity.User"</span> &gt;</span>        update user        set user_name = #&#123;userName,jdbcType=VARCHAR&#125;,            password = #&#123;password,jdbcType=VARCHAR&#125;,            create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;        where id = #&#123;id,jdbcType=INTEGER&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>    <span class="hljs-comment">&lt;!--根据用户名、密码查询--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectByUserNamePassword"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"com.debug.middleware.model.entity.User"</span>&gt;</span>        SELECT <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">"Base_Column_List"</span>/&gt;</span>        FROM user WHERE user_name=#&#123;userName&#125; AND password=#&#123;password&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><p>SysLog对应的Mapper操作接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysLogMapper</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteByPrimaryKey</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(SysLog record)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertSelective</span><span class="hljs-params">(SysLog record)</span></span>;    <span class="hljs-function">SysLog <span class="hljs-title">selectByPrimaryKey</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKeySelective</span><span class="hljs-params">(SysLog record)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKey</span><span class="hljs-params">(SysLog record)</span></span>;&#125;</code></pre></div><p>SysLogMapper.xml</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-comment">&lt;!--xml头部定义--&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span><span class="hljs-comment">&lt;!--SysLogMapper操作接口所在的命名空间--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.debug.middleware.model.mapper.SysLogMapper"</span> &gt;</span>    <span class="hljs-comment">&lt;!--查询得到的结果集映射配置--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"BaseResultMap"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.debug.middleware.model.entity.SysLog"</span> &gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"INTEGER"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"user_id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userId"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"INTEGER"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"VARCHAR"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"data"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"data"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"VARCHAR"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"memo"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"memo"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"VARCHAR"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"create_time"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"createTime"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"TIMESTAMP"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>    <span class="hljs-comment">&lt;!--定义查询的SQL片段--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"Base_Column_List"</span> &gt;</span>        id, user_id, module, data, memo, create_time    <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span>    <span class="hljs-comment">&lt;!--根据主键id查询日志记录--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectByPrimaryKey"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"BaseResultMap"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"java.lang.Integer"</span> &gt;</span>        select        <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">"Base_Column_List"</span> /&gt;</span>        from sys_log        where id = #&#123;id,jdbcType=INTEGER&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-comment">&lt;!--根据主键id删除日志记录--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"deleteByPrimaryKey"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"java.lang.Integer"</span> &gt;</span>        delete from sys_log        where id = #&#123;id,jdbcType=INTEGER&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span>    <span class="hljs-comment">&lt;!--插入日志记录--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"insert"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.debug.middleware.model.entity.SysLog"</span> &gt;</span>        insert into sys_log (id, user_id, module,                             data, memo, create_time                )        values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;userId,jdbcType=INTEGER&#125;, #&#123;module,jdbcType=VARCHAR&#125;,                #&#123;data,jdbcType=VARCHAR&#125;, #&#123;memo,jdbcType=VARCHAR&#125;, #&#123;createTime,jdbcType=TIMESTAMP&#125;                       )    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>    <span class="hljs-comment">&lt;!--插入日志记录--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"insertSelective"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.debug.middleware.model.entity.SysLog"</span> &gt;</span>        insert into sys_log        <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"("</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">")"</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">","</span> &gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"id != null"</span> &gt;</span>                id,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"userId != null"</span> &gt;</span>                user_id,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"module != null"</span> &gt;</span>                module,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"data != null"</span> &gt;</span>                data,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"memo != null"</span> &gt;</span>                memo,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"createTime != null"</span> &gt;</span>                create_time,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"values ("</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">")"</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">","</span> &gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"id != null"</span> &gt;</span>                #&#123;id,jdbcType=INTEGER&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"userId != null"</span> &gt;</span>                #&#123;userId,jdbcType=INTEGER&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"module != null"</span> &gt;</span>                #&#123;module,jdbcType=VARCHAR&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"data != null"</span> &gt;</span>                #&#123;data,jdbcType=VARCHAR&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"memo != null"</span> &gt;</span>                #&#123;memo,jdbcType=VARCHAR&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"createTime != null"</span> &gt;</span>                #&#123;createTime,jdbcType=TIMESTAMP&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>    <span class="hljs-comment">&lt;!--更新日志记录--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"updateByPrimaryKeySelective"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.debug.middleware.model.entity.SysLog"</span> &gt;</span>        update sys_log        <span class="hljs-tag">&lt;<span class="hljs-name">set</span> &gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"userId != null"</span> &gt;</span>                user_id = #&#123;userId,jdbcType=INTEGER&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"module != null"</span> &gt;</span>                module = #&#123;module,jdbcType=VARCHAR&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"data != null"</span> &gt;</span>                data = #&#123;data,jdbcType=VARCHAR&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"memo != null"</span> &gt;</span>                memo = #&#123;memo,jdbcType=VARCHAR&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"createTime != null"</span> &gt;</span>                create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>        where id = #&#123;id,jdbcType=INTEGER&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>    <span class="hljs-comment">&lt;!--更新日志记录--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"updateByPrimaryKey"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.debug.middleware.model.entity.SysLog"</span> &gt;</span>        update sys_log        set user_id = #&#123;userId,jdbcType=INTEGER&#125;,            module = #&#123;module,jdbcType=VARCHAR&#125;,            data = #&#123;data,jdbcType=VARCHAR&#125;,            memo = #&#123;memo,jdbcType=VARCHAR&#125;,            create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;        where id = #&#123;id,jdbcType=INTEGER&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><h3 id="5-5-3-开发环境搭建"><a href="#5-5-3-开发环境搭建" class="headerlink" title="5.5.3 开发环境搭建"></a>5.5.3 开发环境搭建</h3><p>1、定义用户单击登录按钮时，后端需要接收的用户登录信息</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserLoginDto</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-meta">@NotBlank</span>    <span class="hljs-keyword">private</span> String userName;    <span class="hljs-meta">@NotBlank</span>    <span class="hljs-keyword">private</span> String password;    <span class="hljs-keyword">private</span> Integer userId;&#125;</code></pre></div><p>2、开发“接收并处理用户登录实体信息”的控制器UserController，主要用于校验前端用户提交的相关登录信息，并将校验通过后的数据传递给Service层进行处理：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(UserController<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">//前端请求前缀</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String prefix = <span class="hljs-string">"user"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 注入用户操作Service层实例</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserService userService;    <span class="hljs-meta">@RequestMapping</span>(value = prefix+<span class="hljs-string">"/login"</span>,method = RequestMethod.POST,consumes = MediaType.APPLICATION_JSON_UTF8_VALUE)    <span class="hljs-function"><span class="hljs-keyword">public</span> BaseResponse <span class="hljs-title">login</span><span class="hljs-params">(@RequestBody @Validated UserLoginDto dto, BindingResult result)</span></span>&#123;        <span class="hljs-comment">//校验前端用户提交的用户登录信息的合法性</span>        <span class="hljs-keyword">if</span>(result.hasErrors())&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BaseResponse(StatusCode.InvalidParams);        &#125;        <span class="hljs-comment">//定义返回结果实例</span>        BaseResponse response = <span class="hljs-keyword">new</span> BaseResponse(StatusCode.Success);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//调用Service层方法真正处理用户登录逻辑</span>            Boolean res = userService.login(dto);            <span class="hljs-keyword">if</span>(res)&#123;                response = <span class="hljs-keyword">new</span> BaseResponse(StatusCode.Success.getCode(),<span class="hljs-string">"登录成功"</span>);            &#125;<span class="hljs-keyword">else</span> &#123;                response = <span class="hljs-keyword">new</span> BaseResponse(StatusCode.Fail.getCode(),<span class="hljs-string">"登录失败-账户名密码不匹配"</span>);            &#125;        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            <span class="hljs-comment">//表示处理过程发生异常</span>            response = <span class="hljs-keyword">new</span> BaseResponse(StatusCode.Fail.getCode(),e.getMessage());        &#125;        <span class="hljs-keyword">return</span> response;    &#125;&#125;</code></pre></div><p>3、开发用户登录服务UserService类相关功能</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(UserService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 注入用户实体类对应的Mapper操作接口</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserMapper userMapper;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 日志生产者-用于发送登录成功后相关用户消息</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> LogPublisher logPublisher;    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">login</span><span class="hljs-params">(UserLoginDto dto)</span></span>&#123;        <span class="hljs-comment">//根据用户名和密码查询用户实体记录</span>        User user = userMapper.selectByUserNamePassword(dto.getUserName(),dto.getPassword());        <span class="hljs-keyword">if</span>(user!=<span class="hljs-keyword">null</span>)&#123;            dto.setUserId(user.getId());            logPublisher.sendLogMsg(dto);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;&#125;</code></pre></div><h3 id="5-5-4-基于TopicExchange构建日志消息模型"><a href="#5-5-4-基于TopicExchange构建日志消息模型" class="headerlink" title="5.5.4 基于TopicExchange构建日志消息模型"></a>5.5.4 基于TopicExchange构建日志消息模型</h3><p>用户登录成功之后将相关的用户登录信息通过RabbitMQ的消息队列异步写入数据库中，相关配置如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 用户登录成功写日志消息模型创建</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"loginQueue"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">loginQueue</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(env.getProperty(<span class="hljs-string">"mq.login.queue.name"</span>),<span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TopicExchange <span class="hljs-title">loginExchange</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TopicExchange(env.getProperty(<span class="hljs-string">"mq.login.exchange.name"</span>),<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">loginBinding</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(loginQueue()).to(loginExchange())                .with(env.getProperty(<span class="hljs-string">"mq.login.routing.key.name"</span>));    &#125;</code></pre></div><p>取值：</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment">#用户登录成功写日志消息模型</span><span class="hljs-meta">mq.login.queue.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.login.queue</span><span class="hljs-meta">mq.login.exchange.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.login.exchange</span><span class="hljs-meta">mq.login.routing.key.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.login.routing.key</span></code></pre></div><h3 id="5-5-5-异步发送接收登录日志消息实战"><a href="#5-5-5-异步发送接收登录日志消息实战" class="headerlink" title="5.5.5 异步发送接收登录日志消息实战"></a>5.5.5 异步发送接收登录日志消息实战</h3><p>用户登录成功后将相关登录信息异步写入数据库，即在LogPublisher类中开发相应的方法，用于将相关消息发送给RabbitMQ队列，并被相应的消费者监听消费。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogPublisher</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(LogPublisher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义RabbitMQ操作组件</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-comment">/**定义环境变量读取实例env*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Environment env;    <span class="hljs-comment">/**定义JSON序列化和反序列化组件*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendLogMsg</span><span class="hljs-params">(UserLoginDto loginDto)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//设置消息传输格式-JSON</span>            rabbitTemplate.setMessageConverter(<span class="hljs-keyword">new</span> Jackson2JsonMessageConverter());            <span class="hljs-comment">//设置交换机</span>            rabbitTemplate.setExchange(env.getProperty(<span class="hljs-string">"mq.login.exchange.name"</span>));            <span class="hljs-comment">//设置路由</span>            rabbitTemplate.setRoutingKey(env.getProperty(<span class="hljs-string">"mq.login.routing.key.name"</span>));            <span class="hljs-comment">//发送消息</span>            rabbitTemplate.convertAndSend(loginDto, <span class="hljs-keyword">new</span> MessagePostProcessor() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> Message <span class="hljs-title">postProcessMessage</span><span class="hljs-params">(Message message)</span> <span class="hljs-keyword">throws</span> AmqpException </span>&#123;                    <span class="hljs-comment">//获取消息属性</span>                    MessageProperties messageProperties = message.getMessageProperties();                    <span class="hljs-comment">//设置消息的持久化模式为持久化</span>                    messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);                    <span class="hljs-comment">//设置消息头，表示传输的消息直接指定为某个类实例，</span>                    <span class="hljs-comment">// 消费者在监听消费时可以直接定义该类对象参数进行接收即可</span>                    messageProperties.setHeader(AbstractJavaTypeMapper                                      .DEFAULT_CONTENT_CLASSID_FIELD_NAME,UserLoginDto<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;                    <span class="hljs-keyword">return</span> message;                &#125;            &#125;);            log.info(<span class="hljs-string">"系统日志记录-生产者-将登陆成功后的用户相关信息发送给队列-内容：&#123;&#125;"</span>,loginDto);        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            log.error(<span class="hljs-string">"系统日志记录-生产者-将登陆成功后的用户相关信息发送给队列-发生异常：&#123;&#125;"</span>,loginDto,e.fillInStackTrace());        &#125;    &#125;&#125;</code></pre></div><p>开发“用户登录成功写日志”队列对应的消费者的相关功能</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogConsumer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(LogConsumer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">//定义系统日志服务实例</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SysLogService sysLogService;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 监听消费并处理用户登录成功后的消息</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"$&#123;mq.login.queue.name&#125;"</span>,containerFactory = <span class="hljs-string">"singleListenerContainer"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeMsg</span><span class="hljs-params">(@Payload UserLoginDto loginDto)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            log.info(<span class="hljs-string">"系统日志记录-消费者-监听消费用户登录成功后的消息=内容：&#123;&#125;"</span>,loginDto);            <span class="hljs-comment">//调用日志记录服务-用于记录用户登录成功后将相关登录信息记入数据库</span>            sysLogService.recordLog(loginDto);        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            log.error(<span class="hljs-string">"系统日志记录-消费者-监听消费用户登录成功后的的消息-发生异常：&#123;&#125;"</span>,loginDto,e.fillInStackTrace());        &#125;    &#125;&#125;</code></pre></div><p>SysLogService类为记录系统日志服务，主要是将相关日志信息记入数据库：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-meta">@EnableAsync</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysLogService</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(SysLogService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/**定义系统日志操作接口Mapper*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SysLogMapper sysLogMapper;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将用户登录成功的信息记入数据库</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recordLog</span><span class="hljs-params">(UserLoginDto dto)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//定义系统日志对象，并设置相应字段的取值</span>            SysLog entity = <span class="hljs-keyword">new</span> SysLog();            entity.setUserId(dto.getUserId());            entity.setModule(<span class="hljs-string">"用户登录模块"</span>);            entity.setData(objectMapper.writeValueAsString(dto));            entity.setMemo(<span class="hljs-string">"用户登录成功记录相关登录信息"</span>);            entity.setCreateTime(<span class="hljs-keyword">new</span> Date());            <span class="hljs-comment">//插入数据库</span>            sysLogMapper.insertSelective(entity);        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            log.error(<span class="hljs-string">"系统日志服务-记录用户登录成功的信息入数据库-发生异常：&#123;&#125;"</span>,dto,e.fillInStackTrace());        &#125;    &#125;&#125;</code></pre></div><h3 id="5-5-6-整体业务模块自测实战"><a href="#5-5-6-整体业务模块自测实战" class="headerlink" title="5.5.6 整体业务模块自测实战"></a>5.5.6 整体业务模块自测实战</h3><p>1、打开Postman，在地址栏输入<a href="http://127.0.0.1:8087/middleware/user/login，请求方法为POST，选择Body为JSON，请求体中" target="_blank" rel="noopener">http://127.0.0.1:8087/middleware/user/login，请求方法为POST，选择Body为JSON，请求体中</a> 参数userName：jack，password：123456</p><p>2、将用户名和登录密码等信息提前在数据库表user中输入，充当“测试数据”。</p><h1 id="第6章-死信队列-延迟队列实战"><a href="#第6章-死信队列-延迟队列实战" class="headerlink" title="第6章 死信队列/延迟队列实战"></a>第6章 死信队列/延迟队列实战</h1><h2 id="6-1-死信队列概述"><a href="#6-1-死信队列概述" class="headerlink" title="6.1 死信队列概述"></a>6.1 死信队列概述</h2><h3 id="6-1-1-死信队列简介与作用"><a href="#6-1-1-死信队列简介与作用" class="headerlink" title="6.1.1 死信队列简介与作用"></a>6.1.1 死信队列简介与作用</h3><p>死信队列又称延迟队列、延时队列，即进入该队列中的消息会被延迟消费的队列。</p><p>RabbitMQ的引入主要是替代了传统处理流程的“定时器”处理逻辑，利用死信队列来进行处理。</p><h2 id="6-2-RabbitMQ死信队列实战"><a href="#6-2-RabbitMQ死信队列实战" class="headerlink" title="6.2 RabbitMQ死信队列实战"></a>6.2 RabbitMQ死信队列实战</h2><p>死信队列占用系统资源少，不需要轮询数据库获取数据，减少DB层面资源的消耗，人为干预很少，只需要搭建好死信队列模型即可，而且会自动消费处理。</p><h3 id="6-2-1-死信队列专有词汇介绍"><a href="#6-2-1-死信队列专有词汇介绍" class="headerlink" title="6.2.1 死信队列专有词汇介绍"></a>6.2.1 死信队列专有词汇介绍</h3><ul><li>DLX：死信交换机</li><li>DLK：死信路由</li><li>TTL：进入死信队列中的消息可以存活的时间</li></ul><h3 id="6-2-2-死信队列消息模型实战"><a href="#6-2-2-死信队列消息模型实战" class="headerlink" title="6.2.2 死信队列消息模型实战"></a>6.2.2 死信队列消息模型实战</h3><p>生产者生产的消息首先到达第一个中转站（即基本交换机），由于基本交换机和基本路由绑定，并对应到指定的“死信队列”，因而消息将进入第一个暂存区，即“死信队列”中，当存活时间一到，消息将进入第二个中转站，即“真正的消息模型”中的死信交换机，然后直接被路由到第二个暂存区，即“真正的队列”中最终该消息被“真正的队列”对应的消费者监听消费。</p><p>基本交换机和基本路由绑定死信队列，死信交换机和死信路由绑定真正的队列。</p><p>1、DeadInfo实体类充当“消息”</p><p>2、在RabbitmqConfig配置类中创建包含死信队列的基本消息模型和包含真正队列的真正消息模型：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 死信队列消息模型构建</span><span class="hljs-comment">     */</span>    <span class="hljs-comment">/**创建死信队列*/</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">basicDeadQueue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//创建死信队列的组成成分map，用于存放组成成分的相关成员</span>        Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-comment">//创建死信交换机</span>        args.put(<span class="hljs-string">"x-dead-letter-exchange"</span>,env.getProperty(<span class="hljs-string">"mq.dead.exchange.name"</span>));        <span class="hljs-comment">//创建死信路由</span>        args.put(<span class="hljs-string">"x-dead-letter-routing-key"</span>,env.getProperty(<span class="hljs-string">"mq.dead.routing.key.name"</span>));        <span class="hljs-comment">//设定TTL，单位为ms，在这里指10s</span>        args.put(<span class="hljs-string">"x-message-ttl"</span>,<span class="hljs-number">10000</span>);        <span class="hljs-comment">//创建并返回死信队列实例</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(env.getProperty(<span class="hljs-string">"mq.dead.queue.name"</span>),<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,args);    &#125;    <span class="hljs-comment">/**创建“基本消息模型”的基本交换机-面向生产者*/</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TopicExchange <span class="hljs-title">basicProducerExchange</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//创建并返回基本交换机实例</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TopicExchange(env.getProperty(<span class="hljs-string">"mq.producer.basic.exchange.name"</span>),<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-comment">/**创建“基本消息模型”的基本绑定-基本交换机+基本路由 -面向生产者*/</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">basicProducerBingding</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(basicQueue()).to(basicExchange())                .with(env.getProperty(<span class="hljs-string">"mq.producer.basic.routing.key.name"</span>));    &#125;    <span class="hljs-comment">/**创建真正的队列-面向消费者*/</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">realConsumerQueue</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(env.getProperty(<span class="hljs-string">"mq.consumer.real.queue.name"</span>),<span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-comment">/**创建死信交换机*/</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TopicExchange <span class="hljs-title">basicDeadExchange</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TopicExchange(env.getProperty(<span class="hljs-string">"mq.dead.exchange.name"</span>),<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-comment">/**创建死信路由及其绑定*/</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">basicDeadBinding</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(realConsumerQueue()).to(basicDeadExchange())                .with(env.getProperty(<span class="hljs-string">"mq.dead.routing.key.name"</span>));    &#125;</code></pre></div><p>3、环境变量实例env取值如下：</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment">#死信队列消息模型</span><span class="hljs-comment">#定义死信队列的名称</span><span class="hljs-meta">mq.dead.queue.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.dead.queue</span><span class="hljs-comment">#定义死信交换机的名称</span><span class="hljs-meta">mq.dead.exchange.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.dead.exchange</span><span class="hljs-comment">#定义死信路由的名称</span><span class="hljs-meta">mq.dead.routing.key.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.dead.routing.key</span><span class="hljs-comment">#定义“基本消息模型”中的基本交换机的名称</span><span class="hljs-meta">mq.producer.basic.exchange.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.producer.basic.exchange</span><span class="hljs-comment">#定义“基本消息模型”中的基本路由名称</span><span class="hljs-meta">mq.producer.basic.routing.key.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.producer.baic.routing.key</span><span class="hljs-comment">#定义面向消费者真正的队列名称</span><span class="hljs-meta">mq.consumer.real.queue.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.consumer.real.queue</span></code></pre></div><p>4、运行项目，在浏览器地址栏中输入<a href="http://127.0.0.1:15672并回车，输入账号和密码后，查看死信队列和真正的队列。">http://127.0.0.1:15672并回车，输入账号和密码后，查看死信队列和真正的队列。</a></p><h3 id="6-2-3-死信队列延迟发送消息实战"><a href="#6-2-3-死信队列延迟发送消息实战" class="headerlink" title="6.2.3 死信队列延迟发送消息实战"></a>6.2.3 死信队列延迟发送消息实战</h3><p>1、开发用于生产、发送消息的生产者DeadPublisher类，主要是将实体对象充当消息发送到“基本消息模型’中</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadPublisher</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(DeadPublisher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/**定义环境变量*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Environment env;    <span class="hljs-comment">/**定义RabbitMQ操作组件*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-comment">/**定义JSON序列化和反序列化组件实例*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-comment">/**发送对象类型的消息给死信队列*/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(DeadInfo info)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//设置消息的传输格式为JSON</span>            rabbitTemplate.setMessageConverter(<span class="hljs-keyword">new</span> Jackson2JsonMessageConverter());            <span class="hljs-comment">//设置基本的交换机</span>            rabbitTemplate.setExchange(env.getProperty(<span class="hljs-string">"mq.producer.basic.exchange.name"</span>));            <span class="hljs-comment">//设置基本路由</span>            rabbitTemplate.setRoutingKey(env.getProperty(<span class="hljs-string">"mq.producer.basic.routing.key.name"</span>));            <span class="hljs-comment">//发送对象类型的消息</span>            rabbitTemplate.convertAndSend(info, <span class="hljs-keyword">new</span> MessagePostProcessor() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> Message <span class="hljs-title">postProcessMessage</span><span class="hljs-params">(Message message)</span> <span class="hljs-keyword">throws</span> AmqpException </span>&#123;                    <span class="hljs-comment">//获取消息属性对象</span>                    MessageProperties messageProperties = message.getMessageProperties();                    <span class="hljs-comment">//设置消息的持久化策略</span>                    messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);                    <span class="hljs-comment">//设置消息头，即直接指定发送的消息所属的对象类型</span>                    messageProperties.setHeader(AbstractJavaTypeMapper                                                .DEFAULT_CONTENT_CLASSID_FIELD_NAME,DeadInfo<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;                    <span class="hljs-comment">//设置消息的TTL，当消息和队列都设置了TTL时，则取较短时间的值</span>                    <span class="hljs-comment">//messageProperties.setExpiration(String.valueOf(10000));</span>                    <span class="hljs-comment">//返回消息实例</span>                    <span class="hljs-keyword">return</span> message;                &#125;            &#125;);            <span class="hljs-comment">//打印日志</span>            log.info(<span class="hljs-string">"死信队列实例-发送对象类型的消息入死信队列-内容为：&#123;&#125;"</span>,info);        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            log.error(<span class="hljs-string">"死信队列实例-发送对象类型的消息入死信队列-发生异常：&#123;&#125;"</span>,info,e.fillInStackTrace());        &#125;    &#125;&#125;</code></pre></div><p>2、消费者</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadConsumer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(DeadConsumer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"$&#123;mq.consumer.real.queue.name&#125;"</span>,containerFactory = <span class="hljs-string">"singleListenerContainer"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeMsg</span><span class="hljs-params">(@Payload DeadInfo info)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            log.info(<span class="hljs-string">"死信队列实战-监听真正的队列-消费队列中的消息，监听到消息内容为：&#123;&#125;"</span>,info);            <span class="hljs-comment">//TODO：用于执行后续的相关业务逻辑</span>                    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            log.error(<span class="hljs-string">"死信队列实战-监听真正的队列-消费队列中的消息 - 面向消费者发生异常：&#123;&#125;"</span>,info,e.fillInStackTrace());        &#125;    &#125;&#125;</code></pre></div><p>3、测试</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**定义死信队列消息模型生产者实例*/</span>   <span class="hljs-meta">@Autowired</span>   <span class="hljs-keyword">private</span> DeadPublisher deadPublisher;   <span class="hljs-meta">@Test</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test8</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;       DeadInfo info = <span class="hljs-keyword">new</span> DeadInfo(<span class="hljs-number">1</span>,<span class="hljs-string">"~~我是第一则消息~~"</span>);       deadPublisher.sendMsg(info);       info = <span class="hljs-keyword">new</span> DeadInfo(<span class="hljs-number">2</span>,<span class="hljs-string">"~~我是第二则消息~~"</span>);       deadPublisher.sendMsg(info);       Thread.sleep(<span class="hljs-number">30000</span>);   &#125;</code></pre></div><h2 id="6-3-典型应用场景实战之商城平台订单支付超时"><a href="#6-3-典型应用场景实战之商城平台订单支付超时" class="headerlink" title="6.3 典型应用场景实战之商城平台订单支付超时"></a>6.3 典型应用场景实战之商城平台订单支付超时</h2><h3 id="6-3-1-整体业务场景介绍"><a href="#6-3-1-整体业务场景介绍" class="headerlink" title="6.3.1 整体业务场景介绍"></a>6.3.1 整体业务场景介绍</h3><p>实现“自动检测用户下单记录是否已经超过了支付时间”</p><h3 id="6-3-2-整体业务流程分析"><a href="#6-3-2-整体业务流程分析" class="headerlink" title="6.3.2 整体业务流程分析"></a>6.3.2 整体业务流程分析</h3><p>该业务场景主要由三大核心业务流程组成：</p><ul><li>用户下单：将用户下单记录存储至数据库，设置支付状态为“已保存”</li><li>死信队列发送和延迟监听下单记录：实现自动监听超时支付的消息记录</li><li>更新用户下单记录状态：当监听到消息记录时查询并决定是否需要更新下单记录状态，如果状态仍为“已保存”，则说明未付款，将该状态更新为“已失效”。</li></ul><h3 id="6-3-3-数据库设计"><a href="#6-3-3-数据库设计" class="headerlink" title="6.3.3 数据库设计"></a>6.3.3 数据库设计</h3><p>用户下单记录表，用来记录用户的下单历史记录</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`user_order`</span> (  <span class="hljs-string">`id`</span>          <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>)      <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,  <span class="hljs-string">`order_no`</span>    <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>  <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'订单编号'</span>,  <span class="hljs-string">`user_id`</span>     <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>)      <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>  <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'用户id'</span>,  <span class="hljs-string">`status`</span>      <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>)               <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>  <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'状态（1=已保存，2=已付款，3=已取消）'</span>,  <span class="hljs-string">`is_active`</span>   <span class="hljs-built_in">int</span>(<span class="hljs-number">255</span>)              <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'1'</span>  <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'是否有效（1=有效，0=失效）'</span>,  <span class="hljs-string">`create_time`</span> datetime              <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`update_time`</span> datetime              <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>))  <span class="hljs-keyword">ENGINE</span> = <span class="hljs-keyword">InnoDB</span>  <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span> = utf8  <span class="hljs-keyword">COMMENT</span> = <span class="hljs-string">'用户下单记录表'</span></code></pre></div><p>RabbitMQ失效下单记录的历史记录表</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`mq_order`</span> (  <span class="hljs-string">`id`</span>            <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,  <span class="hljs-string">`order_id`</span>      <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>  <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'下单记录id'</span>,  <span class="hljs-string">`business_time`</span> datetime         <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>  <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'失效下单记录的时间'</span>,  <span class="hljs-string">`memo`</span>          <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>)     <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>  <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'备注信息'</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>))  <span class="hljs-keyword">ENGINE</span> = <span class="hljs-keyword">InnoDB</span>  <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span> = utf8  <span class="hljs-keyword">COMMENT</span> = <span class="hljs-string">'RabbitMQ失效下单记录的历史记录表'</span></code></pre></div><p>1、UserOrder，用户下单实体类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserOrder</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String orderNo;    <span class="hljs-keyword">private</span> Integer userId;    <span class="hljs-keyword">private</span> Integer status;    <span class="hljs-keyword">private</span> Integer isActive;    <span class="hljs-keyword">private</span> Date createTime;    <span class="hljs-keyword">private</span> Date updateTime;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getOrderNo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> orderNo;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOrderNo</span><span class="hljs-params">(String orderNo)</span> </span>&#123;        <span class="hljs-keyword">this</span>.orderNo = orderNo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : orderNo.trim();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getUserId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> userId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserId</span><span class="hljs-params">(Integer userId)</span> </span>&#123;        <span class="hljs-keyword">this</span>.userId = userId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> status;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(Integer status)</span> </span>&#123;        <span class="hljs-keyword">this</span>.status = status;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getIsActive</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> isActive;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setIsActive</span><span class="hljs-params">(Integer isActive)</span> </span>&#123;        <span class="hljs-keyword">this</span>.isActive = isActive;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getCreateTime</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> createTime;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCreateTime</span><span class="hljs-params">(Date createTime)</span> </span>&#123;        <span class="hljs-keyword">this</span>.createTime = createTime;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getUpdateTime</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> updateTime;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUpdateTime</span><span class="hljs-params">(Date updateTime)</span> </span>&#123;        <span class="hljs-keyword">this</span>.updateTime = updateTime;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"UserOrder&#123;"</span> +                <span class="hljs-string">"id="</span> + id +                <span class="hljs-string">", orderNo='"</span> + orderNo + <span class="hljs-string">'\''</span> +                <span class="hljs-string">", userId="</span> + userId +                <span class="hljs-string">", status="</span> + status +                <span class="hljs-string">", isActive="</span> + isActive +                <span class="hljs-string">", createTime="</span> + createTime +                <span class="hljs-string">", updateTime="</span> + updateTime +                <span class="hljs-string">'&#125;'</span>;    &#125;&#125;</code></pre></div><p>MqOrder类，RabbitMQ死信队列更新失效订单的状态实体</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MqOrder</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id; <span class="hljs-comment">//主键id</span>    <span class="hljs-keyword">private</span> Integer orderId; <span class="hljs-comment">//下单记录id</span>    <span class="hljs-keyword">private</span> Date businessTime; <span class="hljs-comment">//失效下单记录状态的业务时间</span>    <span class="hljs-keyword">private</span> String memo; <span class="hljs-comment">//备注信息</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getOrderId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> orderId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOrderId</span><span class="hljs-params">(Integer orderId)</span> </span>&#123;        <span class="hljs-keyword">this</span>.orderId = orderId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getBusinessTime</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> businessTime;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBusinessTime</span><span class="hljs-params">(Date businessTime)</span> </span>&#123;        <span class="hljs-keyword">this</span>.businessTime = businessTime;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMemo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> memo;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMemo</span><span class="hljs-params">(String memo)</span> </span>&#123;        <span class="hljs-keyword">this</span>.memo = memo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : memo.trim();    &#125;&#125;</code></pre></div><p>2、MqOrderMapper</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MqOrderMapper</span> </span>&#123;    <span class="hljs-comment">/**根据主键id删除记录*/</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteByPrimaryKey</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-comment">/**插入记录*/</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(MqOrder record)</span></span>;    <span class="hljs-comment">/**插入记录*/</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertSelective</span><span class="hljs-params">(MqOrder record)</span></span>;    <span class="hljs-comment">/**根据主键id查询记录*/</span>    <span class="hljs-function">MqOrder <span class="hljs-title">selectByPrimaryKey</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-comment">/**更新记录*/</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKeySelective</span><span class="hljs-params">(MqOrder record)</span></span>;    <span class="hljs-comment">/**更新记录*/</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKey</span><span class="hljs-params">(MqOrder record)</span></span>;&#125;</code></pre></div><p>对应的MqOrderMapper.xml代码如下：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-comment">&lt;!--xml文档类型定义--&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span><span class="hljs-comment">&lt;!--Mapper操作接口--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.debug.middleware.model.mapper.MqOrderMapper"</span> &gt;</span>  <span class="hljs-comment">&lt;!--Mapper查询结果集映射--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"BaseResultMap"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.debug.middleware.model.entity.MqOrder"</span> &gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"INTEGER"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"order_id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"orderId"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"INTEGER"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"business_time"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"businessTime"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"TIMESTAMP"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"memo"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"memo"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"VARCHAR"</span> /&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>  <span class="hljs-comment">&lt;!--Mapper查询SQL片段定义--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"Base_Column_List"</span> &gt;</span>    id, order_id, business_time, memo  <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据主键id查询--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectByPrimaryKey"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"BaseResultMap"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"java.lang.Integer"</span> &gt;</span>    select     <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">"Base_Column_List"</span> /&gt;</span>    from mq_order    where id = #&#123;id,jdbcType=INTEGER&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据主键id删除--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"deleteByPrimaryKey"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"java.lang.Integer"</span> &gt;</span>    delete from mq_order    where id = #&#123;id,jdbcType=INTEGER&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span>  <span class="hljs-comment">&lt;!--插入记录--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"insert"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.debug.middleware.model.entity.MqOrder"</span> &gt;</span>    insert into mq_order (id, order_id, business_time,       memo)    values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;orderId,jdbcType=INTEGER&#125;, #&#123;businessTime,jdbcType=TIMESTAMP&#125;,       #&#123;memo,jdbcType=VARCHAR&#125;)  <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>  <span class="hljs-comment">&lt;!--插入记录--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"insertSelective"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.debug.middleware.model.entity.MqOrder"</span> &gt;</span>    insert into mq_order    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"("</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">")"</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">","</span> &gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"id != null"</span> &gt;</span>        id,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"orderId != null"</span> &gt;</span>        order_id,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"businessTime != null"</span> &gt;</span>        business_time,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"memo != null"</span> &gt;</span>        memo,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"values ("</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">")"</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">","</span> &gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"id != null"</span> &gt;</span>        #&#123;id,jdbcType=INTEGER&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"orderId != null"</span> &gt;</span>        #&#123;orderId,jdbcType=INTEGER&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"businessTime != null"</span> &gt;</span>        #&#123;businessTime,jdbcType=TIMESTAMP&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"memo != null"</span> &gt;</span>        #&#123;memo,jdbcType=VARCHAR&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>  <span class="hljs-comment">&lt;!--更新记录--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"updateByPrimaryKeySelective"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.debug.middleware.model.entity.MqOrder"</span> &gt;</span>    update mq_order    <span class="hljs-tag">&lt;<span class="hljs-name">set</span> &gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"orderId != null"</span> &gt;</span>        order_id = #&#123;orderId,jdbcType=INTEGER&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"businessTime != null"</span> &gt;</span>        business_time = #&#123;businessTime,jdbcType=TIMESTAMP&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"memo != null"</span> &gt;</span>        memo = #&#123;memo,jdbcType=VARCHAR&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>    where id = #&#123;id,jdbcType=INTEGER&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>  <span class="hljs-comment">&lt;!--更新记录--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"updateByPrimaryKey"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.debug.middleware.model.entity.MqOrder"</span> &gt;</span>    update mq_order    set order_id = #&#123;orderId,jdbcType=INTEGER&#125;,      business_time = #&#123;businessTime,jdbcType=TIMESTAMP&#125;,      memo = #&#123;memo,jdbcType=VARCHAR&#125;    where id = #&#123;id,jdbcType=INTEGER&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><p>3、UserOrderMapper操作接口和对应的xml配置文件</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserOrderMapper</span> </span>&#123;    <span class="hljs-comment">/**根据主键id删除记录*/</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteByPrimaryKey</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-comment">/**插入记录*/</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(UserOrder record)</span></span>;    <span class="hljs-comment">/**插入记录*/</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertSelective</span><span class="hljs-params">(UserOrder record)</span></span>;    <span class="hljs-comment">/**根据主键id查询记录*/</span>    <span class="hljs-function">UserOrder <span class="hljs-title">selectByPrimaryKey</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-comment">/**更新记录*/</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKeySelective</span><span class="hljs-params">(UserOrder record)</span></span>;    <span class="hljs-comment">/**更新记录*/</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKey</span><span class="hljs-params">(UserOrder record)</span></span>;    <span class="hljs-comment">/**根据下单记录Id和支付状态查询*/</span>    <span class="hljs-function">UserOrder <span class="hljs-title">selectByIdAndStatus</span><span class="hljs-params">(@Param(<span class="hljs-string">"id"</span>)</span> Integer id, @<span class="hljs-title">Param</span><span class="hljs-params">(<span class="hljs-string">"status"</span>)</span> Integer status)</span>;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-comment">&lt;!--xml文档类型说明--&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span><span class="hljs-comment">&lt;!--UserOrderMapper操作接口所在的命名空间定义--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.debug.middleware.model.mapper.UserOrderMapper"</span> &gt;</span>  <span class="hljs-comment">&lt;!--查询得到的结果集映射--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"BaseResultMap"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.debug.middleware.model.entity.UserOrder"</span> &gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"INTEGER"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"order_no"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"orderNo"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"VARCHAR"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"user_id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userId"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"INTEGER"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"status"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"status"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"INTEGER"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"is_active"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"isActive"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"INTEGER"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"create_time"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"createTime"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"TIMESTAMP"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"update_time"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"updateTime"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"TIMESTAMP"</span> /&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>  <span class="hljs-comment">&lt;!--查询的SQL片段--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"Base_Column_List"</span> &gt;</span>    id, order_no, user_id, status, is_active, create_time, update_time  <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据下单记录Id查询记录--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectByPrimaryKey"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"BaseResultMap"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"java.lang.Integer"</span> &gt;</span>    select     <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">"Base_Column_List"</span> /&gt;</span>    from user_order    where id = #&#123;id,jdbcType=INTEGER&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据主键id删除记录--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"deleteByPrimaryKey"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"java.lang.Integer"</span> &gt;</span>    delete from user_order    where id = #&#123;id,jdbcType=INTEGER&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span>  <span class="hljs-comment">&lt;!--插入用户下单记录--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"insert"</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.debug.middleware.model.entity.UserOrder"</span> &gt;</span>    insert into user_order (id, order_no, user_id,       status, is_active, create_time,       update_time)    values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;orderNo,jdbcType=VARCHAR&#125;, #&#123;userId,jdbcType=INTEGER&#125;,       #&#123;status,jdbcType=INTEGER&#125;, #&#123;isActive,jdbcType=INTEGER&#125;, #&#123;createTime,jdbcType=TIMESTAMP&#125;,       #&#123;updateTime,jdbcType=TIMESTAMP&#125;)  <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>  <span class="hljs-comment">&lt;!--插入用户下单记录--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"insertSelective"</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.debug.middleware.model.entity.UserOrder"</span> &gt;</span>    insert into user_order    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"("</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">")"</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">","</span> &gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"id != null"</span> &gt;</span>        id,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"orderNo != null"</span> &gt;</span>        order_no,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"userId != null"</span> &gt;</span>        user_id,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"status != null"</span> &gt;</span>        status,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"isActive != null"</span> &gt;</span>        is_active,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"createTime != null"</span> &gt;</span>        create_time,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"updateTime != null"</span> &gt;</span>        update_time,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"values ("</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">")"</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">","</span> &gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"id != null"</span> &gt;</span>        #&#123;id,jdbcType=INTEGER&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"orderNo != null"</span> &gt;</span>        #&#123;orderNo,jdbcType=VARCHAR&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"userId != null"</span> &gt;</span>        #&#123;userId,jdbcType=INTEGER&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"status != null"</span> &gt;</span>        #&#123;status,jdbcType=INTEGER&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"isActive != null"</span> &gt;</span>        #&#123;isActive,jdbcType=INTEGER&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"createTime != null"</span> &gt;</span>        #&#123;createTime,jdbcType=TIMESTAMP&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"updateTime != null"</span> &gt;</span>        #&#123;updateTime,jdbcType=TIMESTAMP&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据下单记录id更新记录--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"updateByPrimaryKeySelective"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.debug.middleware.model.entity.UserOrder"</span> &gt;</span>    update user_order    <span class="hljs-tag">&lt;<span class="hljs-name">set</span> &gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"orderNo != null"</span> &gt;</span>        order_no = #&#123;orderNo,jdbcType=VARCHAR&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"userId != null"</span> &gt;</span>        user_id = #&#123;userId,jdbcType=INTEGER&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"status != null"</span> &gt;</span>        status = #&#123;status,jdbcType=INTEGER&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"isActive != null"</span> &gt;</span>        is_active = #&#123;isActive,jdbcType=INTEGER&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"createTime != null"</span> &gt;</span>        create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"updateTime != null"</span> &gt;</span>        update_time = #&#123;updateTime,jdbcType=TIMESTAMP&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>    where id = #&#123;id,jdbcType=INTEGER&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据下单记录id更新记录--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"updateByPrimaryKey"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.debug.middleware.model.entity.UserOrder"</span> &gt;</span>    update user_order    set order_no = #&#123;orderNo,jdbcType=VARCHAR&#125;,      user_id = #&#123;userId,jdbcType=INTEGER&#125;,      status = #&#123;status,jdbcType=INTEGER&#125;,      is_active = #&#123;isActive,jdbcType=INTEGER&#125;,      create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;,      update_time = #&#123;updateTime,jdbcType=TIMESTAMP&#125;    where id = #&#123;id,jdbcType=INTEGER&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据下单记录Id和支付状态查询--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectByIdAndStatus"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"com.debug.middleware.model.entity.UserOrder"</span>&gt;</span>    SELECT        <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">"Base_Column_List"</span>/&gt;</span>    FROM        user_order    WHERE        is_active    AND `status` = #&#123;status&#125;    AND id = #&#123;id&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><h3 id="6-3-4-构建RabbitMQ死信队列消息模型"><a href="#6-3-4-构建RabbitMQ死信队列消息模型" class="headerlink" title="6.3.4 构建RabbitMQ死信队列消息模型"></a>6.3.4 构建RabbitMQ死信队列消息模型</h3><p>假设用户下单之后超时支付的时间为“10秒”</p><p>1、在RabbitmqConfig配置类中构建“用户下单支付超时”对应的死信队列消息模型</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**用户下单支付超时-RabbitMQ死信队列消息模型构建**/</span>    <span class="hljs-comment">//创建死信队列</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">orderDeadQueue</span><span class="hljs-params">()</span> </span>&#123;        Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> HashMap();        args.put(<span class="hljs-string">"x-dead-letter-exchange"</span>, env.getProperty(<span class="hljs-string">"mq.order.dead.exchange.name"</span>));        args.put(<span class="hljs-string">"x-dead-letter-routing-key"</span>, env.getProperty(<span class="hljs-string">"mq.order.dead.routing.key.name"</span>));        <span class="hljs-comment">//设定TTL，单位为ms，在这里为了测试方便，设置为10s，当然实际业务场景可能为1h或者更长</span>        args.put(<span class="hljs-string">"x-message-ttl"</span>, <span class="hljs-number">10000</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(env.getProperty(<span class="hljs-string">"mq.order.dead.queue.name"</span>), <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, args);    &#125;    <span class="hljs-comment">//创建“基本消息模型”的基本交换机 - 面向生产者</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TopicExchange <span class="hljs-title">orderProducerExchange</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TopicExchange(env.getProperty(<span class="hljs-string">"mq.producer.order.exchange.name"</span>), <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-comment">//创建“基本消息模型”的基本绑定-基本交换机+基本路由 - 面向生产者</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">orderProducerBinding</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(orderDeadQueue()).to(orderProducerExchange())            .with(env.getProperty(<span class="hljs-string">"mq.producer.order.routing.key.name"</span>));    &#125;    <span class="hljs-comment">//创建真正队列 - 面向消费者</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">realOrderConsumerQueue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(env.getProperty(<span class="hljs-string">"mq.consumer.order.real.queue.name"</span>), <span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-comment">//创建死信交换机</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TopicExchange <span class="hljs-title">basicOrderDeadExchange</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TopicExchange(env.getProperty(<span class="hljs-string">"mq.order.dead.exchange.name"</span>), <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-comment">//创建死信路由及其绑定</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">basicOrderDeadBinding</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(realOrderConsumerQueue()).to(basicOrderDeadExchange())            .with(env.getProperty(<span class="hljs-string">"mq.order.dead.routing.key.name"</span>));    &#125;</code></pre></div><p>读取的变量取值如下：</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment">#用户下单支付超时-死信队列消息模型</span><span class="hljs-comment">#定义死信队列名称</span><span class="hljs-meta">mq.order.dead.queue.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.order.dead.queue</span><span class="hljs-comment">#定义交换机名称</span><span class="hljs-meta">mq.order.dead.exchange.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.order.dead.exchange</span><span class="hljs-comment">#定义死信路由名称</span><span class="hljs-meta">mq.order.dead.routing.key.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.order.dead.routing.key</span><span class="hljs-comment">#定义基本交换机名称</span><span class="hljs-meta">mq.producer.order.exchange.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.order.basic.exchange</span><span class="hljs-comment">#定义基本路由名称</span><span class="hljs-meta">mq.producer.order.routing.key.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.order.basic.routing.key</span><span class="hljs-comment">#定义真正队列名称</span><span class="hljs-meta">mq.consumer.order.real.queue.name</span>=<span class="hljs-string">$&#123;mq.env&#125;.middleware.consumer.order.real.queue</span></code></pre></div><p>2、运行项目，在浏览器地址栏中输入<a href="http://127.0.0.1.15672，查看该消息模型对应的“死信队列”和“真正的队列”信息" target="_blank" rel="noopener">http://127.0.0.1.15672，查看该消息模型对应的“死信队列”和“真正的队列”信息</a></p><h3 id="6-3-5-Controller层开发用户下单及订单失效功能"><a href="#6-3-5-Controller层开发用户下单及订单失效功能" class="headerlink" title="6.3.5 Controller层开发用户下单及订单失效功能"></a>6.3.5 Controller层开发用户下单及订单失效功能</h3><p>Controller层指应用系统针对指定的业务模块开发相关的业务逻辑处理代码，包括接收用户前端请求的控制层、处理核心业务逻辑的服务层及提供额外服务的中间件处理层。</p><p>1、开发用于接受并处理用户前端请求的控制层UserOrderController，主要用于接收前端用户下单时的相关信息</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserOrderController</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(UserOrderController<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">//定义请求前缀</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String prefix = <span class="hljs-string">"user/order"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 用户下单处理服务实例</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DeadUserOrderService deadUserOrderService;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 用户下单请求的接收和处理</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@RequestMapping</span>(value = prefix+<span class="hljs-string">"/push"</span>,method = RequestMethod.POST,    consumes = MediaType.APPLICATION_JSON_UTF8_VALUE)    <span class="hljs-function"><span class="hljs-keyword">public</span> BaseResponse <span class="hljs-title">login</span><span class="hljs-params">(@RequestBody @Validated UserOrderDto dto, BindingResult result)</span></span>&#123;        <span class="hljs-comment">//判断请求参数的合法性</span>        <span class="hljs-keyword">if</span>(result.hasErrors())&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BaseResponse(StatusCode.InvalidParams);        &#125;        <span class="hljs-comment">//定义响应结果实例</span>        BaseResponse response = <span class="hljs-keyword">new</span> BaseResponse(StatusCode.Success);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//调用Service层真正处理用户下单的业务逻辑</span>            deadUserOrderService.pushUserOrder(dto);        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            <span class="hljs-comment">//Service层在处理的过程中如果发生异常，</span>            <span class="hljs-comment">//则抛出异常并被Controller层捕获返回给前端用户</span>            response = <span class="hljs-keyword">new</span> BaseResponse(StatusCode.Fail.getCode(),e.getMessage());        &#125;        <span class="hljs-keyword">return</span> response;    &#125;&#125;</code></pre></div><p>2、UserOrderDto实体类用于接收前端用户下单时提交的信息。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserOrderDto</span> </span>&#123;    <span class="hljs-meta">@NotBlank</span>    <span class="hljs-keyword">private</span> String orderNo;    <span class="hljs-meta">@NotNull</span>    <span class="hljs-keyword">private</span> Integer userId;&#125;</code></pre></div><p>3、DeadUserOrderService类，主要包含两大核心功能，即“用户下单”功能和“更新用户下单记录的状态”功能</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadUserOrderService</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(DeadUserOrderService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/**定义用户下单操作Mapper*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserOrderMapper userOrderMapper;    <span class="hljs-comment">/**定义更新失效用户下单记录状态Mapper*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> MqOrderMapper mqOrderMapper;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 用户下单-将生成的下单记录id压入死信队列中等待延迟处理</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userOrderDto</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushUserOrder</span><span class="hljs-params">(UserOrderDto userOrderDto)</span></span>&#123;        <span class="hljs-comment">//创建用户下单实例</span>        UserOrder userOrder = <span class="hljs-keyword">new</span> UserOrder();        <span class="hljs-comment">//复制userOrderDto对应的字段取值到新的实例对象userOrder中</span>        BeanUtils.copyProperties(userOrderDto,userOrder);        <span class="hljs-comment">//设置支付状态为已保存</span>        userOrder.setStatus(<span class="hljs-number">1</span>);        <span class="hljs-comment">//设置下单时间</span>        userOrder.setCreateTime(<span class="hljs-keyword">new</span> Date());        <span class="hljs-comment">//插入用户下单记录</span>        userOrderMapper.insertSelective(userOrder);        log.info(<span class="hljs-string">"用户成功下单，下单信息为“&#123;&#125;"</span>,userOrder);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 更新用户下单记录的状态</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateUserOrderRecord</span><span class="hljs-params">(UserOrder userOrder)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//判断用户下单记录实体是否为null</span>            <span class="hljs-keyword">if</span>(userOrder != <span class="hljs-keyword">null</span>)&#123;                <span class="hljs-comment">//更新失效用户下单记录</span>                userOrder.setIsActive(<span class="hljs-number">0</span>);                <span class="hljs-comment">//设置失效时进行更新的时间</span>                userOrder.setUpdateTime(<span class="hljs-keyword">new</span> Date());                <span class="hljs-comment">//更新下单记录实体信息</span>                userOrderMapper.updateByPrimaryKeySelective(userOrder);                                <span class="hljs-comment">//记录“失效用户下单记录”的历史</span>                <span class="hljs-comment">//定义Rabbitmq死信队列历史失效记录实例</span>                MqOrder mqOrder = <span class="hljs-keyword">new</span> MqOrder();;                <span class="hljs-comment">//设置失效时间</span>                mqOrder.setBusinessTime(<span class="hljs-keyword">new</span> Date());                <span class="hljs-comment">//设置备注信息</span>                mqOrder.setMemo(<span class="hljs-string">"更新失效当前用户下单记录Id,orderId="</span>+userOrder.getId());                <span class="hljs-comment">//设置下单记录id</span>                mqOrder.setOrderId(userOrder.getId());                <span class="hljs-comment">//插入失效记录</span>                mqOrderMapper.insertSelective(mqOrder);            &#125;        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            log.error(<span class="hljs-string">"用户下单支付超时-处理服务-更新用户下单记录的状态发生异常："</span>,e.fillInStackTrace());        &#125;    &#125;&#125;</code></pre></div><p>4、运行项目，打开Postman，在地址栏中输入“访问用户下单”的请求链接<a href="http://127.0.0.1:8087/middleware/user/order/push，请求方式为Post，并选择请求体的数据格式为JSON，请求体的数据如下：" target="_blank" rel="noopener">http://127.0.0.1:8087/middleware/user/order/push，请求方式为Post，并选择请求体的数据格式为JSON，请求体的数据如下：</a></p><div class="hljs"><pre><code class="hljs json">&#123;<span class="hljs-attr">"orderNo"</span>:<span class="hljs-number">201190411001</span>,<span class="hljs-attr">"userId"</span>:<span class="hljs-number">10010</span>&#125;</code></pre></div><p>此时Postman得到了“成功”的响应结果，并且用户下单记录已经成功存储至数据表中。</p><h3 id="6-3-6-“用户下单支付超时”延迟发送接收实战"><a href="#6-3-6-“用户下单支付超时”延迟发送接收实战" class="headerlink" title="6.3.6 “用户下单支付超时”延迟发送接收实战"></a>6.3.6 “用户下单支付超时”延迟发送接收实战</h3><p>1、开发生产者</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadOrderPublisher</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(DeadOrderPublisher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/**定义读取环境变量实例*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Environment env;    <span class="hljs-comment">/**定义RabbitMQ操作组件*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-comment">/**定义JSON序列化和反序列化组件实例*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将用户下单记录id充当消息发送给死信队列</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(Integer orderId)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//设置消息的传输格式-JSON</span>            rabbitTemplate.setMessageConverter(<span class="hljs-keyword">new</span> Jackson2JsonMessageConverter());            <span class="hljs-comment">//设置基本交换机</span>            rabbitTemplate.setExchange(env.getProperty(<span class="hljs-string">"mq.producer.order.exchange.name"</span>));            <span class="hljs-comment">//设置基本路由</span>            rabbitTemplate.setRoutingKey(env.getProperty(<span class="hljs-string">"mq.producer.order.routing.key.name"</span>));            <span class="hljs-comment">//发送对象类型的消息</span>            rabbitTemplate.convertAndSend(orderId, <span class="hljs-keyword">new</span> MessagePostProcessor() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> Message <span class="hljs-title">postProcessMessage</span><span class="hljs-params">(Message message)</span> <span class="hljs-keyword">throws</span> AmqpException </span>&#123;                    <span class="hljs-comment">//获取消息属性对象</span>                    MessageProperties messageProperties = message.getMessageProperties();                    <span class="hljs-comment">//设置消息的持久化策略</span>                    messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);                    <span class="hljs-comment">//设置消息头，即直接指定发送的消息所属的对象类型</span>                    messageProperties.setHeader(AbstractJavaTypeMapper.DEFAULT_CONTENT_CLASSID_FIELD_NAME,Integer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;                    <span class="hljs-comment">//返回消息实例</span>                    <span class="hljs-keyword">return</span> message;                &#125;            &#125;);            <span class="hljs-comment">//打印日志</span>            log.info(<span class="hljs-string">"用户下单支付超时-发送用户下单记录id的消息入死信队列-内容为:orderId=&#123;&#125; "</span>,orderId);        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            log.error(<span class="hljs-string">"用户下单支付超时-发送用户下单记录id的消息入死信队列-发生异常：orderId=&#123;&#125; "</span>,orderId,e.fillInStackTrace());        &#125;    &#125;&#125;</code></pre></div><p>2、开发消费者</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadOrderConsumer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(DeadOrderConsumer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/**定义JSON序列化和反序列化组件*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-comment">/**定义用户下单操作Mapper*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserOrderMapper userOrderMapper;    <span class="hljs-comment">/**用户下单支付超时-处理服务实例*/</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DeadUserOrderService deadUserOrderService;    <span class="hljs-comment">/**用户下单支付超时消息模型-监听真正的队列*/</span>    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"$&#123;mq.consumer.order.real.queue.name&#125;"</span>,containerFactory = <span class="hljs-string">"singleListenerContainer"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeMsg</span><span class="hljs-params">(@Payload Integer orderId)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            log.info(<span class="hljs-string">"用户下单支付超时消息模型-监听真正的队列-监听到消息内容为：orderId=&#123;&#125;"</span>,orderId);            <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span>接下来是执行核心的业务逻辑</span>            <span class="hljs-comment">//查询该用户下单记录id对应的支付状态是否为“已保存”</span>            UserOrder userOrder = userOrderMapper.selectByIdAndStatus(orderId,<span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(userOrder != <span class="hljs-keyword">null</span>)&#123;                <span class="hljs-comment">//不等于null，则代表该用户下单记录仍然为“已保存”状态，即该用户已经超时，</span>                <span class="hljs-comment">// 没支付该笔订单，因而需要失效该笔下单价记录</span>                deadUserOrderService.updateUserOrderRecord(userOrder);            &#125;        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            log.error(<span class="hljs-string">"用户下单支付超时消息模型-监听真正队列-发生异常：orderId=&#123;&#125;"</span>                    ,orderId,e.fillInStackTrace());        &#125;    &#125;&#125;</code></pre></div><p>3、在用户下单服务DeadUserOrderService类的pushUserOrder方法中，加入死信队列生产者“发送订单记录id”的方法调用</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushUserOrder</span><span class="hljs-params">(UserOrderDto userOrderDto)</span></span>&#123;        <span class="hljs-comment">//创建用户下单实例</span>        UserOrder userOrder = <span class="hljs-keyword">new</span> UserOrder();        <span class="hljs-comment">//复制userOrderDto对应的字段取值到新的实例对象userOrder中</span>        BeanUtils.copyProperties(userOrderDto,userOrder);        <span class="hljs-comment">//设置支付状态为已保存</span>        userOrder.setStatus(<span class="hljs-number">1</span>);        <span class="hljs-comment">//设置下单时间</span>        userOrder.setCreateTime(<span class="hljs-keyword">new</span> Date());        <span class="hljs-comment">//插入用户下单记录</span>        userOrderMapper.insertSelective(userOrder);        log.info(<span class="hljs-string">"用户成功下单，下单信息为“&#123;&#125;"</span>,userOrder);                <span class="hljs-comment">//生成用户下单记录id</span>        Integer orderId = userOrder.getId();        <span class="hljs-comment">//将生成的用户下单记录id压入死信队列中等待延迟处理</span>        deadOrderPublisher.sendMsg(orderId);    &#125;</code></pre></div><h3 id="6-3-7-“用户下单支付超时”整体功能自测"><a href="#6-3-7-“用户下单支付超时”整体功能自测" class="headerlink" title="6.3.7 “用户下单支付超时”整体功能自测"></a>6.3.7 “用户下单支付超时”整体功能自测</h3><p>1、打开postman，在地址栏中输入“访问用户下单”的请求链接<a href="http://127.0.0.1:8087/middleware/user/order/push，请求方式为Post，并选择请求体的数据格式为JSON，请求体的数据如下：" target="_blank" rel="noopener">http://127.0.0.1:8087/middleware/user/order/push，请求方式为Post，并选择请求体的数据格式为JSON，请求体的数据如下：</a></p><div class="hljs"><pre><code class="hljs json">&#123;<span class="hljs-attr">"orderNo"</span>:<span class="hljs-number">201190412001</span>,<span class="hljs-attr">"userId"</span>:<span class="hljs-number">10011</span>&#125;</code></pre></div><p>表示当前用户id为10011，购物车对应的订单编号为20190412001，单击Send按钮。</p><h1 id="第7章-分布式锁实战"><a href="#第7章-分布式锁实战" class="headerlink" title="第7章 分布式锁实战"></a>第7章 分布式锁实战</h1><h2 id="7-1-分布式锁概念"><a href="#7-1-分布式锁概念" class="headerlink" title="7.1 分布式锁概念"></a>7.1 分布式锁概念</h2><p>集群、分布式部署的服务实例一般是部署在不同机器上，此种资源共享将不再是传统的线程共享，而是跨JVM进程之间资源的共享。</p><h3 id="7-1-1-锁机制"><a href="#7-1-1-锁机制" class="headerlink" title="7.1.1 锁机制"></a>7.1.1 锁机制</h3><p>共享资源：指可以被多个线程、进程同时访问并进行操作的数据或者代码块。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockOne</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(LockOne<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//创建存钱线程实例</span>        Thread tAdd = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> LockThread(<span class="hljs-number">100</span>));        <span class="hljs-comment">//创建取钱线程实例</span>        Thread tSub = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> LockThread(-<span class="hljs-number">100</span>));        <span class="hljs-comment">//开启存钱线程的操作</span>        tAdd.start();        <span class="hljs-comment">//开启取钱线程的操作</span>        tSub.start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(LockThread<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/**定义成员变量-用于接收线程初始化时提供的金额-代表取/存的金额*/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LockThread</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;        <span class="hljs-keyword">this</span>.count = count;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;                <span class="hljs-comment">//通过传进来的金额（可正、可负）执行叠加操作</span>                SysConstant.amount = SysConstant.amount + count;                log.info(<span class="hljs-string">"此时账户余额为：&#123;&#125;"</span>,SysConstant.amount);            &#125;        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre></div><p>其中，SysConstant为存放共享变量的系统常量类</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">SysConstant</span> &#123;    <span class="hljs-keyword">public</span> static Integer amount = <span class="hljs-number">500</span>;&#125;</code></pre></div><p>未完…待定~</p>]]></content>
    
    
    <categories>
      
      <category>微服务分布式架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序员高效开发手册</title>
    <link href="/2021/05/30/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/"/>
    <url>/2021/05/30/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>迭代开发，价值优先</p><p>分解任务，真实进度</p><p>站立会议，交流畅通</p><p>用户参与，调整方向</p><p>结对编程，代码质量</p><p>测试驱动，安全可靠</p><p>持续集成，尽早反馈</p><p>自动部署，一键安装</p><p>定期回顾，持续改进</p><p>不断学习，提高能力</p><p>​        —–编程的武功秘籍</p></blockquote><h1 id="第1章-敏捷–高效软件开发之道"><a href="#第1章-敏捷–高效软件开发之道" class="headerlink" title="第1章 敏捷–高效软件开发之道"></a>第1章 敏捷–高效软件开发之道</h1><ul><li><strong>个体和交互</strong>胜过过程和工具</li><li><strong>可工作的软件</strong>胜过面面俱到的文档</li><li><strong>客户协作</strong>胜过合同谈判</li><li><strong>响应变化</strong>胜过遵循计划</li></ul><p><strong>敏捷开发</strong>：一种把以人为本、团队合作、快速响应变化和可工作的软件作为宗旨的开发方法，要求在一个高度协作的环境中，不断地使用反馈进行自我调整和完善。</p><p>重点：持续开发、持续反馈、发现问题及时解决问题。</p><p><strong>重构</strong>：不断从自己写的代码中得到反馈，并且使用自动化工具不断构建（持续集成）和测试系统，在功能不变的情况下，对部分代码重新设计，来改善代码的质量。</p><p><strong>迭代</strong>：将当前版本演示给客户，及时得到他们的反馈，然后根据实际情况进行修改。</p><p>敏捷工具箱：</p><ul><li>Wiki【Wiki之道】</li><li>版本控制</li><li>单元测试【单元测试之道Java版】</li><li>自动构建</li><li>《软件项目成功之道》</li></ul><h1 id="第2章-态度决定一切"><a href="#第2章-态度决定一切" class="headerlink" title="第2章 态度决定一切"></a>第2章 态度决定一切</h1><p>专业的态度应该着眼于项目和团队的积极结果，关注个人和团队的成长，围绕最后的成功开展工作。  </p><p>出了问题，第一重要的不是确定元凶，而是解决问题【<strong>指责不能修复bug</strong>】。</p><p>一个重大的错误应该被当作是一次学习而不是指责他人的机会。团队成员们在一起工作，应互相帮助，而不是互相指责。  </p><p>千里之堤，溃于蚁穴，大灾难是逐步演化来的。一次又一次的快速修复，每一次都不探究问题的根源，久而久之就形成了一个危险的沼泽地，最终会吞噬整个项目的生命。  </p><p>实行代码复审，不仅有助于代码更好理解，而且是发现bug最有效的方法之一 ，所以<strong>不要孤立的编码</strong>，多花些时间阅读其他同事写的代码。</p><p>多投入时间和精力保持代码的整洁、敞亮。</p><p>不要急于修复一段没能真正理解的代码。</p><p>没有一个人能完全明白所有的代码。除了深入了解你正在开发的那部分代码之外，你还需要从更高的层面来了解大部分代码的功能，这样就可以理解系统各个功能块之间是如何交互的。  </p><p>小故事：</p><blockquote><p>多年以前，在我担任系统管理员的第一天，一位资深的管理员和我一起安装一些软件，我突然按错了一个按钮，把服务器给关掉了。没过几分钟，几位不爽的用户就在敲门了。<br>这时，我的导师赢得了我的信任和尊重，他并没有指责我，而是对他们说：“对不起，我们正在查找是什么地方出错了。系统会在几分钟之内启动起来。”这让我学到了难忘的重要一课。  </p></blockquote><p>在一个需要紧密合作的开发团队中，如果能稍加注意礼貌对待他人，将会有益于整个团队关注真正有价值的问题，而不是勾心斗角，误入歧途。  </p><p>负面的评论和态度扼杀了创新。  把重点放在解决问题上，而不是去极力证明谁的主意更好。  </p><p>你不需要很出色才能起步，但是你必须起步才能变得很出色。  —莱斯·布朗</p><p>能欣赏自己并不接受的想法， 表明你的头脑足够有学识。—亚里士多德</p><p>没有最好的答案，只有更合适的方案。  </p><p>开会的时候设立仲裁人，其责任就是确保每个人都有发言的机会，并维持会议的正常进行。</p><p>支持已经做出的决定，让我们骄傲的应该是解决了问题，而不是比较出谁的主意更好。</p><p>想要支持或者反驳一个观点，有时候你必须先做一个原型或者调查出它有多少的同意者或者反对者。    </p><p>假如要你修复其他人编写的代码，  抱怨和发泄并不能解决问题，最有效的方式是动手重写这些代码，并比较重写前后的优缺点。</p><p>如果发现你以前的一段代码出错了，不要试图掩盖这些问题，而是应该主动承认，并且寻求解决方案。</p><p>要诚实，要有勇气去说出实情。有时，这样做很困难，所以我们要有足够的勇气。  </p>]]></content>
    
    
    <categories>
      
      <category>Java开发规范</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高效开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java全栈工程师的必修之路</title>
    <link href="/2021/05/30/Java%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E5%BF%85%E4%BF%AE%E4%B9%8B%E8%B7%AF/"/>
    <url>/2021/05/30/Java%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E5%BF%85%E4%BF%AE%E4%B9%8B%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530094550.png" srcset="/img/loading.gif" alt="image-20210530094550164"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>重构</title>
    <link href="/2021/05/29/%E9%87%8D%E6%9E%84/"/>
    <url>/2021/05/29/%E9%87%8D%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p>重构：在不改变软件可观察行为的前提下，对代码进行修改，以改善其内部结构。</p></blockquote><h1 id="第1章-重构，第一个案例"><a href="#第1章-重构，第一个案例" class="headerlink" title="第1章 重构，第一个案例"></a>第1章 重构，第一个案例</h1><h2 id="1-1-起点"><a href="#1-1-起点" class="headerlink" title="1.1 起点"></a>1.1 起点</h2><p>案例：影片出租店用的程序，计算每一位顾客的消费金额并打印详单。操作者告诉程序：顾客租了哪些影片、租期多长，程序便根据租赁时间和影片类型算出费用。影片分为三类：普通片、儿童片和新片。除了计算费用，还要为常客计算积分，积分会根据租片种类是否为新片而有所不同。</p><p>UML类图如下所示：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529221426.png" srcset="/img/loading.gif" alt="image-20210527232752556"></p><p><strong>Movie（影片）</strong>：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Movie</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CHILDREDS = <span class="hljs-number">2</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> REGULAR = <span class="hljs-number">2</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NEW_RELEASE = <span class="hljs-number">2</span>;    <span class="hljs-keyword">private</span> String _title;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> _priceCode;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Movie</span><span class="hljs-params">(String _title, <span class="hljs-keyword">int</span> _priceCode)</span> </span>&#123;        <span class="hljs-keyword">this</span>._title = _title;        <span class="hljs-keyword">this</span>._priceCode = _priceCode;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get_priceCode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> _priceCode;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set_priceCode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _priceCode)</span> </span>&#123;        <span class="hljs-keyword">this</span>._priceCode = _priceCode;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get_title</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> _title;    &#125;&#125;</code></pre></div><p><strong>Rental（租赁）</strong>：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rental</span> </span>&#123;    <span class="hljs-keyword">private</span> Movie _movie;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> _daysRented;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rental</span><span class="hljs-params">(Movie _movie, <span class="hljs-keyword">int</span> _daysRented)</span> </span>&#123;        <span class="hljs-keyword">this</span>._movie = _movie;        <span class="hljs-keyword">this</span>._daysRented = _daysRented;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Movie <span class="hljs-title">get_movie</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> _movie;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get_daysRented</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> _daysRented;    &#125;&#125;</code></pre></div><p><strong>Customer（顾客）</strong>:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> </span>&#123;    <span class="hljs-keyword">private</span> String _name;    <span class="hljs-keyword">private</span> Vector _rentals = <span class="hljs-keyword">new</span> Vector();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Customer</span><span class="hljs-params">(String _name)</span> </span>&#123;        <span class="hljs-keyword">this</span>._name = _name;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addRental</span><span class="hljs-params">(Rental arg)</span></span>&#123;        _rentals.addElement(arg);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> _name;    &#125;&#125;</code></pre></div><p>Customer还提供了一个用于生成详单的函数，该函数交互过程如下图所示。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529221438.png" srcset="/img/loading.gif" alt="image-20210519072922928"></p><p>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">statement</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">double</span> totalAmount = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> frequentRenterPoints = <span class="hljs-number">0</span>;        Enumeration rentals = _rentals.elements();        String result = <span class="hljs-string">"Rental Record for "</span> + getName() + <span class="hljs-string">"\n"</span>;        <span class="hljs-keyword">while</span> (rentals.hasMoreElements()) &#123;            <span class="hljs-keyword">double</span> thisAmount = <span class="hljs-number">0</span>;            Rental each = (Rental) rentals.nextElement();            <span class="hljs-keyword">switch</span> (each.getMovie().getPriceCode()) &#123;                <span class="hljs-keyword">case</span> Movie.REGULAR:                    thisAmount += <span class="hljs-number">2</span>;                    <span class="hljs-keyword">if</span> (each.getDaysRented() &gt; <span class="hljs-number">2</span>) &#123;                        thisAmount += (each.getDaysRented() - <span class="hljs-number">2</span>) * <span class="hljs-number">1.5</span>;                    &#125;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> Movie.NEW_RELEASE:                    thisAmount += each.getDaysRented() * <span class="hljs-number">3</span>;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> Movie.CHILDRENS:                    thisAmount += <span class="hljs-number">1.5</span>;                    <span class="hljs-keyword">if</span> (each.getDaysRented() &gt; <span class="hljs-number">3</span>) &#123;                        thisAmount += (each.getDaysRented() - <span class="hljs-number">3</span>) * <span class="hljs-number">1.5</span>;                    &#125;                    <span class="hljs-keyword">break</span>;            &#125;            frequentRenterPoints++;            <span class="hljs-keyword">if</span> ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE) &amp;&amp;                    each.getDaysRented() &gt; <span class="hljs-number">1</span>) &#123;                frequentRenterPoints ++;            &#125;            result += <span class="hljs-string">"\t"</span> + each.getMovie().getTitle() + <span class="hljs-string">"\t"</span> + String.valueOf(thisAmount)+<span class="hljs-string">"\n"</span>;            totalAmount += thisAmount;        &#125;        result +=<span class="hljs-string">"Amount owed is "</span> + String.valueOf(totalAmount)+<span class="hljs-string">"\n"</span>;        result +=<span class="hljs-string">"You earned "</span>+ String.valueOf(frequentRenterPoints)+<span class="hljs-string">" frequent renter points"</span>;        <span class="hljs-keyword">return</span> result;    &#125;</code></pre></div><p><strong>评价：</strong></p><p>不符合面向对象精神，<code>statement()</code>做的事情太多，容易产生bug，另外如果需求改变，比如希望以HTML格式输出详单，该方法没有任何作用，需要重写一个新的方法，导致大量重复工作产生。</p><p><strong>关键点：如果你发现自己需要为程序添加一个特性，而代码结构使你无法很方便地达成目的，那就先重构那个程序，使特性的添加比较容易进行，然后再添加特性。</strong></p><h2 id="1-2-重构的第一步"><a href="#1-2-重构的第一步" class="headerlink" title="1.2 重构的第一步"></a>1.2 重构的第一步</h2><p>第一步：<strong>为即将修改的代码建立一组可靠的测试环境</strong>，保证重构前后代码功能没有改变。要求这些测试都能够自我检测，要么输出“<strong>OK</strong>”，要么列出失败清单，显示问题出现的行号等。</p><h2 id="1-3-分解并重组statement"><a href="#1-3-分解并重组statement" class="headerlink" title="1.3 分解并重组statement()"></a>1.3 分解并重组statement()</h2><h3 id="1-3-1-找出代码的逻辑泥团"><a href="#1-3-1-找出代码的逻辑泥团" class="headerlink" title="1.3.1 找出代码的逻辑泥团"></a>1.3.1 找出代码的逻辑泥团</h3><p>如上例中的<code>switch</code>语句，将它提炼到独立函数中。</p><p>首先、<strong>找出这段代码内的局部变量和参数</strong>，这里是<code>each</code>和<code>thisAmount</code>。前者并未修改，后者会被修改。</p><p>记住：<strong>任何不会被修改的变量都可以当成参数传入新的函数，如果只有一个变量会被修改，可以将它作为返回值。</strong></p><p>重构后的代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">statement</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">double</span> totalAmount = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> frequentRenterPoints = <span class="hljs-number">0</span>;        Enumeration rentals = _rentals.elements();        String result = <span class="hljs-string">"Rental Record for "</span> + getName() + <span class="hljs-string">"\n"</span>;        <span class="hljs-keyword">while</span> (rentals.hasMoreElements()) &#123;            <span class="hljs-keyword">double</span> thisAmount = <span class="hljs-number">0</span>;            Rental each = (Rental) rentals.nextElement();            thisAmount = amountFor(each);            frequentRenterPoints++;            <span class="hljs-keyword">if</span> ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE) &amp;&amp;                    each.getDaysRented() &gt; <span class="hljs-number">1</span>) &#123;                frequentRenterPoints ++;            &#125;            result += <span class="hljs-string">"\t"</span> + each.getMovie().getTitle() + <span class="hljs-string">"\t"</span> + String.valueOf(thisAmount)+<span class="hljs-string">"\n"</span>;            totalAmount += thisAmount;        &#125;        result +=<span class="hljs-string">"Amount owed is "</span> + String.valueOf(totalAmount)+<span class="hljs-string">"\n"</span>;        result +=<span class="hljs-string">"You earned "</span>+ String.valueOf(frequentRenterPoints)+<span class="hljs-string">" frequent renter points"</span>;        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> <span class="hljs-title">amountFor</span><span class="hljs-params">(Rental each)</span> </span>&#123;        <span class="hljs-keyword">int</span> thisAmount = <span class="hljs-number">0</span>;        <span class="hljs-keyword">switch</span> (each.getMovie().getPriceCode()) &#123;            <span class="hljs-keyword">case</span> Movie.REGULAR:                thisAmount += <span class="hljs-number">2</span>;                <span class="hljs-keyword">if</span> (each.getDaysRented() &gt; <span class="hljs-number">2</span>) &#123;                    thisAmount += (each.getDaysRented() - <span class="hljs-number">2</span>) * <span class="hljs-number">1.5</span>;                &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> Movie.NEW_RELEASE:                thisAmount += each.getDaysRented() * <span class="hljs-number">3</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> Movie.CHILDRENS:                thisAmount += <span class="hljs-number">1.5</span>;                <span class="hljs-keyword">if</span> (each.getDaysRented() &gt; <span class="hljs-number">3</span>) &#123;                    thisAmount += (each.getDaysRented() - <span class="hljs-number">3</span>) * <span class="hljs-number">1.5</span>;                &#125;                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> thisAmount;    &#125;  &#125;</code></pre></div><p>然后、修改<code>amountFor()</code>内的某些变量名称。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> <span class="hljs-title">amountFor</span><span class="hljs-params">(Rental aRental)</span> </span>&#123;        <span class="hljs-keyword">double</span> result = <span class="hljs-number">0</span>;        <span class="hljs-keyword">switch</span> (aRental.getMovie().getPriceCode()) &#123;            <span class="hljs-keyword">case</span> Movie.REGULAR:                result += <span class="hljs-number">2</span>;                <span class="hljs-keyword">if</span> (aRental.getDaysRented() &gt; <span class="hljs-number">2</span>) &#123;                    result += (aRental.getDaysRented() - <span class="hljs-number">2</span>) * <span class="hljs-number">1.5</span>;                &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> Movie.NEW_RELEASE:                result += aRental.getDaysRented() * <span class="hljs-number">3</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> Movie.CHILDRENS:                result += <span class="hljs-number">1.5</span>;                <span class="hljs-keyword">if</span> (aRental.getDaysRented() &gt; <span class="hljs-number">3</span>) &#123;                    result += (aRental.getDaysRented() - <span class="hljs-number">3</span>) * <span class="hljs-number">1.5</span>;                &#125;                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;</code></pre></div><p>改名之后也要重新编译并测试，确保没有破坏任何东西。</p><p>改名的重要性：<strong>提高代码的清晰度，写出人类容易理解的代码</strong>。</p><h3 id="1-3-2-搬移“金额计算”代码"><a href="#1-3-2-搬移“金额计算”代码" class="headerlink" title="1.3.2 搬移“金额计算”代码"></a>1.3.2 搬移“金额计算”代码</h3><p><code>amountFor()</code>这个函数使用了来自<code>Rental</code>类的信息，却没有使用来自<code>Customer</code>类的信息，而函数应该放在它所使用的数据的所属对象内，因此需要将该函数移到<code>Rental</code>类去，并适当作出修改。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getCharge</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">double</span> result = <span class="hljs-number">0</span>;    <span class="hljs-keyword">switch</span> (getMovie().getPriceCode()) &#123;        <span class="hljs-keyword">case</span> Movie.REGULAR:            result += <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (getDaysRented() &gt; <span class="hljs-number">2</span>) &#123;                result += (getDaysRented() - <span class="hljs-number">2</span>) * <span class="hljs-number">1.5</span>;            &#125;            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> Movie.NEW_RELEASE:            result += getDaysRented() * <span class="hljs-number">3</span>;            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> Movie.CHILDRENS:            result += <span class="hljs-number">1.5</span>;            <span class="hljs-keyword">if</span> (getDaysRented() &gt; <span class="hljs-number">3</span>) &#123;                result += (getDaysRented() - <span class="hljs-number">3</span>) * <span class="hljs-number">1.5</span>;            &#125;            <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>在这里去掉了多余的参数，并改变了函数名称，private变为public。</p><p>修改完之后，去掉旧函数，然后再进行测试。</p><p>再回到<code>statement()</code>函数中，发现<code>thisAmount</code>比较多余，去掉，直接改为<code>each.getCharge()</code>替代。</p><p>去掉临时变量的好处是避免引发问题，缺点是性能上差点。</p><h3 id="1-3-3-提炼“常客积分计算”代码"><a href="#1-3-3-提炼“常客积分计算”代码" class="headerlink" title="1.3.3 提炼“常客积分计算”代码"></a>1.3.3 提炼“常客积分计算”代码</h3><p>积分的计算跟影片种类有关，可以将积分计算放在<code>Rental</code>类里。</p><p>“常客积分计算”代码如下：</p><div class="hljs"><pre><code class="hljs java">frequentRenterPoints++;<span class="hljs-keyword">if</span> ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE) &amp;&amp;    each.getDaysRented() &gt; <span class="hljs-number">1</span>) &#123;    frequentRenterPoints ++;&#125;</code></pre></div><p>涉及两个局部变量，<code>each</code>和<code>frequentRenterPoints</code>，<code>each</code>可以被当做参数传入新函数中，<code>frequentRenterPoints</code>在使用前已经有初值，但提炼出来的函数并没有读取该值，所以我们不需要将它作为参数传进去，只需把新函数的返回值累加即可。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529221537.png" srcset="/img/loading.gif" alt="image-20210527230811817"></p><center>“常客积分计算“函数被提炼及搬移之前的类图</center><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529221547.png" srcset="/img/loading.gif" alt="image-20210527231218079"></p><center>“常客积分计算“函数被提炼及搬移之后的类图</center><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529221647.png" srcset="/img/loading.gif" alt="image-20210527232715018"></p><center>序列图（前）</center><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529221714.png" srcset="/img/loading.gif" alt="image-20210527232552508"></p><center>序列图（后）</center><h3 id="1-3-4-去掉临时变量"><a href="#1-3-4-去掉临时变量" class="headerlink" title="1.3.4 去掉临时变量"></a>1.3.4 去掉临时变量</h3><p>利用查询函数来取代<code>totalAmount</code>和<code>frequentRentalPoints</code>这两个临时变量。</p><p>首先用<code>Customer</code>类的<code>getTotalCharge()</code>取代<code>totalAmount</code>，由于<code>totalAmount</code>在循环内部被赋值，所以不得不把循环复制到查询函数中。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (rentals.hasMoreElements()) &#123;          Rental each = (Rental) rentals.nextElement();          frequentRenterPoints += each.getFrequentRenterPoints();          result += <span class="hljs-string">"\t"</span> + each.getMovie().getTitle() + <span class="hljs-string">"\t"</span>                  + String.valueOf(each.getCharge())+<span class="hljs-string">"\n"</span>;         <span class="hljs-comment">// totalAmount += each.getCharge();</span>      &#125;      result +=<span class="hljs-string">"Amount owed is "</span> + String.valueOf(getTotalCharge())+<span class="hljs-string">"\n"</span>;      result +=<span class="hljs-string">"You earned "</span>+ String.valueOf(frequentRenterPoints)+<span class="hljs-string">" frequent renter points"</span>;      <span class="hljs-keyword">return</span> result;  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getTotalCharge</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">double</span> result = <span class="hljs-number">0</span>;      Enumeration rentals = _rentals.elements();      <span class="hljs-keyword">while</span> (rentals.hasMoreElements())&#123;          Rental each = (Rental) rentals.nextElement();          result += each.getCharge();      &#125;      <span class="hljs-keyword">return</span> result;  &#125;</code></pre></div><p>用同样的方法处理<code>frequentRenterPoints</code>：</p><div class="hljs"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">statement</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//double totalAmount = 0;</span><span class="hljs-comment">//        int frequentRenterPoints = 0;</span>        Enumeration rentals = _rentals.elements();        String result = <span class="hljs-string">"Rental Record for "</span> + getName() + <span class="hljs-string">"\n"</span>;        <span class="hljs-keyword">while</span> (rentals.hasMoreElements()) &#123;            Rental each = (Rental) rentals.nextElement();<span class="hljs-comment">//            frequentRenterPoints += each.getFrequentRenterPoints();</span>            result += <span class="hljs-string">"\t"</span> + each.getMovie().getTitle() + <span class="hljs-string">"\t"</span>                    + String.valueOf(each.getCharge())+<span class="hljs-string">"\n"</span>;           <span class="hljs-comment">// totalAmount += each.getCharge();</span>        &#125;        result +=<span class="hljs-string">"Amount owed is "</span> + String.valueOf(getTotalCharge())+<span class="hljs-string">"\n"</span>;        result +=<span class="hljs-string">"You earned "</span>+ String.valueOf(getTotalFrequentRenterPoints())+<span class="hljs-string">" frequent renter points"</span>;        <span class="hljs-keyword">return</span> result;    &#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getTotalFrequentRenterPoints</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;        Enumeration rentals = _rentals.elements();        <span class="hljs-keyword">while</span>(rentals.hasMoreElements())&#123;            Rental each = (Rental) rentals.nextElement();            result += each.getFrequentRenterPoints();        &#125;        <span class="hljs-keyword">return</span> result;    &#125;</code></pre></div><p>对比：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529221732.png" srcset="/img/loading.gif" alt="image-20210527231218079"></p><center/>“总量计算”函数被提炼前的类图<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529221748.png" srcset="/img/loading.gif" alt="image-20210528065054433"></p><center>“总量计算”函数被提炼后的类图</center><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529221802.png" srcset="/img/loading.gif" alt="image-20210528065346215"></p><center/>“总量计算”函数被提炼前的时序图<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529221815.png" srcset="/img/loading.gif" alt="image-20210528070115851"></p><center/>“总量计算”函数被提炼后的时序图<p>如果需要修改影片分类规则，但是与之相应的费用计算方式与常客积分计算方式还未确定，可以将费用计算和常客积分计算代码中因条件而异的代码替换掉。</p><h2 id="1-4-运用多态取代与价格相关的条件逻辑"><a href="#1-4-运用多态取代与价格相关的条件逻辑" class="headerlink" title="1.4 运用多态取代与价格相关的条件逻辑"></a>1.4 运用多态取代与价格相关的条件逻辑</h2><p>问题一：最好不要在另一个对象的属性基础上运用<strong>switch</strong>语句，如果不得不使用，也应该在对象自己的数据上使用。</p><p>计算费用时需要两项数据：租期长度和影片类型，这里选择将租期长度传给Movie对象，因为本系统可能发生的变化是加入新影片类型，这种变化带有不稳定倾向，如果影片类型有所变化，则需要尽量控制它造成的影响。</p><p>这里将计费方法放进<strong>Movie</strong>类，然后修改<code>Rental的getCharge()</code>，让它调用这个新函数。</p><div class="hljs"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getCharge</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">return</span> _movie.getCharge(_daysRented); &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getCharge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> daysRented)</span> </span>&#123;    <span class="hljs-keyword">double</span> result = <span class="hljs-number">0</span>;    <span class="hljs-keyword">switch</span> (getPriceCode()) &#123;        <span class="hljs-keyword">case</span> Movie.REGULAR:            result += <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (daysRented &gt; <span class="hljs-number">2</span>) &#123;                result += (daysRented - <span class="hljs-number">2</span>) * <span class="hljs-number">1.5</span>;            &#125;            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> Movie.NEW_RELEASE:            result += daysRented * <span class="hljs-number">3</span>;            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> Movie.CHILDRENS:            result += <span class="hljs-number">1.5</span>;            <span class="hljs-keyword">if</span> (daysRented &gt; <span class="hljs-number">3</span>) &#123;                result += (daysRented - <span class="hljs-number">3</span>) * <span class="hljs-number">1.5</span>;            &#125;            <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>搬移<code>getCharge()</code>之后，以同样手法处理常客积分计算，这样就把根据影片类型而变化的所有东西，都放到影片类型所属的类中。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFrequentRenterPoints</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> _movie.getFrequentRenterPoints(_daysRented);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFrequentRenterPoints</span><span class="hljs-params">(<span class="hljs-keyword">int</span> daysRented)</span> </span>&#123;    <span class="hljs-keyword">if</span> ((getPriceCode() == Movie.NEW_RELEASE) &amp;&amp;        daysRented &gt; <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;    &#125;<span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;&#125;</code></pre></div><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529221834.png" srcset="/img/loading.gif" alt="image-20210528070449852"></p><center/>移动前的类图<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529221848.png" srcset="/img/loading.gif" alt="image-20210528071049301"></p><center/>移动后的类图<h3 id="1-4-1-终于…开始继承"><a href="#1-4-1-终于…开始继承" class="headerlink" title="1.4.1 终于…开始继承"></a>1.4.1 终于…开始继承</h3><p>建立Movie的三个子类，代表不同影片类型，每个都有自己的计费法。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529221858.png" srcset="/img/loading.gif" alt="image-20210528072142525"></p><p>本来想法是利用多态取代switch语句，但是这里不允许这么做，因为<strong>一部影片可以在生命周期内修改自己的分类，但一个对象却不能在生命周期内修改自己所属的类。</strong></p><p>解决方法：<strong>State模式</strong></p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529221920.png" srcset="/img/loading.gif" alt="image-20210528072556454"></p><p>加上这一层间接性，我们就可以在Price对象内进行子类化动作，于是便可以在任何必要时刻修改价格。</p><p>为了引入State模式，这里将使用三个重构手法，首先将与类型相关的行为搬移至State模式内，然后将switch语句移到Price类，最后去掉switch语句。</p><p>第一步骤需要确保任何时候都通过取值函数和设值函数来访问类型代码。</p><p>将Movie类中的构造函数进行修改，用一个设值函数来代替直接访问价格代码。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Movie</span><span class="hljs-params">(String _title, <span class="hljs-keyword">int</span> _priceCode)</span> </span>&#123;    <span class="hljs-keyword">this</span>._title = _title;    setPriceCode(_priceCode);&#125;</code></pre></div><p>新建一个Price类，并在其中提供类型相关的行为。因此在Price类中加入一个抽象函数。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Price</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPriceCode</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildrensPrice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Price</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getPriceCode</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> Movie.CHILDRENS;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewReleasePrice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Price</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getPriceCode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> Movie.NEW_RELEASE;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegularPrice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Price</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getPriceCode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> Movie.REGULAR;    &#125;&#125;</code></pre></div><p>现在需要修改Movie类内的“价格代号”访问函数（取值/设值函数），让它们使用新类。</p><p>因此需要在Movie类内保存一个Price对象，而不是一个_priceCode变量。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Price _price;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPriceCode</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> _price.getPriceCode();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPriceCode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;    <span class="hljs-keyword">switch</span> (arg)&#123;        <span class="hljs-keyword">case</span> REGULAR:            _price = <span class="hljs-keyword">new</span> RegularPrice();            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> CHILDRENS:            _price = <span class="hljs-keyword">new</span> ChildrensPrice();            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> NEW_RELEASE:            _price = <span class="hljs-keyword">new</span> NewReleasePrice();            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Incorrect Price Code"</span>);    &#125;&#125;</code></pre></div><p>接着改写getCharge()，将Movie类中的getCharge代码搬移到Price类中。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//Movie类</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getCharge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> daysRented)</span> </span>&#123;    <span class="hljs-keyword">return</span> _price.getCharge(daysRented);&#125;<span class="hljs-comment">// Price类    </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getCharge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> daysRented)</span></span>&#123;    <span class="hljs-keyword">double</span> result = <span class="hljs-number">0</span>;    <span class="hljs-keyword">switch</span> (getPriceCode())&#123;        <span class="hljs-keyword">case</span> Movie.REGULAR:            result += <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(daysRented &gt; <span class="hljs-number">2</span>)&#123;                result += (daysRented - <span class="hljs-number">2</span>) * <span class="hljs-number">1.5</span>;            &#125;            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> Movie.NEW_RELEASE:            result += daysRented * <span class="hljs-number">3</span>;            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> Movie.CHILDRENS:            result += <span class="hljs-number">1.5</span>;            <span class="hljs-keyword">if</span>(daysRented &gt; <span class="hljs-number">3</span>)&#123;                result += (daysRented - <span class="hljs-number">3</span>) * <span class="hljs-number">1.5</span>;            &#125;            <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>取出一个case分支，在相应的类建立一个覆盖函数，先从RegelarPrice开始：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getCharge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> daysRented)</span></span>&#123;    <span class="hljs-keyword">double</span> result = <span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span>(daysRented &gt; <span class="hljs-number">2</span>)&#123;        result += (daysRented - <span class="hljs-number">2</span>) * <span class="hljs-number">1.5</span>;    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>依次处理剩下两个分支：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//ChildrensPrice类</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getCharge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> daysRented)</span></span>&#123;    <span class="hljs-keyword">double</span> result = <span class="hljs-number">1.5</span>;    <span class="hljs-keyword">if</span>(daysRented &gt; <span class="hljs-number">3</span>)&#123;        result += (daysRented - <span class="hljs-number">3</span>) * <span class="hljs-number">1.5</span>;    &#125;    <span class="hljs-keyword">return</span> result;&#125;<span class="hljs-comment">// NewReleasePrice类</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getCharge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> daysRented)</span></span>&#123;    <span class="hljs-keyword">return</span> daysRented * <span class="hljs-number">3</span>;&#125;</code></pre></div><p>处理完所有分支后，将Price.getCharge()声明为abstract：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getCharge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> daysRented)</span></span>;</code></pre></div><p>用同样手法处理getFrequentRenterPoints()。</p><p>首先将Movie类中的getFrequentRenterPoints()方法移到Price类中，默认情况下返回1。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFrequentRenterPoints</span><span class="hljs-params">(<span class="hljs-keyword">int</span> daysRented)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre></div><p>在新片类型重写该方法。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFrequentRenterPoints</span><span class="hljs-params">(<span class="hljs-keyword">int</span> daysRented)</span> </span>&#123;    <span class="hljs-keyword">return</span> (daysRented &gt; <span class="hljs-number">1</span>) ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;&#125;</code></pre></div><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529221930.png" srcset="/img/loading.gif" alt="image-20210528075518286"></p><center/>重构后的时序图<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529221943.png" srcset="/img/loading.gif" alt="image-20210528075024347"></p><center/>重构后的类图<h1 id="第2章-重构原理"><a href="#第2章-重构原理" class="headerlink" title="第2章 重构原理"></a>第2章 重构原理</h1><h2 id="2-1-何谓重构"><a href="#2-1-何谓重构" class="headerlink" title="2.1 何谓重构"></a>2.1 何谓重构</h2><ul><li>重构（名词）：对软件内部结构的一种调整，目的是在<strong>不改变软件可观察行为的前提</strong>下，提高其可理解性，降低其修改成本。</li><li>重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。</li></ul><p>一般而言，重构都是对软件的小改动。</p><h2 id="2-2-为何重构"><a href="#2-2-为何重构" class="headerlink" title="2.2 为何重构"></a>2.2 为何重构</h2><ul><li>重构改进软件设计，经常性的重构可以帮助代码维持自己该有的形态，改进代码的一个重要方向就是消除重复代码，优秀设计的根本在于所有事物和行为在代码中只表述一次；</li><li>重构使软件更容易理解；</li><li>重构帮助找到bug；</li><li>重构能提高编程效率，良好的设计是快速开发的根本。</li></ul><h2 id="2-3-何时重构"><a href="#2-3-何时重构" class="headerlink" title="2.3 何时重构"></a>2.3 何时重构</h2><blockquote><p>事不过三，三则重构。</p></blockquote><ul><li>第一次做某件事时只管去做；第二次做类似的事会产生反感；第三次再做类似的事，就应该重构。</li><li><strong>添加功能时重构</strong></li><li>修补错误时重构</li><li>复审代码时重构：最好是一个复审者搭配一个原作者，两人共同判断这些修改是否能通过重构轻松实现。</li></ul><p>困扰程序员的四种程序：</p><ul><li>难以阅读的程序</li><li>逻辑重复的程序</li><li>添加新行为时需要修改已有代码的程序</li><li>带复杂条件逻辑的程序</li></ul><h2 id="2-5-重构的难题"><a href="#2-5-重构的难题" class="headerlink" title="2.5 重构的难题"></a>2.5 重构的难题</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>绝大多数商用程序都与它们背后的数据库结构紧密耦合在一起，另外就是数据迁移。</p><p>在非对象数据库中，解决该问题的一个办法是在对象模型和数据库模型之间插入一个分隔层，以隔离两个模型各自的变化。</p><h3 id="修改接口"><a href="#修改接口" class="headerlink" title="修改接口"></a>修改接口</h3><p>如果重构手法改变了已发布接口，那么就必须同时维护新旧两个接口，知道所有用户都有时间对这个变化做出反应。</p><p>可以让旧接口调用新接口，同时将旧接口标记为deprecated，当你要修改某个函数名称时，留下旧函数，让它调用新函数。</p><p>建议：不要过早发布接口，请修改你的代码所有权政策，使重构更顺畅。</p><h3 id="何时不该重构"><a href="#何时不该重构" class="headerlink" title="何时不该重构"></a>何时不该重构</h3><p>如果现有代码根本不能正常运作，建议重写！</p><p>折中办法是：将“大块头软件”重构为封装良好的小型组件，然后逐一对组件作出“重构或重建”的决定。</p><p>另外如果项目已近最后期限，也应该避免重构。</p><h2 id="2-6-重构与设计"><a href="#2-6-重构与设计" class="headerlink" title="2.6 重构与设计"></a>2.6 重构与设计</h2><p>设计是软件开发的关键环节，编程只是机械式的低级劳动！！</p><p>有了重构，不必再逐一实现每一个风险的解决方案，而是在实现中不断优化。</p><h2 id="2-7-重构与性能"><a href="#2-7-重构与性能" class="headerlink" title="2.7 重构与性能"></a>2.7 重构与性能</h2><p>大多数程序把大半时间都耗费在一小半代码身上。</p><p>在性能优化阶段，首先应该用度量工具来监控程序的运行，找出哪些地方大量消耗时间和空间，再去对代码进行优化。</p><h1 id="第3章-代码的坏味道"><a href="#第3章-代码的坏味道" class="headerlink" title="第3章 代码的坏味道"></a>第3章 代码的坏味道</h1><h2 id="3-1-重复代码-Duplicated-Code"><a href="#3-1-重复代码-Duplicated-Code" class="headerlink" title="3.1 重复代码(Duplicated Code)"></a>3.1 重复代码(Duplicated Code)</h2><p>如果在一个以上的地点看到相同的代码，设法将它们合而为一。</p><p>场景一：同一个类的两个函数含有相同的表达式。</p><p>场景二：两个互为兄弟的子类还有相同表达式。【将相同部分提炼出来，放入超类中】</p><p>场景三：两个毫不相干的类出现重复代码。【对其中一个类将重复代码提炼到一个独立类中，然后在另一个类内使用这个新类】</p><h2 id="3-2-过长函数-Long-Method"><a href="#3-2-过长函数-Long-Method" class="headerlink" title="3.2 过长函数(Long Method)"></a>3.2 过长函数(Long Method)</h2><p>有一条原则：每当感觉需要以注释来说明点什么的时候（就算只有一行代码），就把需要说明的东西写进一个独立函数中，并以其用途命名。</p><p>条件表达式和循环也是提炼的信号。</p><h2 id="3-3-过大的类-Large-Class"><a href="#3-3-过大的类-Large-Class" class="headerlink" title="3.3 过大的类(Large Class)"></a>3.3 过大的类(Large Class)</h2><p>如果某个类有太多实例变量，可以将几个相关联的变量提炼到新类。</p><p>如果有五个“百行函数”，它们之间有很多相同代码，则可以试着将它们变成五个“十行代码”和十个“双行代码”。</p><h2 id="3-4-过长参数列-Long-Parameter-List"><a href="#3-4-过长参数列-Long-Parameter-List" class="headerlink" title="3.4 过长参数列(Long Parameter List)"></a>3.4 过长参数列(Long Parameter List)</h2><p>全局参数是邪恶的东西。</p><p>将繁杂的参数整合成一个对象，有了对象，就不必将函数需要的所有东西都以参数传递给它，只需传给它足够的、让函数能从中获取自己所需要的东西即可。</p><h2 id="3-5-发散式变化-Divergent-Change"><a href="#3-5-发散式变化-Divergent-Change" class="headerlink" title="3.5 发散式变化(Divergent Change)"></a>3.5 发散式变化(Divergent Change)</h2><p>针对某一外界变化的所有相应修改，都只应该发生在单一类中。如果一个类受多种变化的影响时，则需要考虑重构</p><h2 id="3-6-霰弹式修改-Shotgun-Surgery"><a href="#3-6-霰弹式修改-Shotgun-Surgery" class="headerlink" title="3.6 霰弹式修改(Shotgun Surgery)"></a>3.6 霰弹式修改(Shotgun Surgery)</h2><p>如果一种变化引发多个类相应修改，则需要整理代码，使“外界变化”和“需要修改的类”趋于一一对应。</p><h2 id="3-7-依恋情结-Feature-Envy"><a href="#3-7-依恋情结-Feature-Envy" class="headerlink" title="3.7 依恋情结(Feature Envy)"></a>3.7 依恋情结(Feature Envy)</h2><p>函数对某个类的兴趣高于对自己所处类的兴趣，如：某个函数为了计算某个值，从另一个对象那儿调用几乎半打的取值函数。</p><p>解决办法：把这个函数移到它该去的地方，如果函数中只有一部分受这种依恋之苦，则可以将这部分提炼到独立函数中。</p><h2 id="3-8-数据泥团-Data-Clumps"><a href="#3-8-数据泥团-Data-Clumps" class="headerlink" title="3.8 数据泥团(Data Clumps)"></a>3.8 数据泥团(Data Clumps)</h2><p>两个类中有相同的字段、许多函数签名中有相同的参数，这些总是绑在一起出现的数据真应该拥有属于它们自己的对象。</p><p>好处是：可以将很多参数列缩短，简化函数调用。</p><h2 id="3-9-基本类型偏执-Primitive-Obsession"><a href="#3-9-基本类型偏执-Primitive-Obsession" class="headerlink" title="3.9 基本类型偏执(Primitive Obsession)"></a>3.9 基本类型偏执(Primitive Obsession)</h2><p>可以将原本单独存在的数据值替换为对象。</p><h2 id="3-10-switch惊悚现身-Switch-Statements"><a href="#3-10-switch惊悚现身-Switch-Statements" class="headerlink" title="3.10 switch惊悚现身(Switch Statements)"></a>3.10 switch惊悚现身(Switch Statements)</h2><p>少用switch语句。</p><p>看到switch语句，就应该考虑用多态来替换。</p><p>方法：将switch语句提炼到一个独立函数中，再将它搬移到需要多态性的那个类里。</p><h2 id="3-11-平行继承体系-Parallel-Inheritance-Hierarchies"><a href="#3-11-平行继承体系-Parallel-Inheritance-Hierarchies" class="headerlink" title="3.11 平行继承体系(Parallel Inheritance Hierarchies)"></a>3.11 平行继承体系(Parallel Inheritance Hierarchies)</h2><p>现象：每当你为某个类增加一个子类，就必须也为另一个类相应增加一个子类。或者是你发现某个继承体系的类名称前缀和另一个继承体系的类名称前缀完全相同。</p><p>策略：让一个继承体系的实例引用另一个继承体系的实例。</p><h2 id="3-12-冗赘类-Lazy-Class"><a href="#3-12-冗赘类-Lazy-Class" class="headerlink" title="3.12 冗赘类(Lazy Class)"></a>3.12 冗赘类(Lazy Class)</h2><p>对于几乎没用的组件，就应该让它消失。</p><h2 id="3-13-夸夸其谈未来性-Speculative-Generality"><a href="#3-13-夸夸其谈未来性-Speculative-Generality" class="headerlink" title="3.13 夸夸其谈未来性(Speculative Generality)"></a>3.13 夸夸其谈未来性(Speculative Generality)</h2><p>企图以各式各样的钩子和特殊情况来处理一些非必要的事情。</p><h2 id="3-14-令人迷惑的暂时字段-Temporary-Field"><a href="#3-14-令人迷惑的暂时字段-Temporary-Field" class="headerlink" title="3.14 令人迷惑的暂时字段(Temporary Field)"></a>3.14 令人迷惑的暂时字段(Temporary Field)</h2><p>如果类中有一个复杂算法，需要好几个变量，而这些变量只有在使用该算法时才有效，往往就有可能导致坏味道的出现。</p><p>可以将这些变量和其相关的函数提炼到一个独立类中。</p><h2 id="3-15-过度耦合的消息链-Message-Chains"><a href="#3-15-过度耦合的消息链-Message-Chains" class="headerlink" title="3.15 过度耦合的消息链(Message Chains)"></a>3.15 过度耦合的消息链(Message Chains)</h2><p>用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象…这就是消息链。这样的后果就是一旦对象间的关系发生任何变化，客户端就不得不作出相应修改。</p><h2 id="3-16-中间人-Middle-Man"><a href="#3-16-中间人-Middle-Man" class="headerlink" title="3.16 中间人(Middle Man)"></a>3.16 中间人(Middle Man)</h2><p>如果某个类的接口有一半的函数都委托给其他类，这就是过度运用委托。</p><h2 id="3-17-狎昵关系-Inappropriate-Intimacy"><a href="#3-17-狎昵关系-Inappropriate-Intimacy" class="headerlink" title="3.17 狎昵关系(Inappropriate Intimacy)"></a>3.17 狎昵关系(Inappropriate Intimacy)</h2><p>继承往往造成过度亲密，因为子类对超类的了解总是超过后者的主观愿望。</p><p>过分狎昵的类必须拆散，或者将两者共同点提炼到一个新类。</p><h2 id="3-18-异曲同工的类-Alternative-Classes-with-Different-Interfaces"><a href="#3-18-异曲同工的类-Alternative-Classes-with-Different-Interfaces" class="headerlink" title="3.18 异曲同工的类(Alternative Classes with Different Interfaces)"></a>3.18 异曲同工的类(Alternative Classes with Different Interfaces)</h2><p>如果两个函数做同一件事，却有着不同的签名，可以根据它们的用途重新命名。</p><h2 id="3-19-不完美的库类-Incomplete-Library-Class"><a href="#3-19-不完美的库类-Incomplete-Library-Class" class="headerlink" title="3.19 不完美的库类(Incomplete Library Class)"></a>3.19 不完美的库类(Incomplete Library Class)</h2><h2 id="3-20-纯粹的数据类-Data-Class"><a href="#3-20-纯粹的数据类-Data-Class" class="headerlink" title="3.20 纯粹的数据类(Data Class)"></a>3.20 纯粹的数据类(Data Class)</h2><p>拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物。</p><h2 id="3-21-被拒绝的遗赠-Refused-Bequest"><a href="#3-21-被拒绝的遗赠-Refused-Bequest" class="headerlink" title="3.21 被拒绝的遗赠(Refused Bequest)"></a>3.21 被拒绝的遗赠(Refused Bequest)</h2><h2 id="3-22-过多的注释-Comments"><a href="#3-22-过多的注释-Comments" class="headerlink" title="3.22 过多的注释(Comments)"></a>3.22 过多的注释(Comments)</h2><p>当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。</p><h1 id="第4章-构筑测试体系"><a href="#第4章-构筑测试体系" class="headerlink" title="第4章 构筑测试体系"></a>第4章 构筑测试体系</h1><h2 id="4-1-自测试代码的价值"><a href="#4-1-自测试代码的价值" class="headerlink" title="4.1 自测试代码的价值"></a>4.1 自测试代码的价值</h2><p>修复错误通常比较快，但找出错误却是噩梦一场。</p><p>确保所有测试都完全自动化，让它们检查自己的测试结果。</p><p>每写一个小功能，就立即添加测试。</p><p>一套测试就是一个强大的bug侦测器，能够大大缩减查找bug所需要的时间。</p><p>编写测试代码的最有用时机是在开始编程之前当你需要添加新特性的时候，先写相应测试代码。因为编写测试代码其实就是在问自己：添加这个功能需要做些什么？此外，编写测试代码还能使你把注意力集中于接口而非实现。预先写好的测试代码也为你的工作安上了一个明确的结束标志：一旦测试代码正常运行，工作就算完成了。</p><p>我们可以建立一个独立类用于测试，并在一个框架中运行它，使测试工作更轻松。</p><h2 id="4-2-JUnit测试框架"><a href="#4-2-JUnit测试框架" class="headerlink" title="4.2 JUnit测试框架"></a>4.2 JUnit测试框架</h2><p>单元测试需要我们去控制台查看测试结果，而引入单元测试框架后会自动帮我们校验结果的正确与否。</p><p>通常Java中常用的单元测试框架包含三个功能：</p><ul><li>测试工具：确保测试能够在共享且固定的环境中运行，保证测试结果的可重复性，具体负责初始化测试环境、准备测试数据和测试数据清理；</li><li>测试套件：捆绑几个测试案例同时运行；</li><li>测试允许器：用于执行测试案例，一般负责调用需要被测试的单元、收集结果并和期望值比较。</li></ul><p>测试Demo：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalculateServiceImplTest</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(CalculateServiceImplTest<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-keyword">private</span> CalculateService calculateService;    <span class="hljs-meta">@Before</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        logger.info(<span class="hljs-string">"begin to test..."</span>);        calculateService = <span class="hljs-keyword">new</span> CalculateServiceImpl();    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAdd</span><span class="hljs-params">()</span></span>&#123;        Assert.assertEquals(calculateService.add(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>),<span class="hljs-number">4</span>);    &#125;    <span class="hljs-meta">@After</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tearDown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        logger.info(<span class="hljs-string">"end to test..."</span>);    &#125;&#125;</code></pre></div><h3 id="Assert类"><a href="#Assert类" class="headerlink" title="Assert类"></a>Assert类</h3><p>该类提供了一系列用于检测测试结果的方法，只有失败的声明方法才会被记录。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">assertEquals</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> expected, <span class="hljs-keyword">boolean</span> actual)</span></span></code></pre></div><p>检查两个变量或者等式是否平衡</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">assertFalse</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> condition)</span></span></code></pre></div><p>检查条件是假的</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">assertNotNull</span><span class="hljs-params">(Object object)</span></span></code></pre></div><p>检查对象不是空的</p><h3 id="JUnit中的注解"><a href="#JUnit中的注解" class="headerlink" title="JUnit中的注解"></a>JUnit中的注解</h3><ul><li><code>@BeforeClass</code>：针对所有测试，只执行一次，且必须为static void</li><li><code>@Before</code>：初始化方法</li><li><code>@Test</code>：测试方法，在这里可以测试期望异常和超时时间</li><li><code>@After</code>：释放资源</li><li><code>@AfterClass</code>：针对所有测试，只执行一次，且必须为static void</li><li><code>@Ignore</code>：忽略的测试方法</li></ul><p>一个单元测试类执行顺序为：</p><p><code>@BeforeClass</code> –&gt; <code>@Before</code> –&gt; <code>@Test</code> –&gt; <code>@After</code> –&gt; <code>@AfterClass</code></p><p>每一个测试方法的调用顺序为：</p><p><code>@Before</code> –&gt; <code>@Test</code> –&gt; <code>@After</code></p><p>@Test(timeout = 1000)：指定测试用例的执行时间，如果超过该时间，那么JUnit会将它标记为失败。</p><p>@Test(expected = NullPointerException.class)：测试代码是否抛出了想要得到的异常。</p><h2 id="4-3-测试技巧"><a href="#4-3-测试技巧" class="headerlink" title="4.3 测试技巧"></a>4.3 测试技巧</h2><p>测试的一项重要技巧是“寻找边界条件”，如第一个字符、最后一个字符、倒数第二个字符等。</p><p>对于文件相关测试，空文件也是一个不错的边界条件。</p><p>当事情认定会出错时，别忘了检查是否抛出了预期的异常。</p><p>单元测试基本准则：<a href="https://www.cnblogs.com/54chensongxia/p/12410239.html" target="_blank" rel="noopener">https://www.cnblogs.com/54chensongxia/p/12410239.html</a></p><h1 id="第5章-重构列表"><a href="#第5章-重构列表" class="headerlink" title="第5章 重构列表"></a>第5章 重构列表</h1><h2 id="5-1-重构的记录格式"><a href="#5-1-重构的记录格式" class="headerlink" title="5.1 重构的记录格式"></a>5.1 重构的记录格式</h2><p>每个重构手法都包括如下五个部分：</p><ul><li>名称（name）</li><li>简短概要（summary）：简单介绍此重构手法的适用场景，以及它所做的事情；</li><li>动机（motivation）：为什么需要重构，以及什么情况下不该使用这个重构；</li><li>做法（mechanics）：进一步介绍如何进行此重构；</li><li>范例（examples）</li></ul><p>“概要”包括三部分：</p><ul><li>一句话介绍这个重构能够帮助解决的问题；</li><li>一段简短陈述，介绍你应该做的事；</li><li>一幅UML图或一段代码，简单展示重构前后示例。</li></ul><h2 id="5-2-寻找引用点"><a href="#5-2-寻找引用点" class="headerlink" title="5.2 寻找引用点"></a>5.2 寻找引用点</h2><p>可以利用工具找到对于某个函数、某个字段或某个类的所有引用点，但是不要盲目地查找-替换，应该仔细检查每个引用点，确定它的确指向你想要替换的东西。</p><h2 id="5-3-这些重构手法有多成熟"><a href="#5-3-这些重构手法有多成熟" class="headerlink" title="5.3 这些重构手法有多成熟"></a>5.3 这些重构手法有多成熟</h2><p>重构的基本技巧–小步前进、频繁测试。</p><p>设计模式是你希望到达的目标，重构则是到达之路。</p><h1 id="第6章-重新组织函数"><a href="#第6章-重新组织函数" class="headerlink" title="第6章 重新组织函数"></a>第6章 重新组织函数</h1><h2 id="6-1-提炼函数-Extract-Method"><a href="#6-1-提炼函数-Extract-Method" class="headerlink" title="6.1 提炼函数(Extract Method)"></a>6.1 提炼函数(Extract Method)</h2><p>如果有一段代码可以被组织在一起并独立出来，则将它们放入一个独立函数中，并让函数名称解释该函数的用途。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printOwing</span><span class="hljs-params">(<span class="hljs-keyword">double</span> amount)</span> </span>&#123;    printBanner();    System.out.println(<span class="hljs-string">"name:"</span> + name);    System.out.println(<span class="hljs-string">"amount:"</span> + amount);&#125;</code></pre></div><p>替换为：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printOwing</span><span class="hljs-params">(<span class="hljs-keyword">double</span> amount)</span> </span>&#123;    printBanner();    printDetails(amount);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printDetails</span><span class="hljs-params">(<span class="hljs-keyword">double</span> amount)</span> </span>&#123;    System.out.println(<span class="hljs-string">"name:"</span> + name);    System.out.println(<span class="hljs-string">"amount:"</span> + amount);&#125;</code></pre></div><p><strong>动机</strong></p><p>如果每个函数的粒度都很小，那么函数被复用的机会就很大，而且高层函数读起来很容易理解，函数的重写也会更容易。</p><p><strong>做法</strong></p><ul><li>创造一个新函数，根据这个函数的意图（功能）来对它命名，而不是以它“怎么做”来命名。</li><li>将提炼出的代码从源函数复制到新建的目标函数中；</li><li>仔细检查提炼出的代码，看看其中是否引用了“作用域限于源函数”的变量；</li><li>检查是否有“仅用于被提炼代码段”的临时变量，如果有，在目标函数中将它们声明为临时变量；</li><li>检查被提炼代码段，看看是否有任何局部变量的值被它改变，如果有，看看是否可以将被提炼代码段处理为一个查询，并将结果赋给相关变量；</li><li>将被提炼代码段中需要读取的局部变量，当做参数传给目标函数；</li><li>处理完所有局部变量后，进行编译；</li><li>在源函数中，将被提炼代码段替换为对目标函数的调用。（如果临时变量的声明在被提炼代码段的外围，记得删除这些声明）</li><li>编译、测试</li></ul><p><strong>范例：对局部变量再赋值</strong></p><p>分两种情况：</p><ul><li>这个变量只在被提炼代码段中使用：将这个临时变量的声明移到被提炼代码段中，然后一起提炼出去；</li><li>被提炼代码段之外的代码也使用了这个变量，这里分两种情况：<ul><li>如果这个变量在被提炼代码段之后再未被使用：直接在目标函数中修改；</li><li>如果这个变量在被提炼代码段之后也被使用：让目标函数返回该变量改变后的值。</li></ul></li></ul><p>初始代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printOwing</span><span class="hljs-params">(<span class="hljs-keyword">double</span> previousAmount)</span></span>&#123;    Enumeration e = _orders.elements();    <span class="hljs-keyword">double</span> outstanding = previousAmount * <span class="hljs-number">2</span>;    printBanner();    <span class="hljs-keyword">while</span>(e.hasMoreElements())&#123;        Order each = (Order) e.nextElement();        outstanding += each.getAmount();    &#125;    printDetails(outstanding);&#125;</code></pre></div><p>重构后的代码：</p><div class="hljs"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printOwing</span><span class="hljs-params">(<span class="hljs-keyword">double</span> previousAmount)</span></span>&#123;     printBanner();     outstanding = getOutstanding(previousAmount * <span class="hljs-number">2</span>);     printDetails(outstanding); &#125;    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getOutstanding</span><span class="hljs-params">(<span class="hljs-keyword">double</span> initialValue)</span></span>&#123;    Double result = initialValue;    Enumeration e = _orders.elements();    <span class="hljs-keyword">while</span>(e.hasMoreElements())&#123;        Order each = (Order) e.nextElement();        result += each.getAmount();    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>如果需要返回的变量不止一个，最好的选择是：挑选另一块代码来提炼，让每个函数都只返回一个值。</p><h2 id="6-2-内联函数-Inline-Method"><a href="#6-2-内联函数-Inline-Method" class="headerlink" title="6.2 内联函数(Inline Method)"></a>6.2 内联函数(Inline Method)</h2><p><strong>动机</strong></p><p>如果一个函数的本体与名称同样清楚易懂，在函数调用点插入函数本体，然后移除该函数。</p><p>如果有一群组织不甚合理的函数，可以将它们都内联到一个大型函数中，再从中提炼出组织合理的小型函数。</p><p><strong>做法</strong></p><ul><li>检查函数，确定它不具备多态性；</li><li>找出这个函数的所有被调用点；</li><li>将这个函数的所有被调用点都替换为函数主体；</li><li>编译、测试</li><li>删掉该函数的定义</li></ul><h2 id="6-3-内联临时变量-Inline-Temp"><a href="#6-3-内联临时变量-Inline-Temp" class="headerlink" title="6.3 内联临时变量(Inline Temp)"></a>6.3 内联临时变量(Inline Temp)</h2><p>如果某个临时变量很少被用到，可以将所有对该变量的引用动作，替换为对它赋值的那个表达式自身。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">double</span> basicPrice = anOrder.basePrice();<span class="hljs-keyword">return</span> (basicPrice &gt; <span class="hljs-number">1000</span>);</code></pre></div><p>替换为：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">return</span> (anOrder.basePrice() &gt; <span class="hljs-number">1000</span>);</code></pre></div><p><strong>做法</strong></p><ul><li>检查给临时变量赋值的语句，确保等号右边的表达式没有副作用；</li><li><strong>如果在这个临时变量并未被声明为final，那就将它声明为final，然后编译，可以检查该变量是否真的只被赋值一次</strong>；</li><li>找到该临时变量的所有引用点，将它们替换为“为临时变量赋值”的表达式；</li><li>每次修改后，编译并测试；修改完所有引用点之后，删除该临时变量的声明和赋值语句；</li><li>编译、测试</li></ul><h2 id="6-4-以查询取代临时变量-Replace-Temp-with-Query"><a href="#6-4-以查询取代临时变量-Replace-Temp-with-Query" class="headerlink" title="6.4 以查询取代临时变量(Replace Temp with Query)"></a>6.4 以查询取代临时变量(Replace Temp with Query)</h2><p>如果临时变量保存某一表达式的运算结果，则将这个表达式提炼到一个独立函数中，将这个临时变量的所有引用点替换为对新函数的调用。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">double</span> basePrice = quantity * itemPrice;<span class="hljs-keyword">if</span>(basePrice &gt; <span class="hljs-number">1000</span>)&#123;<span class="hljs-keyword">return</span> basePrice * <span class="hljs-number">0.95</span>;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> basePrice * <span class="hljs-number">0.98</span>;&#125;</code></pre></div><p>替换为：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(basePrice() &gt; <span class="hljs-number">1000</span>)&#123;<span class="hljs-keyword">return</span> basePrice() * <span class="hljs-number">0.95</span>;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> basePrice() * <span class="hljs-number">0.98</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">basePrice</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> quantity * itemPrice;&#125;</code></pre></div><p><strong>做法</strong></p><p>简单情况：</p><ul><li>找出只被赋值一次的临时变量（如果被赋值超过一次，考虑将它分割成多个变量）；</li><li>将该变量声明为final（确保只被赋值一次）；</li><li>编译</li><li>将赋值语句等号右侧部分提炼到一个独立函数中；<ul><li>首先将函数声明为private，如果后面有其他类需要使用，可以再改变；</li><li>确保该函数并不修改任何对象内容。</li></ul></li><li>编译、测试</li></ul><h2 id="6-5-引入解释性变量-Introduce-Explaining-Variable"><a href="#6-5-引入解释性变量-Introduce-Explaining-Variable" class="headerlink" title="6.5 引入解释性变量(Introduce Explaining Variable)"></a>6.5 引入解释性变量(Introduce Explaining Variable)</h2><p>如果有一个复杂表达式，可以将该表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">if</span>((platform.toUpperCase().indexOf(<span class="hljs-string">"MAC"</span>) &gt; -<span class="hljs-number">1</span>) &amp;&amp; (browser.toUpperCase().indexOf(<span class="hljs-string">"IE"</span>) &gt; -<span class="hljs-number">1</span>) &amp;&amp; wasInitialized() &amp;&amp; resize &gt; <span class="hljs-number">0</span>)&#123;&#125;</code></pre></div><p>替换为：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isMacOs = platform.toUpperCase().indexOf(<span class="hljs-string">"MAC"</span>) &gt; -<span class="hljs-number">1</span>;<span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isIEBrowser = browser.toUpperCase().indexOf(<span class="hljs-string">"IE"</span>) &gt; -<span class="hljs-number">1</span>;<span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> wasResized = resize &gt; <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(isMacOs &amp;&amp; isIEBrowser &amp;&amp; wasInitialized &amp;&amp; wasResized)&#123;&#125;</code></pre></div><p>除非是要处理一个拥有大量局部变量的算法，否则一般情况下都会考虑Extract Method对函数进行提炼。</p><h2 id="6-6-分解临时变量-Split-Temporary-Variable"><a href="#6-6-分解临时变量-Split-Temporary-Variable" class="headerlink" title="6.6 分解临时变量(Split Temporary Variable)"></a>6.6 分解临时变量(Split Temporary Variable)</h2><p>如果程序中有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果，可以<strong>针对每次赋值，创造一个独立、对应的临时变量。</strong></p><p><strong>范例</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getDistanceTravelled</span><span class="hljs-params">(<span class="hljs-keyword">int</span> time)</span></span>&#123;    <span class="hljs-keyword">double</span> result;    <span class="hljs-keyword">double</span> acc = primaryForce / mass;    <span class="hljs-keyword">int</span> primaryTime = Math.min(time,delay);    result = <span class="hljs-number">0.5</span> * acc * primaryTime * primaryTime;    <span class="hljs-keyword">int</span> secondaryTime = time - delay;    <span class="hljs-keyword">if</span>(secondaryTime &gt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">double</span> primaryVel = acc * delay;        acc = (primaryForce + secondaryForce) / mass;        result += primaryVel * secondaryTime + <span class="hljs-number">0.5</span> * acc * secondaryTime * secondaryTime;    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>第一个acc是保存第一个力造成的初始加速度，第二个是保存两个力共同造成的加速度。</p><ul><li>首先，在函数开始处修改这个临时变量名称，并声明为final；</li><li>接着，把第二次赋值之前对acc变量的所有引用点全部改为新的临时变量；</li><li>最后，在第二次赋值处重新声明acc变量。</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getDistanceTravelled</span><span class="hljs-params">(<span class="hljs-keyword">int</span> time)</span></span>&#123;        <span class="hljs-keyword">double</span> result;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> primaryAcc = primaryForce / mass;        <span class="hljs-keyword">int</span> primaryTime = Math.min(time,delay);        result = <span class="hljs-number">0.5</span> * primaryAcc * primaryTime * primaryTime;        <span class="hljs-keyword">int</span> secondaryTime = time - delay;        <span class="hljs-keyword">if</span>(secondaryTime &gt; <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">double</span> primaryVel = primaryAcc * delay;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> secondaryAcc = (primaryForce + secondaryForce) / mass;            result += primaryVel * secondaryTime + <span class="hljs-number">0.5</span> * secondaryAcc * secondaryTime * secondaryTime;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;</code></pre></div><h2 id="6-7-移除对参数的赋值-Remove-Assignments-to-Parameters"><a href="#6-7-移除对参数的赋值-Remove-Assignments-to-Parameters" class="headerlink" title="6.7 移除对参数的赋值(Remove Assignments to Parameters)"></a>6.7 移除对参数的赋值(Remove Assignments to Parameters)</h2><p>代码对一个参数进行赋值，以一个临时变量取代该参数的位置。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">discount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> inputVal,<span class="hljs-keyword">int</span> quantity,<span class="hljs-keyword">int</span> yearToDate)</span></span>&#123;    <span class="hljs-keyword">if</span>(inputVal&gt;<span class="hljs-number">50</span>)&#123;        inputVal -= <span class="hljs-number">2</span>;    &#125;&#125;</code></pre></div><p>替换为：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">discount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> inputVal,<span class="hljs-keyword">int</span> quantity,<span class="hljs-keyword">int</span> yearToDate)</span></span>&#123;<span class="hljs-keyword">int</span> result = inputVal;    <span class="hljs-keyword">if</span>(inputVal&gt;<span class="hljs-number">50</span>)&#123;        result -= <span class="hljs-number">2</span>;    &#125;&#125;</code></pre></div><p>这里需要明确“对参数赋值”的含义，如果是在“被传入对象”身上进行什么操作，那没问题，而如果该对象指向另一个对象，则最好进行修改。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aMethod</span><span class="hljs-params">(Object foo)</span></span>&#123;foo.modifyInSomeWay();  <span class="hljs-comment">//that's OK</span>foo = anotherObject;<span class="hljs-comment">//trouble and despair will follow you</span>&#125;</code></pre></div><p><strong>Java的按值传递</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Param</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Date d1 = <span class="hljs-keyword">new</span> Date(<span class="hljs-string">"1 Apr 98"</span>);        nextDateUpdate(d1);        System.out.println(<span class="hljs-string">"d1 after nextDay："</span> + d1);        Date d2 = <span class="hljs-keyword">new</span> Date(<span class="hljs-string">"1 Apr 98"</span>);        nextDateReplace(d2);        System.out.println(<span class="hljs-string">"d2 after nextDay:"</span> + d2);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextDateUpdate</span><span class="hljs-params">(Date arg)</span> </span>&#123;        arg.setDate(arg.getDate() + <span class="hljs-number">1</span>);        System.out.println(<span class="hljs-string">"arg in nextDay:"</span> + arg);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextDateReplace</span><span class="hljs-params">(Date arg)</span> </span>&#123;        arg = <span class="hljs-keyword">new</span> Date(arg.getYear(), arg.getMonth(), arg.getDate() + <span class="hljs-number">1</span>);        System.out.println(<span class="hljs-string">"arg in nextDay:"</span> + arg);    &#125;&#125;</code></pre></div><p>输出结果：</p><div class="hljs"><pre><code class="hljs j">arg in nextDay:Thu Apr 02 00:00:00 CST 1998d1 after nextDay：Thu Apr 02 00:00:00 CST 1998arg in nextDay:Thu Apr 02 00:00:00 CST 1998d2 after nextDay:Wed Apr 01 00:00:00 CST 1998</code></pre></div><h2 id="6-8-以函数对象取代函数-Replace-Method-with-Method-Object"><a href="#6-8-以函数对象取代函数-Replace-Method-with-Method-Object" class="headerlink" title="6.8 以函数对象取代函数(Replace Method with Method Object)"></a>6.8 以函数对象取代函数(Replace Method with Method Object)</h2><p>如果一个大型函数有许多局部变量，可以将这个函数放进一个单独对象中，让局部变量成为对象内的字段，然后在同一个对象中将这个大型函数分解为多个小型函数。</p><div class="hljs"><pre><code class="hljs java">Class Order...<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">price</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">primaryBasePrice</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">secondaryBasePrice</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">tertiaryBasePrice</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>转变为：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529222035.png" srcset="/img/loading.gif" alt="image-20210528221101435"></p><p><strong>做法</strong></p><ul><li>新建一个类，根据用途来命名；</li><li>在新类中建立一个final字段，用以保存原先大型函数所在的对象，简称“源对象”，同时针对原函数的每个临时变量和每个参数，在新类中建立一个对应的字段保存；</li><li>在新类中建立一个构造函数，接收源对象及原函数的所有参数作为参数；</li><li>在新类中建立一个compute()函数；</li><li>将原函数的代码复制到compute()函数中；</li><li>编译</li><li>将旧函数的函数本体替换为：创建新类的一个对象，然后调用compute()方法。</li></ul><h2 id="6-9-替换算法-Substitute-Algorithm"><a href="#6-9-替换算法-Substitute-Algorithm" class="headerlink" title="6.9 替换算法(Substitute Algorithm)"></a>6.9 替换算法(Substitute Algorithm)</h2><p>如果你发现做一件事可以有更清晰的方式，那就应该以较清晰的方式取代复杂的方式。</p><p><strong>做法</strong></p><ul><li>准备好另一个（替换用）算法，让它通过编译；</li><li>针对现有测试，执行上述的新算法，比较两者的效果。</li></ul><h1 id="第7章-在对象之间搬移特性"><a href="#第7章-在对象之间搬移特性" class="headerlink" title="第7章 在对象之间搬移特性"></a>第7章 在对象之间搬移特性</h1><h2 id="7-1-搬移函数-Move-Method"><a href="#7-1-搬移函数-Move-Method" class="headerlink" title="7.1 搬移函数(Move Method)"></a>7.1 搬移函数(Move Method)</h2><p>如果一个类有太多行为，或如果一个类与另一个类有太多合作而形成高度耦合，就要考虑搬移函数。</p><p><strong>做法</strong></p><ul><li>检查源类中被源函数所使用的一切特性（包括字段和函数），考虑它们是否也该被搬移；</li><li>检查源类的子类和超类，看看是否有该函数的其他声明；</li><li>在目标类中声明这个函数；</li><li>将源函数的代码复制到目标函数中，使其能正常工作；</li><li>编译目标类；</li><li>决定如何从源函数正确引入目标对象；</li><li>修改源函数，使之成为一个纯委托函数；</li><li>编译、测试；</li><li>决定是否删除源函数，或将它当做一个委托函数保留下来；</li><li>编译、测试。</li></ul><p><strong>范例</strong></p><p>用一个表示“账户”的Account类来说明这项重构：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;    <span class="hljs-keyword">private</span> AccountType type;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> daysOverdrawn;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 透支金额计费规则</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">overdraftCharge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (type.isPremium()) &#123;            <span class="hljs-keyword">double</span> result = <span class="hljs-number">10</span>;            <span class="hljs-keyword">if</span> (daysOverdrawn &gt; <span class="hljs-number">7</span>) &#123;                result += (daysOverdrawn - <span class="hljs-number">7</span>) * <span class="hljs-number">0.85</span>;            &#125;            <span class="hljs-keyword">return</span> result;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> daysOverdrawn * <span class="hljs-number">1.75</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">bankCharge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">double</span> result = <span class="hljs-number">4.5</span>;        <span class="hljs-keyword">if</span> (daysOverdrawn &gt; <span class="hljs-number">0</span>) &#123;            result += overdraftCharge();        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre></div><p>因为“透支金额计费规则”随着账户类型而变化，所以将overdraftCharge()搬移到AccountType类去。</p><p>第一步：观察被overdraftCharge()使用的每一项特性，考虑是否值得将它们与overdraftCharge()一起移动，这里需要让daysOverdrawn留在Account类，因为这个值会随不同账户而变化。将函数复制到AccountType中，并进行相应调整。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">overdraftCharge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> daysOverdrawn)</span> </span>&#123;        <span class="hljs-keyword">if</span> (isPremium()) &#123;            <span class="hljs-keyword">double</span> result = <span class="hljs-number">10</span>;            <span class="hljs-keyword">if</span> (daysOverdrawn &gt; <span class="hljs-number">7</span>) &#123;                result += (daysOverdrawn - <span class="hljs-number">7</span>) * <span class="hljs-number">0.85</span>;            &#125;            <span class="hljs-keyword">return</span> result;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> daysOverdrawn * <span class="hljs-number">1.75</span>;        &#125;    &#125;</code></pre></div><p>当我们需要使用源类的特性时，有4种选择：</p><ol><li>将这个特性也移到目标类；</li><li>建立或使用一个从目标类到源类的引用关系；</li><li>将源对象当做参数传给目标函数；</li><li>如果特性是个变量，将它当做参数传给目标函数。</li></ol><p>调整目标函数使之通过编译，然后就可以将源函数的函数本体替换为一个简单的委托动作，然后编译并测试。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">overdraftCharge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> type.overdraftCharge(daysOverdrawn);    &#125;</code></pre></div><h2 id="7-2-搬移字段-Move-Field"><a href="#7-2-搬移字段-Move-Field" class="headerlink" title="7.2 搬移字段(Move Field)"></a>7.2 搬移字段(Move Field)</h2><p>如果某个字段被其所驻类之外的类更多地用到，则需要在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段。</p><p><strong>范例</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;    <span class="hljs-keyword">private</span> AccountType type;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> daysOverdrawn;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> interestRate;    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">interestForAmount_days</span><span class="hljs-params">(<span class="hljs-keyword">double</span> amount,<span class="hljs-keyword">int</span> days)</span></span>&#123;        <span class="hljs-keyword">return</span> interestRate * amount * days / <span class="hljs-number">365</span>;    &#125;&#125;</code></pre></div><p>这里我想把表示利率的interestRate搬移到AccountType类去。</p><p>在AccountType中建立interestRate字段以及相应的访问函数：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountType</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> interestRate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getInterestRate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> interestRate;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setInterestRate</span><span class="hljs-params">(<span class="hljs-keyword">double</span> interestRate)</span> </span>&#123;        <span class="hljs-keyword">this</span>.interestRate = interestRate;    &#125;&#125;</code></pre></div><p>现在需要让Account类中访问interestRate字段的函数转而使用AccountType对象，然后删除Account类中的interestRate字段。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">interestForAmount_days</span><span class="hljs-params">(<span class="hljs-keyword">double</span> amount,<span class="hljs-keyword">int</span> days)</span></span>&#123;    <span class="hljs-keyword">return</span> type.getInterestRate() * amount * days / <span class="hljs-number">365</span>;&#125;</code></pre></div><h2 id="7-3-提炼类-Extract-Class"><a href="#7-3-提炼类-Extract-Class" class="headerlink" title="7.3 提炼类(Extract Class)"></a>7.3 提炼类(Extract Class)</h2><p>如果某个类做了应该由两个类做的事，则需要建立一个新类，将相关的字段和函数从旧类搬移到新类。</p><p>一个类应该是一个清楚的抽象，处理一些明确的责任。</p><h2 id="7-4-将类内联化-Inline-Class"><a href="#7-4-将类内联化-Inline-Class" class="headerlink" title="7.4 将类内联化(Inline Class)"></a>7.4 将类内联化(Inline Class)</h2><p>如果某个类没有做太多事情，则考虑将这个类的所有特性搬移到另一个类中，然后移除原类。</p><h2 id="7-5-隐藏“委托关系”-Hide-Delegate"><a href="#7-5-隐藏“委托关系”-Hide-Delegate" class="headerlink" title="7.5 隐藏“委托关系”(Hide Delegate)"></a>7.5 隐藏“委托关系”(Hide Delegate)</h2><p>客户通过一个委托类来调用另一个对象，如在服务类上建立客户所需的所有函数，用以隐藏委托关系。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529222048.png" srcset="/img/loading.gif" alt="image-20210528221542715"></p><p><strong>做法</strong></p><ul><li>对于每一个委托关系中的函数，在服务对象端建立一个简单的委托函数；</li><li>调整客户，令它只调用服务对象提供的函数；</li><li>每次调整后，编译并测试；</li><li>如果将来不再有任何客户需要取用Delegate(受托类)，便可移除服务对象中的相关访问函数；</li><li>编译，测试。</li></ul><p><strong>范例</strong></p><p>先编写代表“人”的Person和代表“部门”的Department：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    Department department;    <span class="hljs-function"><span class="hljs-keyword">public</span> Department <span class="hljs-title">getDepartment</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> department;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDepartment</span><span class="hljs-params">(Department department)</span> </span>&#123;        <span class="hljs-keyword">this</span>.department = department;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Department</span> </span>&#123;    <span class="hljs-keyword">private</span> String chargeCode;    <span class="hljs-keyword">private</span> Person manager;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Department</span><span class="hljs-params">(Person manager)</span> </span>&#123;        <span class="hljs-keyword">this</span>.manager = manager;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">getManager</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> manager;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setManager</span><span class="hljs-params">(Person manager)</span> </span>&#123;        <span class="hljs-keyword">this</span>.manager = manager;    &#125;&#125;</code></pre></div><p>如果客户希望知道某人的经理是谁，他必须先取得Department对象：</p><div class="hljs"><pre><code class="hljs java">manager = john.getDepartment().getManager();</code></pre></div><p>这样的编码就是对客户揭露了Department的工作内容，而且属于高耦合代码，为了对客户隐藏Department，减少耦合，在Person类中建立一个简单的委托函数：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">getManager</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> department.getManager();&#125;</code></pre></div><p>然后让Person的所有对象去调用新函数getManager，就可以将getDepartment()移除了。</p><h2 id="7-6-移除中间人-Remove-Middle-Man"><a href="#7-6-移除中间人-Remove-Middle-Man" class="headerlink" title="7.6 移除中间人(Remove Middle Man)"></a>7.6 移除中间人(Remove Middle Man)</h2><p>某个类做了<strong>过多</strong>的简单委托动作，让客户直接调用受托类。</p><h2 id="7-7-引入外加函数-Introduce-Foreign-Method"><a href="#7-7-引入外加函数-Introduce-Foreign-Method" class="headerlink" title="7.7 引入外加函数(Introduce Foreign Method)"></a>7.7 引入外加函数(Introduce Foreign Method)</h2><p>当你需要为提供服务的类增加一个函数，但无法修改这个类的时候，可以在客户类中建立一个函数(nextDay)，并以第一参数形式传入一个服务类实例(previousEnd)。</p><div class="hljs"><pre><code class="hljs java">Date newStart = <span class="hljs-keyword">new</span> Date(previousEnd.getYear(),previousEnd.getMonth(),previousEnd.getDate()+<span class="hljs-number">1</span>);</code></pre></div><p>替换为：</p><div class="hljs"><pre><code class="hljs java">Date newStart = nextDay(previousEnd);<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">nextDay</span><span class="hljs-params">(Date arg)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Date(arg.getYear(),arg.geteMonth(),arg.getDate()+<span class="hljs-number">1</span>);&#125;</code></pre></div><h2 id="7-8-引入本地扩展-Introduce-Local-Extension"><a href="#7-8-引入本地扩展-Introduce-Local-Extension" class="headerlink" title="7.8 引入本地扩展(Introduce Local Extension)"></a>7.8 引入本地扩展(Introduce Local Extension)</h2><p>当你需要为服务类提供<strong>一些</strong>额外函数，但你无法修改这个类的时候，可以建立一个新类，使它包含这些额外函数（<strong>新特性</strong>），让这个扩展品成为源类的<strong>子类</strong>或者<strong>包装类</strong>。</p><p><strong>范例</strong></p><p>以Java1.0.1的Date类为例，假设我有一些功能需要增加。</p><p>使用子类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MfDateSub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Date</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MfDateSub</span><span class="hljs-params">(Date arg)</span></span>&#123;        <span class="hljs-keyword">super</span>(arg.getTime());    &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> MfDateSub <span class="hljs-title">nextDay</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Date(getYear(),getMonth(),getDate()+<span class="hljs-number">1</span>);    &#125;&#125;</code></pre></div><p>使用包装类则需要用上委托：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MfDateWrap</span></span>&#123;<span class="hljs-keyword">private</span> Date original;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MfDateWrap</span><span class="hljs-params">(String dateString)</span></span>&#123;        original = <span class="hljs-keyword">new</span> Date(dateString);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MfDateWrap</span><span class="hljs-params">(Date arg)</span></span>&#123;        original = arg;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">nextDay</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Date(getYear(),getMonth(),getDate()+<span class="hljs-number">1</span>);    &#125;&#125;</code></pre></div><h1 id="第8章-重新组织数据"><a href="#第8章-重新组织数据" class="headerlink" title="第8章 重新组织数据"></a>第8章 重新组织数据</h1><h2 id="8-1-自封装字段-Self-Encapsulate-Field"><a href="#8-1-自封装字段-Self-Encapsulate-Field" class="headerlink" title="8.1 自封装字段(Self Encapsulate Field)"></a>8.1 自封装字段(Self Encapsulate Field)</h2><p>为字段建立取值/设置函数，并且只以这些函数来访问字段。</p><h2 id="8-2-以对象取代数据值-Replace-Data-Value-with-Object"><a href="#8-2-以对象取代数据值-Replace-Data-Value-with-Object" class="headerlink" title="8.2 以对象取代数据值(Replace Data Value with Object)"></a>8.2 以对象取代数据值(Replace Data Value with Object)</h2><p>比如说我们通常用字符串来存储电话号码，但是一旦需要将电话号码“格式化”或者“抽取区号”等，那我们就需要将电话号码转换为对象。</p><p><strong>范例</strong></p><p>订单类Order，用字符串customer来记录订单客户。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span> </span>&#123;    <span class="hljs-keyword">private</span> String customer;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Order</span><span class="hljs-params">(String customer)</span> </span>&#123;        <span class="hljs-keyword">this</span>.customer = customer;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCustomer</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> customer;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCustomer</span><span class="hljs-params">(String customer)</span> </span>&#123;        <span class="hljs-keyword">this</span>.customer = customer;    &#125;&#125;</code></pre></div><p>改造，新建一个Customer类来表示“客户”概念，然后在这个类中建立一个final字段，用以保存一个字符串，记录客户名称。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Customer</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;&#125;</code></pre></div><p>接着将Order中的customer字段的类型修改为Customer，并修改所有引用该字段的函数。</p>]]></content>
    
    
    <categories>
      
      <category>Java开发规范</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java开发规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA Debug指南</title>
    <link href="/2021/05/29/IDEA-Debug%E6%8C%87%E5%8D%97/"/>
    <url>/2021/05/29/IDEA-Debug%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://www.cnblogs.com/chiangchou/p/idea-debug.html#_label3" target="_blank" rel="noopener">https://www.cnblogs.com/chiangchou/p/idea-debug.html#_label3</a></p><p>由于原文的IDEA版本与本人实际使用的版本（<strong>本人IDEA版本为2018.2.4</strong>）略有不同，因此在原文的基础上进行了一些修改。</p><h2 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h2><p>Debug用来追踪代码的运行流程，通常在程序运行过程中出现异常，启用Debug模式可以分析定位异常发生的位置，以及在运行过程中参数的变化。通常我们也可以启用Debug模式来跟踪代码的运行流程去学习三方框架的源码。</p><h2 id="一、Debug开篇"><a href="#一、Debug开篇" class="headerlink" title="一、Debug开篇"></a>一、Debug开篇</h2><p>首先看下IDEA中Debug模式下的界面。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529195822.png" srcset="/img/loading.gif" alt="image-20210529195822117"></p><center>图 1.1</center><p>简单说下图中标注的8个地方：</p><ol><li>以Debug模式启动程序，左边的一个三角形按钮则是以<code>Run</code>模式启动。在开发中，我一般会直接启动Debug模式，方便随时调试代码。</li><li>断点：在左边行号栏单击左键，或者快捷键<code>Ctrl+F8</code>打上/取消断点，断点行的颜色可自己去设置。</li><li>Debug窗口：访问请求到达第一个断点后，会自动激活Debug窗口。如果没有自动激活，可以去设置里设置，勾选即可，如图1.2。</li><li>调试按钮：一共有8个按钮，调试的主要用到这几个按钮，鼠标悬停在按钮上可以查看对应的快捷键。在菜单栏<code>Run</code>里可以找到同样的对应的功能，如图1.4。</li><li>服务按钮：可以在这里关闭/启动服务，设置断点等。</li><li>方法调用栈：这里显示了该线程调试所经过的所有方法，勾选右上角的<code>[Show All Frames]</code>按钮，就不会显示其它类库的方法了，否则这里会有一大堆的方法。</li><li>Variables：在变量区可以查看当前断点之前的当前方法内的变量。</li><li>Watches：查看变量，可以将Variables区中的变量拖到Watches中查看 。</li></ol><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194752.png" srcset="/img/loading.gif" alt="img"></p><center>图 1.2</center><p>如果你的IDEA底部没有显示工具栏或状态栏，可以在View里打开，显示出工具栏会方便我们使用。可以勾选以下这四个选项。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529195851.png" srcset="/img/loading.gif" alt="image-20210523084528274"></p><center>图 1.3</center><p>在菜单栏Run里有调试对应的功能，同时可以查看对应的快捷键。　　</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529195929.png" srcset="/img/loading.gif" alt="image-20210523084655256"></p> <center>图 1.4</center><h2 id="二、基本用法-amp-快捷键"><a href="#二、基本用法-amp-快捷键" class="headerlink" title="二、基本用法&amp;快捷键"></a>二、基本用法&amp;快捷键</h2><p>Debug调试的功能主要对应着图一中4和5两组按钮（快捷键以实际为准）：</p><p>1、首先说第一组按钮，共8个按钮，从左到右依次如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529195941.png" srcset="/img/loading.gif" alt="image-20210523083953585"></p><center>图 2.1</center><ul><li><strong>Show Execution Point</strong> (<code>Alt + F10</code>)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行。</li><li><strong>Step Over</strong> (<code>F6</code>)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。</li><li><strong>Step Into</strong> (<code>F5</code>)：步入，如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法。</li><li><strong>Force Step Into</strong> (<code>Alt + Shift + F7</code>)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。</li><li><strong>Step Out</strong> (<code>F7</code>)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。</li><li><strong>Drop Frame</strong> (默认无)：回退断点，后面章节详细说明。</li><li><strong>Run to Cursor</strong> (<code>Ctrl + R</code>)：运行到光标处，你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。</li><li><strong>Evaluate Expression</strong> (<code>Ctrl + U</code>)：计算表达式，后面章节详细说明。</li></ul><p>2、第二组按钮，共6个按钮，从上到下依次如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529195952.png" srcset="/img/loading.gif" alt="image-20210523085302910">   </p><center>图 2.2</center><p><strong>Rerun ‘xxxx’</strong>（<code>Ctrl + F11</code>）：重新运行程序，会关闭服务后重新启动程序。</p><p><strong>Resume Program</strong> (<code>F8</code>)：恢复程序，比如，你在第20行和25行有两个断点，当前运行至第20行，按<code>F8</code>，则运行到下一个断点(即第25行)，再按<code>F8</code>，则运行完整个流程，因为后面已经没有断点了。</p><p><strong>Pause Program</strong>：暂停程序，启用Debug。目前没发现具体用法。</p><p><strong>Stop ‘xxx’</strong>：关闭程序。有时候你会发现关闭服务再启动时，报端口被占用，这是因为没完全关闭服务的原因，你就需要查杀所有JVM进程了。</p><p><strong>View Breakpoints</strong> (<code>Ctrl + Shift + F8</code>)：查看所有断点，后面章节会涉及到。</p><p><strong>Mute Breakpoints</strong>：哑的断点，选择这个后，所有断点变为灰色，断点失效，按<code>F8</code>则可以直接运行完程序。再次点击，断点变为红色，有效。如果只想使某一个断点失效，可以在断点上右键取消Enabled，如图2.3，则该行断点失效。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529200001.png" srcset="/img/loading.gif" alt="img"></p> <center>图 2.3</center><h2 id="三、变量查看"><a href="#三、变量查看" class="headerlink" title="三、变量查看"></a>三、变量查看</h2><p>在Debug过程中，跟踪查看变量的变化是非常必要的，这里就简单说下IDEA中可以查看变量的几个地方，相信大部分人都了解。</p><p>1、如下，在IDEA中，参数所在行后面会显示当前变量的值。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529200012.png" srcset="/img/loading.gif" alt="img"></p><center>图 3.1</center><p>2、光标悬停到参数上，显示当前变量信息。点击打开详情如图3.3。我一般会使用这种方式，快捷方便。</p><p>  <img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529200021.png" srcset="/img/loading.gif" alt="img">     </p><center>图 3.2</center><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529200033.png" srcset="/img/loading.gif" alt="img"> </p><center>图 3.3</center><p>3、在<code>Variables</code>里查看，这里显示当前方法里的所有变量。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529200116.png" srcset="/img/loading.gif" alt="img"></p><center>图 3.4</center><p>4、在Watches里，点击<code>New Watch</code>，输入需要查看的变量。或者可以从<code>Variables</code>里拖到Watche里查看。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529200127.png" srcset="/img/loading.gif" alt="img"> </p><center>图 3.5</center><p>如果你发现你没有Watches，可能在下图所在的地方。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529200135.png" srcset="/img/loading.gif" alt="image-20210523091015317"></p><center>图 3.6</center><h2 id="四、计算表达式"><a href="#四、计算表达式" class="headerlink" title="四、计算表达式"></a>四、计算表达式</h2><p>在前面提到的计算表达式如图4.1的按钮，<code>Evaluate Expression</code> (<code>Ctrl + U</code>) 。可以使用这个操作在调试过程中计算某个表达式的值，而不用再去打印信息。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529200143.png" srcset="/img/loading.gif" alt="image-20210523091147106"> </p><center>图 4.1</center><p>1、选中某个表达式再按<code>Ctrl + U</code>，弹出计算表达式的窗口，如下，回车或点击Evaluate计算表达式的值。</p><p>这个表达式不仅可以是一般变量或参数，也可以是方法，当你的一行代码中调用了几个方法时，就可以通过这种方式查看某个方法的返回值。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529200152.png" srcset="/img/loading.gif" alt="image-20210523092226126">   </p><center>图 4.2</center><p>2、设置变量，在计算表达式的框里，可以改变变量的值，这样有时候就能很方便我们去调试各种值的情况了。</p><h2 id="五、智能步入"><a href="#五、智能步入" class="headerlink" title="五、智能步入"></a>五、智能步入</h2><p>想想，一行代码里有好几个方法，怎么只选择某一个方法进入。之前提到过使用<code>Step Into</code>或者<code>Force Step Into</code>进入到方法内部，但这两个操作会根据方法调用顺序依次进入，比较麻烦。</p><p>那么智能步入就很方便了，智能步入，这个功能在Run里可以看到，<code>Smart Step Into</code>(<code>Ctrl + F5</code>)</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529200206.png" srcset="/img/loading.gif" alt="image-20210523092656071"></p><center>图 5.1</center><p>按<code>Ctrl + F5</code>，会自动定位到当前断点行，并列出需要进入的方法，如图5.2，点击方法进入方法内部。</p><p>如果只有一个方法，则直接进入，类似<code>Force Step Into</code>。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529200215.png" srcset="/img/loading.gif" alt="img"></p><center>图 5.2</center><h2 id="六、断点条件设置"><a href="#六、断点条件设置" class="headerlink" title="六、断点条件设置"></a>六、断点条件设置</h2><p>通过设置断点条件，在满足条件时，才停在断点处，否则直接运行。</p><p>通常，当我们在遍历一个比较大的集合或数组时，在循环内设置了一个断点，难道我们要一个一个去看变量的值？那肯定很累，说不定你还错过这个值得重新来一次。(戳中泪点）</p><p>1、在断点上右键直接设置当前断点的条件，如图6.1。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529200223.png" srcset="/img/loading.gif" alt="image-20210523093253417"></p><center>图 6.1</center><p>2、点击<code>View Breakpoints</code> (<code>Ctrl + Shift + F8</code>)，查看所有断点。</p><p><code>Java Line Breakpoints</code>显示了所有的断点，在右边勾选Condition，设置断点的条件。</p><p>勾选<code>Evaluate and log</code>，可以在执行这行代码时计算表达式的值，并将结果输出到控制台。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529200235.png" srcset="/img/loading.gif" alt="image-20210523094224290"></p><center>图 6.2</center><p>3、再说说右边的Filters过滤，这些一般情况下不常用，简单说下意思。</p><p><code>Instance filters</code>：实例过滤。</p><p><code>Class filters</code>：类过滤，根据类名过滤。</p><p><code>Pass count</code>：用于循环中，如果断点在循环中，可以设置该值，循环多少次后停在断点处，之后的循环都会停在断点处。</p><p>4、异常断点，通过设置异常断点，在程序中出现需要拦截的异常时，会自动定位到异常行。</p><p>如图6.3，点击+号添加<code>Java Exception Breakpoints</code>，添加异常断点。然后输入需要断点的异常类，之后可以在Java Exception Breakpoints里看到添加的异常断点，如果添加了一个NullPointerException异常断点，出现空指针异常后，自动定位在空指针异常行。</p><p> <img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529200246.png" srcset="/img/loading.gif" alt="img"></p><center>图 6.3</center><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529200257.png" srcset="/img/loading.gif" alt="img"> </p><center>图 6.4</center><h2 id="七、多线程调试"><a href="#七、多线程调试" class="headerlink" title="七、多线程调试"></a>七、多线程调试</h2><p>一般情况下我们调试的时候是在一个线程中的，一步一步往下走。但有时候你会发现在Debug的时候，想发起另外一个请求都无法进行了？</p><p>那是因为IDEA在Debug时默认阻塞级别是ALL，会阻塞其它线程，只有在当前调试线程走完时才会走其它线程。可以在<code>View Breakpoints</code>里选择<code>Thread</code>，如图7.1，然后点击<code>Make Default</code>设置为默认选项。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529200307.png" srcset="/img/loading.gif" alt="image-20210523094949100"></p><center>图 7.1</center><p>切换线程，在图7.2中Frames的下拉列表里，可以切换当前的线程，如我这里有两个Debug的线程，切换另外一个则进入另一个Debug的线程。(暂未接触到多线程调试，后面遇到了会进行补充)</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529200318.png" srcset="/img/loading.gif" alt="img"> </p><center>图 7.2</center><h2 id="八、回退断点"><a href="#八、回退断点" class="headerlink" title="八、回退断点"></a>八、回退断点</h2><p>在调试的时候，想要重新走一下流程而不用再次发起一个请求？</p><p>1、首先认识下这个方法调用栈，如图8.1，首先请求进入DemoController的<code>insertDemo</code>方法，然后调用<code>insert</code>方法，其它的invoke我们且先不管，最上面的方法是当前断点所在的方法。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529200335.png" srcset="/img/loading.gif" alt="img"> </p><center>图 8.1</center><p>2、断点回退</p><p>所谓的断点回退，其实就是<strong>回退到上一个方法调用的开始处</strong>，在IDEA里测试无法一行一行地回退或回到到上一个断点处，而是回到上一个方法。</p><p>回退的方式有两种：</p><ul><li>一种是<code>Drop Frame</code>按钮(图8.2)，<strong>按调用的方法逐步回退</strong>，包括三方类库的其它方法(取消<code>Show All Frames</code>按钮会显示三方类库的方法，如图8.3。</li><li>第二种方式，在调用栈方法上选择要回退的方法，右键选择<code>Drop Frame</code>(图8.4)，回退到该方法的上一个方法调用处，此时再按<code>F8</code>(<code>Resume Program</code>)，可以看到程序进入到该方法的断点处了。</li></ul><p>但有一点需要注意，断点回退只能重新走一下流程，之前的某些参数/数据的状态已经改变了的是无法回退到之前的状态的，如对象、集合、更新了数据库数据等等。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529200352.png" srcset="/img/loading.gif" alt="image-20210523095655317"></p><center>图 8.2</center><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529200408.png" srcset="/img/loading.gif" alt="img"></p><center>图 8.3</center><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529200429.png" srcset="/img/loading.gif" alt="img"></p> <center>图 8.4</center><h2 id="九、中断Debug"><a href="#九、中断Debug" class="headerlink" title="九、中断Debug"></a>九、中断Debug</h2><p>想要在Debug的时候，中断请求，不要再走剩余的流程了？</p><p>有些时候，我们看到传入的参数有误后，不想走后面的流程了，怎么中断这次请求呢(后面的流程要删除数据库数据呢….)，难道要关闭服务重新启动程序？嗯，我以前也是这么干的。</p><p>确切的说，我也没发现可以直接中断请求的方式(除了关闭服务)，但可以通过<code>Force Return</code>，即强制返回，避免后续的流程，如图9.1。</p><p>点击<code>Force Return</code>，弹出<code>Return Value</code>的窗口，我这个方法的返回类型为Map，所以，我这里直接返回 results，来强制返回，从而不再进行后续的流程。或者你可以new HashMap&lt;&gt;()。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529201545.png" srcset="/img/loading.gif" alt="img"> </p><center>图 9.1</center><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529200539.png" srcset="/img/loading.gif" alt="img"></p> <center>图 9.2</center>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git技巧</title>
    <link href="/2021/05/29/Git%E6%8A%80%E5%B7%A7/"/>
    <url>/2021/05/29/Git%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="一、创建版本库"><a href="#一、创建版本库" class="headerlink" title="一、创建版本库"></a>一、创建版本库</h2><p>版本库又称仓库，英文名<code>repository</code>，你可以简单的理解一个目录，这个目录里面的所有文件都可以被<code>Git</code>管理起来，每个文件的修改，删除，<code>Git</code>都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”<strong>还原</strong>”。</p><p>创建一个版本库：如下我是D盘 –&gt; www下目录下新建一个<code>testgit</code>版本库。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193407.png" srcset="/img/loading.gif" alt="img"></p><p><code>pwd</code>命令是用于显示当前的目录。</p><p>通过命令<code>git init</code>把这个目录变成<code>git</code>可以管理的仓库。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193429.png" srcset="/img/loading.gif" alt="img"></p><p>此时当前<code>testgit</code>目录下会多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把<code>git</code>仓库给破坏了。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193438.png" srcset="/img/loading.gif" alt="img"></p><p><strong>Demo演示：</strong></p><p>在版本库<code>testgit</code>目录下新建一个记事本文件 readme.txt 内容如下：11111111</p><p>第一步：使用命令<code>git add readme.txt</code>添加到暂存区里面去。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193448.png" srcset="/img/loading.gif" alt="img"></p><p>如果没有任何提示，说明已经添加成功了。</p><p>第二步：用命令 <code>git commit</code>告诉Git，把文件提交到仓库。</p><p><code>Git commit -m &quot;readme.txt提交&quot;</code>：后面双引号为提示提交的注释信息。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193519.png" srcset="/img/loading.gif" alt="img"></p><p>可以通过命令<code>git status</code>来查看是否还有文件未提交：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193537.png" srcset="/img/loading.gif" alt="img"></p><p>说明没有任何文件未提交，但是我现在继续来改下readme.txt内容，比如我在下面添加一行2222222222内容，继续使用<code>git status</code>来查看下结果，如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193548.png" srcset="/img/loading.gif" alt="img"></p><p>上面的命令告诉我们readme.txt文件已被修改，但是未被提交。利用<code>git diff readme.txt</code>查看有哪些内容被修改了。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193558.png" srcset="/img/loading.gif" alt="img"></p><p>如上可以看到，readme.txt文件内容从一行11111111改成两行，添加了一行22222222内容。</p><p>知道了对readme.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的。</p><ul><li>第一步是<code>git add</code></li><li>第二步是：<code>git commit</code></li></ul><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193615.png" srcset="/img/loading.gif" alt="img"></p><h2 id="二：版本回退"><a href="#二：版本回退" class="headerlink" title="二：版本回退"></a>二：版本回退</h2><p>如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行内容为33333333333333.继续执行命令<code>git add readme.txt</code>：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193624.png" srcset="/img/loading.gif" alt="img"></p><p>现在我已经对readme.txt文件做了三次修改了，那么我们现在可以使用命令 <code>git log</code>来查看下历史记录：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193633.png" srcset="/img/loading.gif" alt="img"></p><p><code>git log</code>命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是增加内容为333333，上一次是添加内容222222，第一次默认是 111111，如果嫌上面显示的信息太多的话，我们可以使用命令<code>git log -–pretty=oneline</code>，演示如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193642.png" srcset="/img/loading.gif" alt="img"></p><p>现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下两种命令：</p><ul><li>回退到上一个版本：<code>git reset --hard HEAD^</code>，如果要回退到上上个版本只需把<code>HEAD^</code> 改成<code>HEAD^^</code>，以此类推。</li><li>如果回退版本过多，我们可以使用下面的简便命令操作：<code>git reset --hard HEAD~100</code> 即可。</li></ul><p>未回退之前的readme.txt内容如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193651.png" srcset="/img/loading.gif" alt="img"></p><p>如果想回退到上一个版本的命令如下操作：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193700.png" srcset="/img/loading.gif" alt="img"></p><p>再来查看下 readme.txt内容如下：通过命令<code>cat readme.txt</code>查看</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193709.png" srcset="/img/loading.gif" alt="img"></p><p>可以看到，内容已经回退到上一个版本了。我们可以继续使用<code>git log</code>来查看下历史记录信息，如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193717.png" srcset="/img/loading.gif" alt="img"></p><p>我们看到增加333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有333333的内容要如何恢复呢？我们可以通过版本号回退，使用命令<code>git reset --hard 版本号</code>，但是现在的问题假如我已经关掉过一次命令行或者333内容的版本号我并不知道呢？要如何知道增加3333内容的版本号呢？</p><p>可以通过命令<code>git reflog</code>即可获取到版本号：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193725.png" srcset="/img/loading.gif" alt="img"></p><p>通过上面的显示我们可以知道，增加内容3333的版本号是 6fcfc89.我们现在可以命令<code>git reset --hard 6fcfc89</code>来恢复了。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193733.png" srcset="/img/loading.gif" alt="img"></p><h2 id="三：工作区与暂存区"><a href="#三：工作区与暂存区" class="headerlink" title="三：工作区与暂存区"></a>三：工作区与暂存区</h2><p><strong>工作区：</strong>就是你在电脑上看到的目录，比如目录下<code>testgit</code>里的文件(<code>.git</code>隐藏目录版本库除外)，或者以后需要再新建的目录文件等等都属于工作区范畴。</p><p><strong>版本库(Repository)：</strong>工作区有一个隐藏目录<code>.git</code>,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是<code>stage</code>(暂存区)，还有<code>Git</code>为我们自动创建了第一个分支<code>master</code>，以及指向<code>master</code>的一个指针<code>HEAD</code>。</p><p>我们前面说过使用<code>Git</code>提交文件到版本库有两步：</p><ul><li>第一步：是使用 <code>git add</code> 把文件添加进去，实际上就是把文件添加到暂存区。</li><li>第二步：使用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到<strong>当前分支</strong>上。</li></ul><p>我们继续使用demo来演示下：</p><p>我们在readme.txt再添加一行内容为4444444，接着在目录下新建一个文件为test.txt 内容为test，我们先用命令<code>git status</code>来查看下状态，如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193744.png" srcset="/img/loading.gif" alt="img"></p><p>现在我们先使用<code>git add</code>命令把两个文件都添加到暂存区中，再使用<code>git status</code>来查看下状态，如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193752.png" srcset="/img/loading.gif" alt="img"></p><p>接着我们可以使用<code>git commit</code>一次性提交到分支上，如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193802.png" srcset="/img/loading.gif" alt="img"></p><h2 id="四：Git撤销修改和删除文件操作"><a href="#四：Git撤销修改和删除文件操作" class="headerlink" title="四：Git撤销修改和删除文件操作"></a>四：Git撤销修改和删除文件操作</h2><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>比如我现在在readme.txt文件里面增加一行，内容为555555555555，我们先通过命令查看如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193813.png" srcset="/img/loading.gif" alt="img"></p><p>在我未提交之前，我发现添加5555555555555内容有误，所以我得马上恢复以前的版本，现在我可以有如下几种方法可以做修改：</p><ul><li>如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后<code>add</code>添加到暂存区，最后<code>commit</code>掉。</li><li>我可以按以前的方法直接恢复到上一个版本。使用<code>git reset --hard HEAD^</code></li></ul><p>但是现在我不想使用上面的两种方法，我想直接想使用撤销命令该如何操作呢？</p><p>首先在做撤销之前，我们可以先用 <code>git status</code> 查看下当前的状态。如下所示：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193820.png" srcset="/img/loading.gif" alt="img"></p><p>可以发现，<code>Git</code>会告诉你，<code>git checkout -- file</code><strong>（注意空格）</strong>可以<strong>丢弃工作区的修改</strong>，执行后：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193830.png" srcset="/img/loading.gif" alt="img"></p><p>命令<code>git checkout -- readme.txt</code>的意思就是，<strong>把readme.txt文件在工作区做的修改全部撤销</strong>，这里有两种情况：</p><ul><li>readme.txt自动修改后，还没有放到暂存区，使用<code>git checkout -- file</code>撤销修改就回到和版本库一模一样的状态。</li><li>另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。</li></ul><p>对于第二种情况，我想我们继续做demo来看下，假如现在我对readme.txt添加一行，内容为6666666666666，我<code>git add</code>增加到暂存区后，接着添加内容7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193838.png" srcset="/img/loading.gif" alt="img"></p><p>注意：命令<code>git checkout -- readme.txt</code>中的 <code>--</code>很重要，如果没有<code>--</code>的话，那么命令变成创建分支了。</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>假如我现在版本库<code>testgit</code>目录添加一个文件b.txt，然后提交：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193847.png" srcset="/img/loading.gif" alt="img"></p><p>一般情况下，可以直接在文件目录中把文件删了，或者使用如上<code>rm</code>命令：<code>rm b.txt</code> ，如果我想彻底从版本库中删掉了此文件的话，可以再执行<code>commit</code>命令提交掉，现在目录是这样的：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193855.png" srcset="/img/loading.gif" alt="img"></p><p>只要没有<code>commit</code>之前，如果我想在版本库中恢复此文件如何操作呢？</p><p>可以使用如下命令 <code>git checkout -- b.txt</code>，如下所示：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193902.png" srcset="/img/loading.gif" alt="img"></p><p>再来看看我们<code>testgit</code>目录，添加了3个文件了。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193916.png" srcset="/img/loading.gif" alt="img"></p><h2 id="五：远程仓库。"><a href="#五：远程仓库。" class="headerlink" title="五：远程仓库。"></a>五：远程仓库。</h2><p>在了解之前，先注册<code>github</code>账号，由于你的本地<code>Git</code>仓库和<code>github</code>仓库之间的传输是通过<code>SSH</code>加密的，所以需要进行如下设置：</p><p>第一步：<strong>创建SSH Key</strong>。在用户主目录下，看看有没有<code>.ssh</code>目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：</p><p><code>ssh-keygen -t rsa –C “youremail@example.com”</code>, 由于我本地此前运行过一次，所以本地有：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193933.png" srcset="/img/loading.gif" alt="img"></p><p><code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p>第二步：登录github,打开<code>settings</code>中的<code>SSH Keys</code>页面，然后点击<code>Add SSH Key</code>，填上任意title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529193949.png" srcset="/img/loading.gif" alt="img"></p><p>点击 <code>Add Key</code>，你就应该可以看到已经添加的key。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194007.png" srcset="/img/loading.gif" alt="img"></p><h3 id="如何添加远程库"><a href="#如何添加远程库" class="headerlink" title="如何添加远程库"></a>如何添加远程库</h3><p>现在的情景是：我们已经在本地创建了一个<code>Git</code>仓库后，又想在<code>github</code>创建一个<code>Git</code>仓库，并且希望这两个仓库进行远程同步，这样<code>github</code>的仓库可以作为备份，又可以让其他人通过该仓库来协作。</p><p>首先，登录<code>github</code>，然后在右上角找到<code>create a new repo</code>创建一个新的仓库。如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194018.png" srcset="/img/loading.gif" alt="img"></p><p>在<code>Repository name</code>填入<code>testgit</code>，其他保持默认设置，点击<code>Create repository</code>按钮，就成功地创建了一个新的<code>Git</code>仓库：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194028.png" srcset="/img/loading.gif" alt="img"></p><p>目前，在<code>GitHub</code>上的这个<code>testgit</code>仓库还是空的，<code>GitHub</code>告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到<code>GitHub</code>仓库。</p><p>现在，我们根据<code>GitHub</code>的提示，在本地的<code>testgit</code>仓库下运行命令：</p><div class="hljs"><pre><code class="hljs vim">git remote <span class="hljs-built_in">add</span> origin http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/tugenhua0707/testgit.git</code></pre></div><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194036.png" srcset="/img/loading.gif" alt="img"></p><p>把本地库的内容推送到远程，使用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了 <code>–u</code>参数，<code>Git</code>不但会把本地的<code>master</code>分支内容推送到远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在<code>github</code>页面中看到远程库的内容已经和本地一模一样了。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194045.png" srcset="/img/loading.gif" alt="img"></p><p>从现在起，只要本地作了提交，就可以通过如下命令：<code>git push origin master</code>，就可以把本地<code>master</code>分支的最新修改推送到<code>github</code>上了，现在你就拥有了真正的分布式版本库了。</p><h3 id="修改已提交的commit注释"><a href="#修改已提交的commit注释" class="headerlink" title="修改已提交的commit注释"></a>修改已提交的commit注释</h3><p>如果代码已经<code>push</code>到远程仓库，先从远程仓库pull下来：<code>git pull</code>，然后进入修改步骤：</p><p>1、修改最后一次注释：</p><ul><li><code>Git commit --amend</code></li><li>输入<code>i</code>进入修改模式</li><li>修改完成后按<code>Esc</code>退出编辑模式，输入<code>:wq</code>保存并退出</li></ul><p>2、修改之前的注释：</p><p><code>Git rebase -I HEAD~2</code>:最后的数字2指的是显示到倒数第几次。</p><p>你想修改哪条注释，就把哪条注释前面的<code>pick</code>换成<code>edit</code>。方法就是上面说的编辑方式：<code>i</code>—编辑，把<code>pick</code>换成<code>edit</code>—<code>Esc</code>—<code>:wq</code>，</p><p>然后：（接下来的步骤<code>Terminal</code>会提示）</p><p><code>git commit --amend</code></p><p>修改注释，保存并退出后，输入：<code>git rebase --continue</code></p><p>3、修改之前的某几次注释：</p><p>修改多次的注释其实步骤和上面的一样，不同点在于：</p><p>你可以将多个想修改的<code>commit</code>注释前面的pick换成edit，依次修改你的注释（顺序是从旧到新），<code>erminal</code>基本都会提示你接下来的操作，每修改一个注释都要重复上面的步骤，直到修改完你所选择的所有注释，最后强制<code>push</code>到远程仓库：<code>git push --force origin master</code></p><h3 id="如何从远程库克隆"><a href="#如何从远程库克隆" class="headerlink" title="如何从远程库克隆"></a>如何从远程库克隆</h3><p>假如远程库有新的内容了，我想克隆到本地来，如何克隆呢？</p><p>首先，登录<code>github</code>，创建一个新的仓库，名字叫<code>testgit2</code>：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194057.png" srcset="/img/loading.gif" alt="img"></p><p>如下，我们看到：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194108.png" srcset="/img/loading.gif" alt="img"></p><p>现在，远程库已经准备好了，下一步是使用命令<code>git clone</code>克隆到本地库了：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194115.png" srcset="/img/loading.gif" alt="img"></p><p>接着在我本地目录下生成<code>testgit2</code>目录：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194122.png" srcset="/img/loading.gif" alt="img"></p><h2 id="六：创建与合并分支"><a href="#六：创建与合并分支" class="headerlink" title="六：创建与合并分支"></a>六：创建与合并分支</h2><p>在版本回退里，你已经知道，每次提交，<code>Gi</code>都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在<code>Git</code>里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p><p>首先，我们来创建<code>dev</code>分支，然后切换到<code>dev</code>分支上。如下操作：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194129.png" srcset="/img/loading.gif" alt="img"></p><p><code>git checkout –b</code>表示创建并切换，相当于如下2条命令:</p><ul><li>git branch dev</li><li>git checkout dev</li></ul><p><code>git branch</code>查看分支，会列出所有的分支，当前分支前面会添加一个<code>*</code>。然后我们在<code>dev</code>分支上继续做demo，比如我们现在在readme.txt再增加一行 7777777777777。</p><p>首先我们先来查看下readme.txt内容，接着添加内容77777777，如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194137.png" srcset="/img/loading.gif" alt="img"></p><p>现在<code>dev</code>分支工作已完成，现在我们切换到主分支<code>master</code>上，继续查看readme.txt内容如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194146.png" srcset="/img/loading.gif" alt="img"></p><p>现在我们使用命令<code>git merge dev</code>，可以把dev分支上的内容合并到分支master上了：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194153.png" srcset="/img/loading.gif" alt="img"></p><p><code>git merge</code>命令用于<strong>合并指定分支到当前分支上</strong>，合并后，再查看readme.txt内容，可以看到，和dev分支最新提交的是完全一样的。</p><p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是<strong>快进模式</strong>，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p><p>合并完成后，我们可以接着使用命令<code>git branch -d dev</code>删除dev分支：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194202.png" srcset="/img/loading.gif" alt="img"></p><h3 id="命令总结"><a href="#命令总结" class="headerlink" title="命令总结"></a>命令总结</h3><ul><li>查看分支：<code>git branch</code></li><li>创建分支：<code>git branch name</code></li><li>切换分支：<code>git checkout name</code></li><li>创建+切换分支：<code>git checkout –b name</code></li><li>合并某分支到当前分支：<code>git merge name</code></li><li>删除分支：<code>git branch –d name</code></li></ul><h3 id="如何解决冲突"><a href="#如何解决冲突" class="headerlink" title="如何解决冲突"></a>如何解决冲突</h3><p>下面我们还是一步一步来，先新建一个新分支，比如名字叫<code>fenzhi1</code>，在readme.txt添加一行内容8888888，然后提交，如下所示：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194216.png" srcset="/img/loading.gif" alt="img"></p><p>同样，我们现在切换到<code>master</code>分支上来，也在最后一行添加内容，内容为99999999，如下所示：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194223.png" srcset="/img/loading.gif" alt="img"></p><p>现在我们需要在<code>master</code>分支上来合并fenzhi1，如下操作：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194229.png" srcset="/img/loading.gif" alt="img"></p><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，其中<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>是指<strong>主分支</strong>修改的内容，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; fenzhi1</code>是指fenzhi1上修改的内容，我们可以修改成如下后保存：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194235.png" srcset="/img/loading.gif" alt="img"></p><p>如果我想查看分支合并的情况的话，需要使用命令<code>git log</code>命令行。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194241.png" srcset="/img/loading.gif" alt="img"></p><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><p>通常合并分支时，<code>git</code>一般使用<code>Fast forward</code>模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数<code>no-ff</code>来禁用<code>Fast forward</code>模式。首先我们来做demo演示下：</p><ol><li>创建一个dev分支。</li><li>修改readme.txt内容。</li><li>添加到暂存区。</li><li>切换回主分支(master)。</li><li>合并dev分支，使用命令<code>git merge no-ff -m &quot;注释&quot; dev</code></li><li>查看历史记录</li></ol><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194254.png" srcset="/img/loading.gif" alt="img"></p><p>分支策略:</p><p>首先master主分支应该是非常稳定的，也就是用来发布新版本，<strong>一般情况下不允许在上面干活</strong>，干活一般情况下在新建的dev分支上干活，干完后，比如要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><h2 id="七：bug分支"><a href="#七：bug分支" class="headerlink" title="七：bug分支"></a>七：bug分支</h2><p>在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</p><p>比如我在开发中遇到一个<code>404 bug</code>时候，我们可以创建一个<code>issue-404</code> bug分支来修复它，但是，当前的<code>dev</code>分支上的工作还没有提交，如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194302.png" srcset="/img/loading.gif" alt="img"></p><p>并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我<code>issue-404</code>bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个<code>stash</code>功能，可以把当前工作现场<strong>隐藏起来</strong>，等以后恢复现场后继续工作。如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194307.png" srcset="/img/loading.gif" alt="img"></p><p>所以现在我可以通过创建<code>issue-404</code>分支来修复bug了。</p><p>首先我们要确定在哪个分支上修复bug，比如我现在是在主分支<code>master</code>上来修复的，现在我要在<code>master</code>分支上创建一个临时分支，演示如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194313.png" srcset="/img/loading.gif" alt="img"></p><p>修复完成后，切换到<code>master</code>分支上，并完成合并，最后删除<code>issue-404</code>分支。演示如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194318.png" srcset="/img/loading.gif" alt="img"></p><p>现在，我们回到<code>dev</code>分支上干活了。</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194322.png" srcset="/img/loading.gif" alt="img"></p><p>工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令<code>git stash list</code>来查看下。如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194329.png" srcset="/img/loading.gif" alt="img"></p><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法：</p><ul><li><code>git stash apply</code>恢复，恢复后，stash内容并不删除，你需要使用命令<code>git stash drop</code>来删除。</li><li>另一种方式是使用<code>git stash pop</code>,恢复的同时把<code>stash</code>内容也删除了。</li></ul><p>演示如下：</p><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210529194337.png" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo知识点</title>
    <link href="/2020/09/04/Dubbo%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2020/09/04/Dubbo%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="为什么要用Dubbo"><a href="#为什么要用Dubbo" class="headerlink" title="为什么要用Dubbo"></a>为什么要用Dubbo</h2><p>随着服务化的进一步发展，服务越来越多，服务之间的调用和依赖关系也越来越复杂，诞生了面向服务的架构体系（SOA），也因此衍生出了一系列相应的技术，如：服务提供、服务调用、连接处理、通信协议、序列化方式、服务发现、服务路由、日志输出等行为进行封装的服务框架，就这样产生了Dobbo这样的为分布式系统服务治理的框架。</p><h2 id="什么是Dobbo"><a href="#什么是Dobbo" class="headerlink" title="什么是Dobbo"></a>什么是Dobbo</h2><p>Dubbo是一款高性能、轻量级的开源RPC框架，能提供服务自动注册、自动发现等高效服务治理方案，可以和Spring框架无缝集成。</p><h2 id="Dubbo的使用场景"><a href="#Dubbo的使用场景" class="headerlink" title="Dubbo的使用场景"></a>Dubbo的使用场景</h2><ul><li>透明化的远程方法调用：就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入；</li><li>软件负载均衡及容错机制：可在内网替代F5等硬件负载均衡器，降低成本，减少单点。</li><li>服务自动注册与发现：不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</li></ul><h2 id="Dubbo的核心功能"><a href="#Dubbo的核心功能" class="headerlink" title="Dubbo的核心功能"></a>Dubbo的核心功能</h2><ul><li>Remoting：网络通信框架，提供对多种NIO框架抽象封装，包括“同步转异步”和“请求-响应”模式的信息交换方式；</li><li>Cluster：服务框架，提供基于接口方法的透明远程过程调用，包括多协议支持，以及软件负载均衡 ，失败容错，地址路由，动态配置等集群支持；</li><li>Registry：服务注册，基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li></ul><h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><h2 id="Dubbo核心组件有哪些"><a href="#Dubbo核心组件有哪些" class="headerlink" title="Dubbo核心组件有哪些"></a>Dubbo核心组件有哪些</h2><p><img src="https://img-blog.csdnimg.cn/20200903145727831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li>Provider：暴露服务的服务提供方；</li><li>Consumer：调用远程服务消费方；</li><li>Registry：服务注册与发现注册中心；</li><li>Monitor：监控中心和访问调用统计；</li><li>Container：服务运行容器</li></ul><h2 id="Dubbo服务器注册与发现的流程"><a href="#Dubbo服务器注册与发现的流程" class="headerlink" title="Dubbo服务器注册与发现的流程"></a>Dubbo服务器注册与发现的流程</h2><ol><li>Container负责启动，加载，运行服务提供者；</li><li>Provider在启动时，向注册中心注册自己提供的服务；</li><li>Consumer在启动时，向注册中心订阅自己所需的服务；</li><li>Registry返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者；</li><li>Consumer从提供者地址列表中，基于软件负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用；</li><li>Consumer和Provider在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><h2 id="Dubbo-的整体架构设计有哪些分层"><a href="#Dubbo-的整体架构设计有哪些分层" class="headerlink" title="Dubbo 的整体架构设计有哪些分层?"></a>Dubbo 的整体架构设计有哪些分层?</h2><p><img src="https://img-blog.csdnimg.cn/20200903150535593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li>接口服务层（Service）：该层与业务逻辑相关，根据provider和consumer的业务设计对应的接口与实现；</li><li>配置层（Config）：对外配置接口，以ServiceConfig和ReferenceConfig为中心；</li><li>服务代理层（Proxy）：服务接口透明代理，生成服务的客户端Stub和服务端的Skeleton，以ServiceProxy为中心，扩展接口为ProxyFactory；</li><li>服务注册层（Registry）：封装服务地址的注册和发现，以服务URL为中心，扩展接口为RegistryFactory、Registry、RegistryService；</li><li>路由层（Cluster）；封装多个提供者的路由和负载均衡，并桥接注册中心，以Invoker为中心，扩展接口为Cluster、Directory、Router和LoadBalance；</li><li>监控层（Monitor）：RPC调用次数和调用时间监控，以Statistics为中心，扩展接口为MonitorFactory、Monitor和MonitorService；</li><li>远程调用层（Protocal）：封装RPC调用，以Invocation和Result为中心，扩展接口为Protocal、Invoker和Exporter；</li><li>信息交换层（Exchange）：封装请求响应模式，同步转异步，以Request和Response为中心，扩展接口为Exchanger、ExchangeChannel、ExchangeClient和ExchangeServer；</li><li>网络传输层（Transport）：抽象mina和Netty为统一接口，以Message为中心，扩展接口为Channel、Transporter、Client、Server和Codec；</li><li>数据序列化层（Serialize）：可复用的一些工具，扩展接口为Serialization、ObjectInput、ObjectOutput和ThreadPoll；</li></ul><h2 id="Dubbo-Monitor的实现原理"><a href="#Dubbo-Monitor的实现原理" class="headerlink" title="Dubbo Monitor的实现原理"></a>Dubbo Monitor的实现原理</h2><p>Consumer端在发起调用之前会先走filter链，Provider端在接收到请求时也是先走filter链，然后才进行真正的业务逻辑处理，默认情况下，在Consumer和Provider的filter链中都会有Monitorfilter。</p><ol><li>MonitorFilter向DubboMonitor发送数据；</li><li>DubboMonitor将数据进行聚合后暂存到ConcurrentMap&lt;Statistics,AtomicReference&gt;statisticMap，然后使用一个含有3个线程的线程池，每隔一分钟调用SimpleMonitorService，遍历发送statisticsMap中的统计数据，每发送完毕一个，就重置当前的statistics的AtomicReference；</li><li>SimpleMonitorService将这些聚合数据塞入BlockingQueue queue中；</li><li>SimpleMonitorService使用一个后台线程将queue中的数据写入文件；</li><li>SimpleMonitorService还会使用一个含有一个线程的线程池每隔5分钟将文件中的统计数据画成图表。</li></ol><h1 id="分布式框架"><a href="#分布式框架" class="headerlink" title="分布式框架"></a>分布式框架</h1><h2 id="Dubbo类似的分布式框架还有哪些？"><a href="#Dubbo类似的分布式框架还有哪些？" class="headerlink" title="Dubbo类似的分布式框架还有哪些？"></a>Dubbo类似的分布式框架还有哪些？</h2><p>Spring Cloud</p><h2 id="Spring-Cloud和Dubbo的关系"><a href="#Spring-Cloud和Dubbo的关系" class="headerlink" title="Spring Cloud和Dubbo的关系"></a>Spring Cloud和Dubbo的关系</h2><p>Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断。而 Spring Cloud 诞生于微服务架构时代，考虑的是微服务治理的方方面面，另外由于依托了 Spring、Spring Boot 的优势之上，两个框架在开始目标就不一致，<strong>Dubbo 定位服务治理</strong>、Spring Cloud 是打造一个生态。</p><h2 id="Dubbo和Spring-Cloud有哪些区别？"><a href="#Dubbo和Spring-Cloud有哪些区别？" class="headerlink" title="Dubbo和Spring Cloud有哪些区别？"></a>Dubbo和Spring Cloud有哪些区别？</h2><p>Dubbo 底层是使用 Netty 这样的 NIO 框架，是基于 <strong>TCP</strong> 协议传输的，配合以 Hessian 序列化完成 RPC 通信。</p><p>Spring Cloud 是基于 <strong>Http</strong> 协议 Rest 接口调用远程过程的通信，相对来说 Http 请求会有更大的报文，占的带宽也会更多。但是 REST 相比 RPC 更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更为合适，至于注重通信速度还是方便灵活性，具体情况具体考虑。</p><h1 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h1><h2 id="Dubbo有哪些注册中心"><a href="#Dubbo有哪些注册中心" class="headerlink" title="Dubbo有哪些注册中心"></a>Dubbo有哪些注册中心</h2><ul><li>Multicast注册中心：Multicast注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现，基于网络中组播传输实现；</li><li>Zookeeper注册中心：基于分布式协调系统Zookeeper实现，采用Zookeeper的watch机制实现数据变更；</li><li>Redis注册中心：基于Redis实现，采用key/map存储，key存储服务名和类型，map中key存储服务url，value服务过期时间，基于Redis的发布/订阅模式通知数据变更；</li><li>Simple注册中心。</li></ul><h2 id="Dubbo的注册中心集群挂掉，发布者和订阅者之间还能通信吗？"><a href="#Dubbo的注册中心集群挂掉，发布者和订阅者之间还能通信吗？" class="headerlink" title="Dubbo的注册中心集群挂掉，发布者和订阅者之间还能通信吗？"></a>Dubbo的注册中心集群挂掉，发布者和订阅者之间还能通信吗？</h2><p>可以通信，启动Dubbo时，消费者会从Zookeeper拉取注册的生产者的地址接口等数据，缓存在本地，每次调用时，按照本地存储的地址进行调用。</p><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h2 id="Dubbo集群提供了哪些负载均衡策略？"><a href="#Dubbo集群提供了哪些负载均衡策略？" class="headerlink" title="Dubbo集群提供了哪些负载均衡策略？"></a>Dubbo集群提供了哪些负载均衡策略？</h2><ul><li>Random LoadBalance: 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀。（默认）</li><li>RoundRobin LoadBalance: 轮循选取提供者策略，平均分布，但是存在请求累积的问题。</li><li>LeastActive LoadBalance: 最少活跃调用策略，解决慢提供者接收更少的请求。</li><li>ConstantHash LoadBalance: 一致性 Hash 策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动。</li></ul><h2 id="Dubbo的集群容错方案有哪些？"><a href="#Dubbo的集群容错方案有哪些？" class="headerlink" title="Dubbo的集群容错方案有哪些？"></a>Dubbo的集群容错方案有哪些？</h2><ul><li>Failover Cluster：失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。</li><li>Failfast Cluster：快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li><li>Failsafe Cluster：失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</li><li>Failback Cluster：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li><li>Forking Cluster：并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2″ 来设置最大并行数。</li><li>Broadcast Cluster：广播调用所有提供者，逐个调用，任意一台报错则报错 。通常用于通知所有提供者更新缓存或日志等本地资源信息。</li></ul><p>默认的容错方案是 Failover Cluster。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="Dubbo-配置文件是如何加载到-Spring-中的？"><a href="#Dubbo-配置文件是如何加载到-Spring-中的？" class="headerlink" title="Dubbo 配置文件是如何加载到 Spring 中的？"></a>Dubbo 配置文件是如何加载到 Spring 中的？</h2><p>Spring 容器在启动的时候，会读取到 Spring 默认的一些 schema 以及 Dubbo 自定义的 schema，每个 schema 都会对应一个自己的 NamespaceHandler，NamespaceHandler 里面通过 BeanDefinitionParser 来解析配置信息并转化为需要加载的 bean 对象！</p><h2 id="说说核心的配置有哪些？"><a href="#说说核心的配置有哪些？" class="headerlink" title="说说核心的配置有哪些？"></a>说说核心的配置有哪些？</h2><p><img src="https://img-blog.csdnimg.cn/20200903202529157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="Dubbo超时设置有哪几种方式？"><a href="#Dubbo超时设置有哪几种方式？" class="headerlink" title="Dubbo超时设置有哪几种方式？"></a>Dubbo超时设置有哪几种方式？</h2><ul><li>服务提供者端设置超时时间，在Dubbo的用户文档中，推荐如果能在服务端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特性。</li><li>服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警告。</li></ul><h2 id="服务调用超时会怎么样？"><a href="#服务调用超时会怎么样？" class="headerlink" title="服务调用超时会怎么样？"></a>服务调用超时会怎么样？</h2><p>dubbo 在调用服务不成功时，默认是会重试两次。</p><h1 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h1><h2 id="Dubbo-使用的是什么通信框架"><a href="#Dubbo-使用的是什么通信框架" class="headerlink" title="Dubbo 使用的是什么通信框架?"></a>Dubbo 使用的是什么通信框架?</h2><p>默认使用 Netty 作为通讯框架。</p><h2 id="Dubbo-支持哪些协议，它们的优缺点有哪些？"><a href="#Dubbo-支持哪些协议，它们的优缺点有哪些？" class="headerlink" title="Dubbo 支持哪些协议，它们的优缺点有哪些？"></a>Dubbo 支持哪些协议，它们的优缺点有哪些？</h2><ul><li>Dubbo： 单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步 Hessian 序列化。Dubbo推荐使用dubbo协议。</li><li>RMI： 采用 JDK 标准的 RMI 协议实现，传输参数和返回参数对象需要实现 Serializable 接口，使用 Java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。 多个短连接 TCP 协议传输，同步传输，适用常规的远程服务调用和 RMI 互操作。在依赖低版本的 Common-Collections 包，Java 序列化存在安全漏洞。</li><li>WebService：基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用。</li><li>HTTP： 基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用。</li><li>Hessian：集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务，Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输，Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件。</li><li>Memcache：基于 Memcache实现的 RPC 协议。</li><li>Redis：基于 Redis 实现的RPC协议。</li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="Dubbo-用到哪些设计模式？"><a href="#Dubbo-用到哪些设计模式？" class="headerlink" title="Dubbo 用到哪些设计模式？"></a>Dubbo 用到哪些设计模式？</h2><p>Dubbo 框架在初始化和通信过程中使用了多种设计模式，可灵活控制类加载、权限控制等功能。</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>Provider 在 export 服务时，会调用 ServiceConfig 的 export 方法。ServiceConfig中有个字段：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Protocol protocol =ExtensionLoader.getExtensionLoader(Protocol<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">getAdaptiveExtension</span>()</span>;</code></pre></div><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>Dubbo 在启动和调用阶段都大量使用了装饰器模式。以 Provider 提供的调用链为例，具体的调用链代码是在 ProtocolFilterWrapper 的 buildInvokerChain 完成的，具体是将注解中含有 group=provider 的 Filter 实现，按照 order 排序，最后的调用顺序是：</p><div class="hljs"><pre><code class="hljs text">EchoFilter -&gt; ClassLoaderFilter -&gt; GenericFilter -&gt; ContextFilter -&gt;ExecuteLimitFilter -&gt; TraceFilter -&gt; TimeoutFilter -&gt; MonitorFilter -&gt;ExceptionFilter</code></pre></div><p>更确切地说，这里是装饰器和责任链模式的混合使用。例如，EchoFilter 的作用是判断是否是回声测试请求，是的话直接返回内容，这是一种责任链的体现。而像ClassLoaderFilter 则只是在主功能上添加了功能，更改当前线程的 ClassLoader，这是典型的装饰器模式。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>Dubbo 的 Provider 启动时，需要与注册中心交互，先注册自己的服务，再订阅自己的服务，订阅时，采用了观察者模式，开启一个 listener。注册中心会每 5 秒定时检查是否有服务更新，如果有更新，向该服务的提供者发送一个 notify 消息，provider 接受到 notify 消息后，运行 NotifyListener 的 notify 方法，执行监听器方法。</p><h3 id="动态代理模式"><a href="#动态代理模式" class="headerlink" title="动态代理模式"></a>动态代理模式</h3><p>Dubbo 扩展 JDK SPI 的类 ExtensionLoader 的 Adaptive 实现是典型的动态代理实现。Dubbo 需要灵活地控制实现类，即在调用阶段动态地根据参数决定调用哪个实现类，所以采用先生成代理类的方法，能够做到灵活的调用。生成代理类的代码是 ExtensionLoader 的 createAdaptiveExtensionClassCode 方法。代理类主要逻辑是，获取 URL 参数中指定参数的值作为获取实现类的 key。</p><h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><h2 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h2><p>RPC（Remote Procedure Call Protocol）远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。简言之，RPC使得程序能够像访问本地系统资源一样，去访问远端系统资源。比较关键的一些方面包括：通讯协议、序列化、资源（接口）描述、服务框架、性能、语言支持等。<br><img src="https://img-blog.csdnimg.cn/20200903204300305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>简单的说，RPC就是从一台机器(客户端)上通过参数传递的方式调用另一台机器(服务器)上的一个函数或方法(可以统称为服务)并得到返回的结果。</p><h2 id="为什么要有RPC"><a href="#为什么要有RPC" class="headerlink" title="为什么要有RPC"></a>为什么要有RPC</h2><p>http接口是在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段；优点就是简单、直接、开发方便。利用现成的http协议进行传输。但是如果是一个大型的网站，内部子系统较多、接口非常多的情况下，RPC框架的好处就显示出来了，首先就是长链接，不必每次通信都要像http一样去3次握手什么的，减少了网络开销；其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。第三个来说就是安全性。最后就是最近流行的服务化架构、服务化治理，RPC框架是一个强力的支撑。</p><p>socket只是一个简单的网络通信方式，只是创建通信双方的通信通道，而要实现rpc的功能，还需要对其进行封装，以实现更多的功能。</p><p>RPC一般配合Netty框架、spring自定义注解来编写轻量级框架，其实netty内部是封装了socket的，较新的jdk的IO一般是NIO，即非阻塞IO，在高并发网站中，RPC的优势会很明显。</p><h2 id="RPC架构组件"><a href="#RPC架构组件" class="headerlink" title="RPC架构组件"></a>RPC架构组件</h2><p>一个基本的RPC架构里面应该至少包含以下4个组件：</p><p>1、客户端（Client）:服务调用方（服务消费者）</p><p>2、客户端存根（Client Stub）:存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端</p><p>3、服务端存根（Server Stub）:接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理</p><p>4、服务端（Server）:服务的真正提供者<br><img src="https://img-blog.csdnimg.cn/20200903205247668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>具体调用过程：</p><p>1、服务消费者（client客户端）通过调用本地服务的方式调用需要消费的服务；</p><p>2、客户端存根（client stub）接收到调用请求后负责将方法、入参等信息序列化（组装）成能够进行网络传输的消息体；</p><p>3、客户端存根（client stub）找到远程的服务地址，并且将消息通过网络发送给服务端；</p><p>4、服务端存根（server stub）收到消息后进行解码（反序列化操作）；</p><p>5、服务端存根（server stub）根据解码结果调用本地的服务进行相关处理；</p><p>6、本地服务执行具体业务逻辑并将处理结果返回给服务端存根（server stub）；</p><p>7、服务端存根（server stub）将返回结果重新打包成消息（序列化）并通过网络发送至消费方；</p><p>8、客户端存根（client stub）接收到消息，并进行解码（反序列化）；</p><p>9、服务消费方得到最终结果；<br>而RPC框架的实现目标则是将上面的第2-10步完好地封装起来，也就是把调用、编码/解码的过程给封装起来，让用户感觉上像调用本地服务一样的调用远程服务。</p><h2 id="RPC和SOA、SOAP、REST的区别"><a href="#RPC和SOA、SOAP、REST的区别" class="headerlink" title="RPC和SOA、SOAP、REST的区别"></a>RPC和SOA、SOAP、REST的区别</h2><p>1、REST</p><p>可以看着是HTTP协议的一种直接应用，默认基于JSON作为传输格式，使用简单，学习成本低效率高，但是安全性较低。</p><p>2、SOAP</p><p>SOAP是一种数据交换协议规范，是一种轻量的、简单的、基于XML的协议的规范。而SOAP可以看着是一个重量级的协议，基于XML、SOAP在安全方面是通过使用XML-Security和XML-Signature两个规范组成了WS-Security来实现安全控制的,当前已经得到了各个厂商的支持 。</p><p>它有什么优点？简单总结为：易用、灵活、跨语言、跨平台。</p><p>3、SOA</p><p>面向服务架构，它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用。服务层是SOA的基础，可以直接被应用调用，从而有效控制系统中与软件代理交互的人为依赖性。</p><p>SOA是一种粗粒度、松耦合服务架构，服务之间通过简单、精确定义接口进行通讯，不涉及底层编程接口和通讯模型。SOA可以看作是B/S模型、XML（标准通用标记语言的子集）/Web Service技术之后的自然延伸。</p><p>4、REST 和 SOAP、RPC 有何区别呢?</p><p>没什么太大区别，他们的本质都是提供可支持分布式的基础服务，最大的区别在于他们各自的的特点所带来的不同应用场景 。</p><h2 id="RPC框架需要解决的问题？"><a href="#RPC框架需要解决的问题？" class="headerlink" title="RPC框架需要解决的问题？"></a>RPC框架需要解决的问题？</h2><p>1、如何确定客户端和服务端之间的通信协议？</p><p>2、如何更高效地进行网络通信？</p><p>3、服务端提供的服务如何暴露给客户端？</p><p>4、客户端如何发现这些暴露的服务？</p><p>5、如何更高效地对请求对象和响应结果进行序列化和反序列化操作？</p><h2 id="RPC的实现基础？"><a href="#RPC的实现基础？" class="headerlink" title="RPC的实现基础？"></a>RPC的实现基础？</h2><p>1、需要有非常高效的网络通信，比如一般选择Netty作为网络通信框架；</p><p>2、需要有比较高效的序列化框架，比如谷歌的Protobuf序列化框架；</p><p>3、可靠的寻址方式（主要是提供服务的发现），比如可以使用Zookeeper来注册服务等等；</p><p>4、如果是带会话（状态）的RPC调用，还需要有会话和状态保持的功能；</p><h2 id="RPC使用了哪些关键技术？"><a href="#RPC使用了哪些关键技术？" class="headerlink" title="RPC使用了哪些关键技术？"></a>RPC使用了哪些关键技术？</h2><p>1、动态代理</p><p>生成Client Stub（客户端存根）和Server Stub（服务端存根）的时候需要用到Java动态代理技术，可以使用JDK提供的原生的动态代理机制，也可以使用开源的：CGLib代理，Javassist字节码生成技术。</p><p>2、序列化和反序列化</p><p>在网络中，所有的数据都将会被转化为字节进行传送，所以为了能够使参数对象在网络中进行传输，需要对这些参数进行序列化和反序列化操作。</p><p>序列化：把对象转换为字节序列的过程称为对象的序列化，也就是编码的过程。<br>反序列化：把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。<br>目前比较高效的开源序列化框架：如Kryo、FastJson和Protobuf等。</p><p>3、NIO通信</p><p>出于并发性能的考虑，传统的阻塞式 IO 显然不太合适，因此我们需要异步的 IO，即 NIO。Java 提供了 NIO 的解决方案，Java 7 也提供了更优秀的 NIO.2 支持。可以选择Netty或者MINA来解决NIO数据传输的问题。</p><p>4、服务注册中心</p><p>可选：Redis、Zookeeper、Consul 、Etcd。一般使用ZooKeeper提供服务注册与发现功能，解决单点故障以及分布式部署的问题(注册中心)。</p><h2 id="RPC的实现原理架构图"><a href="#RPC的实现原理架构图" class="headerlink" title="RPC的实现原理架构图"></a>RPC的实现原理架构图</h2><p><img src="https://img-blog.csdnimg.cn/20200903213231475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>这张图非常重点，是PRC的基本原理，请大家一定记住！</p><p>也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</p><p>比如说，A服务器想调用B服务器上的一个方法：User getUserByName(String userName)</p><p>1、建立通信</p><p>首先要解决通讯的问题：即A机器想要调用B机器，首先得建立起通信连接。</p><p>主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。</p><p>通常这个连接可以是按需连接（需要调用的时候就先建立连接，调用结束后就立马断掉），也可以是长连接（客户端和服务器建立起连接之后保持长期持有，不管此时有无数据包的发送，可以配合心跳检测机制定期检测建立的连接是否存活有效），多个远程过程调用共享同一个连接。</p><p>2、服务寻址</p><p>要解决寻址的问题，也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么。</p><p>通常情况下我们需要提供B机器（主机名或IP地址）以及特定的端口，然后指定调用的方法或者函数的名称以及入参出参等信息，这样才能完成服务的一个调用。</p><p>可靠的寻址方式（主要是提供服务的发现）是RPC的实现基石，比如可以采用Redis或者Zookeeper来注册服务等等。<img src="https://img-blog.csdnimg.cn/20200903213308160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>2.1、从服务提供者的角度看：</p><p>当服务提供者启动的时候，需要将自己提供的服务注册到指定的注册中心，以便服务消费者能够通过服务注册中心进行查找；</p><p>当服务提供者由于各种原因致使提供的服务停止时，需要向注册中心注销停止的服务；</p><p>服务的提供者需要定期向服务注册中心发送心跳检测，服务注册中心如果一段时间未收到来自服务提供者的心跳后，认为该服务提供者已经停止服务，则将该服务从注册中心上去掉。</p><p>2.2、从调用者的角度看：</p><p>服务的调用者启动的时候根据自己订阅的服务向服务注册中心查找服务提供者的地址等信息；</p><p>当服务调用者消费的服务上线或者下线的时候，注册中心会告知该服务的调用者；</p><p>服务调用者下线的时候，则取消订阅。</p><p>3、网络传输</p><p>3.1、序列化当A机器上的应用发起一个RPC调用时，调用方法和其入参等信息需要通过底层的网络协议如TCP传输到B机器，由于网络协议是基于二进制的，所有我们传输的参数数据都需要先进行序列化（Serialize）或者编组（marshal）成二进制的形式才能在网络中进行传输。然后通过寻址操作和网络传输将序列化或者编组之后的二进制数据发送给B机器。</p><p>3.2、反序列化</p><p>当B机器接收到A机器的应用发来的请求之后，又需要对接收到的参数等信息进行反序列化操作（序列化的逆操作），即将二进制信息恢复为内存中的表达方式，然后再找到对应的方法（寻址的一部分）进行本地调用（一般是通过生成代理Proxy去调用,<br>通常会有JDK动态代理、CGLIB动态代理、Javassist生成字节码技术等），之后得到调用的返回值。</p><p>4、服务调用</p><p>B机器进行本地调用（通过代理Proxy和反射调用）之后得到了返回值，此时还需要再把返回值发送回A机器，同样也需要经过序列化操作，然后再经过网络传输将二进制数据发送回A机器，而当A机器接收到这些返回值之后，则再次进行反序列化操作，恢复为内存中的表达方式，最后再交给A机器上的应用进行相关处理（一般是业务逻辑处理操作）。</p><p>通常，经过以上四个步骤之后，一次完整的RPC调用算是完成了，另外可能因为网络抖动等原因需要重试等。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Dubbo-支持分布式事务吗？"><a href="#Dubbo-支持分布式事务吗？" class="headerlink" title="Dubbo 支持分布式事务吗？"></a>Dubbo 支持分布式事务吗？</h2><p>目前暂时不支持，可与通过 tcc-transaction 框架实现</p><blockquote><p>介绍：tcc-transaction 是开源的 TCC 补偿性分布式事务框架</p><p>TCC-Transaction 通过 Dubbo 隐式传参的功能，避免自己对业务代码的入侵。</p></blockquote><h2 id="Dubbo-可以对结果进行缓存吗？"><a href="#Dubbo-可以对结果进行缓存吗？" class="headerlink" title="Dubbo 可以对结果进行缓存吗？"></a>Dubbo 可以对结果进行缓存吗？</h2><p>为了提高数据访问的速度。Dubbo 提供了声明式缓存，以减少用户加缓存的工作量&lt;dubbo:reference cache=“true” /&gt;</p><p>其实比普通的配置文件就多了一个标签 cache=“true”</p><h2 id="Dubbo-必须依赖的包有哪些？"><a href="#Dubbo-必须依赖的包有哪些？" class="headerlink" title="Dubbo 必须依赖的包有哪些？"></a>Dubbo 必须依赖的包有哪些？</h2><p>Dubbo 必须依赖 JDK，其他为可选。</p><h2 id="Dubbo-支持哪些序列化方式？"><a href="#Dubbo-支持哪些序列化方式？" class="headerlink" title="Dubbo 支持哪些序列化方式？"></a>Dubbo 支持哪些序列化方式？</h2><p>默认使用 Hessian 序列化，还有 Duddo、FastJson、Java 自带序列化。</p><h2 id="Dubbo-在安全方面有哪些措施？"><a href="#Dubbo-在安全方面有哪些措施？" class="headerlink" title="Dubbo 在安全方面有哪些措施？"></a>Dubbo 在安全方面有哪些措施？</h2><p>Dubbo 通过 Token 令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。<br>Dubbo 还提供服务黑白名单，来控制服务所允许的调用方。</p><h2 id="服务调用是阻塞的吗？"><a href="#服务调用是阻塞的吗？" class="headerlink" title="服务调用是阻塞的吗？"></a>服务调用是阻塞的吗？</h2><p>默认是阻塞的，可以异步调用，没有返回值的可以这么做。Dubbo 是基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个 Future 对象。</p><h2 id="服务提供者能实现失效踢出是什么原理？"><a href="#服务提供者能实现失效踢出是什么原理？" class="headerlink" title="服务提供者能实现失效踢出是什么原理？"></a>服务提供者能实现失效踢出是什么原理？</h2><p>服务失效踢出基于 zookeeper 的临时节点原理。</p><h2 id="同一个服务多个注册的情况下可以直连某一个服务吗？"><a href="#同一个服务多个注册的情况下可以直连某一个服务吗？" class="headerlink" title="同一个服务多个注册的情况下可以直连某一个服务吗？"></a>同一个服务多个注册的情况下可以直连某一个服务吗？</h2><p>可以点对点直连，修改配置即可，也可以通过 telnet 直接某个服务。</p><h2 id="Dubbo-服务降级，失败重试怎么做？"><a href="#Dubbo-服务降级，失败重试怎么做？" class="headerlink" title="Dubbo 服务降级，失败重试怎么做？"></a>Dubbo 服务降级，失败重试怎么做？</h2><p>可以通过 dubbo:reference 中设置 mock=“return null”。mock 的值也可以修改为 true，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 “接口名称+Mock” 后缀。然后在 Mock 类里实现自己的降级逻辑</p><h2 id="Dubbo-使用过程中都遇到了些什么问题？"><a href="#Dubbo-使用过程中都遇到了些什么问题？" class="headerlink" title="Dubbo 使用过程中都遇到了些什么问题？"></a>Dubbo 使用过程中都遇到了些什么问题？</h2><p>在注册中心找不到对应的服务,检查 service 实现类是否添加了@service 注解无法连接到注册中心,检查配置文件中的对应的测试 ip 是否正确。</p>]]></content>
    
    
    <categories>
      
      <category>微服务分布式架构</category>
      
      <category>Dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Security核心(四)-过滤器链加载流程解析</title>
    <link href="/2020/09/02/Spring-Security%E6%A0%B8%E5%BF%83-%E5%9B%9B-%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/"/>
    <url>/2020/09/02/Spring-Security%E6%A0%B8%E5%BF%83-%E5%9B%9B-%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>SpringSecurityFilterChain 作为 SpringSecurity 的核心过滤器链在整个认证授权过程中起着举足轻重的地位，每个请求到来，都会经过该过滤器链，上一篇文章中我们分析了 SpringSecurityFilterChain 的构成，但还有很多疑问可能没有解开：</p><ol><li>这个 SpringSecurityFilterChain 是怎么注册到 web 环境中的？</li><li>有读者发出这样的疑问：”SpringSecurityFilterChain 的实现类到底是什么，我知道它是一个 Filter，但是在很多配置类中看到了 BeanName=SpringSecurityFilterChain 相关的类，比如 DelegatingFilterProxy，FilterChainProxy，SecurityFilterChain，他们的的名称实在太相似了，到底哪个才是真正的实现，SpringSecurity 又为什么要这么设计？“</li><li>我们貌似一直在配置 WebSecurity ，但没有对 SpringSecurityFilterChain 进行什么配置，WebSecurity 相关配置是怎么和 SpringSecurityFilterChain 结合在一起的？</li></ol><p>以上是个人 YY 的一些 SpringSecurityFilterChain 相关的问题，因为我当初研究了一段时间 SpringSecurity 源码，依旧没有理清这么多错综复杂的类。那么本文就主要围绕 SpringSecurityFilterChain 展开我们的探索。</p><h3 id="6-1-SpringSecurityFilterChain-是怎么注册的？"><a href="#6-1-SpringSecurityFilterChain-是怎么注册的？" class="headerlink" title="6.1 SpringSecurityFilterChain 是怎么注册的？"></a>6.1 SpringSecurityFilterChain 是怎么注册的？</h3><p>这个问题并不容易解释，因为 SpringSecurity 仅仅在 web 环境下（SpringSecurity 还支持非 web 环境）就有非常多的支持形式：</p><p><strong>Java 配置方式</strong></p><ol><li>作为独立的 SpringSecurity 依赖提供给朴素的 java web 项目使用，并且项目不使用 Spring！没错，仅仅使用 servlet，jsp 的情况下也是可以集成 SpringSecurity 的。</li><li>提供给包含 SpringMVC 项目使用。</li><li>提供给具备 Servlet3.0+ 的 web 项目使用。</li><li>SpringBoot 内嵌容器环境下使用 SpringSecurity，并且包含了一定程度的自动配置。</li></ol><p><strong>XML 配置方式</strong></p><ol><li>使用 XML 中的命名空间配置 SpringSecurity。</li></ol><p>注意，以上条件可能存在交集，比如我的项目是一个使用 servlet3.0 的 web 项目同时使用了 SpringMVC；也有可能使用了 SpringBoot 同时配合 SpringMVC；还有可能使用了 SpringBoot，却打成了 war 包，部署在外置的支持 Servlet3.0+ 规范的应用容器中… 各种组合方式会导致配置 SpringSecurityFilterChain 的注册方式产生差异，所以，这个问题说复杂还真有点，需要根据你的环境来分析。我主要分析几种较为常见的注册方式。</p><p>SpringSecurityFilterChain 抽象概念里最重要的三个类：<strong>DelegatingFilterProxy</strong>，<strong>FilterChainProxy</strong> 和 <strong>SecurityFilterChain</strong>，对这三个类的源码分析和设计将会贯彻本文。不同环境下 DelegatingFilterProxy 的注册方式区别较大，但 FilterChainProxy 和 SecurityFilterChain 的差异不大，所以重点就是分析 DelegatingFilterProxy 的注册方式。它们三者的分析会放到下一节中。</p><h4 id="6-1-1-servlet3-0-环境下-SpringSecurity-的-java-config-方式"><a href="#6-1-1-servlet3-0-环境下-SpringSecurity-的-java-config-方式" class="headerlink" title="6.1.1 servlet3.0+ 环境下 SpringSecurity 的 java config 方式"></a>6.1.1 servlet3.0+ 环境下 SpringSecurity 的 java config 方式</h4><p>这是一个比较常见的场景，你可能还没有使用 SpringBoot 内嵌的容器，将项目打成 war 包部署在外置的应用容器中，比如最常见的 tomcat，一般很少 web 项目低于 servlet3.0 版本的，并且该场景摒弃了 XML 配置。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.security.web.context.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityWebApplicationInitializer</span></span><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSecurityWebApplicationInitializer</span> </span>&#123;&#125;</code></pre></div><p>主要自定义一个 SecurityWebApplicationInitializer 并且让其继承自 AbstractSecurityWebApplicationInitializer 即可。如此简单的一个继承背后又经历了 Spring 怎样的封装呢？自然要去 AbstractSecurityWebApplicationInitializer 中去一探究竟。经过删减后的源码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractSecurityWebApplicationInitializer</span></span><span class="hljs-class">      <span class="hljs-keyword">implements</span> <span class="hljs-title">WebApplicationInitializer</span> </span>&#123;<span class="hljs-comment">//&lt;1&gt;</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_FILTER_NAME = <span class="hljs-string">"springSecurityFilterChain"</span>;   <span class="hljs-comment">// &lt;1&gt; 父类 WebApplicationInitializer 的加载入口</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartup</span><span class="hljs-params">(ServletContext servletContext)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;      beforeSpringSecurityFilterChain(servletContext);      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.configurationClasses != <span class="hljs-keyword">null</span>) &#123;         AnnotationConfigWebApplicationContext rootAppContext = <span class="hljs-keyword">new</span> AnnotationConfigWebApplicationContext();         rootAppContext.register(<span class="hljs-keyword">this</span>.configurationClasses);         servletContext.addListener(<span class="hljs-keyword">new</span> ContextLoaderListener(rootAppContext));      &#125;      <span class="hljs-keyword">if</span> (enableHttpSessionEventPublisher()) &#123;         servletContext.addListener(               <span class="hljs-string">"org.springframework.security.web.session.HttpSessionEventPublisher"</span>);      &#125;      servletContext.setSessionTrackingModes(getSessionTrackingModes());      insertSpringSecurityFilterChain(servletContext);<span class="hljs-comment">//&lt;2&gt;</span>      afterSpringSecurityFilterChain(servletContext);   &#125;       <span class="hljs-comment">// &lt;2&gt; 在这儿初始化了关键的 DelegatingFilterProxy</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertSpringSecurityFilterChain</span><span class="hljs-params">(ServletContext servletContext)</span> </span>&#123;String filterName = DEFAULT_FILTER_NAME;        <span class="hljs-comment">// &lt;2&gt; 该方法中最关键的一个步骤，DelegatingFilterProxy 在此被创建</span>DelegatingFilterProxy springSecurityFilterChain = <span class="hljs-keyword">new</span> DelegatingFilterProxy(filterName);String contextAttribute = getWebApplicationContextAttribute();<span class="hljs-keyword">if</span> (contextAttribute != <span class="hljs-keyword">null</span>) &#123;springSecurityFilterChain.setContextAttribute(contextAttribute);&#125;registerFilter(servletContext, <span class="hljs-keyword">true</span>, filterName, springSecurityFilterChain);&#125;        <span class="hljs-comment">// &lt;3&gt; 使用 servlet3.0 的新特性，动态注册 springSecurityFilterChain(实际上注册的是 springSecurityFilterChain 代理类)</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerFilter</span><span class="hljs-params">(ServletContext servletContext,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span> insertBeforeOtherFilters, String filterName, Filter filter)</span> </span>&#123;Dynamic registration = servletContext.addFilter(filterName, filter);registration.setAsyncSupported(isAsyncSecuritySupported());EnumSet&lt;DispatcherType&gt; dispatcherTypes = getSecurityDispatcherTypes();registration.addMappingForUrlPatterns(dispatcherTypes, !insertBeforeOtherFilters,<span class="hljs-string">"/*"</span>);&#125;&#125;</code></pre></div><p>&lt;1&gt;&lt;3&gt; 放在一起讲，因为他们都和 servlet3.0 新特性以及 spring 对 servlet3.0 的支持相关，这也是为什么在场景描述中我特地强调了需要 servlet3.0 环境。如果你对 servlet3.0 的新特性不了解，这儿准备了一篇详细的介绍为你阐述 <a href="https://www.cnkirito.moe/servlet-explore/" target="_blank" rel="noopener">《Spring 揭秘 – 寻找遗失的 web.xml》</a> 。得益于 Spring 的封装，在 servlet3.0 环境下，web 容器启动时会自行去寻找类路径下所有实现了 WebApplicationInitializer 接口的 Initializer 实例，并调用他们的 onStartup 方法。所以，我们只需要继承 AbstractSecurityWebApplicationInitializer ，便可以自动触发 web 容器的加载，进而配置和 SpringSecurityFilterChain 第一个密切相关的类，第 &lt;2&gt; 步中的 DelegatingFilterProxy。</p><p>&lt;2&gt; DelegatingFilterProxy 在此被实例化出来。在第 &lt;3&gt; 步中，它作为一个 Filter 正式注册到了 web 容器中。</p><h4 id="6-1-2-XML-配置"><a href="#6-1-2-XML-配置" class="headerlink" title="6.1.2 XML 配置"></a>6.1.2 XML 配置</h4><p>这个真的是简单易懂，因为它是被指名道姓配置成一个 Filter 的。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre></div><p><code>web.xml</code> 的存在注定了其无所谓当前环境是不是 servlet3.0+，虽然我个人不太喜欢 xml 的配置方式，但不得不说，这样真的很简单粗暴。</p><h4 id="6-1-3-SpringBoot-内嵌应用容器并且使用自动配置"><a href="#6-1-3-SpringBoot-内嵌应用容器并且使用自动配置" class="headerlink" title="6.1.3 SpringBoot 内嵌应用容器并且使用自动配置"></a>6.1.3 SpringBoot 内嵌应用容器并且使用自动配置</h4><p><a href="https://www.cnkirito.moe/servlet-explore/" target="_blank" rel="noopener">《Spring 揭秘 – 寻找遗失的 web.xml》</a> 中我曾经得出一个结论，内嵌容器是完全不会使用 SPI 机制加载 servlet3.0 新特性的那些 Initializer 的，springboot 又推崇 java configuration，所以上述两种方案完全被抛弃了。那么 SpringBoot 如何注册 DelegatingFilterProxy 呢？</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnWebApplication</span><span class="hljs-meta">@EnableConfigurationProperties</span><span class="hljs-meta">@ConditionalOnClass</span>(&#123; AbstractSecurityWebApplicationInitializer<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">      <span class="hljs-title">SessionCreationPolicy</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class">@<span class="hljs-title">AutoConfigureAfter</span>(<span class="hljs-title">SecurityAutoConfiguration</span>.<span class="hljs-title">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">SecurityFilterAutoConfiguration</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_FILTER_NAME = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME;<span class="hljs-comment">//springSecurityFilterChain</span>    <span class="hljs-comment">// &lt;1&gt;</span>   <span class="hljs-meta">@Bean</span>   <span class="hljs-meta">@ConditionalOnBean</span>(name = DEFAULT_FILTER_NAME)   <span class="hljs-function"><span class="hljs-keyword">public</span> DelegatingFilterProxyRegistrationBean <span class="hljs-title">securityFilterChainRegistration</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">         SecurityProperties securityProperties)</span> </span>&#123;      DelegatingFilterProxyRegistrationBean registration = <span class="hljs-keyword">new</span> DelegatingFilterProxyRegistrationBean(            DEFAULT_FILTER_NAME);      registration.setOrder(securityProperties.getFilterOrder());      registration.setDispatcherTypes(getDispatcherTypes(securityProperties));      <span class="hljs-keyword">return</span> registration;   &#125;   <span class="hljs-meta">@Bean</span>   <span class="hljs-meta">@ConditionalOnMissingBean</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> SecurityProperties <span class="hljs-title">securityProperties</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SecurityProperties();   &#125;&#125;</code></pre></div><p>&lt;1&gt; DelegatingFilterProxyRegistrationBean 的分析在之前那篇文章中也有详细的介绍，其作用便是在 SpringBoot 环境下通过 TomcatStarter 等内嵌容器启动类来注册一个 DelegatingFilterProxy。这下，和前面两种配置方式都对应上了。</p><h3 id="SpringSecurityFilterChain-三个核心类的源码分析"><a href="#SpringSecurityFilterChain-三个核心类的源码分析" class="headerlink" title="SpringSecurityFilterChain 三个核心类的源码分析"></a>SpringSecurityFilterChain 三个核心类的源码分析</h3><p>理解 SpringSecurityFilterChain 的工作流程必须搞懂三个类：</p><p><code>org.springframework.web.filter.DelegatingFilterProxy</code>，</p><p><code>org.springframework.security.web.FilterChainProxy</code> ，</p><p> <code>org.springframework.security.web.SecurityFilterChain</code></p><h4 id="DelegatingFilterProxy"><a href="#DelegatingFilterProxy" class="headerlink" title="DelegatingFilterProxy"></a>DelegatingFilterProxy</h4><p>上面一节主要就是介绍 DelegatingFilterProxy 在不同环境下的注册方式，可以很明显的发现，DelegatingFilterProxy 是 SpringSecurity 的“门面”，注意它的包结构：org.springframework.web.filter，它本身是 Spring Web 包中的类，并不是 SpringSecurity 中的类。因为 Spring 考虑到了多种使用场景，自然希望将侵入性降到最低，所以使用了这个委托代理类来代理真正的 SpringSecurityFilterChain。DelegatingFilterProxy 实现了 javax.servlet.Filter 接口，使得它可以作为一个 java web 的标准过滤器，其职责也很简单，只负责调用真正的 SpringSecurityFilterChain。</p><p>删减掉非重要代码后的 DelegatingFilterProxy：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelegatingFilterProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span> </span>&#123;   <span class="hljs-keyword">private</span> WebApplicationContext webApplicationContext;   <span class="hljs-comment">// springSecurityFilterChain</span>   <span class="hljs-keyword">private</span> String targetBeanName;   <span class="hljs-comment">// &lt;1&gt; 关键点</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Filter delegate;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object delegateMonitor = <span class="hljs-keyword">new</span> Object();   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DelegatingFilterProxy</span><span class="hljs-params">(String targetBeanName, WebApplicationContext wac)</span> </span>&#123;      Assert.hasText(targetBeanName, <span class="hljs-string">"Target Filter bean name must not be null or empty"</span>);      <span class="hljs-keyword">this</span>.setTargetBeanName(targetBeanName);      <span class="hljs-keyword">this</span>.webApplicationContext = wac;      <span class="hljs-keyword">if</span> (wac != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">this</span>.setEnvironment(wac.getEnvironment());      &#125;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initFilterBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;      <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.delegateMonitor) &#123;         <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.delegate == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.targetBeanName == <span class="hljs-keyword">null</span>) &#123;               <span class="hljs-keyword">this</span>.targetBeanName = getFilterName();            &#125;            <span class="hljs-comment">// Fetch Spring root application context and initialize the delegate early,</span>            <span class="hljs-comment">// if possible. If the root application context will be started after this</span>            <span class="hljs-comment">// filter proxy, we'll have to resort to lazy initialization.</span>            WebApplicationContext wac = findWebApplicationContext();            <span class="hljs-keyword">if</span> (wac != <span class="hljs-keyword">null</span>) &#123;               <span class="hljs-keyword">this</span>.delegate = initDelegate(wac);            &#125;         &#125;      &#125;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span><span class="hljs-function">         <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;      <span class="hljs-comment">// 过滤器代理支持懒加载</span>      Filter delegateToUse = <span class="hljs-keyword">this</span>.delegate;      <span class="hljs-keyword">if</span> (delegateToUse == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.delegateMonitor) &#123;            delegateToUse = <span class="hljs-keyword">this</span>.delegate;            <span class="hljs-keyword">if</span> (delegateToUse == <span class="hljs-keyword">null</span>) &#123;               WebApplicationContext wac = findWebApplicationContext();               delegateToUse = initDelegate(wac);            &#125;            <span class="hljs-keyword">this</span>.delegate = delegateToUse;         &#125;      &#125;      <span class="hljs-comment">// 让代理过滤器执行实际的过滤行为</span>      invokeDelegate(delegateToUse, request, response, filterChain);   &#125;   <span class="hljs-comment">// 初始化过滤器代理</span>   <span class="hljs-comment">// &lt;2&gt;</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> Filter <span class="hljs-title">initDelegate</span><span class="hljs-params">(WebApplicationContext wac)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;      Filter delegate = wac.getBean(getTargetBeanName(), Filter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;      <span class="hljs-keyword">if</span> (isTargetFilterLifecycle()) &#123;         delegate.init(getFilterConfig());      &#125;      <span class="hljs-keyword">return</span> delegate;   &#125;   <span class="hljs-comment">// 调用代理过滤器</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeDelegate</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">         Filter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span><span class="hljs-function">         <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;      delegate.doFilter(request, response, filterChain);   &#125;&#125;</code></pre></div><p>&lt;1&gt; 可以发现整个 DelegatingFilterProxy 的逻辑就是为了调用 <code>private volatile Filter delegate;</code> 那么问题来了，这个 delegate 的真正实现是什么呢？</p><p>&lt;2&gt; 可以看到，DelegatingFilterProxy 尝试去容器中获取名为 targetBeanName 的类，而 targetBeanName 的默认值便是 Filter 的名称，也就是 springSecurityFilterChain！也就是说，DelegatingFilterProxy 只是名称和 targetBeanName 叫 springSecurityFilterChain，真正容器中的 Bean(name=”springSecurityFilterChain”) 其实另有其人（这里 springboot 稍微有点区别，不过不影响理解，我们不纠结这个细节了）。通过 debug，我们发现了真正的 springSecurityFilterChain — FilterChainProxy。</p><p><img src="https://kirito.iocoder.cn/C811CC2A-9434-49C8-9240-15BD0EE5A21E.png" srcset="/img/loading.gif" alt="delegate"></p><h4 id="FilterChainProxy-和-SecurityFilterChain"><a href="#FilterChainProxy-和-SecurityFilterChain" class="headerlink" title="FilterChainProxy 和 SecurityFilterChain"></a>FilterChainProxy 和 SecurityFilterChain</h4><p><code>org.springframework.security.web.FilterChainProxy</code> 已经是 SpringSecurity 提供的类了，原来它才是真正的 springSecurityFilterChain，我们来看看它的源码（有删减，不影响理解）。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilterChainProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span> </span>&#123;   <span class="hljs-comment">// &lt;1&gt; 包含了多个 SecurityFilterChain</span>   <span class="hljs-keyword">private</span> List&lt;SecurityFilterChain&gt; filterChains;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FilterChainProxy</span><span class="hljs-params">(SecurityFilterChain chain)</span> </span>&#123;      <span class="hljs-keyword">this</span>(Arrays.asList(chain));   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FilterChainProxy</span><span class="hljs-params">(List&lt;SecurityFilterChain&gt; filterChains)</span> </span>&#123;      <span class="hljs-keyword">this</span>.filterChains = filterChains;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> </span>&#123;      filterChainValidator.validate(<span class="hljs-keyword">this</span>);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response,</span></span><span class="hljs-function"><span class="hljs-params">         FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;         doFilterInternal(request, response, chain);   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(ServletRequest request, ServletResponse response,</span></span><span class="hljs-function"><span class="hljs-params">         FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;      FirewalledRequest fwRequest = firewall            .getFirewalledRequest((HttpServletRequest) request);      HttpServletResponse fwResponse = firewall            .getFirewalledResponse((HttpServletResponse) response);  <span class="hljs-comment">// &lt;1&gt;</span>      List&lt;Filter&gt; filters = getFilters(fwRequest);      <span class="hljs-keyword">if</span> (filters == <span class="hljs-keyword">null</span> || filters.size() == <span class="hljs-number">0</span>) &#123;         fwRequest.reset();         chain.doFilter(fwRequest, fwResponse);         <span class="hljs-keyword">return</span>;      &#125;      VirtualFilterChain vfc = <span class="hljs-keyword">new</span> VirtualFilterChain(fwRequest, chain, filters);      vfc.doFilter(fwRequest, fwResponse);   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * &lt;1&gt; 可能会有多个过滤器链，返回第一个和请求 URL 匹配的过滤器链</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Filter&gt; <span class="hljs-title">getFilters</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;      <span class="hljs-keyword">for</span> (SecurityFilterChain chain : filterChains) &#123;         <span class="hljs-keyword">if</span> (chain.matches(request)) &#123;            <span class="hljs-keyword">return</span> chain.getFilters();         &#125;      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;&#125;</code></pre></div><p>看 FilterChainProxy 的名字就可以发现，它依旧不是真正实施过滤的类，它内部维护了一个 SecurityFilterChain，这个过滤器链才是请求真正对应的过滤器链，并且同一个 Spring 环境下，可能同时存在多个安全过滤器链，如 private List filterChains 所示，需要经过 chain.matches(request) 判断到底哪个过滤器链匹配成功，每个 request 最多只会经过一个 SecurityFilterChain。为何要这么设计？因为 Web 环境下可能有多种安全保护策略，每种策略都需要有自己的一条链路，比如我曾经设计过 Oauth2 服务，在极端条件下，可能同一个服务本身既是资源服务器，又是认证服务器，还需要做 Web 安全！</p><p><img src="https://kirito.iocoder.cn/F0EAD340-B206-4FB0-A660-4CEB28AB8609.png" srcset="/img/loading.gif" alt="多个 SecurityFilterChain"></p><p>如上图，4 个 SecurityFilterChain 存在于 FilterChainProxy 中，值得再次强调：<strong>实际每次请求，最多只有一个安全过滤器链被返回</strong>。</p><p>SecurityFilterChain 才是真正意义上的 SpringSecurityFilterChain：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultSecurityFilterChain</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SecurityFilterChain</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RequestMatcher requestMatcher;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Filter&gt; filters;   <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Filter&gt; <span class="hljs-title">getFilters</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> filters;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;      <span class="hljs-keyword">return</span> requestMatcher.matches(request);   &#125;&#125;</code></pre></div><p>其中的 List filters 包含了 <code>UsernamePasswordAuthenticationFilter</code>，<code>SecurityContextPersistenceFilter</code>，<code>FilterSecurityInterceptor</code> 等之前就介绍过的 Filter。</p><h3 id="SecurityFilterChain-的注册过程"><a href="#SecurityFilterChain-的注册过程" class="headerlink" title="SecurityFilterChain 的注册过程"></a>SecurityFilterChain 的注册过程</h3><p>还记得 DelegatingFilterProxy 从 Spring 容器中寻找了一个 targetBeanName=springSecurityFilterChain 的 Bean 吗？我们通过 debug 直接定位到了其实现是 SecurityFilterChain，但它又是什么时候被放进去的呢？</p><p>这就得说到老朋友 WebSecurity 了，还记得一般我们都会选择使用 @EnableWebSecurity 和 WebSecurityConfigurerAdapter 来进行 web 安全配置吗，来到 WebSecurity 的源码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurity</span> <span class="hljs-keyword">extends</span></span><span class="hljs-class">      <span class="hljs-title">AbstractConfiguredSecurityBuilder</span>&lt;<span class="hljs-title">Filter</span>, <span class="hljs-title">WebSecurity</span>&gt; <span class="hljs-keyword">implements</span></span><span class="hljs-class">      <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">Filter</span>&gt;, <span class="hljs-title">ApplicationContextAware</span> </span>&#123;        <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> Filter <span class="hljs-title">performBuild</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<span class="hljs-keyword">int</span> chainSize = ignoredRequests.size()+ securityFilterChainBuilders.size();List&lt;SecurityFilterChain&gt; securityFilterChains = <span class="hljs-keyword">new</span> ArrayList&lt;SecurityFilterChain&gt;(chainSize);<span class="hljs-keyword">for</span> (RequestMatcher ignoredRequest : ignoredRequests) &#123;securityFilterChains.add(<span class="hljs-keyword">new</span> DefaultSecurityFilterChain(ignoredRequest));&#125;<span class="hljs-keyword">for</span> (SecurityBuilder&lt;? extends SecurityFilterChain&gt; securityFilterChainBuilder : securityFilterChainBuilders) &#123;securityFilterChains.add(securityFilterChainBuilder.build());&#125;        <span class="hljs-comment">// &lt;1&gt; FilterChainProxy 由 WebSecurity 构建</span>FilterChainProxy filterChainProxy = <span class="hljs-keyword">new</span> FilterChainProxy(securityFilterChains);<span class="hljs-keyword">if</span> (httpFirewall != <span class="hljs-keyword">null</span>) &#123;filterChainProxy.setFirewall(httpFirewall);&#125;filterChainProxy.afterPropertiesSet();Filter result = filterChainProxy;postBuildAction.run();<span class="hljs-keyword">return</span> result;&#125;&#125;</code></pre></div><p>&lt;1&gt; 最终定位到 WebSecurity 的 performBuild 方法，我们之前配置了一堆参数的 WebSecurity 最终帮助我们构建了 FilterChainProxy。</p><p><img src="https://kirito.iocoder.cn/8E09B17E-EC83-4824-9ED9-AF2814AC6B3A.png" srcset="/img/loading.gif" alt="WebSecurityConfiguration"></p><p>并且，最终在 <code>org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration</code> 中被注册为默认名称为 SpringSecurityFilterChain。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一个名称 SpringSecurityFilterChain，借助于 Spring 的 IOC 容器，完成了 DelegatingFilterProxy 到 FilterChainProxy 的连接，并借助于 FilterChainProxy 内部维护的 List 中的某一个 SecurityFilterChain 来完成最终的过滤。</p>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Security核心(二)-核心配置解读</title>
    <link href="/2020/09/02/Spring-Security%E6%A0%B8%E5%BF%83-%E4%BA%8C-%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E8%A7%A3%E8%AF%BB/"/>
    <url>/2020/09/02/Spring-Security%E6%A0%B8%E5%BF%83-%E4%BA%8C-%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="3-核心配置解读"><a href="#3-核心配置解读" class="headerlink" title="3 核心配置解读"></a>3 核心配置解读</h2><h3 id="3-1-功能介绍"><a href="#3-1-功能介绍" class="headerlink" title="3.1 功能介绍"></a>3.1 功能介绍</h3><p>这是 Spring Security 入门指南中的配置项：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;      http          .authorizeRequests()              .antMatchers(<span class="hljs-string">"/"</span>, <span class="hljs-string">"/home"</span>,<span class="hljs-string">"/logout"</span>).permitAll()              .anyRequest().authenticated()              .and()          .formLogin()              .loginPage(<span class="hljs-string">"/login"</span>)              .permitAll()              .and()          .logout()              .permitAll();  &#125;  <span class="hljs-meta">@Autowired</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureGlobal</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;      auth          .inMemoryAuthentication()              .withUser(<span class="hljs-string">"admin"</span>).password(<span class="hljs-string">"admin"</span>).roles(<span class="hljs-string">"USER"</span>);  &#125;&#125;</code></pre></div><p>当配置了上述的 javaconfig 之后，我们的应用便具备了如下的功能：</p><ul><li><p>除了“/”,”/home”(首页),”/login”(登录),”/logout”(注销), 之外，其他路径都需要认证。</p></li><li><p>指定“/login”该路径为登录页面，当未认证的用户尝试访问任何受保护的资源时，都会跳转到“/login”。</p></li><li><p>默认指定“/logout”为注销页面</p></li><li><p>配置一个内存中的用户认证器，使用 admin/admin 作为用户名和密码，具有 USER 角色</p></li><li><p>防止 CSRF 攻击</p></li><li><p><a href="https://en.wikipedia.org/wiki/Session_fixation" target="_blank" rel="noopener">Session Fixation</a> protection(可以参考我之前讲解 Spring Session 的文章，防止别人篡改 sessionId)</p></li><li><p>Security Header(添加一系列和 Header 相关的控制)</p><ul><li><a href="https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security" target="_blank" rel="noopener">HTTP Strict Transport Security</a> for secure requests</li><li>集成 X-Content-Type-Options</li><li>缓存控制</li><li>集成 <a href="https://msdn.microsoft.com/en-us/library/dd565647(v=vs.85).aspx" target="_blank" rel="noopener">X-XSS-Protection</a></li><li>X-Frame-Options integration to help prevent <a href="https://en.wikipedia.org/wiki/Clickjacking" target="_blank" rel="noopener">Clickjacking</a>(iframe 被默认禁止使用)</li></ul></li><li><p>为 Servlet API 集成了如下的几个方法</p><ul><li><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRemoteUser()" target="_blank" rel="noopener">HttpServletRequest#getRemoteUser()</a></li><li><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getUserPrincipal()" target="_blank" rel="noopener">HttpServletRequest.html#getUserPrincipal()</a></li><li><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String)" target="_blank" rel="noopener">HttpServletRequest.html#isUserInRole(java.lang.String)</a></li><li>[HttpServletRequest.html#login(java.lang.String, java.lang.String)](<a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login" target="_blank" rel="noopener">https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login</a>(java.lang.String, java.lang.String))</li><li><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#logout()" target="_blank" rel="noopener">HttpServletRequest.html#logout()</a></li></ul></li></ul><h3 id="3-2-EnableWebSecurity"><a href="#3-2-EnableWebSecurity" class="headerlink" title="3.2 @EnableWebSecurity"></a>3.2 @EnableWebSecurity</h3><p>我们自己定义的配置类 WebSecurityConfig 加上了 @EnableWebSecurity 注解，同时继承了 WebSecurityConfigurerAdapter。你可能会在想谁的作用大一点，毫无疑问 @EnableWebSecurity 起到决定性的配置作用，它其实是个组合注解。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Import</span>(&#123; WebSecurityConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>, // &lt;2&gt;</span><span class="hljs-class">      <span class="hljs-title">SpringWebMvcImportSelector</span>.<span class="hljs-title">class</span> &#125;) // &lt;1&gt;</span><span class="hljs-class">@<span class="hljs-title">EnableGlobalAuthentication</span> // &lt;3&gt;</span><span class="hljs-class">@<span class="hljs-title">Configuration</span></span><span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">EnableWebSecurity</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;&#125;</code></pre></div><p>@Import 是 springboot 提供的用于引入外部的配置的注解，可以理解为：@EnableWebSecurity 注解激活了 @Import 注解中包含的配置类。</p><p>&lt;1&gt; <code>SpringWebMvcImportSelector</code> 的作用是判断当前的环境是否包含 springmvc，因为 spring security 可以在非 spring 环境下使用，为了避免 DispatcherServlet 的重复配置，所以使用了这个注解来区分。</p><p>&lt;2&gt; <code>WebSecurityConfiguration</code> 顾名思义，是用来配置 web 安全的，下面的小节会详细介绍。</p><p>&lt;3&gt; <code>@EnableGlobalAuthentication</code> 注解的源码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Import</span>(AuthenticationConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">Configuration</span></span><span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">EnableGlobalAuthentication</span> </span>&#123;&#125;</code></pre></div><p>注意点同样在 @Import 之中，它实际上激活了 AuthenticationConfiguration 这样的一个配置类，用来配置认证相关的核心类。</p><p>也就是说：@EnableWebSecurity 完成的工作便是加载了 <strong>WebSecurityConfiguration</strong>，<strong>AuthenticationConfiguration</strong> 这两个核心配置类，也就此将 spring security 的职责划分为了配置安全信息，配置认证信息两部分。</p><h4 id="WebSecurityConfiguration"><a href="#WebSecurityConfiguration" class="headerlink" title="WebSecurityConfiguration"></a>WebSecurityConfiguration</h4><p>在这个配置类中，有一个非常重要的 Bean 被注册了。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfiguration</span> </span>&#123;<span class="hljs-comment">//DEFAULT_FILTER_NAME = "springSecurityFilterChain"</span><span class="hljs-meta">@Bean</span>(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)    <span class="hljs-function"><span class="hljs-keyword">public</span> Filter <span class="hljs-title">springSecurityFilterChain</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    ...    &#125;    &#125;</code></pre></div><p>在未使用 springboot 之前，大多数人都应该对“springSecurityFilterChain”这个名词不会陌生，他是 spring security 的核心过滤器，是整个认证的入口。在曾经的 XML 配置中，想要启用 spring security，需要在 web.xml 中进行如下配置：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Spring Security --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre></div><p>而在 springboot 集成之后，这样的 XML 被 java 配置取代。WebSecurityConfiguration 中完成了声明 springSecurityFilterChain 的作用，并且最终交给 DelegatingFilterProxy 这个代理类，负责拦截请求（注意 DelegatingFilterProxy 这个类不是 spring security 包中的，而是存在于 web 包中，spring 使用了代理模式来实现安全过滤的解耦）。</p><h4 id="AuthenticationConfiguration"><a href="#AuthenticationConfiguration" class="headerlink" title="AuthenticationConfiguration"></a>AuthenticationConfiguration</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@Import</span>(ObjectPostProcessorConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">AuthenticationConfiguration</span> </span>&#123;  <span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationManagerBuilder <span class="hljs-title">authenticationManagerBuilder</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">ObjectPostProcessor&lt;Object&gt; objectPostProcessor)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AuthenticationManagerBuilder(objectPostProcessor);&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationManager <span class="hljs-title">getAuthenticationManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    ...    &#125;&#125;</code></pre></div><p>AuthenticationConfiguration 的主要任务，便是负责生成全局的身份认证管理者 AuthenticationManager。还记得在《Spring Security(一)–Architecture Overview》中，介绍了 Spring Security 的认证体系，AuthenticationManager 便是最核心的身份认证管理器。</p><h3 id="3-3-WebSecurityConfigurerAdapter"><a href="#3-3-WebSecurityConfigurerAdapter" class="headerlink" title="3.3 WebSecurityConfigurerAdapter"></a>3.3 WebSecurityConfigurerAdapter</h3><p>适配器模式在 spring 中被广泛的使用，在配置中使用 Adapter 的好处便是，我们可以选择性的配置想要修改的那一部分配置，而不用覆盖其他不相关的配置。WebSecurityConfigurerAdapter 中我们可以选择自己想要修改的内容，来进行重写，而其提供了三个 configure 重载方法，是我们主要关心的：</p><p><img src="https://kirito.iocoder.cn/QQ%E5%9B%BE%E7%89%8720170924215436.png" srcset="/img/loading.gif" alt="WebSecurityConfigurerAdapter 中的 configure"></p><center>WebSecurityConfigurerAdapter 中的 configure</center><p>由参数就可以知道，分别是对 AuthenticationManagerBuilder，WebSecurity，HttpSecurity 进行个性化的配置。</p><h4 id="HttpSecurity-常用配置"><a href="#HttpSecurity-常用配置" class="headerlink" title="HttpSecurity 常用配置"></a>HttpSecurity 常用配置</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomWebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;      <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http            .authorizeRequests()                .antMatchers(<span class="hljs-string">"/resources/**"</span>, <span class="hljs-string">"/signup"</span>, <span class="hljs-string">"/about"</span>).permitAll()                .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"ADMIN"</span>)                .antMatchers(<span class="hljs-string">"/db/**"</span>).access(<span class="hljs-string">"hasRole('ADMIN') and hasRole('DBA')"</span>)                .anyRequest().authenticated()                .and()            .formLogin()                .usernameParameter(<span class="hljs-string">"username"</span>)                .passwordParameter(<span class="hljs-string">"password"</span>)                .failureForwardUrl(<span class="hljs-string">"/login?error"</span>)                .loginPage(<span class="hljs-string">"/login"</span>)                .permitAll()                .and()            .logout()                .logoutUrl(<span class="hljs-string">"/logout"</span>)                .logoutSuccessUrl(<span class="hljs-string">"/index"</span>)                .permitAll()                .and()            .httpBasic()                .disable();    &#125;&#125;</code></pre></div><p>上述是一个使用 Java Configuration 配置 HttpSecurity 的典型配置，其中 http 作为根开始配置，每一个 and()对应了一个模块的配置（等同于 xml 配置中的结束标签），并且 and() 返回了 HttpSecurity 本身，于是可以连续进行配置。他们配置的含义也非常容易通过变量本身来推测，</p><ul><li>authorizeRequests() 配置路径拦截，表明路径访问所对应的权限，角色，认证信息。</li><li>formLogin() 对应表单认证相关的配置</li><li>logout() 对应了注销相关的配置</li><li>httpBasic() 可以配置 basic 登录</li><li>etc</li></ul><p>他们分别代表了 http 请求相关的安全配置，这些配置项无一例外的返回了 Configurer 类，而所有的 http 相关配置可以通过查看 HttpSecurity 的主要方法得知：</p><p><img src="https://kirito.iocoder.cn/QQ%E5%9B%BE%E7%89%8720170924223252.png" srcset="/img/loading.gif" alt="https://kirito.iocoder.cn/QQ%E5%9B%BE%E7%89%8720170924223252.png"></p><p>需要对 http 协议有一定的了解才能完全掌握所有的配置，不过，springboot 和 spring security 的自动配置已经足够使用了。其中每一项 Configurer（e.g.FormLoginConfigurer,CsrfConfigurer）都是 HttpConfigurer 的细化配置项。</p><h4 id="WebSecurityBuilder"><a href="#WebSecurityBuilder" class="headerlink" title="WebSecurityBuilder"></a>WebSecurityBuilder</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        web            .ignoring()            .antMatchers(<span class="hljs-string">"/resources/**"</span>);    &#125;&#125;</code></pre></div><p>以笔者的经验，这个配置中并不会出现太多的配置信息。</p><h4 id="AuthenticationManagerBuilder"><a href="#AuthenticationManagerBuilder" class="headerlink" title="AuthenticationManagerBuilder"></a>AuthenticationManagerBuilder</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth            .inMemoryAuthentication()            .withUser(<span class="hljs-string">"admin"</span>).password(<span class="hljs-string">"admin"</span>).roles(<span class="hljs-string">"USER"</span>);    &#125;&#125;</code></pre></div><p>想要在 WebSecurityConfigurerAdapter 中进行认证相关的配置，可以使用 configure(AuthenticationManagerBuilder auth) 暴露一个 AuthenticationManager 的建造器：AuthenticationManagerBuilder 。如上所示，我们便完成了内存中用户的配置。</p><p>细心的朋友会发现，在前面的文章中我们配置内存中的用户时，似乎不是这么配置的，而是：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;        <span class="hljs-meta">@Autowired</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureGlobal</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth            .inMemoryAuthentication()                .withUser(<span class="hljs-string">"admin"</span>).password(<span class="hljs-string">"admin"</span>).roles(<span class="hljs-string">"USER"</span>);    &#125;&#125;</code></pre></div><p>如果你的应用只有唯一一个 WebSecurityConfigurerAdapter，那么他们之间的差距可以被忽略，从方法名可以看出两者的区别：使用 @Autowired 注入的 AuthenticationManagerBuilder 是全局的身份认证器，作用域可以跨越多个 WebSecurityConfigurerAdapter，以及影响到基于 Method 的安全控制；而 <code>protected configure()</code> 的方式则类似于一个匿名内部类，它的作用域局限于一个 WebSecurityConfigurerAdapter 内部。关于这一点的区别，可以参考我曾经提出的 issue<a href="https://github.com/spring-projects/spring-security/issues/4571" target="_blank" rel="noopener">spring-security#issues4571</a>。官方文档中，也给出了配置多个 WebSecurityConfigurerAdapter 的场景以及 demo，将在该系列的后续文章中解读。</p>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Security核心(三)-核心过滤器源码分析</title>
    <link href="/2020/09/02/Spring-Security%E6%A0%B8%E5%BF%83-%E4%B8%89-%E6%A0%B8%E5%BF%83%E8%BF%87%E6%BB%A4%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2020/09/02/Spring-Security%E6%A0%B8%E5%BF%83-%E4%B8%89-%E6%A0%B8%E5%BF%83%E8%BF%87%E6%BB%A4%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>前面的部分，我们关注了 Spring Security 是如何完成认证工作的，但是另外一部分核心的内容：过滤器，一直没有提到，我们已经知道 Spring Security 使用了 springSecurityFillterChian 作为了安全过滤的入口，这一节主要分析一下这个过滤器链都包含了哪些关键的过滤器，并且各自的使命是什么。</p><h2 id="4-过滤器详解"><a href="#4-过滤器详解" class="headerlink" title="4 过滤器详解"></a>4 过滤器详解</h2><h3 id="4-1-核心过滤器概述"><a href="#4-1-核心过滤器概述" class="headerlink" title="4.1 核心过滤器概述"></a>4.1 核心过滤器概述</h3><div class="hljs"><pre><code class="hljs angelscript">Creating filter chain: o.s.s.web.util.matcher.<span class="hljs-symbol">AnyRequestMatcher@</span><span class="hljs-number">1</span>, [o.s.s.web.context.<span class="hljs-symbol">SecurityContextPersistenceFilter@</span><span class="hljs-number">8851</span>ce1, o.s.s.web.header.<span class="hljs-symbol">HeaderWriterFilter@</span><span class="hljs-number">6</span>a472566, o.s.s.web.csrf.<span class="hljs-symbol">CsrfFilter@</span><span class="hljs-number">61</span>cd1c71, o.s.s.web.authentication.logout.<span class="hljs-symbol">LogoutFilter@</span><span class="hljs-number">5e1</span>d03d7, o.s.s.web.authentication.<span class="hljs-symbol">UsernamePasswordAuthenticationFilter@</span><span class="hljs-number">122</span>d6c22, o.s.s.web.savedrequest.<span class="hljs-symbol">RequestCacheAwareFilter@</span><span class="hljs-number">5</span>ef6fd7f, o.s.s.web.servletapi.<span class="hljs-symbol">SecurityContextHolderAwareRequestFilter@</span><span class="hljs-number">4</span>beaf6bd, o.s.s.web.authentication.<span class="hljs-symbol">AnonymousAuthenticationFilter@</span><span class="hljs-number">6</span>edcad64, o.s.s.web.session.<span class="hljs-symbol">SessionManagementFilter@</span><span class="hljs-number">5e65</span>afb6, o.s.s.web.access.<span class="hljs-symbol">ExceptionTranslationFilter@</span><span class="hljs-number">5</span>b9396d3, o.s.s.web.access.<span class="hljs-built_in">int</span>ercept.<span class="hljs-symbol">FilterSecurityInterceptor@</span><span class="hljs-number">3</span>c5dbdf8]</code></pre></div><p>上述的 log 信息是我从 springboot 启动的日志中 CV 所得，spring security 的过滤器日志有一个特点：log 打印顺序与实际配置顺序符合，也就意味着 <code>SecurityContextPersistenceFilter</code> 是整个过滤器链的第一个过滤器，而 <code>FilterSecurityInterceptor</code> 则是末置的过滤器。另外通过观察过滤器的名称，和所在的包名，可以大致地分析出他们各自的作用，如 <code>UsernamePasswordAuthenticationFilter</code> 明显便是与使用用户名和密码登录相关的过滤器，而 <code>FilterSecurityInterceptor</code> 我们似乎看不出它的作用，但是其位于 <code>web.access</code> 包下，大致可以分析出他与访问限制相关。这篇文章主要就是介绍这些常用的过滤器，对其中关键的过滤器进行一些源码分析。先大致介绍下每个过滤器的作用：</p><ul><li><strong>SecurityContextPersistenceFilter</strong> 两个主要职责：请求来临时，创建 <code>SecurityContext</code> 安全上下文信息，请求结束时清空 <code>SecurityContextHolder</code>。</li><li>HeaderWriterFilter (文档中并未介绍，非核心过滤器) 用来给 http 响应添加一些 Header, 比如 X-Frame-Options, X-XSS-Protection，X-Content-Type-Options.</li><li>CsrfFilter 在 spring4 这个版本中被默认开启的一个过滤器，用于防止 csrf 攻击，了解前后端分离的人一定不会对这个攻击方式感到陌生，前后端使用 json 交互需要注意的一个问题。</li><li>LogoutFilter 顾名思义，处理注销的过滤器</li><li><strong>UsernamePasswordAuthenticationFilter</strong> 这个会重点分析，表单提交了 username 和 password，被封装成 token 进行一系列的认证，便是主要通过这个过滤器完成的，在表单认证的方法中，这是最最关键的过滤器。</li><li>RequestCacheAwareFilter (文档中并未介绍，非核心过滤器) 内部维护了一个 RequestCache，用于缓存 request 请求</li><li>SecurityContextHolderAwareRequestFilter 此过滤器对 ServletRequest 进行了一次包装，使得 request 具有更加丰富的 API</li><li><strong>AnonymousAuthenticationFilter</strong> 匿名身份过滤器，这个过滤器个人认为很重要，需要将它与 UsernamePasswordAuthenticationFilter 放在一起比较理解，spring security 为了兼容未登录的访问，也走了一套认证流程，只不过是一个匿名的身份。</li><li>SessionManagementFilter 和 session 相关的过滤器，内部维护了一个 SessionAuthenticationStrategy，两者组合使用，常用来防止 <code>session-fixation protection attack</code>，以及限制同一用户开启多个会话的数量</li><li><strong>ExceptionTranslationFilter</strong> 直译成异常翻译过滤器，还是比较形象的，这个过滤器本身不处理异常，而是将认证过程中出现的异常交给内部维护的一些类去处理；</li><li><strong>FilterSecurityInterceptor</strong> 这个过滤器决定了访问特定路径应该具备的权限，访问的用户的角色，权限是什么？访问的路径需要什么样的角色和权限？这些判断和处理都是由该类进行的。</li></ul><p>其中加粗的过滤器可以被认为是 Spring Security 的核心过滤器，将在下面，一个过滤器对应一个小节来讲解。</p><h3 id="4-2-SecurityContextPersistenceFilter"><a href="#4-2-SecurityContextPersistenceFilter" class="headerlink" title="4.2 SecurityContextPersistenceFilter"></a>4.2 SecurityContextPersistenceFilter</h3><p>试想一下，如果我们不使用 Spring Security，如何保存用户信息呢，大多数情况下会考虑使用 Session 对吧？在 Spring Security 中也是如此，用户在登录过一次之后，后续的访问便是通过 sessionId 来识别，从而认为用户已经被认证。具体在何处存放用户信息，便是第一篇文章中提到的 <strong>SecurityContextHolder</strong>；认证相关的信息是如何被存放到其中的，便是通过 SecurityContextPersistenceFilter。在 4.1 概述中也提到了，SecurityContextPersistenceFilter 的两个主要作用便是请求来临时，创建 <code>SecurityContext</code> 安全上下文信息和请求结束时清空 <code>SecurityContextHolder</code>。顺带提一下：微服务的一个设计理念需要实现服务通信的无状态，而 http 协议中的无状态意味着不允许存在 session，这可以通过 <code>setAllowSessionCreation(false)</code> 实现，这并不意味着 SecurityContextPersistenceFilter 变得无用，因为它还需要负责清除用户信息。在 Spring Security 中，虽然安全上下文信息被存储于 Session 中，但我们在实际使用中不应该直接操作 Session，而应当使用 SecurityContextHolder。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><div class="hljs"><pre><code class="hljs java">org.springframework.security.web.context.SecurityContextPersistenceFilter    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityContextPersistenceFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span> </span>&#123;   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FILTER_APPLIED = <span class="hljs-string">"__spring_security_scpf_applied"</span>;   <span class="hljs-comment">// 安全上下文存储的仓库</span>   <span class="hljs-keyword">private</span> SecurityContextRepository repo;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SecurityContextPersistenceFilter</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">// HttpSessionSecurityContextRepository 是 SecurityContextRepository 接口的一个实现类</span>      <span class="hljs-comment">// 使用 HttpSession 来存储 SecurityContext</span>      <span class="hljs-keyword">this</span>(<span class="hljs-keyword">new</span> HttpSessionSecurityContextRepository());   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><span class="hljs-function">         <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;      HttpServletRequest request = (HttpServletRequest) req;      HttpServletResponse response = (HttpServletResponse) res;      <span class="hljs-keyword">if</span> (request.getAttribute(FILTER_APPLIED) != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-comment">// ensure that filter is only applied once per request</span>         chain.doFilter(request, response);         <span class="hljs-keyword">return</span>;      &#125;      request.setAttribute(FILTER_APPLIED, Boolean.TRUE);      <span class="hljs-comment">// 包装 request，response</span>      HttpRequestResponseHolder holder = <span class="hljs-keyword">new</span> HttpRequestResponseHolder(request,            response);      <span class="hljs-comment">// 从 Session 中获取安全上下文信息</span>      SecurityContext contextBeforeChainExecution = repo.loadContext(holder);      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-comment">// 请求开始时，设置安全上下文信息，这样就避免了用户直接从 Session 中获取安全上下文信息</span>         SecurityContextHolder.setContext(contextBeforeChainExecution);         chain.doFilter(holder.getRequest(), holder.getResponse());      &#125;      <span class="hljs-keyword">finally</span> &#123;         <span class="hljs-comment">// 请求结束后，清空安全上下文信息</span>         SecurityContext contextAfterChainExecution = SecurityContextHolder               .getContext();         SecurityContextHolder.clearContext();         repo.saveContext(contextAfterChainExecution, holder.getRequest(),               holder.getResponse());         request.removeAttribute(FILTER_APPLIED);         <span class="hljs-keyword">if</span> (debug) &#123;            logger.debug(<span class="hljs-string">"SecurityContextHolder now cleared, as request processing completed"</span>);         &#125;      &#125;   &#125;&#125;</code></pre></div><p>过滤器一般负责核心的处理流程，而具体的业务实现，通常交给其中聚合的其他实体类，这在 Filter 的设计中很常见，同时也符合职责分离模式。例如存储安全上下文和读取安全上下文的工作完全委托给了 HttpSessionSecurityContextRepository 去处理，而这个类中也有几个方法可以稍微解读下，方便我们理解内部的工作流程.</p><div class="hljs"><pre><code class="hljs java">org.springframework.security.web.context.HttpSessionSecurityContextRepository    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpSessionSecurityContextRepository</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SecurityContextRepository</span> </span>&#123;   <span class="hljs-comment">// 'SPRING_SECURITY_CONTEXT' 是安全上下文默认存储在 Session 中的键值</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SPRING_SECURITY_CONTEXT_KEY = <span class="hljs-string">"SPRING_SECURITY_CONTEXT"</span>;   ...   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object contextObject = SecurityContextHolder.createEmptyContext();   <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> allowSessionCreation = <span class="hljs-keyword">true</span>;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> disableUrlRewriting = <span class="hljs-keyword">false</span>;   <span class="hljs-keyword">private</span> String springSecurityContextKey = SPRING_SECURITY_CONTEXT_KEY;   <span class="hljs-keyword">private</span> AuthenticationTrustResolver trustResolver = <span class="hljs-keyword">new</span> AuthenticationTrustResolverImpl();   <span class="hljs-comment">// 从当前 request 中取出安全上下文，如果 session 为空，则会返回一个新的安全上下文</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> SecurityContext <span class="hljs-title">loadContext</span><span class="hljs-params">(HttpRequestResponseHolder requestResponseHolder)</span> </span>&#123;      HttpServletRequest request = requestResponseHolder.getRequest();      HttpServletResponse response = requestResponseHolder.getResponse();      HttpSession httpSession = request.getSession(<span class="hljs-keyword">false</span>);      SecurityContext context = readSecurityContextFromSession(httpSession);      <span class="hljs-keyword">if</span> (context == <span class="hljs-keyword">null</span>) &#123;         context = generateNewContext();      &#125;      ...      <span class="hljs-keyword">return</span> context;   &#125;   ...   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsContext</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;      HttpSession session = request.getSession(<span class="hljs-keyword">false</span>);      <span class="hljs-keyword">if</span> (session == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      &#125;      <span class="hljs-keyword">return</span> session.getAttribute(springSecurityContextKey) != <span class="hljs-keyword">null</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> SecurityContext <span class="hljs-title">readSecurityContextFromSession</span><span class="hljs-params">(HttpSession httpSession)</span> </span>&#123;      <span class="hljs-keyword">if</span> (httpSession == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      &#125;      ...      <span class="hljs-comment">// Session 存在的情况下，尝试获取其中的 SecurityContext</span>      Object contextFromSession = httpSession.getAttribute(springSecurityContextKey);      <span class="hljs-keyword">if</span> (contextFromSession == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      &#125;      ...      <span class="hljs-keyword">return</span> (SecurityContext) contextFromSession;   &#125;   <span class="hljs-comment">// 初次请求时创建一个新的 SecurityContext 实例</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> SecurityContext <span class="hljs-title">generateNewContext</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> SecurityContextHolder.createEmptyContext();   &#125;&#125;</code></pre></div><p>SecurityContextPersistenceFilter 和 HttpSessionSecurityContextRepository 配合使用，构成了 Spring Security 整个调用链路的入口，为什么将它放在最开始的地方也是显而易见的，后续的过滤器中大概率会依赖 Session 信息和安全上下文信息。</p><h3 id="4-3-UsernamePasswordAuthenticationFilter"><a href="#4-3-UsernamePasswordAuthenticationFilter" class="headerlink" title="4.3 UsernamePasswordAuthenticationFilter"></a>4.3 UsernamePasswordAuthenticationFilter</h3><p>表单认证是最常用的一个认证方式，一个最直观的业务场景便是允许用户在表单中输入用户名和密码进行登录，而这背后的 UsernamePasswordAuthenticationFilter，在整个 Spring Security 的认证体系中则扮演着至关重要的角色。</p><p><img src="https://kirito.iocoder.cn/2011121410543010.jpg" srcset="/img/loading.gif" alt="https://kirito.iocoder.cn/2011121410543010.jpg"></p><p>上述的时序图，可以看出 UsernamePasswordAuthenticationFilter 主要肩负起了调用身份认证器，校验身份的作用，至于认证的细节，在前面几章花了很大篇幅进行了介绍，到这里，其实 Spring Security 的基本流程就已经走通了。</p><h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><div class="hljs"><pre><code class="hljs java">org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter#attemptAuthentication    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">      HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;   <span class="hljs-comment">// 获取表单中的用户名和密码</span>   String username = obtainUsername(request);   String password = obtainPassword(request);   ...   username = username.trim();   <span class="hljs-comment">// 组装成 username+password 形式的 token</span>   UsernamePasswordAuthenticationToken authRequest = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(         username, password);   <span class="hljs-comment">// 对请求参数做提取，来设置details,至于details的值，则是通过authenticationDetailsSource来构建的</span>   setDetails(request, authRequest);   <span class="hljs-comment">// 交给内部的 AuthenticationManager 去认证，并返回认证信息</span>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);&#125;</code></pre></div><p><code>UsernamePasswordAuthenticationFilter</code> 本身的代码只包含了上述这么一个方法，非常简略，而在其父类 <code>AbstractAuthenticationProcessingFilter</code> 中包含了大量的细节，值得我们分析：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractAuthenticationProcessingFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span></span><span class="hljs-class">      <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationEventPublisherAware</span>, <span class="hljs-title">MessageSourceAware</span> </span>&#123;<span class="hljs-comment">// 包含了一个身份认证器</span><span class="hljs-keyword">private</span> AuthenticationManager authenticationManager;<span class="hljs-comment">// 用于实现 remeberMe</span><span class="hljs-keyword">private</span> RememberMeServices rememberMeServices = <span class="hljs-keyword">new</span> NullRememberMeServices();<span class="hljs-keyword">private</span> RequestMatcher requiresAuthenticationRequestMatcher;<span class="hljs-comment">// 这两个 Handler 很关键，分别代表了认证成功和失败相应的处理器</span><span class="hljs-keyword">private</span> AuthenticationSuccessHandler successHandler = <span class="hljs-keyword">new</span> SavedRequestAwareAuthenticationSuccessHandler();<span class="hljs-keyword">private</span> AuthenticationFailureHandler failureHandler = <span class="hljs-keyword">new</span> SimpleUrlAuthenticationFailureHandler();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;HttpServletRequest request = (HttpServletRequest) req;HttpServletResponse response = (HttpServletResponse) res;...Authentication authResult;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// 此处实际上就是调用 UsernamePasswordAuthenticationFilter 的 attemptAuthentication 方法</span>authResult = attemptAuthentication(request, response);<span class="hljs-keyword">if</span> (authResult == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 子类未完成认证，立刻返回</span><span class="hljs-keyword">return</span>;&#125;sessionStrategy.onAuthentication(authResult, request, response);&#125;<span class="hljs-comment">// 在认证过程中可以直接抛出异常，在过滤器中，就像此处一样，进行捕获</span><span class="hljs-keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;<span class="hljs-comment">// 内部服务异常</span>unsuccessfulAuthentication(request, response, failed);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">catch</span> (AuthenticationException failed) &#123;<span class="hljs-comment">// 认证失败</span>unsuccessfulAuthentication(request, response, failed);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">// 认证成功</span><span class="hljs-keyword">if</span> (continueChainBeforeSuccessfulAuthentication) &#123;chain.doFilter(request, response);&#125;<span class="hljs-comment">// 注意，认证成功后过滤器把 authResult 结果也传递给了成功处理器</span>successfulAuthentication(request, response, chain, authResult);&#125;&#125;</code></pre></div><p>整个流程理解起来也并不难，主要就是内部调用了 authenticationManager 完成认证，根据认证结果执行 successfulAuthentication 或者 unsuccessfulAuthentication，无论成功失败，一般的实现都是转发或者重定向等处理，不再细究 AuthenticationSuccessHandler 和 AuthenticationFailureHandler，有兴趣的朋友，可以去看看两者的实现类。</p><h3 id="4-4-AnonymousAuthenticationFilter"><a href="#4-4-AnonymousAuthenticationFilter" class="headerlink" title="4.4 AnonymousAuthenticationFilter"></a>4.4 AnonymousAuthenticationFilter</h3><p>匿名认证过滤器，可能有人会想：匿名了还有身份？我自己对于 Anonymous 匿名身份的理解是 Spirng Security 为了整体逻辑的统一性，即使是未通过认证的用户，也给予了一个匿名身份。而 <code>AnonymousAuthenticationFilter</code> 该过滤器的位置也是非常科学的，它位于常用的身份认证过滤器（如 <code>UsernamePasswordAuthenticationFilter</code>、<code>BasicAuthenticationFilter</code>、<code>RememberMeAuthenticationFilter</code>）之后，意味着只有在上述身份过滤器执行完毕后，SecurityContext 依旧没有用户信息，<code>AnonymousAuthenticationFilter</code> 该过滤器才会有意义 —- 基于用户一个匿名身份。</p><h4 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h4><div class="hljs"><pre><code class="hljs java">org.springframework.security.web.authentication.AnonymousAuthenticationFilter<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnonymousAuthenticationFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span> <span class="hljs-keyword">implements</span></span><span class="hljs-class">      <span class="hljs-title">InitializingBean</span> </span>&#123;   <span class="hljs-keyword">private</span> AuthenticationDetailsSource&lt;HttpServletRequest, ?&gt; authenticationDetailsSource = <span class="hljs-keyword">new</span> WebAuthenticationDetailsSource();   <span class="hljs-keyword">private</span> String key;   <span class="hljs-keyword">private</span> Object principal;   <span class="hljs-keyword">private</span> List&lt;GrantedAuthority&gt; authorities;   <span class="hljs-comment">// 自动创建一个 "anonymousUser" 的匿名用户, 其具有 ANONYMOUS 角色</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnonymousAuthenticationFilter</span><span class="hljs-params">(String key)</span> </span>&#123;      <span class="hljs-keyword">this</span>(key, <span class="hljs-string">"anonymousUser"</span>, AuthorityUtils.createAuthorityList(<span class="hljs-string">"ROLE_ANONYMOUS"</span>));   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> key key 用来识别该过滤器创建的身份</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> principal principal 代表匿名用户的身份</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> authorities authorities 代表匿名用户的权限集合</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnonymousAuthenticationFilter</span><span class="hljs-params">(String key, Object principal,</span></span><span class="hljs-function"><span class="hljs-params">         List&lt;GrantedAuthority&gt; authorities)</span> </span>&#123;      Assert.hasLength(key, <span class="hljs-string">"key cannot be null or empty"</span>);      Assert.notNull(principal, <span class="hljs-string">"Anonymous authentication principal must be set"</span>);      Assert.notNull(authorities, <span class="hljs-string">"Anonymous authorities must be set"</span>);      <span class="hljs-keyword">this</span>.key = key;      <span class="hljs-keyword">this</span>.principal = principal;      <span class="hljs-keyword">this</span>.authorities = authorities;   &#125;   ...   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><span class="hljs-function">         <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;      <span class="hljs-comment">// 过滤器链都执行到匿名认证过滤器这儿了还没有身份信息，塞一个匿名身份进去</span>      <span class="hljs-keyword">if</span> (SecurityContextHolder.getContext().getAuthentication()== <span class="hljs-keyword">null</span>) &#123;         SecurityContextHolder.getContext().setAuthentication(               createAuthentication((HttpServletRequest) req));      &#125;      chain.doFilter(req, res);   &#125;   <span class="hljs-function"><span class="hljs-keyword">protected</span> Authentication <span class="hljs-title">createAuthentication</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;     <span class="hljs-comment">// 创建一个 AnonymousAuthenticationToken</span>      AnonymousAuthenticationToken auth = <span class="hljs-keyword">new</span> AnonymousAuthenticationToken(key,            principal, authorities);      auth.setDetails(authenticationDetailsSource.buildDetails(request));      <span class="hljs-keyword">return</span> auth;   &#125;   ...&#125;</code></pre></div><p>其实对比 AnonymousAuthenticationFilter 和 UsernamePasswordAuthenticationFilter 就可以发现一些门道了，UsernamePasswordAuthenticationToken 对应 AnonymousAuthenticationToken，他们都是 Authentication 的实现类，而 Authentication 则是被 SecurityContextHolder(SecurityContext) 持有的，一切都被串联在了一起。</p><h3 id="4-5-ExceptionTranslationFilter"><a href="#4-5-ExceptionTranslationFilter" class="headerlink" title="4.5 ExceptionTranslationFilter"></a>4.5 ExceptionTranslationFilter</h3><p>ExceptionTranslationFilter 异常转换过滤器位于整个 springSecurityFilterChain 的后方，用来转换整个链路中出现的异常，将其转化，顾名思义，转化意味本身并不处理。一般其只处理两大类异常：<strong>AccessDeniedException</strong> 访问异常和 <strong>AuthenticationException</strong> 认证异常。</p><p>这个过滤器非常重要，因为它将 Java 中的异常和 HTTP 的响应连接在了一起，这样在处理异常时，我们不用考虑密码错误该跳到什么页面，账号锁定该如何，只需要关注自己的业务逻辑，抛出相应的异常便可。如果该过滤器检测到 AuthenticationException，则将会交给内部的 AuthenticationEntryPoint 去处理，如果检测到 AccessDeniedException，需要先判断当前用户是不是匿名用户，如果是匿名访问，则和前面一样运行 AuthenticationEntryPoint，否则会委托给 AccessDeniedHandler 去处理，而 AccessDeniedHandler 的默认实现，是 AccessDeniedHandlerImpl。所以 ExceptionTranslationFilter 内部的 AuthenticationEntryPoint 是至关重要的，顾名思义：认证的入口点。</p><h4 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionTranslationFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span> </span>&#123;  <span class="hljs-comment">// 处理异常转换的核心方法</span>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleSpringSecurityException</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">        HttpServletResponse response, FilterChain chain, RuntimeException exception)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;     <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> AuthenticationException) &#123;       <span class="hljs-comment">// 重定向到登录端点</span>        sendStartAuthentication(request, response, chain,              (AuthenticationException) exception);     &#125;     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> AccessDeniedException) &#123;        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();        <span class="hljs-keyword">if</span> (authenticationTrustResolver.isAnonymous(authentication) || authenticationTrustResolver.isRememberMe(authentication)) &#123;  <span class="hljs-comment">// 重定向到登录端点</span>           sendStartAuthentication(                 request,                 response,                 chain,                 <span class="hljs-keyword">new</span> InsufficientAuthenticationException(                       <span class="hljs-string">"Full authentication is required to access this resource"</span>));        &#125;        <span class="hljs-keyword">else</span> &#123;           <span class="hljs-comment">// 交给 accessDeniedHandler 处理</span>           accessDeniedHandler.handle(request, response,                 (AccessDeniedException) exception);        &#125;     &#125;  &#125;&#125;</code></pre></div><p>剩下的便是要搞懂 AuthenticationEntryPoint 和 AccessDeniedHandler 就可以了。</p><p><img src="https://kirito.iocoder.cn/QQ%E5%9B%BE%E7%89%8720170929231608.png" srcset="/img/loading.gif" alt="AuthenticationEntryPoint"></p><p>选择了几个常用的登录端点，以其中第一个为例来介绍，看名字就能猜到是认证失败之后，让用户跳转到登录页面。还记得我们一开始怎么配置表单登录页面的吗？</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http            .authorizeRequests()                .antMatchers(<span class="hljs-string">"/"</span>, <span class="hljs-string">"/home"</span>).permitAll()                .anyRequest().authenticated()                .and()            .formLogin()<span class="hljs-comment">//FormLoginConfigurer</span>                .loginPage(<span class="hljs-string">"/login"</span>)                .permitAll()                .and()            .logout()                .permitAll();    &#125;&#125;</code></pre></div><p>我们顺着 formLogin 返回的 FormLoginConfigurer 往下找，看看能发现什么，最终在 FormLoginConfigurer 的父类 AbstractAuthenticationFilterConfigurer 中有了不小的收获：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractAuthenticationFilterConfigurer</span> <span class="hljs-keyword">extends</span> ...</span>&#123;   ...   <span class="hljs-comment">//formLogin 不出所料配置了 AuthenticationEntryPoint</span>   <span class="hljs-keyword">private</span> LoginUrlAuthenticationEntryPoint authenticationEntryPoint;   <span class="hljs-comment">// 认证失败的处理器</span>   <span class="hljs-keyword">private</span> AuthenticationFailureHandler failureHandler;   ...&#125;</code></pre></div><p>具体如何配置的就不看了，我们得出了结论，formLogin() 配置了之后最起码做了两件事，其一，为 UsernamePasswordAuthenticationFilter 设置了相关的配置，其二配置了 AuthenticationEntryPoint。</p><p>登录端点还有 Http401AuthenticationEntryPoint，Http403ForbiddenEntryPoint 这些都是很简单的实现，有时候我们访问受限页面，又没有配置登录，就看到了一个空荡荡的默认错误页面，上面显示着 401,403，就是这两个入口起了作用。</p><p>还剩下一个 AccessDeniedHandler 访问决策器未被讲解，简单提一下：AccessDeniedHandlerImpl 这个默认实现类会根据 errorPage 和状态码来判断，最终决定跳转的页面</p><div class="hljs"><pre><code class="hljs java">org.springframework.security.web.access.AccessDeniedHandlerImpl#handle    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span><span class="hljs-function"><span class="hljs-params">      AccessDeniedException accessDeniedException)</span> <span class="hljs-keyword">throws</span> IOException,</span><span class="hljs-function">      ServletException </span>&#123;   <span class="hljs-keyword">if</span> (!response.isCommitted()) &#123;      <span class="hljs-keyword">if</span> (errorPage != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-comment">// Put exception into request scope (perhaps of use to a view)</span>         request.setAttribute(WebAttributes.ACCESS_DENIED_403,               accessDeniedException);         <span class="hljs-comment">// Set the 403 status code.</span>         response.setStatus(HttpServletResponse.SC_FORBIDDEN);         <span class="hljs-comment">// forward to error page.</span>         RequestDispatcher dispatcher = request.getRequestDispatcher(errorPage);         dispatcher.forward(request, response);      &#125;      <span class="hljs-keyword">else</span> &#123;         response.sendError(HttpServletResponse.SC_FORBIDDEN,               accessDeniedException.getMessage());      &#125;   &#125;&#125;</code></pre></div><h3 id="4-6-FilterSecurityInterceptor"><a href="#4-6-FilterSecurityInterceptor" class="headerlink" title="4.6 FilterSecurityInterceptor"></a>4.6 FilterSecurityInterceptor</h3><p>想想整个认证安全控制流程还缺了什么？我们已经有了认证，有了请求的封装，有了 Session 的关联… 还缺一个：由什么控制哪些资源是受限的，这些受限的资源需要什么权限，需要什么角色… 这一切和访问控制相关的操作，都是由 FilterSecurityInterceptor 完成的。</p><p>FilterSecurityInterceptor 的工作流程用笔者的理解可以理解如下：FilterSecurityInterceptor 从 SecurityContextHolder 中获取 Authentication 对象，然后比对用户拥有的权限和资源所需的权限。前者可以通过 Authentication 对象直接获得，而后者则需要引入我们之前一直未提到过的两个类：<strong>SecurityMetadataSource</strong>，<strong>AccessDecisionManager</strong>。理解清楚决策管理器的整个创建流程和 SecurityMetadataSource 的作用需要花很大一笔功夫，这里，暂时只介绍其大概的作用。</p><p>在 JavaConfig 的配置中，我们通常如下配置路径的访问控制：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;http.authorizeRequests().antMatchers(<span class="hljs-string">"/resources/**"</span>, <span class="hljs-string">"/signup"</span>, <span class="hljs-string">"/about"</span>).permitAll()             .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"ADMIN"</span>)             .antMatchers(<span class="hljs-string">"/db/**"</span>).access(<span class="hljs-string">"hasRole('ADMIN') and hasRole('DBA')"</span>)             .anyRequest().authenticated().withObjectPostProcessor(<span class="hljs-keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;<span class="hljs-keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">O fsi)</span> </span>&#123;fsi.setPublishAuthorizationSuccess(<span class="hljs-keyword">true</span>);<span class="hljs-keyword">return</span> fsi;&#125;&#125;);&#125;</code></pre></div><p>在 ObjectPostProcessor 的泛型中看到了 FilterSecurityInterceptor，以笔者的经验，目前并没有太多机会需要修改 FilterSecurityInterceptor 的配置。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇文章在介绍过滤器时，顺便进行了一些源码的分析，目的是方便理解整个 Spring Security 的工作流。伴随着整个过滤器链的介绍，安全框架的轮廓应该已经浮出水面了，下面的章节，主要打算通过自定义一些需求，再次分析其他组件的源码，学习应该如何改造 Spring Security，为我们所用。</p>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Security核心(一)-概述</title>
    <link href="/2020/09/02/Spring-Security%E6%A0%B8%E5%BF%83-%E4%B8%80-%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/09/02/Spring-Security%E6%A0%B8%E5%BF%83-%E4%B8%80-%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-核心组件"><a href="#1-核心组件" class="headerlink" title="1 核心组件"></a>1 核心组件</h1><p>这一节主要介绍一些在 Spring Security 中常见且核心的 Java 类，它们之间的依赖，构建起了整个框架。想要理解整个架构，最起码得对这些类眼熟。</p><h3 id="1-1-SecurityContextHolder"><a href="#1-1-SecurityContextHolder" class="headerlink" title="1.1 SecurityContextHolder"></a>1.1 SecurityContextHolder</h3><p><code>SecurityContextHolder</code> 用于存储安全上下文（security context）的信息。当前操作的用户是谁，该用户是否已经被认证，它拥有哪些角色权限… 这些都被保存在 SecurityContextHolder 中。<code>SecurityContextHolder</code> 默认使用 <code>ThreadLocal</code> 策略来存储认证信息。看到 <code>ThreadLocal</code> 也就意味着，这是一种与线程绑定的策略。Spring Security 在用户登录时自动绑定认证信息到当前线程，在用户退出时，自动清除当前线程的认证信息。但这一切的前提，是你在 web 场景下使用 Spring Security，而如果是 Swing 界面，Spring 也提供了支持，<code>SecurityContextHolder</code> 的策略则需要被替换，鉴于我的初衷是基于 web 来介绍 Spring Security，所以这里以及后续，非 web 的相关的内容都一笔带过。</p><h4 id="获取当前用户的信息"><a href="#获取当前用户的信息" class="headerlink" title="获取当前用户的信息"></a>获取当前用户的信息</h4><p>因为身份信息是与线程绑定的，所以可以在程序的任何地方使用静态方法获取用户信息。一个典型的获取当前登录用户的姓名的例子如下所示：</p><div class="hljs"><pre><code class="hljs java">Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();<span class="hljs-keyword">if</span> (principal <span class="hljs-keyword">instanceof</span> UserDetails) &#123;String username = ((UserDetails)principal).getUsername();&#125; <span class="hljs-keyword">else</span> &#123;String username = principal.toString();&#125;</code></pre></div><p><code>getAuthentication()</code>返回了认证信息， <code>getPrincipal()</code>返回了身份信息，UserDetails 便是 Spring 对身份信息封装的一个接口。Authentication 和 UserDetails 的介绍在下面的小节具体讲解，本节重要的内容是介绍 SecurityContextHolder 这个容器。</p><h3 id="1-2-Authentication"><a href="#1-2-Authentication" class="headerlink" title="1.2 Authentication"></a>1.2 Authentication</h3><p>先看看这个接口的源码长什么样：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.security.core;<span class="hljs-comment">// &lt;1&gt;</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Authentication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Principal</span>, <span class="hljs-title">Serializable</span> </span>&#123; <span class="hljs-comment">// &lt;1&gt;</span>    Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); <span class="hljs-comment">// &lt;2&gt;</span>    <span class="hljs-function">Object <span class="hljs-title">getCredentials</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// &lt;2&gt;</span>    <span class="hljs-function">Object <span class="hljs-title">getDetails</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// &lt;2&gt;</span>    <span class="hljs-function">Object <span class="hljs-title">getPrincipal</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// &lt;2&gt;</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAuthenticated</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// &lt;2&gt;</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAuthenticated</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> var1)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException</span>;&#125;</code></pre></div><p>&lt;1&gt; Authentication 是 spring security 包中的接口，直接继承自 Principal 类，而 Principal 是位于 <code>java.security</code> 包中的。可以见得，Authentication 在 spring security 中是最高级别的身份 / 认证的抽象。</p><p>&lt;2&gt; 由这个顶级接口，我们可以得到用户拥有的权限信息列表，密码，用户细节信息，用户身份信息，认证信息。</p><p>还记得 1.1 节中，authentication.getPrincipal() 返回了一个 Object，我们将 Principal 强转成了 Spring Security 中最常用的 UserDetails，这在 Spring Security 中非常常见，接口返回 Object，使用 instanceof 判断类型，强转成对应的具体实现类。接口详细解读如下：</p><ul><li>getAuthorities()，权限信息列表，默认是 GrantedAuthority 接口的一些实现类，通常是代表权限信息的一系列字符串。</li><li>getCredentials()，密码信息，用户输入的密码字符串，在认证过后通常会被移除，用于保障安全。</li><li>getDetails()，细节信息，web 应用中的实现接口通常为 WebAuthenticationDetails，它记录了访问者的 ip 地址和 sessionId 的值。</li><li>getPrincipal()，敲黑板！！！最重要的身份信息，大部分情况下返回的是 UserDetails 接口的实现类，也是框架中的常用接口之一。UserDetails 接口将会在下面的小节重点介绍。</li></ul><h4 id="Spring-Security-是如何完成身份认证的？"><a href="#Spring-Security-是如何完成身份认证的？" class="headerlink" title="Spring Security 是如何完成身份认证的？"></a>Spring Security 是如何完成身份认证的？</h4><p>1 用户名和密码被过滤器获取到，封装成 <code>Authentication</code>, 通常情况下是 <code>UsernamePasswordAuthenticationToken</code> 这个实现类。</p><p>2 <code>AuthenticationManager</code> 身份管理器负责验证这个 <code>Authentication</code>;</p><p>3 认证成功后，<code>AuthenticationManager</code> 身份管理器返回一个被填充满了信息的（包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除）<code>Authentication</code> 实例。</p><p>4 <code>SecurityContextHolder</code> 安全上下文容器将第 3 步填充了信息的 <code>Authentication</code>，通过 SecurityContextHolder.getContext().setAuthentication(…) 方法，设置到其中。</p><p>这是一个抽象的认证流程，而整个过程中，如果不纠结于细节，其实只剩下一个 <code>AuthenticationManager</code> 是我们没有接触过的了，这个身份管理器我们在后面的小节介绍。将上述的流程转换成代码，便是如下的流程：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthenticationExample</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AuthenticationManager am = <span class="hljs-keyword">new</span> SampleAuthenticationManager();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        BufferedReader in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            System.out.println(<span class="hljs-string">"Please enter your username:"</span>);            String name = in.readLine();            System.out.println(<span class="hljs-string">"Please enter your password:"</span>);            String password = in.readLine();            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//将用户的用户名和密码封装成Authentication</span>                Authentication request = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(name, password);                <span class="hljs-comment">//交给AuthenticationManager去验证，如果验证成功就返回一个被填充了信息的Authentication实例(此时用户密码已擦除)</span>                Authentication result = am.authenticate(request);                <span class="hljs-comment">//SecurityContextHolder将填充了信息的authentication设置到其中</span>                SecurityContextHolder.getContext().setAuthentication(result);                <span class="hljs-keyword">break</span>;            &#125; <span class="hljs-keyword">catch</span>(AuthenticationException e) &#123;                System.out.println(<span class="hljs-string">"Authentication failed:"</span> + e.getMessage());            &#125;        &#125;        System.out.println(<span class="hljs-string">"Successfully authenticated. Security context contains:"</span> +                SecurityContextHolder.getContext().getAuthentication());    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleAuthenticationManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationManager</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;GrantedAuthority&gt; AUTHORITIES = <span class="hljs-keyword">new</span> ArrayList&lt;GrantedAuthority&gt;();    <span class="hljs-keyword">static</span> &#123;        AUTHORITIES.add(<span class="hljs-keyword">new</span> SimpleGrantedAuthority(<span class="hljs-string">"ROLE_USER"</span>));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication auth)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        <span class="hljs-keyword">if</span> (auth.getName().equals(auth.getCredentials())) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(auth.getName(),            auth.getCredentials(), AUTHORITIES);        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">"Bad Credentials"</span>);    &#125;&#125;</code></pre></div><p>注意：上述这段代码只是为了让大家了解 Spring Security 的工作流程而写的，不是什么源码。在实际使用中，整个流程会变得更加的复杂，但是基本思想，和上述代码如出一辙。</p><h3 id="1-3-AuthenticationManager"><a href="#1-3-AuthenticationManager" class="headerlink" title="1.3 AuthenticationManager"></a>1.3 AuthenticationManager</h3><p>​       初次接触 Spring Security 的朋友相信会被 <code>AuthenticationManager</code>，<code>ProviderManager</code> ，<code>AuthenticationProvider</code> … 这么多相似的 Spring 认证类搞得晕头转向，但只要稍微梳理一下就可以理解清楚它们的联系和设计者的用意。AuthenticationManager（接口）是认证相关的核心接口，也是发起认证的出发点，因为在实际需求中，我们可能会允许用户使用用户名 + 密码登录，同时允许用户使用邮箱 + 密码，手机号码 + 密码登录，甚至，可能允许用户使用指纹登录（还有这样的操作？没想到吧），所以说 <code>AuthenticationManager</code> 一般不直接认证，AuthenticationManager 接口的常用实现类 <code>ProviderManager</code> 内部会维护一个 <code>List&lt;AuthenticationProvider&gt;</code> 列表，存放多种认证方式，实际上这是委托者模式的应用（Delegate）。也就是说，核心的认证入口始终只有一个：AuthenticationManager，不同的认证方式：用户名 + 密码（UsernamePasswordAuthenticationToken），邮箱 + 密码，手机号码 + 密码登录则对应了三个 AuthenticationProvider。这样一来四不四就好理解多了？熟悉 shiro 的朋友可以把 <code>AuthenticationProvider</code> 理解成 Realm。在默认策略下，只需要通过一个 AuthenticationProvider 的认证，即可被认为是登录成功。</p><p>只保留了关键认证部分的 ProviderManager 源码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProviderManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationManager</span>, <span class="hljs-title">MessageSourceAware</span>,</span><span class="hljs-class"><span class="hljs-title">InitializingBean</span> </span>&#123;    <span class="hljs-comment">// 维护一个 AuthenticationProvider 列表</span>    <span class="hljs-keyword">private</span> List&lt;AuthenticationProvider&gt; providers = Collections.emptyList();              <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span><span class="hljs-function">          <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;       Class&lt;? extends Authentication&gt; toTest = authentication.getClass();       AuthenticationException lastException = <span class="hljs-keyword">null</span>;       Authentication result = <span class="hljs-keyword">null</span>;       <span class="hljs-comment">// 依次认证</span>       <span class="hljs-keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;          <span class="hljs-keyword">if</span> (!provider.supports(toTest)) &#123;             <span class="hljs-keyword">continue</span>;          &#125;          <span class="hljs-keyword">try</span> &#123;             result = provider.authenticate(authentication);             <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;                copyDetails(authentication, result);                <span class="hljs-keyword">break</span>;             &#125;          &#125;          ...          <span class="hljs-keyword">catch</span> (AuthenticationException e) &#123;             lastException = e;          &#125;       &#125;       <span class="hljs-comment">// 如果有 Authentication 信息，则直接返回</span>       <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (eraseCredentialsAfterAuthentication&amp;&amp; (result <span class="hljs-keyword">instanceof</span> CredentialsContainer)) &#123;               <span class="hljs-comment">// 移除密码</span>((CredentialsContainer) result).eraseCredentials();&#125;             <span class="hljs-comment">// 发布登录成功事件</span>eventPublisher.publishAuthenticationSuccess(result);<span class="hljs-keyword">return</span> result;   &#125;   ...       <span class="hljs-comment">// 执行到此，说明没有认证成功，包装异常信息</span>       <span class="hljs-keyword">if</span> (lastException == <span class="hljs-keyword">null</span>) &#123;          lastException = <span class="hljs-keyword">new</span> ProviderNotFoundException(messages.getMessage(                <span class="hljs-string">"ProviderManager.providerNotFound"</span>,                <span class="hljs-keyword">new</span> Object[] &#123; toTest.getName() &#125;,                <span class="hljs-string">"No AuthenticationProvider found for &#123;0&#125;"</span>));       &#125;       prepareException(lastException, authentication);       <span class="hljs-keyword">throw</span> lastException;    &#125;&#125;</code></pre></div><p><code>ProviderManager</code> 中的 List，会依照次序去认证，认证成功则立即返回，若认证失败则返回 null，下一个 AuthenticationProvider 会继续尝试认证，如果所有认证器都无法认证成功，则 <code>ProviderManager</code> 会抛出一个 ProviderNotFoundException 异常。</p><p>到这里，如果不纠结于 AuthenticationProvider 的实现细节以及安全相关的过滤器，认证相关的核心类其实都已经介绍完毕了：身份信息的存放容器 SecurityContextHolder，身份信息的抽象 Authentication，身份认证器 AuthenticationManager 及其认证流程。姑且在这里做一个分隔线。下面来介绍下 AuthenticationProvider 接口的具体实现。</p><h3 id="1-4-DaoAuthenticationProvider"><a href="#1-4-DaoAuthenticationProvider" class="headerlink" title="1.4 DaoAuthenticationProvider"></a>1.4 DaoAuthenticationProvider</h3><p>AuthenticationProvider 最最最常用的一个实现便是 DaoAuthenticationProvider。顾名思义，Dao 正是数据访问层的缩写，也暗示了这个身份认证器的实现思路。由于本文是一个 Overview，姑且只给出其 UML 类图：</p><p><img src="https://kirito.iocoder.cn/QQ%E5%9B%BE%E7%89%8720170919204228.png" srcset="/img/loading.gif" alt="DaoAuthenticationProvider UML"></p><p>​                                                                                DaoAuthenticationProvider UML</p><p>​       按照我们最直观的思路，怎么去认证一个用户呢？用户前台提交了用户名和密码，而数据库中保存了用户名和密码，认证便是负责比对同一个用户名，提交的密码和保存的密码是否相同便是了。在 Spring Security 中。提交的用户名和密码，被封装成了 UsernamePasswordAuthenticationToken，而根据用户名加载用户的任务则是交给了 UserDetailsService，在 DaoAuthenticationProvider 中，对应的方法便是 retrieveUser，虽然有两个参数，但是 retrieveUser 只有第一个参数起主要作用，返回一个 UserDetails。还需要完成 UsernamePasswordAuthenticationToken 和 UserDetails 密码的比对，这便是交给 additionalAuthenticationChecks 方法完成的，如果这个 void 方法没有抛异常，则认为比对成功。比对密码的过程，用到了 PasswordEncoder 和 SaltSource，密码加密和盐的概念相信不用我赘述了，它们为保障安全而设计，都是比较基础的概念。</p><p>如果你已经被这些概念搞得晕头转向了，不妨这么理解 DaoAuthenticationProvider：它获取用户提交的用户名和密码，比对其正确性，如果正确，返回一个数据库中的用户信息（假设用户信息被保存在数据库中）。</p><h3 id="1-5-UserDetails-与-UserDetailsService"><a href="#1-5-UserDetails-与-UserDetailsService" class="headerlink" title="1.5 UserDetails 与 UserDetailsService"></a>1.5 UserDetails 与 UserDetailsService</h3><p>上面不断提到了 UserDetails 这个接口，它代表了最详细的用户信息，这个接口涵盖了一些必要的用户信息字段，具体的实现类对它进行了扩展。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDetails</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span> </span>&#123;   Collection&lt;? extends GrantedAuthority&gt; getAuthorities();   <span class="hljs-function">String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span></span>;   <span class="hljs-function">String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span></span>;   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonExpired</span><span class="hljs-params">()</span></span>;   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonLocked</span><span class="hljs-params">()</span></span>;   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCredentialsNonExpired</span><span class="hljs-params">()</span></span>;   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>它和 Authentication 接口很类似，比如它们都拥有 username，authorities，区分他们也是本文的重点内容之一。Authentication 的 getCredentials()与 UserDetails 中的 getPassword() 需要被区分对待，前者是用户提交的密码凭证，后者是用户正确的密码，认证器其实就是对这两者的比对。Authentication 中的 getAuthorities()实际是由 UserDetails 的 getAuthorities() 传递而形成的。还记得 Authentication 接口中的 getUserDetails() 方法吗？其中的 UserDetails 用户详细信息便是经过了 AuthenticationProvider 之后被填充的。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;   <span class="hljs-function">UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException</span>;&#125;</code></pre></div><p>UserDetailsService 和 AuthenticationProvider 两者的职责常常被人们搞混，关于他们的问题在文档的 FAQ 和 issues 中屡见不鲜。记住一点即可，敲黑板！！！<strong>UserDetailsService 只负责从特定的地方（通常是数据库）加载用户信息</strong>，仅此而已，记住这一点，可以避免走很多弯路。UserDetailsService 常见的实现类有 JdbcDaoImpl，InMemoryUserDetailsManager，前者从数据库加载用户，后者从内存中加载用户，也可以自己实现 UserDetailsService，通常这更加灵活。</p><h3 id="1-6-架构概览图"><a href="#1-6-架构概览图" class="headerlink" title="1.6 架构概览图"></a>1.6 架构概览图</h3><p>为了更加形象的理解上述我介绍的这些核心类，附上一张按照我的理解，所画出 Spring Security 的一张非典型的 UML 图</p><p><img src="https://kirito.iocoder.cn/spring%20security%20architecture.png" srcset="/img/loading.gif" alt="架构概览图"></p><center>架构概览图</center><p>如果对 Spring Security 的这些概念感到理解困难，不用担心，因为这是 Architecture First 导致的必然结果，先过个眼熟。后续的文章会秉持 Code First 的理念，陆续详细地讲解这些实现类的使用场景，源码分析，以及最基本的：如何配置 Spring Security，在后面的文章中可以不时翻看这篇文章，找到具体的类在整个架构中所处的位置，这也是本篇文章的定位。另外，一些 Spring Security 的过滤器还未囊括在架构概览中，如将表单信息包装成 UsernamePasswordAuthenticationToken 的过滤器，考虑到这些虽然也是架构的一部分，但是真正重写他们的可能性较小，所以打算放到后面的章节讲解。</p>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux入门</title>
    <link href="/2020/08/18/Linux%E5%85%A5%E9%97%A8/"/>
    <url>/2020/08/18/Linux%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一、常用操作以及概念"><a href="#一、常用操作以及概念" class="headerlink" title="一、常用操作以及概念"></a>一、常用操作以及概念</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>Tab：命令和文件名补全；</li><li>Ctrl+C：中断正在运行的程序；</li><li>Ctrl+D：结束键盘输入</li></ul><h2 id="求助"><a href="#求助" class="headerlink" title="求助"></a>求助</h2><h3 id="1-help"><a href="#1-help" class="headerlink" title="1. help"></a>1. help</h3><p>指令的基本用法与选项介绍</p><h3 id="2-man"><a href="#2-man" class="headerlink" title="2. man"></a>2. man</h3><p>man是manual的缩写，将指令的具体信息显示出来，当执行man date时，有DATE(1)出现，其中的数字代表指令的类型，常用的数字及其类型如下：<br><img src="https://img-blog.csdnimg.cn/20200818171226705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="3-info"><a href="#3-info" class="headerlink" title="3. info"></a>3. info</h3><p>info与man类似，但info将文档分成一个个页面，每个页面可以进行跳转。</p><h3 id="4-doc"><a href="#4-doc" class="headerlink" title="4. doc"></a>4. doc</h3><p><code>/usr/share/doc</code>存放着软件的一整套说明文件。</p><h2 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h2><h3 id="1-who"><a href="#1-who" class="headerlink" title="1. who"></a>1. who</h3><p>在关机前需要先使用who命令查看有没有其他用户在线。</p><h3 id="2-sync"><a href="#2-sync" class="headerlink" title="2. sync"></a>2. sync</h3><p>为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘，因此关机之前需要先进行sync同步操作。</p><h3 id="3-shutdown"><a href="#3-shutdown" class="headerlink" title="3. shutdown"></a>3. shutdown</h3><ul><li>-k：不会关机，只是发送警告信息，通知所有在线的用户；</li><li>-r：将系统的服务停掉后就重新启动；</li><li>-h：将系统的服务停掉后就立即关机；</li><li>-c：取消已经在进行的shutdown指令内容。</li></ul><h2 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a>PATH</h2><p>可以在环境变量 PATH 中声明可执行文件的路径，路径之间用<code>:</code> 分隔。</p><h2 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h2><p>sudo 允许一般用户使用 root 可执行的命令，不过只有在<code>/etc/sudoers</code>配置文件中添加的用户才能使用该指令。 </p><h2 id="Vim三个模式"><a href="#Vim三个模式" class="headerlink" title="Vim三个模式"></a>Vim三个模式</h2><ul><li>一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容； </li><li>编辑模式（Insert mode）：按下<code>i</code>等按键之后进入，可以对文本进行编辑； </li><li>指令列模式（Bottom-line mode）：按下<code>:</code>按键之后进入，用于保存退出等操作。</li></ul><p>在指令列模式下，有以下命令用于离开或者保存文件。<br><img src="https://img-blog.csdnimg.cn/20200818173232109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="二、文件"><a href="#二、文件" class="headerlink" title="二、文件"></a>二、文件</h1><h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><p>用户分为三种：文件拥有者、群组以及其他用户，对不同的用户有不同的文件权限。<br>使用<code>IS</code>查看一个文件时，会显示一个文件的信息，例如：<code>drwxr-xr-x 3 root root 17 May 6 00:14 .config</code> ，对这个信息的解释如下：</p><ul><li>drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段 </li><li>3：链接数 </li><li>root：文件拥有者 </li><li>root：所属群组 </li><li>17：文件大小 </li><li>May 6 00:14：文件后被修改的时间 </li><li>.conﬁg：文件名</li></ul><p>常见的文件类型及其含义有：</p><ul><li>d：目录</li><li>-：文件</li><li>l：链接文件</li></ul><p>9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它用户的文件权限。 一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。<br>文件时间有以下三种：</p><ul><li>modiﬁcation time (mtime)：文件的内容更新就会更新； </li><li>status time (ctime)：文件的状态（权限、属性）更新就会更新；</li><li>access time (atime)：读取文件时就会更新。</li></ul><h2 id="文件与目录的基本操作"><a href="#文件与目录的基本操作" class="headerlink" title="文件与目录的基本操作"></a>文件与目录的基本操作</h2><h3 id="1-Is：列出文件或目录的信息，目录的信息就是其中包含的文件。"><a href="#1-Is：列出文件或目录的信息，目录的信息就是其中包含的文件。" class="headerlink" title="1. Is：列出文件或目录的信息，目录的信息就是其中包含的文件。"></a>1. Is：列出文件或目录的信息，目录的信息就是其中包含的文件。</h3><ul><li>-a：列出全部的文件</li><li>-d：仅列出目录本身</li><li>-l：以长数据串列出，包含文件的属性与权限等数据</li></ul><h3 id="2-cd：更换当前目录"><a href="#2-cd：更换当前目录" class="headerlink" title="2. cd：更换当前目录"></a>2. cd：更换当前目录</h3><h3 id="3-mkdir：创建目录"><a href="#3-mkdir：创建目录" class="headerlink" title="3. mkdir：创建目录"></a>3. mkdir：创建目录</h3><ul><li>-m：配置目录权限</li><li>-p：递归创建目录</li></ul><h3 id="4-rmdir：删除目录，目录必须为空"><a href="#4-rmdir：删除目录，目录必须为空" class="headerlink" title="4. rmdir：删除目录，目录必须为空"></a>4. rmdir：删除目录，目录必须为空</h3><ul><li>-p：递归删除目录</li></ul><h3 id="5-touch：更新文件时间或建立新文件"><a href="#5-touch：更新文件时间或建立新文件" class="headerlink" title="5. touch：更新文件时间或建立新文件"></a>5. touch：更新文件时间或建立新文件</h3><ul><li>-a ： 更新 atime </li><li>-c ： 更新 ctime，若该文件不存在则不建立新文件 </li><li>-m ： 更新 mtime </li><li>-d ： 后面可以接更新日期而不使用当前日期，也可以使用 –date=”日期或时间” </li><li>-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm] </li></ul><h3 id="6-cp：复制文件"><a href="#6-cp：复制文件" class="headerlink" title="6. cp：复制文件"></a>6. cp：复制文件</h3><p>如果源文件有两个以上，则目的文件一定要是目录才行</p><ul><li>-a ：相当于 -dr –preserve=all 的意思，至于 dr 请参考下列说明 </li><li>-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身 </li><li>-i ：若目标文件已经存在时，在覆盖前会先询问 </li><li>-p ：连同文件的属性一起复制过去 </li><li>-r ：递归持续复制 </li><li>-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制</li><li>–preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了 </li></ul><h3 id="7-rm-：删除文件。"><a href="#7-rm-：删除文件。" class="headerlink" title="7. rm ：删除文件。"></a>7. rm ：删除文件。</h3><ul><li>-r ：递归删除 <h3 id="8-mv-：移动文件。"><a href="#8-mv-：移动文件。" class="headerlink" title="8. mv ：移动文件。"></a>8. mv ：移动文件。</h3></li><li># mv [-fiu] source destination </li><li># mv [options] source1 source2 source3 …. directory </li><li>-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖</li></ul><h3 id="9-两台Linux服务器相互拷贝文件"><a href="#9-两台Linux服务器相互拷贝文件" class="headerlink" title="9.两台Linux服务器相互拷贝文件"></a>9.两台Linux服务器相互拷贝文件</h3><div class="hljs"><pre><code class="hljs linux">scp[参数][原路径][目标路径]</code></pre></div><p>scp是secure copy的缩写，scp是linux系统下基于ssh登录进行安全的远程文件拷贝命令。</p><p>参数有：</p><ul><li>-1：强制scp命令使用协议ssh1</li><li>-2：强制scp命令使用协议ssh2</li><li>-4：强制scp命令只使用ipv4寻址</li><li>-6：强制scp命令只使用ipv6寻址</li><li>-B  使用批处理模式（传输过程中不询问传输口令或短语）  </li><li>-C  允许压缩。（将-C标志传递给ssh，从而打开压缩功能）  </li><li>-p 保留原文件的修改时间，访问时间和访问权限。 </li><li>-q  不显示传输进度条。  </li><li>-r  递归复制整个目录。  </li><li>-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。   </li></ul><h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><p>可以将一组权限用数字来表示，此时一组权限的3个位当做二进制数字的位，从左到右每个位的权值为4、2、1，即每个权限对应的数字权值为r：4，w：2，x：1。<br>示例：将 .bashrc 文件的权限修改为 -rwx-xr-r-。 </p><div class="hljs"><pre><code class="hljs shell">chmod 754 .bashrc</code></pre></div><p>也可以使用符号来设定权限。</p><ul><li>u：拥有者 </li><li>g：所属群组 </li><li>o：其他人 </li><li>a：所有人 </li><li>+：添加权限 </li><li>-：移除权限 </li><li>=：设定权限 </li></ul><p>示例：为 .bashrc 文件的所有用户添加写权限。</p><div class="hljs"><pre><code class="hljs shell">chmod a+w .bashrc</code></pre></div><h2 id="文件默认权限"><a href="#文件默认权限" class="headerlink" title="文件默认权限"></a>文件默认权限</h2><p>文件默认是没有可执行权限，因此为666，目录必须要能够进入，也就是必须拥有可执行权限，因此为777。</p><h2 id="获取文件内容"><a href="#获取文件内容" class="headerlink" title="获取文件内容"></a>获取文件内容</h2><ul><li>cat：取得文件内容</li><li>tac：是cat的反向操作，从后一行开始打印</li><li>more：它可以一页一页查看文件内容，比较适合大文件的查看</li><li>less：和more类似，但是多了一个向前翻页的功能</li><li>head：取得文件前几页</li><li>tail：是head的反向操作，只是取得的是后几行</li><li>od：以字符或者十六进制的形式显示二进制文件 </li></ul><h1 id="六、压缩与打包"><a href="#六、压缩与打包" class="headerlink" title="六、压缩与打包"></a>六、压缩与打包</h1><h2 id="压缩文件名"><a href="#压缩文件名" class="headerlink" title="压缩文件名"></a>压缩文件名</h2><p>Linux 底下有很多压缩文件名，常见的如下：<br><img src="https://img-blog.csdnimg.cn/20200818193707681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="压缩指令"><a href="#压缩指令" class="headerlink" title="压缩指令"></a>压缩指令</h2><h3 id="1-gzip"><a href="#1-gzip" class="headerlink" title="1. gzip"></a>1. gzip</h3><p>gzip 是 Linux 使用广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。<br>经过 gzip 压缩过，源文件就不存在了。 有 9 个不同的压缩等级可以使用。 可以使用 zcat、zmore、zless 来读取压缩文件的内容。</p><ul><li>$ gzip [-cdtv#] filename</li><li>-c ：将压缩的数据输出到屏幕上 </li><li>-d ：解压缩 -t ：检验压缩文件是否出错 </li><li>-v ：显示压缩比等信息 </li><li>-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6 <h3 id="2-bzip2"><a href="#2-bzip2" class="headerlink" title="2. bzip2"></a>2. bzip2</h3>提供比 gzip 更高的压缩比。 查看命令：bzcat、bzmore、bzless、bzgrep。</li><li>$ bzip2 [-cdkzv#] filename</li><li>-k ：保留源文件</li></ul><h3 id="3-xz"><a href="#3-xz" class="headerlink" title="3. xz"></a>3. xz</h3><p>提供比 bzip2 更佳的压缩比。<br>可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，<strong>压缩比越高，压缩的时间也越长</strong>。 查看命令：xzcat、xzmore、xzless、xzgrep。</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> xz [-dtlkc<span class="hljs-comment">#] filename</span></span></code></pre></div><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。</p><ul><li>$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename…  ==打包压缩</li><li>$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件]              ==查看</li><li>$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录]    ==解压缩</li><li>-z ：使用 zip；</li><li>-j ：使用 bzip2；</li><li>-J ：使用 xz；</li><li>-c ：新建打包文件；</li><li>-t ：查看打包文件里面有哪些文件；</li><li>-x ：解打包或解压缩的功能；</li><li>-v ：在压缩/解压缩的过程中，显示正在处理的文件名；</li><li>-f : filename：要处理的文件；</li><li>-C 目录 ： 在特定目录解压缩。<br><img src="https://img-blog.csdnimg.cn/2020081819505488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><h1 id="七、正则表达式"><a href="#七、正则表达式" class="headerlink" title="七、正则表达式"></a>七、正则表达式</h1><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2>grep（globally search a regular expression and print)，使用正则表示式进行全局查找并打印。<ul><li>$ grep [-acinv] [–color=auto] 搜寻字符串 filename </li><li>-c ： 统计个数 </li><li>-i ： 忽略大小写</li><li>-n ： 输出行号 </li><li>-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行 </li><li>–color=auto ：找到的关键字加颜色显示 </li></ul></li></ul><p>示例：把含有 the 字符串的行提取出来（注意默认会有 –color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串）</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> grep -n <span class="hljs-string">'the'</span> regular_express.txt </span>8:I can't finish the test. 12:the symbol '*' is represented as start. 15:You are the best is mean you are the no. 1. 16:The world Happy is the same with "glad". 18:google is the best tools for search keyword</code></pre></div><p>因为<code>{</code> 和 <code>}</code>在 shell 是有特殊意义的，因此必须要使用转义字符进行转义。</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> grep -n <span class="hljs-string">'go\&#123;2,5\&#125;g'</span> regular_express.txt</span></code></pre></div><h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><p>用于格式化输出。它不属于管道命令，在给 printf 传数据时需要使用<code>$( )</code> 形式。</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">printf</span> <span class="hljs-string">'%10s %5i %5i %5i %8.2f \n'</span> $(cat printf.txt)     </span>DmTsai    80    60    92    77.33     VBird    75    55    80    70.00        Ken    60    90    70    73.33</code></pre></div><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>是由 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 创造，awk 这个名字就是这三个创始人名字的首字母。 awk 每次处理一行，处理的小单位是字段，每个字段的命名方式为：$n，n 为字段号，从 1 开始，$0 表示一整行。<br>示例：取出近五个登录用户的用户名和 IP</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> last -n 5 </span>dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22) dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12) dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14) dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15)</code></pre></div><div class="hljs"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> last <span class="hljs-literal">-n</span> <span class="hljs-number">5</span> | awk <span class="hljs-string">'&#123;print $1 "\t" $3&#125;'</span></code></pre></div><p>可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据。<br>$ awk ‘条件类型 1 {动作 1} 条件类型 2 {动作 2} …’ filename<br>示例：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。</p><div class="hljs"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> cat /etc/passwd | awk <span class="hljs-string">'BEGIN &#123;FS=":"&#125; $3 &lt; 10 &#123;print $1 "\t " $3&#125;'</span> root <span class="hljs-number">0</span> bin <span class="hljs-number">1</span> daemon <span class="hljs-number">2</span></code></pre></div><p>awk 变量：<img src="https://img-blog.csdnimg.cn/20200818200447426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>示例：显示正在处理的行号以及每一行有多少字段</p><div class="hljs"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> last <span class="hljs-literal">-n</span> <span class="hljs-number">5</span> | awk <span class="hljs-string">'&#123;print $1 "\t lines: " NR "\t columns: " NF&#125;'</span> dmtsai lines: <span class="hljs-number">1</span> columns: <span class="hljs-number">10</span> dmtsai lines: <span class="hljs-number">2</span> columns: <span class="hljs-number">10</span> dmtsai lines: <span class="hljs-number">3</span> columns: <span class="hljs-number">10</span> dmtsai lines: <span class="hljs-number">4</span> columns: <span class="hljs-number">10</span> dmtsai lines: <span class="hljs-number">5</span> columns: <span class="hljs-number">9</span></code></pre></div><h1 id="八、进程管理"><a href="#八、进程管理" class="headerlink" title="八、进程管理"></a>八、进程管理</h1><h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><h3 id="1-ps"><a href="#1-ps" class="headerlink" title="1. ps"></a>1. ps</h3><p>查看某个时间点的进程信息<br>示例一：查看自己的进程</p><div class="hljs"><pre><code class="hljs powershell"><span class="hljs-comment"># ps -l</span></code></pre></div><p>示例二：查看系统所有进程</p><div class="hljs"><pre><code class="hljs powershell"><span class="hljs-comment"># ps aux</span></code></pre></div><p>示例三：查看特定的进程</p><div class="hljs"><pre><code class="hljs powershell"><span class="hljs-comment"># ps aux | grep threadx</span></code></pre></div><h3 id="2-pstree"><a href="#2-pstree" class="headerlink" title="2. pstree"></a>2. pstree</h3><p>查看进程树<br>示例：查看所有进程树</p><div class="hljs"><pre><code class="hljs powershell"><span class="hljs-comment"># pstree -A</span></code></pre></div><h3 id="3-top"><a href="#3-top" class="headerlink" title="3. top"></a>3. top</h3><p>实时显示进程信息<br>示例：两秒钟刷新一次</p><div class="hljs"><pre><code class="hljs powershell"><span class="hljs-comment"># top -d 2</span></code></pre></div><h3 id="4-netstat"><a href="#4-netstat" class="headerlink" title="4. netstat"></a>4. netstat</h3><p>查看占用端口的进程<br>示例：查看特定端口的进程</p><div class="hljs"><pre><code class="hljs powershell"><span class="hljs-comment"># netstat -anp | grep port</span></code></pre></div><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态 "></a>进程状态 <img src="https://img-blog.csdnimg.cn/20200818201750770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></h2><h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。<br>孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。<br>由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。 </p><h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会 释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这 种进程称之为僵尸进程。<br>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。<br>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。<br>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养， 这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。 </p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL优化</title>
    <link href="/2020/08/18/MySQL%E4%BC%98%E5%8C%96/"/>
    <url>/2020/08/18/MySQL%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="为什么要优化"><a href="#为什么要优化" class="headerlink" title="为什么要优化"></a>为什么要优化</h2><ul><li>系统的吞吐量瓶颈往往出现在数据库的访问速度上；</li><li>随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢；</li><li>数据是存放在磁盘上的，读写速度无法和内存相比。</li></ul><h1 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h1><ul><li>设计数据库时：数据库表、字段的设计，存储引擎</li><li>利用好MySQL自身提供的功能，如索引等</li><li>横向扩展：MySQL集群、负载均衡、读写分离</li><li>SQL语句的优化（收效甚微）</li></ul><h1 id="2、字段设计"><a href="#2、字段设计" class="headerlink" title="2、字段设计"></a>2、字段设计</h1><ul><li>尽量使用整型表示字符串；</li><li>尽可能选择小的数据类型和指定短的长度；</li><li>对于金额等使用定点数decimal，不会出现精度问题；</li><li>字段注释要完整，见名知意；</li><li>单表字段不宜过多；</li><li>尽可能使用not null，因为非null字段的处理要比null字段的处理高效些！且不需要判断是否为null。</li><li>可以预留字段，以满足业务需要。</li></ul><h1 id="3、存储引擎的选择"><a href="#3、存储引擎的选择" class="headerlink" title="3、存储引擎的选择"></a>3、存储引擎的选择</h1><h2 id="存储差异"><a href="#存储差异" class="headerlink" title="存储差异"></a>存储差异</h2><table><thead><tr><th></th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>文件格式</td><td>数据和索引是分别存储的，数据.MYD，索引.MYI</td><td>数据和索引是集中存储的，.ibd</td></tr><tr><td>文件能否移动</td><td>能，一张表就对应.frm、MYD、MYI3个文件</td><td>否，因为关联的还有data下的其它文件</td></tr><tr><td>记录存储顺序</td><td>按记录插入顺序保存</td><td>按主键大小有序插入</td></tr><tr><td>空间碎片（删除记录并flush table 表名之后，表文件大小不变）</td><td>产生。定时整理：使用命令optimize table 表名实现</td><td>不产生</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的）</td><td>表级锁定</td><td>行级锁定、表级锁定，锁定粒度小并发能力高</td></tr></tbody></table><h2 id="选择依据"><a href="#选择依据" class="headerlink" title="选择依据"></a>选择依据</h2><ul><li>默认使用InnoDB；</li><li>MyISAM：以读写插入为主的应用程序，比如博客系统，新闻门户网站；</li><li>InnoDB：更新（删除）操作频繁，或者要保证数据的完整性；并发量高，支持事务和外键保证数据完整性，比如：OA自动化办公系统。</li></ul><h1 id="4、索引"><a href="#4、索引" class="headerlink" title="4、索引"></a>4、索引</h1><h2 id="索引为什么这么快"><a href="#索引为什么这么快" class="headerlink" title="索引为什么这么快"></a>索引为什么这么快</h2><ul><li>关键字相对数据本身，数据量小；</li><li>关键字是有序的，二分查找可快速确定位置</li></ul><h2 id="MySQL中的索引类型："><a href="#MySQL中的索引类型：" class="headerlink" title="MySQL中的索引类型："></a>MySQL中的索引类型：</h2><ul><li>普通索引：对关键字没有限制；</li><li>唯一索引：要求记录提供的关键字不能重复；</li><li>主键索引：要求关键字唯一且不为null<h2 id="执行计划explain"><a href="#执行计划explain" class="headerlink" title="执行计划explain"></a>执行计划explain</h2>通过explain select 来分析SQL语句执行前的执行计划。<br><img src="https://img-blog.csdnimg.cn/2020081816101547.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>由上图可看出此SQL语句是按照主键索引来检索的。<br>执行计划是：当执行SQL语句时，首先会分析、优化，形成执行计划，再按照执行计划执行。</li></ul><h2 id="索引使用场景（重点）"><a href="#索引使用场景（重点）" class="headerlink" title="索引使用场景（重点）"></a>索引使用场景（重点）</h2><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p><img src="https://img-blog.csdnimg.cn/20200818160615496.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>上图中，根据id查询记录，因为id字段仅建立了主键索引，因此此SQL执行可选的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">-- 增加一个没有建立索引的字段</span><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> innodb1 <span class="hljs-keyword">add</span> sex <span class="hljs-built_in">char</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">-- 按sex检索时可选的索引为null</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">from</span> innodb1 <span class="hljs-keyword">where</span> sex=<span class="hljs-string">'男'</span>;</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200818160730280.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引（alter table 表名 add index(字段名)），同样的SQL执行的效率，你会发现查询效率会有明显的提升（数据量越大越明显）。</p><h3 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h3><p>当我们使用order by将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。</p><p>但是如果我们对该字段建立索引<code>alter table 表名 add index(字段名)</code>，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用取出索引表某个范围内的索引对应的数据，而不用像上述那取出所有数据进行排序再返回某个范围内的数据。</p><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>对join语句匹配关系（on）涉及的字段建立索引能够提高效率;</p><h2 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h2><p>如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能地在select后==只写必要的查询字段==，以增加索引覆盖的几率。<br>这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。</p><h2 id="如何创建索引"><a href="#如何创建索引" class="headerlink" title="如何创建索引"></a>如何创建索引</h2><ul><li>建立基础索引：在where、order by、join字段上建立索引。</li><li>优化，组合索引：基于业务逻辑</li><li>如果条件经常性出现在一起，那么可以考虑将多字段索引升级为==复合索引==</li><li>如果通过增加个别字段的索引，就可以出现==索引覆盖==，那么可以考虑为该字段建立索引</li><li>查询时，不常用到的索引，应该删除掉</li></ul><h1 id="5、分区"><a href="#5、分区" class="headerlink" title="5、分区"></a>5、分区</h1><p>一般情况下我们创建的表对应一组存储文件，使用MyISAM存储引擎时是一个.MYI和.MYD文件，使用Innodb存储引擎时是一个.ibd和.frm（表结构）文件。<br>当数据量较大时（一般千万条记录级别以上），MySQL的性能就会开始下降，这时我们就需要将数据分散到多组存储文件，==保证其单个文件的执行效率==。<br>最常见的分区方案是按id分区，如下将id的哈希值对10取模将数据均匀分散到10个.ibd存储文件中：</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> article(   <span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> auto_increment PRIMARY <span class="hljs-keyword">KEY</span>,   title <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>),   <span class="hljs-keyword">content</span> <span class="hljs-built_in">text</span>)<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">HASH</span>(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">PARTITIONS</span> <span class="hljs-number">10</span></code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200818162532687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>==服务端的表分区对于客户端是透明的==，客户端还是照常插入数据，但服务端会按照分区算法分散存储数据。</p><h2 id="MySQL提供的分区算法"><a href="#MySQL提供的分区算法" class="headerlink" title="MySQL提供的分区算法"></a>MySQL提供的分区算法</h2><p>==分区依据的字段必须是主键的一部分==，分区是为了快速定位数据，因此该字段的搜索频次较高应作为强检索字段，否则依照该字段分区毫无意义。</p><h3 id="hash-field"><a href="#hash-field" class="headerlink" title="hash(field)"></a>hash(field)</h3><p>相同的输入得到相同的输出。输出的结果跟输入是否具有规律无关。==仅适用于整型字段==</p><h3 id="key-field"><a href="#key-field" class="headerlink" title="key(field)"></a>key(field)</h3><p>和hash(field)的性质一样，只不过key是==处理字符串==的，比hash()多了一步从字符串中计算出一个整型在做取模操作。</p><h3 id="range算法"><a href="#range算法" class="headerlink" title="range算法"></a>range算法</h3><p>是一种==条件分区==算法，按照数据大小范围分区（将数据使用某种条件，分散到不同的分区中）。</p><h3 id="list算法"><a href="#list算法" class="headerlink" title="list算法"></a>list算法</h3><p>也是一种条件分区，按照列表值分区（in (值列表)）。</p><h2 id="分区的使用"><a href="#分区的使用" class="headerlink" title="分区的使用"></a>分区的使用</h2><p>当数据表中的数据量很大时，分区带来的效率提升才会显现出来。<br>只有检索字段为分区字段时，分区带来的效率提升才会比较明显。因此，==分区字段的选择很重要==，并且==业务逻辑要尽可能地根据分区字段做相应调整==（尽量使用分区字段作为查询条件）。</p><h1 id="6、水平分割和垂直分割"><a href="#6、水平分割和垂直分割" class="headerlink" title="6、水平分割和垂直分割"></a>6、水平分割和垂直分割</h1><p>水平分割：通过建立<strong>结构相同</strong>的几张表分别存储数据<br>垂直分割：将经常一起使用的字段放在一个单独的表中，分割后的表记录之间是一一对应关系。</p><h2 id="分表原因"><a href="#分表原因" class="headerlink" title="分表原因"></a>分表原因</h2><ul><li>为数据库减压</li><li>分区算法局限</li><li>数据库支持不完善（5.1之后mysql才支持分区操作）</li></ul><h2 id="id重复的解决方案"><a href="#id重复的解决方案" class="headerlink" title="id重复的解决方案"></a>id重复的解决方案</h2><p>借用第三方应用如memcache、redis的id自增器<br>单独建一张只包含id一个字段的表，每次自增该字段作为数据记录的id </p><h1 id="7、集群"><a href="#7、集群" class="headerlink" title="7、集群"></a>7、集群</h1><p>横向扩展：从根本上（单机的硬件处理能力有限）提升数据库性能 。由此而生的相关技术：==读写分离、负载均衡==</p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求slave不能写只能读（如果对slave执行写操作，那么show slave status将会呈现<code>Slave_SQL_Running=NO</code>，此时你需要按照前面提到的手动同步一下slave）。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>负载均衡算法</p><ul><li>轮询</li><li>加权轮询：按照处理能力来加权</li><li>负载分配：依据当前的空闲状态（但是测试每个节点的内存使用率、CPU利用率等，再做比较选出最闲的那个，效率太低）</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL语句</title>
    <link href="/2020/08/18/SQL%E8%AF%AD%E5%8F%A5/"/>
    <url>/2020/08/18/SQL%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p>模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。<br><strong>主键的值不允许修改，也不允许复用</strong>（不能使用已经删除的主键值赋给新数据行的主键）。<br>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。<br>SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。<br>SQL 支持以下三种注释：</p><ul><li># 注释</li><li>SELECT *FROM mytable; – 注释</li><li>/* 注释1<br>注释2 */</li></ul><p>数据库创建与使用：</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> <span class="hljs-keyword">test</span>;<span class="hljs-keyword">USE</span> <span class="hljs-keyword">test</span>;</code></pre></div><h1 id="二、创建表"><a href="#二、创建表" class="headerlink" title="二、创建表"></a>二、创建表</h1><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> mytable (<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,col1 <span class="hljs-built_in">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>,col2 <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">45</span>) <span class="hljs-literal">NULL</span>,col3 <span class="hljs-built_in">DATE</span> <span class="hljs-literal">NULL</span>,PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>));</code></pre></div><h1 id="三、修改表"><a href="#三、修改表" class="headerlink" title="三、修改表"></a>三、修改表</h1><p>添加列</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> mytable<span class="hljs-keyword">ADD</span> <span class="hljs-keyword">col</span> <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">20</span>);</code></pre></div><p>删除列</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> mytable<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-keyword">col</span>;</code></pre></div><p>删除表</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> mytable;</code></pre></div><h1 id="四、插入"><a href="#四、插入" class="headerlink" title="四、插入"></a>四、插入</h1><p>普通插入</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> mytable(col1, col2)<span class="hljs-keyword">VALUES</span>(val1, val2);</code></pre></div><p>插入检索出来的数据</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> mytable1(col1, col2)<span class="hljs-keyword">SELECT</span> col1, col2<span class="hljs-keyword">FROM</span> mytable2;</code></pre></div><p>将一个表的内容插入到一个新表</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> newtable <span class="hljs-keyword">AS</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> mytable;</code></pre></div><h1 id="五、更新"><a href="#五、更新" class="headerlink" title="五、更新"></a>五、更新</h1><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> mytable<span class="hljs-keyword">SET</span> <span class="hljs-keyword">col</span> = val<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">1</span>;</code></pre></div><h1 id="六、删除"><a href="#六、删除" class="headerlink" title="六、删除"></a>六、删除</h1><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> mytable<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">1</span>;</code></pre></div><p>TRUNCATE TABLE 可以清空表，也就是删除所有行。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> mytable;</code></pre></div><p>使用更新和删除操作时一定要用<code>WHERE</code>子句，不然会把整张表的数据都破坏。<strong>可以先用 SELECT 语句进行测试，防止错误删除。</strong></p><h1 id="七、查询"><a href="#七、查询" class="headerlink" title="七、查询"></a>七、查询</h1><p><strong>DISTINCT</strong><br>相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。<br><strong>LIMIT</strong><br>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。<br>LIMIT 0, 5;</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *<span class="hljs-keyword">FROM</span> mytable<span class="hljs-keyword">LIMIT</span> <span class="hljs-number">5</span>;<span class="hljs-keyword">SELECT</span> *<span class="hljs-keyword">FROM</span> mytable<span class="hljs-keyword">LIMIT</span> <span class="hljs-number">0</span>, <span class="hljs-number">5</span>;</code></pre></div><h1 id="八、排序"><a href="#八、排序" class="headerlink" title="八、排序"></a>八、排序</h1><ul><li>ASC：升序（默认）</li><li>DESC：降序</li></ul><p>可以按多个列进行排序，并且为每个列指定不同的排序方式：</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *<span class="hljs-keyword">FROM</span> mytable<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> col1 <span class="hljs-keyword">DESC</span>, col2 <span class="hljs-keyword">ASC</span>;</code></pre></div><h1 id="九、过滤"><a href="#九、过滤" class="headerlink" title="九、过滤"></a>九、过滤</h1><p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中，然后由客户端进行过滤。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *<span class="hljs-keyword">FROM</span> mytable<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">col</span> <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;</code></pre></div><p>下表显示了 WHERE 子句可用的操作符<br><img src="https://img-blog.csdnimg.cn/20200818101407504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>应该注意到，NULL 与 0、空字符串都不同。<br><code>AND</code>和 <code>OR</code>用于连接多个过滤条件。<strong>优先处理 AND</strong>，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用<code>()</code> 来决定优先级，使得优先级关系更清晰。<br><code>IN</code>操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。<br><code>NOT</code>操作符用于否定一个条件。</p><h1 id="十、通配符"><a href="#十、通配符" class="headerlink" title="十、通配符"></a>十、通配符</h1><p>通配符也是用在过滤语句中，但它只能用于文本字段。<br><code>%</code>匹配 &gt;=0 个任意字符；<br><code>_</code> 匹配 ==1 个任意字符；<br><code>[ ]</code>可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符<code>^</code>可以对其进行否定，也就是不匹配集合内的字符。<br>使用 <code>Like</code>来进行通配符匹配。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *<span class="hljs-keyword">FROM</span> mytable<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">col</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'[^AB]%'</span>; <span class="hljs-comment">-- 不以 A 和 B 开头的任意文本</span></code></pre></div><p>不要滥用通配符，通配符位于开头处匹配会非常慢。</p><h1 id="十一、计算字段"><a href="#十一、计算字段" class="headerlink" title="十一、计算字段"></a>十一、计算字段</h1><p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快很多，并且转换和格式化后的数据量更少的话可以减少网络通信量，计算字段通常需要使用<code>AS</code>来取别名，否则输出的时候字段名为计算表达式。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> col1 * col2 <span class="hljs-keyword">AS</span> <span class="hljs-keyword">alias</span><span class="hljs-keyword">FROM</span> mytable;</code></pre></div><p><code>CONCAT()</code>用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <code>TRIM()</code>可以去除首尾空格。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CONCAT</span>(<span class="hljs-keyword">TRIM</span>(col1), <span class="hljs-string">'('</span>, <span class="hljs-keyword">TRIM</span>(col2), <span class="hljs-string">')'</span>) <span class="hljs-keyword">AS</span> concat_col<span class="hljs-keyword">FROM</span> mytable;</code></pre></div><h1 id="十二、函数"><a href="#十二、函数" class="headerlink" title="十二、函数"></a>十二、函数</h1><p><strong>各个 DBMS 的函数都是不相同的，因此不可移植</strong>，以下主要是 MySQL 的函数。</p><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><p><img src="https://img-blog.csdnimg.cn/20200818102444510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><code>AVG()</code>会忽略 NULL 行。<br>使用 <code>DISTINCT</code> 可以让汇总函数值汇总不同的值。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">AVG</span>(<span class="hljs-keyword">DISTINCT</span> col1) <span class="hljs-keyword">AS</span> avg_col<span class="hljs-keyword">FROM</span> mytable;</code></pre></div><h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><p><img src="https://img-blog.csdnimg.cn/20200818102558138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>其中， <code>SOUNDEX()</code> 可以将一个字符串转换为描述其语音表示的字母数字模式。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *<span class="hljs-keyword">FROM</span> mytable<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">SOUNDEX</span>(col1) = <span class="hljs-keyword">SOUNDEX</span>(<span class="hljs-string">'apple'</span>)</code></pre></div><h2 id="日期和时间处理"><a href="#日期和时间处理" class="headerlink" title="日期和时间处理"></a>日期和时间处理</h2><p>日期格式：YYYY-MM-DD<br>时间格式：HH:MM:SS<br><img src="https://img-blog.csdnimg.cn/20200818102637343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs sql">mysql&gt; SELECT NOW();2018-4-14 20:25:11</code></pre></div><h2 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理<img src="https://img-blog.csdnimg.cn/20200818102704738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></h2><h1 id="十三、分组"><a href="#十三、分组" class="headerlink" title="十三、分组"></a>十三、分组</h1><p>分组就是把具有相同的数据值的行放在同一组中。<br>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。<br>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">col</span>, <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span><span class="hljs-keyword">FROM</span> mytable<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">col</span>;</code></pre></div><p><code>GROUP BY</code>自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">col</span>, <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span><span class="hljs-keyword">FROM</span> mytable<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">col</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">num</span>;</code></pre></div><p><strong>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</strong></p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">col</span>, <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span><span class="hljs-keyword">FROM</span> mytable<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">col</span> &gt; <span class="hljs-number">2</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">col</span><span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">num</span> &gt;= <span class="hljs-number">2</span>;</code></pre></div><p>分组规定：</p><ul><li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li><li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li><li>NULL 的行会单独分为一组；</li><li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li></ul><h1 id="十四、子查询"><a href="#十四、子查询" class="headerlink" title="十四、子查询"></a>十四、子查询</h1><p>子查询中只能返回一个字段的数据。<br>可以将子查询的结果作为<code>WHRER</code>语句的过滤条件：</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *<span class="hljs-keyword">FROM</span> mytable1<span class="hljs-keyword">WHERE</span> col1 <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> col2<span class="hljs-keyword">FROM</span> mytable2);</code></pre></div><p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cust_name, (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(*)                    <span class="hljs-keyword">FROM</span> Orders                    <span class="hljs-keyword">WHERE</span> Orders.cust_id = Customers.cust_id)                    <span class="hljs-keyword">AS</span> orders_num<span class="hljs-keyword">FROM</span> Customers<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cust_name;</code></pre></div><h1 id="十五、连接"><a href="#十五、连接" class="headerlink" title="十五、连接"></a>十五、连接</h1><p>连接用于连接多个表，使用<code>JOIN</code>关键字，并且条件语句使用 <code>ON</code>而不是 WHERE。<br>连接可以替换子查询，并且比子查询的效率一般会更快。<br>可以用<code>AS</code>给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p>内连接又称<strong>等值连接</strong>，使用<code>INNER JOIN</code>关键字。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> A.value, B.value<span class="hljs-keyword">FROM</span> tablea <span class="hljs-keyword">AS</span> A <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> tableb <span class="hljs-keyword">AS</span> B<span class="hljs-keyword">ON</span> A.key = B.key;</code></pre></div><p>可以不明确使用<code>INNER JOIN</code>，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> A.value, B.value<span class="hljs-keyword">FROM</span> tablea <span class="hljs-keyword">AS</span> A, tableb <span class="hljs-keyword">AS</span> B<span class="hljs-keyword">WHERE</span> A.key = B.key;</code></pre></div><p>在没有条件语句的情况下返回笛卡尔积。</p><h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><p>自连接可以看成内连接的一种，只是连接的表是自身而已。<br>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p><h3 id="子查询版本"><a href="#子查询版本" class="headerlink" title="子查询版本"></a>子查询版本</h3><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span><span class="hljs-keyword">FROM</span> employee<span class="hljs-keyword">WHERE</span> department = (<span class="hljs-keyword">SELECT</span> department<span class="hljs-keyword">FROM</span> employee<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">"Jim"</span>);</code></pre></div><h3 id="自连接版本"><a href="#自连接版本" class="headerlink" title="自连接版本"></a>自连接版本</h3><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> e1.name<span class="hljs-keyword">FROM</span> employee <span class="hljs-keyword">AS</span> e1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> employee <span class="hljs-keyword">AS</span> e2<span class="hljs-keyword">ON</span> e1.department = e2.department<span class="hljs-keyword">AND</span> e2.name = <span class="hljs-string">"Jim"</span>;</code></pre></div><h2 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h2><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。<br>内连接和自然连接的区别：<strong>内连接提供连接的列，而自然连接自动连接所有同名列。</strong></p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> A.value, B.value<span class="hljs-keyword">FROM</span> tablea <span class="hljs-keyword">AS</span> A <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">JOIN</span> tableb <span class="hljs-keyword">AS</span> B;</code></pre></div><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，<strong>左外连接就是保留左表没有关联的行。</strong><br>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Customers.cust_id, Orders.order_num<span class="hljs-keyword">FROM</span> Customers <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> Orders<span class="hljs-keyword">ON</span> Customers.cust_id = Orders.cust_id;</code></pre></div><p>customers 表：<img src="https://img-blog.csdnimg.cn/20200818105011208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>orders 表：<img src="https://img-blog.csdnimg.cn/20200818105027692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>结果：<img src="https://img-blog.csdnimg.cn/20200818105041277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="十六、组合查询"><a href="#十六、组合查询" class="headerlink" title="十六、组合查询"></a>十六、组合查询</h1><p>使用 <code>UNION</code>来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为M+N 行。<br>每个查询必须包含相同的列、表达式和聚集函数。<br>默认会去除相同行，<strong>如果需要保留相同行，使用 UNION ALL</strong>。<br>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">col</span><span class="hljs-keyword">FROM</span> mytable<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">col</span> = <span class="hljs-number">1</span><span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">col</span><span class="hljs-keyword">FROM</span> mytable<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">col</span> = <span class="hljs-number">2</span>;</code></pre></div><h1 id="十七、视图"><a href="#十七、视图" class="headerlink" title="十七、视图"></a>十七、视图</h1><p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。<br>对视图的操作和对普通表的操作一样。<br>视图具有如下好处：</p><ul><li>简化复杂的 SQL 操作，比如复杂的连接；</li><li>只使用实际表的一部分数据；</li><li>通过只给用户访问视图的权限，保证数据的安全性；</li><li>更改数据格式和表示</li></ul><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> myview <span class="hljs-keyword">AS</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">Concat</span>(col1, col2) <span class="hljs-keyword">AS</span> concat_col, col3*col4 <span class="hljs-keyword">AS</span> compute_col<span class="hljs-keyword">FROM</span> mytable<span class="hljs-keyword">WHERE</span> col5 = val;</code></pre></div><h1 id="十八、存储过程"><a href="#十八、存储过程" class="headerlink" title="十八、存储过程"></a>十八、存储过程</h1><p>存储过程可以看成是对一系列 SQL 操作的批处理。<br>使用存储过程的好处：</p><ul><li>代码封装，保证了一定的安全性；</li><li>代码复用；</li><li>由于是预先编译，因此具有很高的性能。</li></ul><p>命令行中创建存储过程需要自定义分隔符，因为命令行是以<code>;</code>为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。<br>包含<code>in</code>、<code>out</code>和<code>inout</code> 三种参数。<br>给变量赋值都需要用 select into 语句。<br>每次只能给一个变量赋值，不支持集合的操作。</p><div class="hljs"><pre><code class="hljs sql">delimiter //<span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> myprocedure( <span class="hljs-keyword">out</span> ret <span class="hljs-built_in">int</span> )    <span class="hljs-keyword">begin</span>        <span class="hljs-keyword">declare</span> y <span class="hljs-built_in">int</span>;        <span class="hljs-keyword">select</span> <span class="hljs-keyword">sum</span>(col1)        <span class="hljs-keyword">from</span> mytable        <span class="hljs-keyword">into</span> y;        <span class="hljs-keyword">select</span> y*y <span class="hljs-keyword">into</span> ret;    <span class="hljs-keyword">end</span> //delimiter ;</code></pre></div><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">call</span> myprocedure(@ret);<span class="hljs-keyword">select</span> @ret;</code></pre></div><h1 id="十九、游标"><a href="#十九、游标" class="headerlink" title="十九、游标"></a>十九、游标</h1><p>在存储过程中使用游标可<strong>以对一个结果集进行移动遍历</strong>。<br>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。<br>使用游标的四个步骤：</p><ol><li>声明游标，这个过程没有实际检索出数据；</li><li>打开游标；</li><li>取出数据；</li><li>关闭游标；</li></ol><div class="hljs"><pre><code class="hljs sql">delimiter //<span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> myprocedure(<span class="hljs-keyword">out</span> ret <span class="hljs-built_in">int</span>)    <span class="hljs-keyword">begin</span>        <span class="hljs-keyword">declare</span> done <span class="hljs-built_in">boolean</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">declare</span> mycursor <span class="hljs-keyword">cursor</span> <span class="hljs-keyword">for</span>        <span class="hljs-keyword">select</span> col1 <span class="hljs-keyword">from</span> mytable;        <span class="hljs-comment"># 定义了一个 continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1</span>        <span class="hljs-keyword">declare</span> continue <span class="hljs-keyword">handler</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">sqlstate</span> <span class="hljs-string">'02000'</span> <span class="hljs-keyword">set</span> done = <span class="hljs-number">1</span>;        open mycursor;        repeat            fetch mycursor into ret;            <span class="hljs-keyword">select</span> ret;        until done <span class="hljs-keyword">end</span> <span class="hljs-keyword">repeat</span>;        close mycursor;    <span class="hljs-keyword">end</span> //delimiter ;</code></pre></div><h1 id="二十、触发器"><a href="#二十、触发器" class="headerlink" title="二十、触发器"></a>二十、触发器</h1><p>触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。<br>触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。<br>BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。<br>INSERT 触发器包含一个名为 NEW 的虚拟表。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> mytrigger <span class="hljs-keyword">AFTER</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> mytable<span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span> <span class="hljs-keyword">SELECT</span> NEW.col <span class="hljs-keyword">into</span> @<span class="hljs-keyword">result</span>;<span class="hljs-keyword">SELECT</span> @<span class="hljs-keyword">result</span>; <span class="hljs-comment">-- 获取结果</span></code></pre></div><p>DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。<br>UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。<br>MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。</p><h1 id="二十一、事务管理"><a href="#二十一、事务管理" class="headerlink" title="二十一、事务管理"></a>二十一、事务管理</h1><p>基本术语：</p><ul><li>事务（transaction）指一组 SQL 语句；</li><li>回退（rollback）指撤销指定 SQL 语句的过程；</li><li>提交（commit）指将未存储的 SQL 语句结果写入数据库表；</li><li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li></ul><p>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。<br>MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现<code>START TRANSACTION</code>语句时，会关闭隐式提交；当 <code>COMMIT</code>或<code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p><p>通过设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。<br>如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK中指定该保留点，则会回退到该保留点。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>// ...<span class="hljs-keyword">SAVEPOINT</span> delete1// ...<span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> delete1// ...<span class="hljs-keyword">COMMIT</span></code></pre></div><h1 id="二十二、字符集"><a href="#二十二、字符集" class="headerlink" title="二十二、字符集"></a>二十二、字符集</h1><p>基本术语：</p><ul><li>字符集为字母和符号的集合；</li><li>编码为某个字符集成员的内部表示；</li><li>校对字符指定如何比较，主要用于排序和分组。</li></ul><p>除了给表指定字符集和校对外，也可以给列指定：</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> mytable(<span class="hljs-keyword">col</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> latin <span class="hljs-keyword">COLLATE</span> latin1_general_ci )<span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> hebrew <span class="hljs-keyword">COLLATE</span> hebrew_general_ci;</code></pre></div><p>可以在排序、分组时指定校对：</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *<span class="hljs-keyword">FROM</span> mytable<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">col</span> <span class="hljs-keyword">COLLATE</span> latin1_general_ci;</code></pre></div><h1 id="二十三、权限管理"><a href="#二十三、权限管理" class="headerlink" title="二十三、权限管理"></a>二十三、权限管理</h1><p>MySQL 的账户信息保存在 mysql 这个数据库中。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">USE</span> mysql;<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;</code></pre></div><p><strong>创建账户</strong><br>新创建的账户没有任何权限。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> myuser <span class="hljs-keyword">IDENTIFIED</span> <span class="hljs-keyword">BY</span> <span class="hljs-string">'mypassword'</span>;</code></pre></div><p><strong>修改账户名</strong></p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">RENAME</span> myuser <span class="hljs-keyword">TO</span> newuser;</code></pre></div><p><strong>删除账户</strong></p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">USER</span> myuser;</code></pre></div><p><strong>查看权限</strong></p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GRANTS</span> <span class="hljs-keyword">FOR</span> myuser;</code></pre></div><p><strong>授予权限</strong><br>账户用 username@host 的形式定义，username@% 使用的是默认主机名。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>, <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> mydatabase.* <span class="hljs-keyword">TO</span> myuser;</code></pre></div><p><strong>删除权限</strong><br>GRANT 和 REVOKE 可在几个层次上控制访问权限：</p><ul><li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li><li>整个数据库，使用 ON database.*；</li><li>特定的表，使用 ON database.table；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">SELECT</span>, <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> mydatabase.* <span class="hljs-keyword">FROM</span> myuser;</code></pre></div><p><strong>更改密码</strong><br>必须使用 Password() 函数</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> PASSWROD <span class="hljs-keyword">FOR</span> myuser = <span class="hljs-keyword">Password</span>(<span class="hljs-string">'new_password'</span>);</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>语言相关</category>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>复杂度分析</title>
    <link href="/2020/08/17/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <url>/2020/08/17/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="1、为什么需要对算法进行复杂度分析？"><a href="#1、为什么需要对算法进行复杂度分析？" class="headerlink" title="1、为什么需要对算法进行复杂度分析？"></a>1、为什么需要对算法进行复杂度分析？</h1><p>实际上一个算法执行所耗费的时间和空间是无法从理论上准确算出来的，必须在计算机上实际运行才知道，但是我们不可能对每个算法都先在计算机上运行一遍，再决定采用其中效率最高的那个。所以我们就需要从理论上分析出每种算法的复杂度，从而去预测其在运行的过程中所需要耗费的资源。<br>通常度量一个程序执行时间的两种方法：事后统计法和事前分析估算法。这两种方法从名字上就可以看出其含义，就不做过多的解释。<br>对算法进行预测分析包括以下方面：<br>（1）预测算法所需的资源</p><ul><li>计算时间（CPU消耗）</li><li>内存空间（RAM消耗）</li><li>通信时间（带宽消耗）</li></ul><p>（2）预测算法的运行时间<br>在输入规模一定时，所执行的基本操作的总数量，即算法的时间复杂度。</p><h1 id="2、如何衡量算法的复杂度？"><a href="#2、如何衡量算法的复杂度？" class="headerlink" title="2、如何衡量算法的复杂度？"></a>2、如何衡量算法的复杂度？</h1><p>衡量一个算法的好坏，我们需要给出一些评定的指标，首先我们能够想到的就是：时间和内存，其实还可以从其他方面去衡量，比如：访问磁盘的次数、指令的总数量等等。但是我们一般只需要关注时间和内存就可以了。<br>总结以上两个问题就是：同一问题可以用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。一个算法的评价主要从时间复杂度和空间复杂度来考虑。</p><h1 id="3、时间复杂度"><a href="#3、时间复杂度" class="headerlink" title="3、时间复杂度"></a>3、时间复杂度</h1><h2 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1  基本概念"></a>1.1  基本概念</h2><p>算法的时间复杂度是一个函数，它定量的描述了该算法的运行时间。这是一个关于代表算法输入值的字符串的长度的函数。时间复杂度通常用大O符号表示。<br><img src="https://img-blog.csdnimg.cn/20200817205816701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="1-2-求解时间复杂度的具体步骤"><a href="#1-2-求解时间复杂度的具体步骤" class="headerlink" title="1.2  求解时间复杂度的具体步骤"></a>1.2  求解时间复杂度的具体步骤</h2><p>（1）找出算法的基本语句：即执行次数最多的语句，通常为内循环体；<br>（2）计算基本语句执行次数的数量级，只保留最高数量级即可，其他省略；<br>（3）用大O表示其时间复杂度,即为基本语句执行的数量级</p><h2 id="1-3-时间复杂度计算的几个法则"><a href="#1-3-时间复杂度计算的几个法则" class="headerlink" title="1.3 时间复杂度计算的几个法则"></a>1.3 时间复杂度计算的几个法则</h2><p>（1）加法法则：总复杂度等于量级最大的那段代码的复杂度<br>（2）乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积<br>（3）求和法则：T1(m) + T2(n) = O(f(m)) + g(n))<br>（4）求积法则：T1(m) * T2(n) = O(f(m) * f(n)),和乘法法则一致</p><h2 id="1-4-常见的时间复杂度示例"><a href="#1-4-常见的时间复杂度示例" class="headerlink" title="1.4 常见的时间复杂度示例"></a>1.4 常见的时间复杂度示例</h2><p><img src="https://img-blog.csdnimg.cn/20200817211343236.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="常数阶O-1"><a href="#常数阶O-1" class="headerlink" title="常数阶O(1)"></a>常数阶O(1)</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;<span class="hljs-keyword">int</span> sum = a + b;</code></pre></div><h3 id="对数阶O-log2n"><a href="#对数阶O-log2n" class="headerlink" title="对数阶O(log2n)"></a>对数阶O(log2n)</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(i &lt;= n)&#123;    i = i * <span class="hljs-number">2</span>;&#125;</code></pre></div><h3 id="对数阶O-log3n"><a href="#对数阶O-log3n" class="headerlink" title="对数阶O(log3n)"></a>对数阶O(log3n)</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(i &lt;= n)&#123;    i = i * <span class="hljs-number">3</span>;&#125;</code></pre></div><h3 id="线性阶-O-n"><a href="#线性阶-O-n" class="headerlink" title="线性阶(O(n))"></a>线性阶(O(n))</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;    sum++;&#125;</code></pre></div><h3 id="线性对数阶-O-nlog2n"><a href="#线性对数阶-O-nlog2n" class="headerlink" title="线性对数阶(O(nlog2n))"></a>线性对数阶(O(nlog2n))</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(i &lt;= n)&#123;       i = i * n;    &#125;&#125;</code></pre></div><h3 id="平方阶-O-n2-）"><a href="#平方阶-O-n2-）" class="headerlink" title="平方阶(O(n2)）"></a>平方阶(O(n2)）</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;        sum++;    &#125;&#125;</code></pre></div><h1 id="4、空间复杂度"><a href="#4、空间复杂度" class="headerlink" title="4、空间复杂度"></a>4、空间复杂度</h1><p>类似于时间复杂度的分析，主要用于分析该算法所耗费的存储空间。一个算法在计算机存储上所占用的空间主要包括三个方面：</p><ul><li>算法本身所占用的存储空间；</li><li>算法的输入输出数据所占用的存储空间；</li><li>算法在运行过程中临时占用的空间。</li></ul><p>算法的本身所占用的存储空间和算法的书写长度成正比，这就要求我们尽量写出简短的算法实现程序；<br>算法的输入输出数据所占用的存储空间是由算法解决的问题决定的，是通过参数传递而来的，它不随算法的不同而改变；<br>算法在运行过程中临时占用的存储空间随算法的不同而改变，有的算法只需要占用少量的临时单元，而且不随问题的规模大小而改变，称这种算法为：“就地算法”，是节省存储的算法。但是有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随n的增大而增大，当n较大时，将会占用较多的存储单元，例如：归并排序和快速排序。</p><h1 id="5、排序算法复杂度"><a href="#5、排序算法复杂度" class="headerlink" title="5、排序算法复杂度"></a>5、排序算法复杂度</h1><p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括：<br><img src="https://img-blog.csdnimg.cn/20200817214918667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h2><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p>作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BubbleSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IArraySort</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span>[] sourceArray) <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="hljs-keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;            <span class="hljs-comment">// 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。</span>            <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - i; j++) &#123;                <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;                    <span class="hljs-keyword">int</span> tmp = arr[j];                    arr[j] = arr[j + <span class="hljs-number">1</span>];                    arr[j + <span class="hljs-number">1</span>] = tmp;                    flag = <span class="hljs-keyword">false</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (flag) &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> arr;    &#125;&#125;</code></pre></div><h2 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h2><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p><h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3></li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectionSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IArraySort</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span>[] sourceArray) <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        <span class="hljs-comment">// 总共要经过 N-1 轮比较</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">int</span> min = i;            <span class="hljs-comment">// 每轮需要比较的次数 N-i</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;                <span class="hljs-keyword">if</span> (arr[j] &lt; arr[min]) &#123;                    <span class="hljs-comment">// 记录目前能找到的最小值元素的下标</span>                    min = j;                &#125;            &#125;            <span class="hljs-comment">// 将找到的最小值和i位置所在的值进行交换</span>            <span class="hljs-keyword">if</span> (i != min) &#123;                <span class="hljs-keyword">int</span> tmp = arr[i];                arr[i] = arr[min];                arr[min] = tmp;            &#125;        &#125;        <span class="hljs-keyword">return</span> arr;    &#125;&#125;</code></pre></div><h2 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h2><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p><h3 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li><li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InsertSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IArraySort</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span>[] sourceArray) <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="hljs-keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        <span class="hljs-comment">// 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;            <span class="hljs-comment">// 记录要插入的数据</span>            <span class="hljs-keyword">int</span> tmp = arr[i];            <span class="hljs-comment">// 从已经排序的序列最右边的开始比较，找到比其小的数</span>            <span class="hljs-keyword">int</span> j = i;            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; tmp &lt; arr[j - <span class="hljs-number">1</span>]) &#123;                arr[j] = arr[j - <span class="hljs-number">1</span>];                j--;            &#125;            <span class="hljs-comment">// 存在比其小的数，插入</span>            <span class="hljs-keyword">if</span> (j != i) &#123;                arr[j] = tmp;            &#125;        &#125;        <span class="hljs-keyword">return</span> arr;    &#125;&#125;</code></pre></div><h2 id="4、希尔排序"><a href="#4、希尔排序" class="headerlink" title="4、希尔排序"></a>4、希尔排序</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：<br>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；<br>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</p><p>希尔排序的基本思想是：<strong>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</strong></p><h3 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；<br>按增量序列个数 k，对序列进行 k 趟排序；<br>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShellSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IArraySort</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span>[] sourceArray) <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="hljs-keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        <span class="hljs-keyword">int</span> gap = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (gap &lt; arr.length) &#123;            gap = gap * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">while</span> (gap &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;                <span class="hljs-keyword">int</span> tmp = arr[i];                <span class="hljs-keyword">int</span> j = i - gap;                <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; tmp) &#123;                    arr[j + gap] = arr[j];                    j -= gap;                &#125;                arr[j + gap] = tmp;            &#125;            gap = (<span class="hljs-keyword">int</span>) Math.floor(gap / <span class="hljs-number">3</span>);        &#125;        <span class="hljs-keyword">return</span> arr;    &#125;&#125;</code></pre></div><h2 id="5、归并排序"><a href="#5、归并排序" class="headerlink" title="5、归并排序"></a>5、归并排序</h2><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用<strong>分治思想</strong>（Divide and Conquer）的一个非常典型的应用。</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li><li>自下而上的迭代；</li></ul><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p><h3 id="算法步骤-4"><a href="#算法步骤-4" class="headerlink" title="算法步骤"></a>算法步骤</h3><ul><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤 3 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ul><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MergeSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IArraySort</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span>[] sourceArray) <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="hljs-keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        <span class="hljs-keyword">if</span> (arr.length &lt; <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span> arr;        &#125;        <span class="hljs-keyword">int</span> middle = (<span class="hljs-keyword">int</span>) Math.floor(arr.length / <span class="hljs-number">2</span>);        <span class="hljs-keyword">int</span>[] left = Arrays.copyOfRange(arr, <span class="hljs-number">0</span>, middle);        <span class="hljs-keyword">int</span>[] right = Arrays.copyOfRange(arr, middle, arr.length);        <span class="hljs-keyword">return</span> merge(sort(left), sort(right));    &#125;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span>[] merge(<span class="hljs-keyword">int</span>[] left, <span class="hljs-keyword">int</span>[] right) &#123;        <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[left.length + right.length];        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (left.length &gt; <span class="hljs-number">0</span> &amp;&amp; right.length &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (left[<span class="hljs-number">0</span>] &lt;= right[<span class="hljs-number">0</span>]) &#123;                result[i++] = left[<span class="hljs-number">0</span>];                left = Arrays.copyOfRange(left, <span class="hljs-number">1</span>, left.length);            &#125; <span class="hljs-keyword">else</span> &#123;                result[i++] = right[<span class="hljs-number">0</span>];                right = Arrays.copyOfRange(right, <span class="hljs-number">1</span>, right.length);            &#125;        &#125;        <span class="hljs-keyword">while</span> (left.length &gt; <span class="hljs-number">0</span>) &#123;            result[i++] = left[<span class="hljs-number">0</span>];            left = Arrays.copyOfRange(left, <span class="hljs-number">1</span>, left.length);        &#125;        <span class="hljs-keyword">while</span> (right.length &gt; <span class="hljs-number">0</span>) &#123;            result[i++] = right[<span class="hljs-number">0</span>];            right = Arrays.copyOfRange(right, <span class="hljs-number">1</span>, right.length);        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre></div><h3 id="力扣经典题：逆序对的个数"><a href="#力扣经典题：逆序对的个数" class="headerlink" title="力扣经典题：逆序对的个数"></a>力扣经典题：逆序对的个数</h3><p><img src="https://img-blog.csdnimg.cn/20200819093401367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReversePairs</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            copy[i] = nums[i];        &#125;        <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        <span class="hljs-comment">//分治思想</span>        <span class="hljs-keyword">return</span> helper(copy, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>, temp);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * nums[left..right]计算逆序对个数并且排序</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] temp)</span> </span>&#123;        <span class="hljs-comment">//递归结束条件</span>        <span class="hljs-keyword">if</span> (left == right) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> leftPairs = helper(nums, left, mid, temp);        <span class="hljs-keyword">int</span> rightPairs = helper(nums, mid + <span class="hljs-number">1</span>, right, temp);        <span class="hljs-comment">// 优化：此时，左边子数组的最大数小于右边子数组的最小数，直接合并即可，不会产生逆序对</span>        <span class="hljs-keyword">if</span> (nums[mid] &lt;= nums[mid + <span class="hljs-number">1</span>]) &#123;            <span class="hljs-keyword">return</span> leftPairs + rightPairs;        &#125;        <span class="hljs-comment">// crossPairs是将两个有序子数组归并为一个有序数组产生的逆序对</span>        <span class="hljs-keyword">int</span> crossPairs = mergerAndCount(nums, left, mid, right, temp);        <span class="hljs-keyword">return</span> leftPairs + rightPairs + crossPairs;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * nums[left..mid]有序，nums[mid+1..right]有序</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mergerAndCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] temp)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt;= right; i++) &#123;            temp[i] = nums[i];        &#125;        <span class="hljs-comment">//i,j分别是维护左右两个子数组的指针</span>        <span class="hljs-keyword">int</span> i = left;        <span class="hljs-keyword">int</span> j = mid + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = left; k &lt;= right; k++) &#123;            <span class="hljs-comment">//如果左边子数组长度为0</span>            <span class="hljs-keyword">if</span> (i == mid + <span class="hljs-number">1</span>) &#123;                nums[k] = temp[j];                j++;            &#125;<span class="hljs-comment">//如果右边子数组的长度为0</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == right + <span class="hljs-number">1</span>) &#123;                nums[k] = temp[i];                i++;            &#125;<span class="hljs-comment">//如果左边子数组的值不大于右边的值，放入有序数组</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp[i] &lt;= temp[j]) &#123;                nums[k] = temp[i];                i++;            &#125;<span class="hljs-comment">//如果左边子数组的值比右边的大，说明有逆序对</span>            <span class="hljs-keyword">else</span> &#123;                nums[k] = temp[j];                j++;                count += (mid - i + <span class="hljs-number">1</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;&#125;</code></pre></div><h2 id="6、快速排序"><a href="#6、快速排序" class="headerlink" title="6、快速排序"></a>6、快速排序</h2><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p><p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：<br>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p><h3 id="算法步骤-5"><a href="#算法步骤-5" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3></li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IArraySort</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span>[] sourceArray) <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="hljs-keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        <span class="hljs-keyword">return</span> quickSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] quickSort(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right) &#123;        <span class="hljs-keyword">if</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> partitionIndex = partition(arr, left, right);            quickSort(arr, left, partitionIndex - <span class="hljs-number">1</span>);            quickSort(arr, partitionIndex + <span class="hljs-number">1</span>, right);        &#125;        <span class="hljs-keyword">return</span> arr;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;        <span class="hljs-comment">// 设定基准值（pivot）</span>        <span class="hljs-keyword">int</span> pivot = left;        <span class="hljs-keyword">int</span> index = pivot + <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt;= right; i++) &#123;            <span class="hljs-keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;                swap(arr, i, index);                index++;            &#125;        &#125;        swap(arr, pivot, index - <span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> index - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    &#125;&#125;</code></pre></div><h2 id="7、堆排序"><a href="#7、堆排序" class="headerlink" title="7、堆排序"></a>7、堆排序</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；<br>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p><p>堆排序的平均时间复杂度为 Ο(nlogn)。</p><h3 id="算法步骤-6"><a href="#算法步骤-6" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>创建一个堆 H[0……n-1]；</li><li>把堆首（最大值）和堆尾互换；</li><li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li><li>重复步骤 2，直到堆的尺寸为 1。</li></ol><h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IArraySort</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span>[] sourceArray) <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="hljs-keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        <span class="hljs-keyword">int</span> len = arr.length;        buildMaxHeap(arr, len);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;            swap(arr, <span class="hljs-number">0</span>, i);            len--;            heapify(arr, <span class="hljs-number">0</span>, len);        &#125;        <span class="hljs-keyword">return</span> arr;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildMaxHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> len)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = (<span class="hljs-keyword">int</span>) Math.floor(len / <span class="hljs-number">2</span>); i &gt;= <span class="hljs-number">0</span>; i--) &#123;            heapify(arr, i, len);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> len)</span> </span>&#123;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> largest = i;        <span class="hljs-keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;            largest = left;        &#125;        <span class="hljs-keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;            largest = right;        &#125;        <span class="hljs-keyword">if</span> (largest != i) &#123;            swap(arr, i, largest);            heapify(arr, largest, len);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    &#125;&#125;</code></pre></div><h2 id="8、计数排序"><a href="#8、计数排序" class="headerlink" title="8、计数排序"></a>8、计数排序</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountingSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IArraySort</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span>[] sourceArray) <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="hljs-keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        <span class="hljs-keyword">int</span> maxValue = getMaxValue(arr);        <span class="hljs-keyword">return</span> countingSort(arr, maxValue);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] countingSort(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> maxValue) &#123;        <span class="hljs-keyword">int</span> bucketLen = maxValue + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[bucketLen];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;            bucket[value]++;        &#125;        <span class="hljs-keyword">int</span> sortedIndex = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; bucketLen; j++) &#123;            <span class="hljs-keyword">while</span> (bucket[j] &gt; <span class="hljs-number">0</span>) &#123;                arr[sortedIndex++] = j;                bucket[j]--;            &#125;        &#125;        <span class="hljs-keyword">return</span> arr;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;        <span class="hljs-keyword">int</span> maxValue = arr[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;            <span class="hljs-keyword">if</span> (maxValue &lt; value) &#123;                maxValue = value;        &#125;        <span class="hljs-keyword">return</span> maxValue;    &#125;&#125;</code></pre></div><h2 id="9、桶排序"><a href="#9、桶排序" class="headerlink" title="9、桶排序"></a>9、桶排序</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3></li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BucketSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IArraySort</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> InsertSort insertSort = <span class="hljs-keyword">new</span> InsertSort();    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span>[] sourceArray) <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="hljs-keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        <span class="hljs-keyword">return</span> bucketSort(arr, <span class="hljs-number">5</span>);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] bucketSort(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> bucketSize) <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> arr;        &#125;        <span class="hljs-keyword">int</span> minValue = arr[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> maxValue = arr[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;            <span class="hljs-keyword">if</span> (value &lt; minValue) &#123;                minValue = value;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &gt; maxValue) &#123;                maxValue = value;            &#125;        &#125;        <span class="hljs-keyword">int</span> bucketCount = (<span class="hljs-keyword">int</span>) Math.floor((maxValue - minValue) / bucketSize) + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span>[][] buckets = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[bucketCount][<span class="hljs-number">0</span>];        <span class="hljs-comment">// 利用映射函数将数据分配到各个桶中</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;            <span class="hljs-keyword">int</span> index = (<span class="hljs-keyword">int</span>) Math.floor((arr[i] - minValue) / bucketSize);            buckets[index] = arrAppend(buckets[index], arr[i]);        &#125;        <span class="hljs-keyword">int</span> arrIndex = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] bucket : buckets) &#123;            <span class="hljs-keyword">if</span> (bucket.length &lt;= <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 对每个桶进行排序，这里使用了插入排序</span>            bucket = insertSort.sort(bucket);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : bucket) &#123;                arr[arrIndex++] = value;            &#125;        &#125;        <span class="hljs-keyword">return</span> arr;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 自动扩容，并保存数据</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arrAppend(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value) &#123;        arr = Arrays.copyOf(arr, arr.length + <span class="hljs-number">1</span>);        arr[arr.length - <span class="hljs-number">1</span>] = value;        <span class="hljs-keyword">return</span> arr;    &#125;&#125;</code></pre></div><h2 id="10、基数排序"><a href="#10、基数排序" class="headerlink" title="10、基数排序"></a>10、基数排序</h2><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><h3 id="基数排序-vs-计数排序-vs-桶排序"><a href="#基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="基数排序 vs 计数排序 vs 桶排序"></a>基数排序 vs 计数排序 vs 桶排序</h3><p>基数排序有两种方法：<br>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ol><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值；<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3></li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RadixSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IArraySort</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span>[] sourceArray) <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="hljs-keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        <span class="hljs-keyword">int</span> maxDigit = getMaxDigit(arr);        <span class="hljs-keyword">return</span> radixSort(arr, maxDigit);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取最高位数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaxDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;        <span class="hljs-keyword">int</span> maxValue = getMaxValue(arr);        <span class="hljs-keyword">return</span> getNumLenght(maxValue);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;        <span class="hljs-keyword">int</span> maxValue = arr[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;            <span class="hljs-keyword">if</span> (maxValue &lt; value) &#123;                maxValue = value;            &#125;        &#125;        <span class="hljs-keyword">return</span> maxValue;    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumLenght</span><span class="hljs-params">(<span class="hljs-keyword">long</span> num)</span> </span>&#123;        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">int</span> lenght = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> temp = num; temp != <span class="hljs-number">0</span>; temp /= <span class="hljs-number">10</span>) &#123;            lenght++;        &#125;        <span class="hljs-keyword">return</span> lenght;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] radixSort(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> maxDigit) &#123;        <span class="hljs-keyword">int</span> mod = <span class="hljs-number">10</span>;        <span class="hljs-keyword">int</span> dev = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxDigit; i++, dev *= <span class="hljs-number">10</span>, mod *= <span class="hljs-number">10</span>) &#123;            <span class="hljs-comment">// 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span>            <span class="hljs-keyword">int</span>[][] counter = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[mod * <span class="hljs-number">2</span>][<span class="hljs-number">0</span>];            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length; j++) &#123;                <span class="hljs-keyword">int</span> bucket = ((arr[j] % mod) / dev) + mod;                counter[bucket] = arrayAppend(counter[bucket], arr[j]);            &#125;            <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] bucket : counter) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : bucket) &#123;                    arr[pos++] = value;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> arr;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 自动扩容，并保存数据</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arrayAppend(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value) &#123;        arr = Arrays.copyOf(arr, arr.length + <span class="hljs-number">1</span>);        arr[arr.length - <span class="hljs-number">1</span>] = value;        <span class="hljs-keyword">return</span> arr;    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复杂度分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-红黑树</title>
    <link href="/2020/08/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2020/08/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>当在10亿数据中只需要进行10几次比较就能查找到目标时，不禁感叹编程之魅力！人类之伟大呀！ —— 学红黑树有感。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>红黑树是一种特殊的二叉查找树，其特别之处在于它是自平衡的二叉查找树，在进行插入和删除等可能会破坏树的平衡操作时，需要自行处理来达到平衡状态。</p><h1 id="红黑树的定义和性质"><a href="#红黑树的定义和性质" class="headerlink" title="红黑树的定义和性质"></a>红黑树的定义和性质</h1><p>红黑树是一种含有红黑节点并能自平衡的二叉查找树，它必须满足下面性质：</p><ul><li>性质1：每个节点要么是黑色，要么是红色；</li><li>性质2：根节点是黑色；</li><li>性质3：每个叶子节点（Nil）是黑色；</li><li>性质4：每个红色节点的两个子节点一定都是黑色；</li><li>性质5：任意一个节点到每个叶子节点的路径都包含数量相同的黑节点。</li></ul><p>注：Java中叶子节点为null的节点。<br>下图就是一棵简单的红黑树，其中Nil为叶子节点，并且是黑色的。<br><img src="https://img-blog.csdnimg.cn/20200817152010283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>红黑树并不是一个完美平衡二叉查找树，从图1可以看到，根结点P的左子树显然比右子树高，但左子树和右子树的黑结点的层数是相等的，也即任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。所以我们叫红黑树这种平衡为<strong>黑色完美平衡</strong>。</p><p>介绍到此，为了后面讲解不至于混淆，我们还需要来约定下红黑树一些结点的叫法，如图2所示。<br><img src="https://img-blog.csdnimg.cn/20200817152106595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>我们把正在处理(遍历)的结点叫做当前结点，如图2中的D，它的父亲叫做父结点，它的父亲的另外一个子结点叫做兄弟结点，父亲的父亲叫做祖父结点。<br>前面讲到红黑树能自平衡，它靠的是什么？三种操作：左旋、右旋和变色。</p><ul><li>左旋：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。如图3。</li><li>右旋：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。如图4。</li><li>变色：结点的颜色由红变黑或由黑变红。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200817152608820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020081715261675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>我们先忽略颜色，可以看到旋转操作不会影响旋转结点的父结点，父结点以上的结构还是保持不变的。<br>左旋只影响旋转结点和其右子树的结构，把右子树的结点往左子树挪了。<br>右旋只影响旋转结点和其左子树的结构，把左子树的结点往右子树挪了。<br>所以旋转操作是局部的。另外可以看出旋转能保持红黑树平衡的一些端详了：当一边子树的结点少了，那么向另外一边子树“借”一些结点；当一边子树的结点多了，那么向另外一边子树“租”一些结点。<br>但要保持红黑树的性质，结点不能乱挪，还得靠变色了。怎么变？具体情景有不同变法，后面会具体讲到，现在只需要记住红黑树总是通过旋转和变色达到自平衡。</p><h1 id="红黑树查找"><a href="#红黑树查找" class="headerlink" title="红黑树查找"></a>红黑树查找</h1><p>因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：</p><ol><li>从根结点开始查找，把根结点设置为当前结点；</li><li>若当前结点为空，返回null； </li><li>若当前结点不为空，4. 用当前结点的key跟查找key作比较；</li><li>若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；</li><li>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；</li><li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；</li></ol><p>正由于红黑树总保持黑色完美平衡，所以它的查找最坏时间复杂度为O(2lgN)，也即整颗树刚好红黑相隔的时候。能有这么好的查找效率得益于红黑树自平衡的特性，而这背后的付出，红黑树的插入操作功不可没～</p><h1 id="红黑树插入"><a href="#红黑树插入" class="headerlink" title="红黑树插入"></a>红黑树插入</h1><p>插入操作包括两部分工作：</p><ul><li>查找插入的位置；</li><li>插入后自平衡。</li></ul><p>查找插入的父结点很简单，跟查找操作区别不大：</p><ol><li>从根结点开始查找；</li><li>若根结点为空，那么插入结点作为根结点，结束。</li><li>若根结点不为空，那么把根结点作为当前结点；</li><li>若当前结点为null，返回当前结点的父结点，结束。</li><li>若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。</li><li>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4；</li><li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4；</li></ol><p>ok，插入位置已经找到，把插入结点放到正确的位置就可以啦，但插入结点是应该是什么颜色呢？答案是红色。理由很简单，红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。<br>所有插入情景如图7所示。<br><img src="https://img-blog.csdnimg.cn/20200817155045387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>嗯，插入情景很多呢，8种插入情景！但情景1、2和3的处理很简单，而情景4.2和情景4.3只是方向反转而已，懂得了一种情景就能推出另外一种情景，所以总体来看，并不复杂，后续我们将一个一个情景来看，把它彻底搞懂。<br>另外，根据二叉树的性质，除了情景2，所有插入操作都是在叶子结点进行的。这点应该不难理解，因为查找插入位置时，我们就是在找子结点为空的父结点的。<br>在开始每个情景的讲解前，我们还是先来约定下，如图8所示。<br><img src="https://img-blog.csdnimg.cn/20200817155314375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>图8的字母并不代表结点Key的大小。I表示插入结点，P表示插入结点的父结点，S表示插入结点的叔叔结点，PP表示插入结点的祖父结点。<br>好了，下面让我们一个一个来分析每个插入的情景以其处理。</p><h2 id="插入情景1：红黑树为空树"><a href="#插入情景1：红黑树为空树" class="headerlink" title="插入情景1：红黑树为空树"></a>插入情景1：红黑树为空树</h2><p>最简单的一种情景，直接把插入结点作为根结点就行，但注意，根据红黑树性质2：根节点是黑色。还需要把插入结点设为黑色。<br>处理：把插入结点作为根结点，并把结点设置为黑色。</p><h2 id="插入情景2：插入结点的Key已存在"><a href="#插入情景2：插入结点的Key已存在" class="headerlink" title="插入情景2：插入结点的Key已存在"></a>插入情景2：插入结点的Key已存在</h2><p>插入结点的Key已存在，既然红黑树总保持平衡，在插入前红黑树已经是平衡的，那么把插入结点设置为将要替代结点的颜色，再把结点的值更新就完成插入。<br>处理：</p><ul><li>把I设为当前结点的颜色</li><li>更新当前结点的值为插入结点的值<h2 id="插入情景3：插入结点的父结点为黑结点"><a href="#插入情景3：插入结点的父结点为黑结点" class="headerlink" title="插入情景3：插入结点的父结点为黑结点"></a>插入情景3：插入结点的父结点为黑结点</h2>由于插入的结点是红色的，当插入结点的黑色时，并不会影响红黑树的平衡，直接插入即可，无需做自平衡。<br>处理：直接插入。<h2 id="插入情景4：插入结点的父结点为红结点"><a href="#插入情景4：插入结点的父结点为红结点" class="headerlink" title="插入情景4：插入结点的父结点为红结点"></a>插入情景4：插入结点的父结点为红结点</h2>再次回想下红黑树的性质2：根结点是黑色。如果插入的父结点为红结点，那么该父结点不可能为根结点，所以插入结点总是存在祖父结点。这点很重要，因为后续的旋转操作肯定需要祖父结点的参与。<br>情景4又分为很多子情景，下面将进入重点部分，各位看官请留神了。<h3 id="插入情景4-1：叔叔结点存在并且为红结点"><a href="#插入情景4-1：叔叔结点存在并且为红结点" class="headerlink" title="插入情景4.1：叔叔结点存在并且为红结点"></a>插入情景4.1：叔叔结点存在并且为红结点</h3>从红黑树性质4可以，祖父结点肯定为黑结点，因为不可以同时存在两个相连的红结点。那么此时该插入子树的红黑层数的情况是：黑红红。显然最简单的处理方式是把其改为：红黑红。如图9和图10所示。<br>处理：</li><li>将P和S设置为黑色</li><li>将PP设置为红色</li><li>把PP设置为当前插入结点<br><img src="https://img-blog.csdnimg.cn/20200817155952671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020081716000221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>可以看到，我们把PP结点设为红色了，如果PP的父结点是黑色，那么无需再做任何处理；但如果PP的父结点是红色，根据性质4，此时红黑树已不平衡了，所以还需要把PP当作新的插入结点，继续做插入操作自平衡处理，直到平衡为止。<br>试想下PP刚好为根结点时，那么根据性质2，我们必须把PP重新设为黑色，那么树的红黑结构变为：黑黑红。换句话说，从根结点到叶子结点的路径中，黑色结点增加了。这也是<strong>唯一一种会增加红黑树黑色结点层数的插入情景。</strong><br>我们还可以总结出另外一个经验：红黑树的生长是自底向上的。这点不同于普通的二叉查找树，普通的二叉查找树的生长是自顶向下的。</li></ul><h3 id="插入情景4-2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点。"><a href="#插入情景4-2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点。" class="headerlink" title="插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点。"></a>插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点。</h3><p>单纯从插入前来看，也即不算情景4.1自底向上处理时的情况，叔叔结点非红即为叶子结点(Nil)。因为如果叔叔结点为黑结点，而父结点为红结点，那么叔叔结点所在的子树的黑色结点就比父结点所在子树的多了，这不满足红黑树的性质5。后续情景同样如此，不再多做说明了。<br>前文说了，需要旋转操作时，肯定一边子树的结点多了或少了，需要租或借给另一边。插入显然是多的情况，那么把多的结点租给另一边子树就可以了。</p><h4 id="插入情景4-2-1：插入结点是其父结点的左子结点"><a href="#插入情景4-2-1：插入结点是其父结点的左子结点" class="headerlink" title="插入情景4.2.1：插入结点是其父结点的左子结点"></a>插入情景4.2.1：插入结点是其父结点的左子结点</h4><p><strong>处理：</strong></p><ul><li>将P设为黑色</li><li>将PP设为红色</li><li>对PP进行右旋<br><img src="https://img-blog.csdnimg.cn/20200817162613109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>由图11可得，左边两个红结点，右边不存在，那么一边一个刚刚好，并且因为为红色，肯定不会破坏树的平衡。<br>咦，可以把PP设为红色，I和P设为黑色吗？答案是可以！看过《算法：第4版》的同学可能知道，书中讲解的就是把PP设为红色，I和P设为黑色。但把PP设为红色，显然又会出现情景4.1的情况，需要自底向上处理，做多了无谓的操作，既然能自己消化就不要麻烦祖辈们啦～</li></ul><h4 id="插入情景4-2-2：插入结点是其父结点的右子结点"><a href="#插入情景4-2-2：插入结点是其父结点的右子结点" class="headerlink" title="插入情景4.2.2：插入结点是其父结点的右子结点"></a>插入情景4.2.2：插入结点是其父结点的右子结点</h4><p>这种情景显然可以转换为情景4.2.1，如图12所示，不做过多说明了。<br><strong>处理：</strong></p><ul><li>对P进行左旋</li><li>把P设置为插入结点，得到情景4.2.1</li><li>进行情景4.2.1的处理<br><img src="https://img-blog.csdnimg.cn/20200817162908386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><h3 id="插入情景4-3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点"><a href="#插入情景4-3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点" class="headerlink" title="插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点"></a>插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点</h3>该情景对应情景4.2，只是方向反转，不做过多说明了，直接看图。<h4 id="插入情景4-3-1：插入结点是其父结点的右子结点"><a href="#插入情景4-3-1：插入结点是其父结点的右子结点" class="headerlink" title="插入情景4.3.1：插入结点是其父结点的右子结点"></a>插入情景4.3.1：插入结点是其父结点的右子结点</h4></li><li><em>处理：*</em></li><li>将P设为黑色</li><li>将PP设为红色</li><li>对PP进行左旋<br><img src="https://img-blog.csdnimg.cn/2020081716310789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><h4 id="插入情景4-3-2：插入结点是其父结点的右子结点"><a href="#插入情景4-3-2：插入结点是其父结点的右子结点" class="headerlink" title="插入情景4.3.2：插入结点是其父结点的右子结点"></a>插入情景4.3.2：插入结点是其父结点的右子结点</h4></li><li><em>处理：*</em></li><li>对P进行右旋</li><li>把P设置为插入结点，得到情景4.3.1</li><li>进行情景4.3.1的处理<br><img src="https://img-blog.csdnimg.cn/20200817163139546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><h1 id="红黑树删除"><a href="#红黑树删除" class="headerlink" title="红黑树删除"></a>红黑树删除</h1>红黑树插入已经够复杂了，但删除更复杂，也是红黑树最复杂的操作了。但稳住，胜利的曙光就在前面了！</li></ul><p>红黑树的删除操作也包括两部分工作：一查找目标结点；而删除后自平衡。查找目标结点显然可以复用查找操作，当不存在目标结点时，忽略本次操作；当存在目标结点时，删除后就得做自平衡处理了。删除了结点后我们还需要找结点来替代删除结点的位置，不然子树跟父辈结点断开了，除非删除结点刚好没子结点，那么就不需要替代。<br>二叉树删除结点找替代结点有3种情情景：</p><ul><li>情景1：若删除结点无子结点，直接删除</li><li>情景2：若删除结点只有一个子结点，用子结点替换删除结点</li><li>情景3：若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点</li></ul><p>补充说明下，情景3的后继结点是大于删除结点的最小结点，也是删除结点的右子树中最右结点。那么可以拿前继结点（删除结点的左子树最左结点）替代吗？可以的。但习惯上大多都是拿后继结点来替代，后文的讲解也是用后继结点来替代。另外告诉大家一种找前继和后继结点的直观的方法（不知为何没人提过，大家都知道？）：<strong>把二叉树所有结点投射在X轴上，所有结点都是从左到右排好序的，所有目标结点的前后结点就是对应前继和后继结点。</strong>如图16所示。<br><img src="https://img-blog.csdnimg.cn/20200817164227122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>接下来，讲一个重要的思路：<strong>删除结点被替代后，在不考虑结点的键值的情况下，对于树来说，可以认为删除的是替代结点！</strong>话很苍白，我们看图17。在不看键值对的情况下，图17的红黑树最终结果是删除了Q所在位置的结点！这种思路非常重要，大大简化了后文讲解红黑树删除的情景！<img src="https://img-blog.csdnimg.cn/20200817164526239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>基于此，上面所说的3种二叉树的删除情景可以相互转换并且最终都是转换为情景1！</p><ul><li>情景2：删除结点用其唯一的子结点替换，子结点替换为删除结点后，可以认为删除的是子结点，若子结点又有两个子结点，那么相当于转换为情景3，一直自顶向下转换，总是能转换为情景1。（对于红黑树来说，根据性质5.1，只存在一个子结点的结点肯定在树末了）</li><li>情景3：删除结点用后继结点（肯定不存在左结点），如果后继结点有右子结点，那么相当于转换为情景2，否则转为为情景1。</li></ul><p>二叉树删除结点情景关系图如图18所示。<br><img src="https://img-blog.csdnimg.cn/20200817164600289.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>综上所述，删除操作删除的结点可以看作删除替代结点，而替代结点最后总是在树末。有了这结论，我们讨论的删除红黑树的情景就少了很多，因为我们只考虑删除树末结点的情景了。<br>同样的，我们也是先来总体看下删除操作的所有情景，如图19所示。<img src="https://img-blog.csdnimg.cn/20200817164618176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>即使简化了还是有9种情景！但跟插入操作一样，存在左右对称的情景，只是方向变了，没有本质区别。同样的，我们还是来约定下，如图20所示。<br><img src="https://img-blog.csdnimg.cn/20200817164936809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>图20的字母并不代表结点Key的大小。R表示替代结点，P表示替代结点的父结点，S表示替代结点的兄弟结点，SL表示兄弟结点的左子结点，SR表示兄弟结点的右子结点。灰色结点表示它可以是红色也可以是黑色。<br>值得特别提醒的是，R是即将被替换到删除结点的位置的替代结点，在删除前，它还在原来所在位置参与树的子平衡，平衡后再替换到删除结点的位置，才算删除完成。<br>万事具备，我们进入最后的也是最难的讲解。</p><h2 id="删除情景1：替换结点是红色结点"><a href="#删除情景1：替换结点是红色结点" class="headerlink" title="删除情景1：替换结点是红色结点"></a>删除情景1：替换结点是红色结点</h2><p>我们把替换结点换到了删除结点的位置时，由于替换结点时红色，删除也了不会影响红黑树的平衡，只要把替换结点的颜色设为删除的结点的颜色即可重新平衡。<br>处理：颜色变为删除结点的颜色</p><h2 id="删除情景2：替换结点是黑结点"><a href="#删除情景2：替换结点是黑结点" class="headerlink" title="删除情景2：替换结点是黑结点"></a>删除情景2：替换结点是黑结点</h2><p>当替换结点是黑色时，我们就不得不进行自平衡处理了。我们必须还得考虑替换结点是其父结点的左子结点还是右子结点，来做不同的旋转操作，使树重新平衡。</p><h3 id="删除情景2-1：替换结点是其父结点的左子结点"><a href="#删除情景2-1：替换结点是其父结点的左子结点" class="headerlink" title="删除情景2.1：替换结点是其父结点的左子结点"></a>删除情景2.1：替换结点是其父结点的左子结点</h3><h4 id="删除情景2-1-1：替换结点的兄弟结点是红结点"><a href="#删除情景2-1-1：替换结点的兄弟结点是红结点" class="headerlink" title="删除情景2.1.1：替换结点的兄弟结点是红结点"></a>删除情景2.1.1：替换结点的兄弟结点是红结点</h4><p>若兄弟结点是红结点，那么根据性质4，兄弟结点的父结点和子结点肯定为黑色，不会有其他子情景，我们按图21处理，得到删除情景2.1.2.3（后续讲解，这里先记住，此时R仍然是替代结点，它的新的兄弟结点SL和兄弟结点的子结点都是黑色）。<br>处理：</p><ul><li>将S设为黑色</li><li>将P设为红色</li><li>对P进行左旋，得到情景2.1.2.3</li><li>进行情景2.1.2.3的处理<br><img src="https://img-blog.csdnimg.cn/20200817170052892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><h4 id="删除情景2-1-2：替换结点的兄弟结点是黑结点"><a href="#删除情景2-1-2：替换结点的兄弟结点是黑结点" class="headerlink" title="删除情景2.1.2：替换结点的兄弟结点是黑结点"></a>删除情景2.1.2：替换结点的兄弟结点是黑结点</h4>当兄弟结点为黑时，其父结点和子结点的具体颜色也无法确定（如果也不考虑自底向上的情况，子结点非红即为叶子结点Nil，Nil结点为黑结点），此时又得考虑多种子情景。<h5 id="删除情景2-1-2-1：替换结点的兄弟结点的右子结点是红结点，左子结点任意颜色"><a href="#删除情景2-1-2-1：替换结点的兄弟结点的右子结点是红结点，左子结点任意颜色" class="headerlink" title="删除情景2.1.2.1：替换结点的兄弟结点的右子结点是红结点，左子结点任意颜色"></a>删除情景2.1.2.1：替换结点的兄弟结点的右子结点是红结点，左子结点任意颜色</h5>即将删除的左子树的一个黑色结点，显然左子树的黑色结点少1了，然而右子树又又红色结点，那么我们直接向右子树“借”个红结点来补充黑结点就好啦，此时肯定需要用旋转处理了。如图22所示。<br>处理：</li><li>将S的颜色设为P的颜色</li><li>将P设为黑色</li><li>将SR设为黑色</li><li>对P进行左旋<br><img src="https://img-blog.csdnimg.cn/20200817170143162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>平衡后的图怎么不满足红黑树的性质？前文提醒过，R是即将替换的，它还参与树的自平衡，平衡后再替换到删除结点的位置，所以R最终可以看作是删除的。另外图2.1.2.1是考虑到第一次替换和自底向上处理的情况，如果只考虑第一次替换的情况，根据红黑树性质，SL肯定是红色或为Nil，所以最终结果树是平衡的。如果是自底向上处理的情况，同样，每棵子树都保持平衡状态，最终整棵树肯定是平衡的。后续的情景同理，不做过多说明了。<h5 id="删除情景2-1-2-2：替换结点的兄弟结点的右子结点为黑结点，左子结点为红结点"><a href="#删除情景2-1-2-2：替换结点的兄弟结点的右子结点为黑结点，左子结点为红结点" class="headerlink" title="删除情景2.1.2.2：替换结点的兄弟结点的右子结点为黑结点，左子结点为红结点"></a>删除情景2.1.2.2：替换结点的兄弟结点的右子结点为黑结点，左子结点为红结点</h5>兄弟结点所在的子树有红结点，我们总是可以向兄弟子树借个红结点过来，显然该情景可以转换为情景2.1.2.1。图如23所示。<br>处理：</li><li>将S设为红色</li><li>将SL设为黑色</li><li>对S进行右旋，得到情景2.1.2.1</li><li>进行情景2.1.2.1的处理<br><img src="https://img-blog.csdnimg.cn/20200817170221155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><h5 id="删除情景2-1-2-3：替换结点的兄弟结点的子结点都为黑结点"><a href="#删除情景2-1-2-3：替换结点的兄弟结点的子结点都为黑结点" class="headerlink" title="删除情景2.1.2.3：替换结点的兄弟结点的子结点都为黑结点"></a>删除情景2.1.2.3：替换结点的兄弟结点的子结点都为黑结点</h5>好了，此次兄弟子树都没红结点“借”了，兄弟帮忙不了，找父母呗，这种情景我们把兄弟结点设为红色，再把父结点当作替代结点，自底向上处理，去找父结点的兄弟结点去“借”。但为什么需要把兄弟结点设为红色呢？显然是为了在P所在的子树中保证平衡（R即将删除，少了一个黑色结点，子树也需要少一个），后续的平衡工作交给父辈们考虑了，还是那句，当每棵子树都保持平衡时，最终整棵总是平衡的。<br>处理：</li><li>将S设为红色</li><li>把P作为新的替换结点</li><li>重新进行删除结点情景处理<br><img src="https://img-blog.csdnimg.cn/2020081717025457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><h3 id="删除情景2-2：替换结点是其父结点的右子结点"><a href="#删除情景2-2：替换结点是其父结点的右子结点" class="headerlink" title="删除情景2.2：替换结点是其父结点的右子结点"></a>删除情景2.2：替换结点是其父结点的右子结点</h3>好啦，右边的操作也是方向相反，不做过多说明了，相信理解了删除情景2.1后，肯定可以理解2.2。<h4 id="删除情景2-2-1：替换结点的兄弟结点是红结点"><a href="#删除情景2-2-1：替换结点的兄弟结点是红结点" class="headerlink" title="删除情景2.2.1：替换结点的兄弟结点是红结点"></a>删除情景2.2.1：替换结点的兄弟结点是红结点</h4>处理：</li><li>将S设为黑色</li><li>将P设为红色</li><li>对P进行右旋，得到情景2.2.2.3</li><li>进行情景2.2.2.3的处理<br><img src="https://img-blog.csdnimg.cn/20200817170431232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><h4 id="删除情景2-2-2：替换结点的兄弟结点是黑结点"><a href="#删除情景2-2-2：替换结点的兄弟结点是黑结点" class="headerlink" title="删除情景2.2.2：替换结点的兄弟结点是黑结点"></a>删除情景2.2.2：替换结点的兄弟结点是黑结点</h4><h5 id="删除情景2-2-2-1：替换结点的兄弟结点的左子结点是红结点，右子结点任意颜色"><a href="#删除情景2-2-2-1：替换结点的兄弟结点的左子结点是红结点，右子结点任意颜色" class="headerlink" title="删除情景2.2.2.1：替换结点的兄弟结点的左子结点是红结点，右子结点任意颜色"></a>删除情景2.2.2.1：替换结点的兄弟结点的左子结点是红结点，右子结点任意颜色</h5>处理：</li><li>将S的颜色设为P的颜色</li><li>将P设为黑色</li><li>将SL设为黑色</li><li>对P进行右旋<br><img src="https://img-blog.csdnimg.cn/20200817170500960.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><h5 id="删除情景2-2-2-2：替换结点的兄弟结点的左子结点为黑结点，右子结点为红结点"><a href="#删除情景2-2-2-2：替换结点的兄弟结点的左子结点为黑结点，右子结点为红结点" class="headerlink" title="删除情景2.2.2.2：替换结点的兄弟结点的左子结点为黑结点，右子结点为红结点"></a>删除情景2.2.2.2：替换结点的兄弟结点的左子结点为黑结点，右子结点为红结点</h5>处理：</li><li>将S设为红色</li><li>将SR设为黑色</li><li>对S进行左旋，得到情景2.2.2.1</li><li>进行情景2.2.2.1的处理<br><img src="https://img-blog.csdnimg.cn/20200817170530255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><h5 id="删除情景2-2-2-3：替换结点的兄弟结点的子结点都为黑结点"><a href="#删除情景2-2-2-3：替换结点的兄弟结点的子结点都为黑结点" class="headerlink" title="删除情景2.2.2.3：替换结点的兄弟结点的子结点都为黑结点"></a>删除情景2.2.2.3：替换结点的兄弟结点的子结点都为黑结点</h5>处理：</li><li>将S设为红色</li><li>把P作为新的替换结点</li><li>重新进行删除结点情景处理<br><img src="https://img-blog.csdnimg.cn/2020081717055789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></li></ul><p>综上，红黑树删除后自平衡的处理可以总结为：</p><ol><li>自己能搞定的自消化（情景1）</li><li>自己不能搞定的叫兄弟帮忙（除了情景1、情景2.1.2.3和情景2.2.2.3）</li><li>兄弟都帮忙不了的，通过父母，找远方亲戚（情景2.1.2.3和情景2.2.2.3）</li></ol><p>哈哈，是不是跟现实中很像，当我们有困难时，首先先自己解决，自己无力了总兄弟姐妹帮忙，如果连兄弟姐妹都帮不上，再去找远方的亲戚了。这里记忆应该会好记点～</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cookie、Session、Token、JWT分析</title>
    <link href="/2020/08/17/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT%E5%88%86%E6%9E%90/"/>
    <url>/2020/08/17/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是认证（Authentication）"><a href="#什么是认证（Authentication）" class="headerlink" title="什么是认证（Authentication）"></a>什么是认证（Authentication）</h1><p>通俗地讲就是<strong>验证当前用户的身份</strong>，证明“你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功）<br>互联网中的认证：</p><ol><li>用用户名密码登录；</li><li>输入验证码；</li><li>短信验证</li></ol><h1 id="什么是授权（Authorization）"><a href="#什么是授权（Authorization）" class="headerlink" title="什么是授权（Authorization）"></a>什么是授权（Authorization）</h1><p>授权是指用户授予第三方应用访问该用户某些资源的权限。包括：</p><ul><li>你在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限）</li><li>你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）</li></ul><p>实现授权的方式有：cookie，session，token，OAuth。</p><h1 id="什么是凭证（Credentials）"><a href="#什么是凭证（Credentials）" class="headerlink" title="什么是凭证（Credentials）"></a>什么是凭证（Credentials）</h1><p>实现认证和授权的前提是需要一种媒介（证书）来标记访问者的身份。</p><ul><li>在现实生活中，每个人都会有一张专属的居民身份证，是用于证明持有人身份的一种法定证件。通过身份证，我们可以办理手机卡/银行卡/个人贷款/交通出行等等，这就是认证的凭证。</li><li>在互联网应用中，一般网站（如掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。</li></ul><h1 id="什么是-Cookie"><a href="#什么是-Cookie" class="headerlink" title="什么是 Cookie"></a>什么是 Cookie</h1><p>HTTP是无状态的协议：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</p><p>cookie存储在客户端： cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</p><p>cookie 是不可跨域的： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。</p><p>cookie 重要的属性<br>|属性|说明  |<br>|–|–|<br>|name=value    |键值对，设置 Cookie 的名称及相对应的值，都必须是字符串类型 - 如果值为 Unicode 字符，需要为字符编码。- 如果值为二进制数据，则需要使用 BASE64 编码。|<br>|domain    |指定 cookie 所属域名，默认是当前域名|<br>|path    |指定 cookie 在哪个路径（路由）下生效，默认是 ‘/‘。如果设置为 /abc，则只有 /abc 下的路由可以访问到该 cookie，如：/abc/read。|<br>|maxAge    |cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。- 比 expires 好用。|<br>|expires    |过期时间，在设置的某个时间点后该 cookie 就会失效。一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除|<br>|secure|    该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。|<br>|httpOnly    |如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全|</p><h1 id="什么是-Session"><a href="#什么是-Session" class="headerlink" title="什么是 Session"></a>什么是 Session</h1><p>session 是另一种记录服务器和客户端会话状态的机制，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中。<br><img src="https://img-blog.csdnimg.cn/20200817090729219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>session 认证流程：</p><ul><li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session；</li><li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器；</li><li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名；</li><li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li></ul><p>根据以上流程可知，SessionID是连接Cookie和Session的一道桥梁，大部分系统是根据此原理来验证用户登录状态。</p><h2 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别"></a>Cookie 和 Session 的区别</h2><ul><li>安全性： Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。</li><li>存取值的类型不同：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。</li><li>有效期不同： Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。</li><li>存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。</li></ul><h1 id="什么是Token（令牌）"><a href="#什么是Token（令牌）" class="headerlink" title="什么是Token（令牌）"></a>什么是Token（令牌）</h1><h2 id="Acesss-Token"><a href="#Acesss-Token" class="headerlink" title="Acesss Token"></a>Acesss Token</h2><ul><li>访问资源接口（API）时所需要的资源凭证</li><li>简单 token 的组成： uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</li></ul><p>特点：</p><ul><li>服务端无状态化、可扩展性好</li><li>支持移动端设备</li><li>安全</li><li>支持跨程序调用</li></ul><p>token 的身份验证流程：<br><img src="https://img-blog.csdnimg.cn/20200817091507778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ol><li>客户端使用用户名跟密码请求登录；</li><li>服务端收到请求，去验证用户名与密码；</li><li>验证成功后，服务端会签发一个 token，并把这个 token 发送给客户端；</li><li>客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里；</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 token；</li><li>服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据；</li></ol><ul><li>每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里；</li><li>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库</li><li>token 完全由应用管理，所以它可以避开同源策略</li></ul><h2 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h2><p>refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。<br><img src="https://img-blog.csdnimg.cn/20200817092341622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。</p><p>Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。</p><h2 id="Token-和-Session-的区别"><a href="#Token-和-Session-的区别" class="headerlink" title="Token 和 Session 的区别"></a>Token 和 Session 的区别</h2><ul><li>Session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而 Token 是令牌，访问资源接口（API）时所需要的资源凭证。Token 使服务端无状态化，不会存储会话信息。</li><li>Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。</li><li>所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。</li></ul><h1 id="什么是-JWT"><a href="#什么是-JWT" class="headerlink" title="什么是 JWT"></a>什么是 JWT</h1><p>JSON Web Token（简称 JWT）是目前最流行的<strong>跨域认证</strong>解决方案。</p><p>JWT 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。</p><p>可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。</p><h2 id="JWT的认证流程"><a href="#JWT的认证流程" class="headerlink" title="JWT的认证流程"></a>JWT的认证流程</h2><p><img src="https://img-blog.csdnimg.cn/202008170953445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>1）前端通过表单将用户名和密码发送到后端接口。</p><p>2）后端核对用户名和密码后，将用户的id及其他非敏感信息作为JWT Payload，将其与头部分别进行base64编码后签名，生成JWT</p><p>3）后端将JWT字符串作为登录成功的结果返回给前端，前端可以将JWT存到localStorage或者cookie（不推荐放到cookie中，因为这样不能跨域，如果需要跨域，可以把JWT放在POST请求的数据体中），退出登录时，前端删除保存的JWT信息即可。</p><p>4）前端每次在请求时，将JWT放到HTTP请求头信息的Authorization字段中，使用Bearer模式添加JWT；</p><div class="hljs"><pre><code class="hljs http">GET /calendar/v1/events<span class="hljs-attribute">Host</span>: api.example.com<span class="hljs-attribute">Authorization</span>: Bearer &lt;token&gt;</code></pre></div><p>5）后端验证JWT的有效性</p><p>6）验证通过后，进行其他逻辑操作。</p><h2 id="Token-和-JWT-的区别"><a href="#Token-和-JWT-的区别" class="headerlink" title="Token 和 JWT 的区别"></a>Token 和 JWT 的区别</h2><p><strong>相同：</strong></p><ul><li>都是访问资源的令牌</li><li>都可以记录用户的信息</li><li>都是使服务端无状态化</li><li>都是只有验证成功后，客户端才能访问服务端上受保护的资源</li></ul><p><strong>区别：</strong></p><ul><li>Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。</li><li>JWT：将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</li></ul><h1 id="常见的前后端鉴权方式"><a href="#常见的前后端鉴权方式" class="headerlink" title="常见的前后端鉴权方式"></a>常见的前后端鉴权方式</h1><ul><li>Session-Cookie</li><li>Token 验证（包括 JWT，SSO）</li><li>OAuth2.0（开放授权）</li></ul><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="使用-cookie-时需要考虑的问题"><a href="#使用-cookie-时需要考虑的问题" class="headerlink" title="使用 cookie 时需要考虑的问题"></a>使用 cookie 时需要考虑的问题</h2><ul><li>因为存储在客户端，容易被客户端篡改，<strong>使用前需要验证合法性</strong></li><li><strong>不要存储敏感数据</strong>，比如用户密码，账户余额</li><li>使用<code>httpOnly</code>在一定程度上提高安全性</li><li>尽量<strong>减少 cookie 的体积</strong>，能存储的数据量不能超过 4kb</li><li>设置正确的 domain 和 path，<strong>减少数据传输</strong></li><li>cookie <strong>无法跨域</strong></li><li>一个浏览器针对一个网站最多存 20 个Cookie，浏览器一般只允许存放 300 个Cookie</li><li>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以<strong>移动端常用的是 token</strong><h2 id="使用-session-时需要考虑的问题"><a href="#使用-session-时需要考虑的问题" class="headerlink" title="使用 session 时需要考虑的问题"></a>使用 session 时需要考虑的问题</h2></li><li>将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要<strong>在服务端定期的去清理过期的 session</strong></li><li>当网站采用集群部署的时候，会遇到多台 web 服务器之间如何做 <strong>session 共享</strong>的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。</li><li>当多个应用要共享 session 时，除了以上问题，还会遇到<strong>跨域</strong>问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。</li><li>sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？ 一般会把 sessionId 跟在 url 参数后面,即<strong>重写 url</strong>，所以 session 不一定非得需要靠 cookie 实现</li><li>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token<h2 id="使用-token-时需要考虑的问题"><a href="#使用-token-时需要考虑的问题" class="headerlink" title="使用 token 时需要考虑的问题"></a>使用 token 时需要考虑的问题</h2></li><li>如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。</li><li>token 完全由应用管理，所以它可以避开同源策略</li><li><strong>token 可以避免 CSRF 攻击</strong>(因为不需要 cookie 了)</li><li>移动端常用的是 token<h2 id="使用-JWT-时需要考虑的问题"><a href="#使用-JWT-时需要考虑的问题" class="headerlink" title="使用 JWT 时需要考虑的问题"></a>使用 JWT 时需要考虑的问题</h2></li><li>因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li><li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。<br>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li><li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li><li>JWT 最大的优势是<strong>服务器不再需要存储 Session</strong>，使得服务器<strong>认证鉴权业务可以方便扩展</strong>。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。</li><li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，<strong>JWT的有效期应该设置得比较短</strong>。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li><li>JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。</li><li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要<strong>使用 HTTPS 协议传输</strong>。<h2 id="使用加密算法时需要考虑的问题"><a href="#使用加密算法时需要考虑的问题" class="headerlink" title="使用加密算法时需要考虑的问题"></a>使用加密算法时需要考虑的问题</h2></li><li>绝不要以明文存储密码；</li><li>永远使用 <strong>哈希算法</strong> 来处理密码，绝不要使用 Base64 或其他编码方式来存储密码，这和以明文存储密码是一样的，使用哈希，而不要使用编码。编码以及加密，都是双向的过程，而密码是保密的，应该只被它的所有者知道， 这个过程必须是单向的。哈希正是用于做这个的，从来没有解哈希这种说法， 但是编码就存在解码，加密就存在解密。</li><li>绝不要使用弱哈希或已被破解的哈希算法，像 MD5 或 SHA1 ，只使用<strong>强密码哈希算法</strong>。</li><li>绝不要以明文形式显示或发送密码，即使是对密码的所有者也应该这样。如果你需要 “忘记密码” 的功能，可以随机生成一个新的 一次性的（这点很重要）密码，然后把这个密码发送给用户。</li></ul><h2 id="分布式架构下-session-共享方案"><a href="#分布式架构下-session-共享方案" class="headerlink" title="分布式架构下 session 共享方案"></a>分布式架构下 session 共享方案</h2><h3 id="1-session-复制"><a href="#1-session-复制" class="headerlink" title="1. session 复制"></a>1. session 复制</h3><p>任何一个服务器上的 session 发生改变（增删改），该节点会<strong>把这个 session 的所有内容序列化，然后广播给所有其它节点</strong>，不管其他服务器需不需要 session ，以此来保证 session 同步。</p><ul><li>优点： 可容错，各个服务器间 session 能够实时响应。</li><li>缺点： 会对<strong>网络负荷</strong>造成一定压力，如果 session 量大的话可能会造成<strong>网络堵塞</strong>，拖慢服务器性能。</li></ul><h3 id="2-粘性-session-IP-绑定策略"><a href="#2-粘性-session-IP-绑定策略" class="headerlink" title="2. 粘性 session /IP 绑定策略"></a>2. 粘性 session /IP 绑定策略</h3><p>采用 Ngnix 中的 ip_hash 机制，将某个 ip的所有请求都定向到同一台服务器上，即将用户与服务器绑定。 用户第一次请求时，负载均衡器将用户的请求转发到了 A 服务器上，如果负载均衡器设置了粘性 session 的话，那么用<strong>户以后的每次请求都会转发到 A 服务器上</strong>，相当于把用户和 A 服务器粘到了一块，这就是粘性 session 机制。</p><ul><li>优点： 简单，不需要对 session 做任何处理。</li><li>缺点： 缺乏容错性，如果当前访问的服务器发生故障，用户被转移到第二个服务器上时，他的 session 信息都将失效。</li><li>适用场景： 发生故障对客户产生的影响较小；服务器发生故障是低概率事件 。</li><li>实现方式： 以 Nginx 为例，在 upstream 模块配置 ip_hash 属性即可实现粘性 session。</li></ul><h3 id="3-session-共享（常用）"><a href="#3-session-共享（常用）" class="headerlink" title="3. session 共享（常用）"></a>3. session 共享（常用）</h3><p>使用分布式缓存方案比如 Memcached 、Redis 来缓存 session，但是要求 Memcached 或 Redis 必须是集群。<br>把 session 放到 Redis 中存储，虽然架构上变得复杂，并且需要多访问一次 Redis ，但是这种方案带来的好处也是很大的：</p><ul><li>实现了 session 共享；</li><li>可以水平扩展（增加 Redis 服务器）；</li><li>服务器重启 session 不丢失（不过也要注意 session 在 Redis 中的刷新/失效机制）；</li><li>不仅可以跨服务器 session 共享，甚至可以跨平台（例如网页端和 APP 端）<br><img src="https://img-blog.csdnimg.cn/20200817101121664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><h3 id="4-session-持久化"><a href="#4-session-持久化" class="headerlink" title="4. session 持久化"></a>4. session 持久化</h3>将 session 存储到数据库中，保证 session 的持久化；<br>优点： 服务器出现问题，session 不会丢失；<br>缺点： 如果网站的访问量很大，把 session 存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库。</li></ul><p><strong>只要关闭浏览器 ，session 真的就消失了？</strong></p><p>不对。对 session 来说，除非程序通知服务器删除一个 session，否则服务器会一直保留，程序一般都是在用户做 log off 的时候发个指令去删除 session。然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分 session 机制都使用会话 cookie 来保存 session id，而关闭浏览器后这个 session id 就消失了，再次连接服务器时也就无法找到原来的 session。如果服务器设置的 cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 session id 发送给服务器，则再次打开浏览器仍然能够打开原来的 session。恰恰是由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。</p><p>参考资料：</p><ol><li><a href="https://juejin.im/post/6844904034181070861" target="_blank" rel="noopener">傻傻分不清之 Cookie、Session、Token、JWT</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java EE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jav EE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发之CountDownLatch</title>
    <link href="/2020/08/05/Java%E5%B9%B6%E5%8F%91%E4%B9%8BCountDownLatch/"/>
    <url>/2020/08/05/Java%E5%B9%B6%E5%8F%91%E4%B9%8BCountDownLatch/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://www.cnblogs.com/fengzheng/p/9153720.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengzheng/p/9153720.html</a></p><h1 id="CountDownLatch的使用"><a href="#CountDownLatch的使用" class="headerlink" title="CountDownLatch的使用"></a>CountDownLatch的使用</h1><p>作用：当一个或多个线程需要另外一个或多个线程完成后，再开始执行，比如主线程需要等待一个子线程完成环境相关配置的加载工作，主线程才继续执行，就可以利用CountDownLatch来实现。<br>例如下面这个例子，首先实例化一个CountDownLatch，参数可以理解为一个计数器，这里为1，然后主线程执行，调用worker子线程，接着调用CountDownLatch的await()方法，表示阻塞主线程，当子线程执行完后，finally块调用countDown()方法，表示一个等待已经完成，把计数器减一，直到减为0，主线程又开始执行。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountDownLatchTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        System.out.println(<span class="hljs-string">"主线程开始。。。"</span>);        Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Worker());        thread.start();        System.out.println(<span class="hljs-string">"主线程等待。。。"</span>);        System.out.println(latch.toString());        latch.await();        System.out.println(latch.toString());        System.out.println(<span class="hljs-string">"主线程继续。。。"</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(<span class="hljs-string">"子线程任务正在执行。。。"</span>);            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">2000</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">finally</span> &#123;                latch.countDown();            &#125;        &#125;    &#125;&#125;</code></pre></div><p>执行结果：</p><div class="hljs"><pre><code class="hljs java">主线程开始。。。主线程等待。。。java.util.concurrent.CountDownLatch@<span class="hljs-number">74</span>a14482[Count = <span class="hljs-number">1</span>]子线程任务正在执行。。。java.util.concurrent.CountDownLatch@<span class="hljs-number">74</span>a14482[Count = <span class="hljs-number">0</span>]主线程继续。。。</code></pre></div><h1 id="AQS的原理"><a href="#AQS的原理" class="headerlink" title="AQS的原理"></a>AQS的原理</h1><p> AQS 全称 <code>AbstractQueuedSynchronizer</code>，是<code>java.util.concurrent</code>中提供的一种高效且可扩展的同步机制。它可以用来实现可以依赖 int 状态的同步器，获取和释放参数以及一个内部FIFO等待队列，除了<code>CountDownLatch</code>，<code>ReentrantLock</code>、<code>Semaphore</code> 等功能实现都使用了它。</p><p>接下来用 CountDownLatch 来分析一下 AQS 的实现。建议看文章的时候先大致看一下源码，有助于理解下面所说的内容。</p><p>在我们的方法中调用 <code>awit()</code>和<code>countDown()</code>的时候，发生了几个关键的调用关系，我画了一个方法调用图。<br><img src="https://img-blog.csdnimg.cn/20200805115252244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>首先在CountDownLatch类内部定义了一个<code>Sync</code>内部类，这个内部类继承自AbstractQueuedSynchronizer，并且重写了方法<code>tryAcquireShared</code>和<code>tryReleaseShared</code>，例如当调用await()方法时，CountDownLatch会调用内部类Sync的<code>acquireQueuedInterruptibly()</code>方法，然后在这个方法中会调用tryAcquireShared方法，这个方法就是CountDownLatch的内部类Sync里重写的AbstractQueuedSynchronizer的方法，调用countDown()方法同理。<br>这种方法是使用AbstractQueuedSynchronizer的标准化方法，大致分为两步：</p><ol><li>内部持有继承自AbstractQueuedSynchronizer的对象Sync；</li><li>并在Sync内重写AbstractQueuedSynchronizer protected的部分或全部方法，这些方法包括如下几个：<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();  &#125;  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();  &#125;  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();  &#125;  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();  &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();  &#125;</code></pre></div>之所以要求子类重写这些方法，是为了让使用者（这里的使用者指 CountDownLatch 等）可以在其中加入自己的判断逻辑，例如 CountDownLatch 在 <code>tryAcquireShared</code>中加入了判断，判断 state 是否不为0，如果不为0，才符合调用条件。</li></ol><p><code>tryAcquire</code>和<code>tryRelease</code>是对应的，前者是独占模式获取，后者是独占模式释放。</p><p><code>tryAcquireShared</code>和<code>tryReleaseShared</code>是对应的，前者是共享模式获取，后者是共享模式释放。</p><p>我们看到 CountDownLatch 重写的方法 tryAcquireShared 实现如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;            <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;        &#125;</code></pre></div><p>判断 state 值是否为0，为0 返回1，否则返回 -1。state 值是 AbstractQueuedSynchronizer 类中的一个 volatile 变量。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;</code></pre></div><p>在 CountDownLatch 中这个 state 值就是计数器，在调用 await 方法的时候，将值赋给 state 。</p><h3 id="等待线程入队"><a href="#等待线程入队" class="headerlink" title="等待线程入队"></a>等待线程入队</h3><p>根据上面的逻辑，调用 await() 方法时，先去获取 state 的值，当计数器不为0的时候，说明还有需要等待的线程在运行，则调用<code>doAcquireSharedInterruptibly</code>方法，进来执行的第一个动作就是尝试加入等待队列 ，即调用 <code>addWaiter()</code>方法。<br>到这里就走到了 AQS 的核心部分，AQS 用内部的一个<code>Node</code>类维护一个 <code>CHL Node FIFO</code>队列。将当前线程加入等待队列，并通过 <code>parkAndCheckInterrupt（）</code>方法实现当前线程的阻塞。下面一大部分都是在说明 CHL 队列的实现，里面用 CAS 实现队列出入不会发生阻塞。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-comment">//加入等待队列       </span>    <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">// 进入 CAS 循环</span>    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-comment">//当一个节点(关联一个线程)进入等待队列后， 获取此节点的 prev 节点 </span>            <span class="hljs-keyword">final</span> Node p = node.predecessor();            <span class="hljs-comment">// 如果获取到的 prev 是 head，也就是队列中第一个等待线程</span>            <span class="hljs-keyword">if</span> (p == head) &#123;                <span class="hljs-comment">// 再次尝试申请 反应到 CountDownLatch 就是查看是否还有线程需要等待(state是否为0)</span>                <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);                <span class="hljs-comment">// 如果 r &gt;=0 说明没有线程需要等待了 state==0</span>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;                    <span class="hljs-comment">//尝试将第一个线程关联的节点设置为 head </span>                    setHeadAndPropagate(node, r);                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>                    failed = <span class="hljs-keyword">false</span>;                    <span class="hljs-keyword">return</span>;                &#125;            &#125;            <span class="hljs-comment">//经过自旋tryAcquireShared后，state还不为0，就会到这里，第一次的时候，waitStatus是0，那么node的waitStatus就会被置为SIGNAL，第二次再走到这里，就会用LockSupport的park方法把当前线程阻塞住</span>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (failed)            cancelAcquire(node);    &#125;&#125;</code></pre></div><p>addWaiter()方法，就是将当前线程加入等待队列，源码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/** Marker to indicate a node is waiting in shared mode */</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node(); <span class="hljs-comment">/** Marker to indicate a node is waiting in exclusive mode */</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;<span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;        Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);        <span class="hljs-comment">// 尝试快速入队操作，因为大多数时候尾节点不为 null</span>        Node pred = tail;        <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;            node.prev = pred;            <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;                pred.next = node;                <span class="hljs-keyword">return</span> node;            &#125;        &#125;    <span class="hljs-comment">//如果尾节点为空(也就是队列为空) 或者尝试CAS入队失败(由于并发原因)，进入enq方法</span>        enq(node);        <span class="hljs-keyword">return</span> node;    &#125;</code></pre></div><p>上面是向等待队列中添加等待者（waiter）的方法，首先构造一个Node实体，参数为当前线程和一个mode，这个mode有两种形式，一个是SHARED，一个是EXCLUSIVE，然后执行下面的入队操作 addWaiter，和 enq() 方法的 else 分支操作是一样的，这里的操作如果成功了，就不用再进到 enq() 方法的循环中去了，可以提高性能。如果没有成功，再调用 enq() 方法。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;    <span class="hljs-comment">// 死循环+CAS保证所有节点都入队</span>        <span class="hljs-keyword">for</span> (;;) &#123;            Node t = tail;            <span class="hljs-comment">// 如果队列为空 设置一个空节点作为 head</span>            <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// Must initialize</span>                <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))                    tail = head;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//加入队尾</span>                node.prev = t;                <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;                    t.next = node;                    <span class="hljs-keyword">return</span> t;                &#125;            &#125;        &#125;    &#125;</code></pre></div><p>说明：循环加 CAS 操作是实现乐观锁的标准方式，CAS 是为了实现原子操作而出现的，所谓的原子操作指操作执行期间，不会受其他线程的干扰。Java 实现的 CAS 是调用 unsafe 类提供的方法，底层是调用 c++ 方法，直接操作内存，在 cpu 层面加锁，直接对内存进行操作。<br>上面是AQS等待队列入队方法，操作在无限循环中进行，如果入队成功则返回新的队尾节点，否则一直自旋，直到入队成功，假设入队的节点为node，上来直接进入循环，在循环中，先拿到尾节点。</p><ol><li>if分支：如果尾节点是null，说明现在队列中还没有等待线程，则尝试CAS操作将头节点初始化，然后将尾节点也设置为头节点，因为初始化的时候头尾是同一个，这和AQS的设计有关，AQS默认要有一个虚拟节点，此时尾节点不再为空，循环继续，进入else分支；</li><li>else分支：如果尾节点不为null，node.prev = t，也就是将当前尾节点设置为待入队节点的前置节点，然后又是利用CAS操作，将待入队的节点设置为队列的尾节点，如果CAS返回false，表示未设置成功，继续循环设置，设置成功后将之前的尾节点（也就是倒数第二个节点）的next属性设置为当前尾节点，然后返回当前尾节点，退出循环。</li></ol><p><code>setHeadAndPropagate</code>方法负责将自旋等待或被LockSupport阻塞的线程唤醒。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> propagate)</span> </span>&#123;    <span class="hljs-comment">//备份现在的 head</span>        Node h = head;      <span class="hljs-comment">//抢到锁的线程被唤醒 将这个节点设置为head</span>        setHead(node)    <span class="hljs-comment">// propagate 一般都会大于0 或者存在可被唤醒的线程</span>        <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||            (h = head) == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;            Node s = node.next;            <span class="hljs-comment">// 只有一个节点 或者是共享模式 释放所有等待线程 各自尝试抢占锁</span>            <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.isShared())                doReleaseShared();        &#125;    &#125;</code></pre></div><p>Node对象中有一个属性是waitStatus，它有四种状态，分别是：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//线程已被 cancelled ，这种状态的节点将会被忽略，并移出队列</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED =  <span class="hljs-number">1</span>;<span class="hljs-comment">// 表示当前线程已被挂起，并且后继节点可以尝试抢占锁</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL    = -<span class="hljs-number">1</span>;<span class="hljs-comment">//线程正在等待某些条件</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;<span class="hljs-comment">//共享模式下 无条件所有等待线程尝试抢占锁</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;</code></pre></div><h3 id="等待线程被唤醒"><a href="#等待线程被唤醒" class="headerlink" title="等待线程被唤醒"></a>等待线程被唤醒</h3><p>当执行CountDownLatch的countDown()方法，将计数器减一，也就是state减一，当减到0的时候，等待队列中的线程被释放，是调用AQS的releaseShared方法来实现的。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// AQS类</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;    <span class="hljs-comment">// arg 为固定值 1</span>    <span class="hljs-comment">// 如果计数器state 为0 返回true，前提是调用 countDown() 之前不能已经为0</span>        <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;            <span class="hljs-comment">// 唤醒等待队列的线程</span>            doReleaseShared();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;<span class="hljs-comment">// CountDownLatch 重写的方法</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;            <span class="hljs-comment">// Decrement count; signal when transition to zero</span>    <span class="hljs-comment">// 依然是循环+CAS配合 实现计数器减1</span>            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-keyword">int</span> c = getState();                <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                <span class="hljs-keyword">int</span> nextc = c-<span class="hljs-number">1</span>;                <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))                    <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;            &#125;        &#125;<span class="hljs-comment">/// AQS类</span> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (;;) &#123;            Node h = head;            <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;                <span class="hljs-keyword">int</span> ws = h.waitStatus;                <span class="hljs-comment">// 如果节点状态为SIGNAL，则他的next节点也可以尝试被唤醒</span>                <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;                    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))                        <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span>                    unparkSuccessor(h);                &#125;                <span class="hljs-comment">// 将节点状态设置为PROPAGATE，表示要向下传播，依次唤醒</span>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;                         !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))                    <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span>            &#125;            <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span>                <span class="hljs-keyword">break</span>;        &#125;    &#125;</code></pre></div><p>因为是共享型的，当计数器为0后，会唤醒等待队列中的所有线程，所有调用了await()方法的线程都被唤醒，并发执行，这种情况对应到的场景是：有多个线程都需等待一些动作完成，比如一个线程完成初始化动作，其他五个线程都需要用到初始化的结果，那么在初始化线程调用countDown之前，其他5个线程都处在等待状态，一旦初始化线程调用了countDown，其他5个线程都被唤醒，开始执行。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1、AQS 分为独占模式和共享模式，CountDownLatch 使用了它的共享模式。<br>2、AQS 当第一个等待线程（被包装为 Node）要入队的时候，要保证存在一个 head 节点，这个 head 节点不关联线程，也就是一个虚节点。<br>3、当队列中的等待节点（关联线程的，非 head 节点）抢到锁，将这个节点设置为 head 节点。<br>4、第一次自旋抢锁失败后，waitStatus 会被设置为 -1（SIGNAL），第二次再失败，就会被 LockSupport 阻塞挂起。<br>5、如果一个节点的前置节点为 SIGNAL 状态，则这个节点可以尝试抢占锁。</p>]]></content>
    
    
    <categories>
      
      <category>语言相关</category>
      
      <category>Java进阶</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发之AQS详解</title>
    <link href="/2020/08/05/Java%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/08/05/Java%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>Java并发包（JUC）中提供了很多并发工具，比如：ReentrantLock，Semaphore，CountDownLatch，FutureTask等，它们的实现都用到了一个共同的基类-AbstractQueuedSynchronizer，简称AQS。AQS是一个用来构建锁和同步其他组件的基础框架，使用AQS能简单且高效地构建出应用广泛的同步器。</p><h1 id="基本实现原理"><a href="#基本实现原理" class="headerlink" title="基本实现原理"></a>基本实现原理</h1><p>AQS使用一个int成员变量<strong>state</strong>来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;<span class="hljs-comment">//共享变量，使用volatile修饰保证内存可见性</span></code></pre></div><p>状态信息通过protected类型的getState，setState，compareAndSetState进行操作。<br>AQS支持两种同步方式：</p><ul><li>独占式</li><li>共享式</li></ul><p>这样方便使用者实现不同类型的同步组件，独占式有ReentrantLock，共享式有Semaphore，CountDownLatch，组合式有ReentrantReadWriteLock，总之，AQS为使用者提供了底层支持，如何组装实现，使用者可以自由发挥。<br>同步器的设计是基于<strong>模板方法</strong>模式的，一般的使用方式如下：</p><ol><li>使用者继承AbstractQueuedSynchronizer并重写指定的方法，这些重写方法就是对共享资源state的释放和获取；</li><li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。<br>我们来看看AQS定义的这些可重写的方法：</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//独占式获取同步状态，试着获取，成功返回true，反之为false</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> ；</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-comment">//独占式释放同步状态，等待中的其他线程此时将有机会获取到同步状态；</span></span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> ；</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-comment">//共享式获取同步状态，返回值大于等于0，代表获取成功；反之获取失败；</span></span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> ；</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-comment">//共享式释放同步状态，成功为true，失败为false</span></span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> ；</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-comment">//是否在独占模式下被线程占用</span></span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> ；</span></code></pre></div><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>首先，我们需要继承<code>AbstractQueuedSynchronizer</code>这个类，然后根据我们的需求去重写相应的方法，比如要实现一个独占锁，那就去重写tryAcquire，tryRelease方法，要实现共享锁，就去重写tryAcquireShared，tryReleaseShared；最后，在我们的组件中调用AQS中的模板方法就可以了，而这些模板方法就会调用我们之前重写的那些方法，也就是说，我们只需要很小的工作量就可以实现自己的同步组件，重写的那些方法，仅仅是一些简单的对于共享资源state的获取和释放操作，至于像是获取资源失败，线程需要阻塞之类的操作，自然是AQS帮我们完成了。</p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>对于使用者来讲，我们无需关心获取资源失败，线程排队，线程阻塞/唤醒等一系列复杂的实现，这些都在AQS中为我们处理好了。我们只需要负责好自己的那个环节就好，也就是获取/释放共享资源state。AQS为我们定义好顶级逻辑的骨架，并提取出公用的线程入队列/出队列，阻塞/唤醒等一系列复杂逻辑的实现，将部分简单的可由使用者决定的操作逻辑延迟到子类中去实现即可。</p><h1 id="自定义同步器"><a href="#自定义同步器" class="headerlink" title="自定义同步器"></a>自定义同步器</h1><h2 id="同步器代码实现"><a href="#同步器代码实现" class="headerlink" title="同步器代码实现"></a>同步器代码实现</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mutex</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">/** 静态内部类，继承AQS */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span>&#123;        <span class="hljs-comment">/** 当状态为0的时候获取锁，CAS操作成功，则state状态为1 */</span>        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;            <span class="hljs-keyword">if</span>(compareAndSetState(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>))&#123;                setExclusiveOwnerThread(Thread.currentThread());                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">/** 释放锁，将同步状态置为0 */</span>        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;            <span class="hljs-keyword">if</span>(getState() == <span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();            &#125;            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);            setState(<span class="hljs-number">0</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">/** 是否处于占用状态 */</span>        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;        &#125;    &#125;        <span class="hljs-comment">/** 同步对象完成一系列复杂的操作，我们仅需指向它即可 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync = <span class="hljs-keyword">new</span> Sync();    <span class="hljs-comment">/** 加锁操作，代理到acquire(模板方法)上就行，acquire会调用我们重写的tryAcquire方法 */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>&#123;        sync.acquire(<span class="hljs-number">1</span>);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>&#123;        sync.release(<span class="hljs-number">1</span>);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLocked</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> sync.isHeldExclusively();    &#125;&#125;</code></pre></div><h2 id="同步器代码测试"><a href="#同步器代码测试" class="headerlink" title="同步器代码测试"></a>同步器代码测试</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutexTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CyclicBarrier barrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">31</span>);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Mutex mutex = <span class="hljs-keyword">new</span> Mutex();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> BrokenBarrierException, InterruptedException </span>&#123;        <span class="hljs-comment">//说明：我们启用30个线程，每个线程对i自加10000次，同步正常的话，最终结果应为30000；</span>        <span class="hljs-comment">//未加锁</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;            Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;                        increment1();                    &#125;                    <span class="hljs-keyword">try</span> &#123;                        barrier.await();<span class="hljs-comment">//等30个线程累加结束</span>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;);            t.start();        &#125;        barrier.await();        System.out.println(<span class="hljs-string">"未加锁：a="</span>+a);        <span class="hljs-comment">//加锁后</span>        <span class="hljs-comment">//重置CyclicBarrier</span>        barrier.reset();        a = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;                        increment2();                    &#125;                    <span class="hljs-keyword">try</span> &#123;                        barrier.await();                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;).start();        &#125;        barrier.await();        System.out.println(<span class="hljs-string">"加锁后：a="</span>+a);    &#125;    <span class="hljs-comment">/** 使用自定义的Mutex进行同步处理的a++ */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment2</span><span class="hljs-params">()</span> </span>&#123;        mutex.lock();        a++;        mutex.unlock();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment1</span><span class="hljs-params">()</span> </span>&#123;        a++;    &#125;&#125;</code></pre></div><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>AQS维护着一个共享资源state，通过内置的FIFO队列（<strong>CLH队列</strong>）来完成获取资源线程的排队工作，该队列由一个个的<code>Node</code>节点组成，每个Node节点维护一个prev引用和next引用，分别指向自己的前驱和后继节点，AQS维护两个指针，分别指向队列头部head和尾部tail。<br><img src="https://img-blog.csdnimg.cn/20200805092440146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>当线程获取资源失败（比如tryAcquire时试图设置state状态失败），会被构造成一个节点加入CLH队列中，同时当前线程会被阻塞在队列中（通过LockSupport.park实现，其实是等待态），当持有同步状态的线程释放同步状态时，会唤醒后继节点，然后此节点线程继续加入到对同步状态的争夺中。</p><h2 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h2><p>Node节点是AbstractQueuedSynchronizer中的一个<strong>静态内部类</strong>，其部分源码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;     <span class="hljs-comment">/** waitStatus值，表示线程已被取消（等待超时或者被中断）*/</span>      <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED =  <span class="hljs-number">1</span>;      <span class="hljs-comment">/** waitStatus值，表示后继线程需要被唤醒（unpaking）*/</span>      <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL    = -<span class="hljs-number">1</span>;      <span class="hljs-comment">/**waitStatus值，表示结点线程等待在condition上，当被signal后，会从等待队列转移到同步到队列中 */</span>      <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;     <span class="hljs-comment">/** waitStatus值，表示下一次共享式同步状态会被无条件地传播下去</span><span class="hljs-comment">      static final int PROPAGATE = -3;</span><span class="hljs-comment">      /** 等待状态，初始为0 */</span>      <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;      <span class="hljs-comment">/**当前结点的前驱结点 */</span>      <span class="hljs-keyword">volatile</span> Node prev;      <span class="hljs-comment">/** 当前结点的后继结点 */</span>      <span class="hljs-keyword">volatile</span> Node next;      <span class="hljs-comment">/** 与当前结点关联的排队中的线程 */</span>      <span class="hljs-keyword">volatile</span> Thread thread;      <span class="hljs-comment">/** ...... */</span>  &#125;</code></pre></div><h2 id="独占式"><a href="#独占式" class="headerlink" title="独占式"></a>独占式</h2><h3 id="获取同步状态：acquire"><a href="#获取同步状态：acquire" class="headerlink" title="获取同步状态：acquire()"></a>获取同步状态：acquire()</h3><p>lock方法一般会直接代理到acquire()上。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span>&#123;<span class="hljs-keyword">if</span>(!tryAcquire(arg) &amp;&amp; acuqireQueued(addWaiter(Node.EXCLUSIVE),arg))selfInterrupt();&#125;</code></pre></div><p><strong>代码逻辑：</strong><br>a. 首先，调用使用者重写的tryAcquire()方法，若返回true，意味着获取同步状态成功，后面的逻辑不再执行；若返回false，也就是获取同步状态失败，进入b步骤；<br>b. 此时，获取同步状态失败，构造独占式同步结点，通过addWatiter方法将此结点添加到同步队列的尾部（此时可能会有多个线程结点试图加入同步队列尾部，需要以线程安全的方式添加）；<br>c. 该结点在队列中尝试获取同步状态，若获取不到，则阻塞结点线程，直到被前驱结点唤醒或者被中断。</p><h4 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h4><p>为获取同步状态失败的线程，构造一个Node节点，添加到同步队列尾部。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;        Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);<span class="hljs-comment">//构造结点</span>        <span class="hljs-comment">//指向尾结点tail</span>        Node pred = tail;        <span class="hljs-comment">//如果尾结点不为空，CAS快速尝试在尾部添加，若CAS设置成功，返回；否则，enq。</span>        <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;            node.prev = pred;            <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;                pred.next = node;                <span class="hljs-keyword">return</span> node;            &#125;        &#125;        enq(node);        <span class="hljs-keyword">return</span> node;    &#125;</code></pre></div><p>先CAS快速设置，若失败，进入<code>enq()</code>方法。<br>将节点添加到同步队列尾部这个操作，同时可能会有多个线程尝试添加到尾部，是非线程安全的操作，以上代码可以看出，使用了compareAndSetTail这个CAS操作保证安全添加至尾节点。</p><h4 id="enq方法"><a href="#enq方法" class="headerlink" title="enq方法"></a>enq方法</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;        <span class="hljs-keyword">for</span> (;;) &#123;            Node t = tail;            <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">//如果队列为空，创建结点，同时被head和tail引用</span>                <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))                    tail = head;            &#125; <span class="hljs-keyword">else</span> &#123;                node.prev = t;                <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<span class="hljs-comment">//cas设置尾结点，不成功就一直重试</span>                    t.next = node;                    <span class="hljs-keyword">return</span> t;                &#125;            &#125;        &#125;    &#125;</code></pre></div><p>enq内部是个死循环，通过CAS设置尾节点，不成功就一直重试。<br>最后看下acquireQueued方法。</p><h4 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">for</span> (;;) &#123;<span class="hljs-comment">//死循环</span>                <span class="hljs-keyword">final</span> Node p = node.predecessor();<span class="hljs-comment">//找到当前结点的前驱结点</span>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="hljs-comment">//如果前驱结点是头结点，才tryAcquire，其他结点是没有机会tryAcquire的。</span>                    setHead(node);<span class="hljs-comment">//获取同步状态成功，将当前结点设置为头结点。</span>                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 方便GC</span>                    failed = <span class="hljs-keyword">false</span>;                    <span class="hljs-keyword">return</span> interrupted;                &#125;                <span class="hljs-comment">// 如果没有获取到同步状态，通过shouldParkAfterFailedAcquire判断是否应该阻塞，parkAndCheckInterrupt用来阻塞线程</span>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                    parkAndCheckInterrupt())                    interrupted = <span class="hljs-keyword">true</span>;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (failed)                cancelAcquire(node);        &#125;    &#125;</code></pre></div><p>acquireQueued内部也是一个死循环，只有前驱节点是头节点的节点，也就是第二个节点才有机会tryAcquire；若tryAcquire成功，表示获取同步状态成功，将此节点设置为头节点，若不是第二个节点，或者tryAcquire失败，则进入shouldParkAfterFailedAccquire去判断当前线程是否应该阻塞，若可以，调用parkAndCheckInterrupt阻塞当前线程，直到被中断或者被前驱节点唤醒，若还不能，继续循环。</p><h4 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h4><p>用来判断当前节点线程是否能休息</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;        <span class="hljs-comment">//获取前驱结点的wait值 </span>        <span class="hljs-keyword">int</span> ws = pred.waitStatus;        <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<span class="hljs-comment">//若前驱结点的状态是SIGNAL，意味着当前结点可以被安全地park</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// ws&gt;0，只有CANCEL状态ws才大于0。若前驱结点处于CANCEL状态，也就是此结点线程已经无效，从后往前遍历，找到一个非CANCEL状态的结点，将自己设置为它的后继结点</span>            <span class="hljs-keyword">do</span> &#123;                node.prev = pred = pred.prev;            &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);            pred.next = node;        &#125; <span class="hljs-keyword">else</span> &#123;              <span class="hljs-comment">// 若前驱结点为其他状态，将其设置为SIGNAL状态</span>            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;</code></pre></div><p>　　若shouldParkAfterFailedAcquire返回true，也就是当前结点的前驱结点为SIGNAL状态，则意味着当前结点可以放心休息，进入parking状态了。parkAndCheckInterrupt阻塞线程并处理中断。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;   LockSupport.park(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//使用LockSupport使线程进入阻塞状态</span>    <span class="hljs-keyword">return</span> Thread.interrupted();<span class="hljs-comment">// 线程是否被中断过</span>&#125;</code></pre></div><p>至此，关于acquire的方法源码已经分析完毕，我们来简单总结下：</p><ul><li>首先tryAcquire获取同步状态，成功则直接返回；否则，进入下一环节；</li><li>线程获取同步状态失败，就构造一个结点，加入同步队列中，这个过程要保证线程安全；</li><li>加入队列中的结点线程进入自旋状态，若是老二结点（即前驱结点为头结点），才有机会尝试去获取同步状态；否则，当其前驱结点的状态为SIGNAL，线程便可安心休息，进入阻塞状态，直到被中断或者被前驱结点唤醒。<h3 id="释放同步状态：release"><a href="#释放同步状态：release" class="headerlink" title="释放同步状态：release()"></a>释放同步状态：release()</h3>当前线程执行完自己的逻辑之后，需要释放同步状态。</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<span class="hljs-comment">//调用使用者重写的tryRelease方法，若成功，唤醒其后继结点，失败则返回false</span>            Node h = head;            <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)                unparkSuccessor(h);<span class="hljs-comment">//唤醒后继结点</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;</code></pre></div><h4 id="UnparkSuccessor：唤醒后继节点"><a href="#UnparkSuccessor：唤醒后继节点" class="headerlink" title="UnparkSuccessor：唤醒后继节点"></a>UnparkSuccessor：唤醒后继节点</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;        <span class="hljs-comment">//获取wait状态</span>        <span class="hljs-keyword">int</span> ws = node.waitStatus;        <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)            compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<span class="hljs-comment">// 将等待状态waitStatus设置为初始值0</span>        Node s = node.next;<span class="hljs-comment">//后继结点</span>        <span class="hljs-comment">//若后继结点为空，或状态为CANCEL（已失效），则从后尾部往前遍历找到一个处于正常阻塞状态的结点进行唤醒</span>        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;            s = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">for</span> (Node t = tail; t != <span class="hljs-keyword">null</span> &amp;&amp; t != node; t = t.prev)                <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)                    s = t;        &#125;        <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)            LockSupport.unpark(s.thread);<span class="hljs-comment">//使用LockSupprot唤醒结点对应的线程</span>    &#125;</code></pre></div><p>release的同步状态相对简单，需要找到头节点的后继节点进行唤醒，若后继节点为空或处于CANNEL状态，从后往前遍历找寻一个正常的节点，唤醒其对应线程。</p><h2 id="共享式"><a href="#共享式" class="headerlink" title="共享式"></a>共享式</h2><p>共享式地获取同步状态，对于独占式同步组件来说，同一时刻只有一个线程能够获取到同步状态，其他线程都得排队等待，而对于共享式同步组件来说，同一时刻可以有很多线程同时获取到同步状态，其待重写的尝试获取同步状态的方法为<code>tryAcquireShared</code>。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(); &#125;</code></pre></div><ol><li>当返回值大于0时，表示获取同步状态成功，同时还有剩余同步状态可供其他线程获取；</li><li>当返回值等于0时，表示获取同步状态成功，但没有可用同步状态了；</li><li>当返回值小于0时，表示获取同步状态失败。</li></ol><h3 id="获取同步状态：acquireShared"><a href="#获取同步状态：acquireShared" class="headerlink" title="获取同步状态：acquireShared"></a>获取同步状态：acquireShared</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//返回值小于0，获取同步状态失败，排队去；获取同步状态成功，直接返回去干自己的事儿。</span>            doAcquireShared(arg);    &#125;</code></pre></div><h4 id="doAcquireShared"><a href="#doAcquireShared" class="headerlink" title="doAcquireShared"></a>doAcquireShared</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);<span class="hljs-comment">//构造一个共享结点，添加到同步队列尾部。若队列初始为空，先添加一个无意义的傀儡结点，再将新节点添加到队列尾部。</span>        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//是否获取成功</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//线程parking过程中是否被中断过</span>            <span class="hljs-keyword">for</span> (;;) &#123;<span class="hljs-comment">//死循环</span>                <span class="hljs-keyword">final</span> Node p = node.predecessor();<span class="hljs-comment">//找到前驱结点</span>                <span class="hljs-keyword">if</span> (p == head) &#123;<span class="hljs-comment">//头结点持有同步状态，只有前驱是头结点，才有机会尝试获取同步状态</span>                    <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);<span class="hljs-comment">//尝试获取同步装填</span>                    <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//r&gt;=0,获取成功</span>                        setHeadAndPropagate(node, r);<span class="hljs-comment">//获取成功就将当前结点设置为头结点，若还有可用资源，传播下去，也就是继续唤醒后继结点</span>                        p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 方便GC</span>                        <span class="hljs-keyword">if</span> (interrupted)                            selfInterrupt();                        failed = <span class="hljs-keyword">false</span>;                        <span class="hljs-keyword">return</span>;                    &#125;                &#125;                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<span class="hljs-comment">//是否能安心进入parking状态</span>                    parkAndCheckInterrupt())<span class="hljs-comment">//阻塞线程</span>                    interrupted = <span class="hljs-keyword">true</span>;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (failed)                cancelAcquire(node);        &#125;    &#125;</code></pre></div><p>大体逻辑与独占式的acquireQueued差距不大，只不过由于是共享式，<strong>会有多个线程同时获取到同步状态，所以当排队中的老二获取到同步状态，如果还有可用资源，会继续传播下去。</strong></p><h4 id="setHeadAndPropagate"><a href="#setHeadAndPropagate" class="headerlink" title="setHeadAndPropagate"></a>setHeadAndPropagate</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> propagate)</span> </span>&#123;        Node h = head; <span class="hljs-comment">// Record old head for check below</span>        setHead(node);        <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;            Node s = node.next;            <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.isShared())                doReleaseShared();        &#125;    &#125;</code></pre></div><h3 id="释放同步状态：releaseShared"><a href="#释放同步状态：releaseShared" class="headerlink" title="释放同步状态：releaseShared"></a>释放同步状态：releaseShared</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;            doReleaseShared();<span class="hljs-comment">//释放同步状态</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;</code></pre></div><h4 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared"></a>doReleaseShared</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (;;) &#123;<span class="hljs-comment">//死循环，共享模式，持有同步状态的线程可能有多个，采用循环CAS保证线程安全</span>            Node h = head;            <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;                <span class="hljs-keyword">int</span> ws = h.waitStatus;                <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;                    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))                        <span class="hljs-keyword">continue</span>;                              unparkSuccessor(h);<span class="hljs-comment">//唤醒后继结点</span>                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;                         !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))                    <span class="hljs-keyword">continue</span>;                            &#125;            <span class="hljs-keyword">if</span> (h == head)                              <span class="hljs-keyword">break</span>;        &#125;    &#125;</code></pre></div><p>共享模式下，释放同步状态也是多线程的，此处采用了CAS自旋来保证。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>AQS是JUC中很多同步组件的构建基础，简单来讲，它内部实现主要是状态变量<code>state</code>和一个<code>FIFO队列</code>来完成，同步队列的头节点是当前获取到同步状态的节点，获取同步状态state失败的线程，会被构造成一个节点（共享式或独占式）加入到同步队列尾部（采用自旋CAS来保证此操作的线程安全），随后线程会被阻塞；释放时唤醒头节点的后继节点，使其加入对同步状态的争夺中。<br>AQS为我们定义好了顶层的处理实现逻辑，我们在使用AQS构建符合我们需求的同步组件时，只需要重写tryAcquire，tryAcquireShared，tryRelease，tryReleaseShared等几个方法，来决定同步状态的释放和获取即可，至于背后复杂的线程排队，线程阻塞/唤醒，如何保证线程安全，都由AQS为我们完成了，这也是非常典型的模板方法的应用。AQS定义好顶级逻辑的骨架，并提取出公用的线程入队列/出队列，阻塞/唤醒等一系列复杂逻辑的实现，将部分简单的可由使用者决定的操作逻辑延迟到子类中去实现。　</p><p>参考：<a href="https://www.cnblogs.com/chengxiao/p/7141160.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/7141160.html</a></p>]]></content>
    
    
    <categories>
      
      <category>语言相关</category>
      
      <category>Java进阶</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="/2020/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>单例模式的主要作用是保证在Java程序中，某个类只有一个实例存在，一些管理器和控制器常被设计成单例模式。</p><p>单例模式有许多好处：它能够避免实例对象的重复创建，不仅可以减少每次创建对象的时间开销，还可以节约内存空间，能够避免由于操作多个实例导致的逻辑错误，如果一个对象有可能贯穿整个应用程序，而且起到了全局统一管理控制的作用，那么单例模式也许是一个值得考虑的选择。</p><p><strong>饿汉模式</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton Instance = <span class="hljs-keyword">new</span> Singleton();<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> Instance;&#125;&#125;</code></pre></div><p>类的构造函数定义为private的，保证其他类不能实例化此类，然后提供了一个静态实例并返回给调用者。</p><p>饿汉模式在类加载的时候就对实例进行创建，实例在整个程序周期都存在，它的好处是只在类加载的时候创建一次实例，不会存在多个线程创建多个实例的情况，避免了多线程同步的问题，它的缺点也很明显，即使这个单例没有用到也会被创建，而且在类加载之后就被创建，内存就被浪费了。</p><p>这种实现方式适合单例占用内存比较小，在初始化时就会被用到的情况，但是如果单例占用的内存比较大，或者单例只是在某个特定场景下才会用到，使用饿汉模式就不合适了。</p><p><strong>懒汉模式</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton Instance;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">if</span>(Instance == <span class="hljs-keyword">null</span>)&#123;Instance = <span class="hljs-keyword">new</span> Singleton();&#125;<span class="hljs-keyword">return</span> Instance;&#125;&#125;</code></pre></div><p>懒汉模式中单例是在需要的时候才去创建的，如果单例已经创建，再次调用获取接口将不会重新创建新的对象，而是直接返回之前创建的对象，如果某个单例使用的次数少，并且创建单例消耗的资源较多，那么就需要实现单例的按需创建，这个时候使用懒汉模式就是一个不错的选择，但是这里的懒汉模式并没有考虑线程安全问题，在多个线程可能会并发调用它的getInstance()方法，导致创建多个实例，因此需要加锁来解决线程同步问题。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton Instance;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">if</span>(Instance == <span class="hljs-keyword">null</span>)&#123;Instance = <span class="hljs-keyword">new</span> Singleton();&#125;<span class="hljs-keyword">return</span> Instance;&#125;&#125;</code></pre></div><p><strong>双重校验锁</strong></p><p>加锁的懒汉模式看起来既解决了线程并发问题，又实现了延迟加载，然而它存在着性能问题，依然不够完美，synchronized修饰的同步方法比一般方法要慢很多，如果多次调用getInstance()，累积的性能损耗就比较大了，因此就有了双重校验锁。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton Instance;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">if</span>(Instance == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;<span class="hljs-keyword">if</span>(Instance == <span class="hljs-keyword">null</span>)&#123;Instance = <span class="hljs-keyword">new</span> Singleton();&#125;&#125;&#125;<span class="hljs-keyword">return</span> Instance;&#125;&#125;</code></pre></div><p>虽然双重校验锁既实现了延迟加载，又解决了线程并发问题，同时还解决了执行效率问题，但是仍存在问题。</p><p>这里要提到Java中的指令重排优化，所谓指令重排优化是指在不改变原语义的情况下，通过调整指令的执行顺序让程序运行更快。由于指令重排序的存在，导致初始化Singleton和将对象地址赋给Instance字段的顺序是不确定的，在某个线程创建单例对象时，在构造方法被调用之前，就为该对象分配了内存空间并将对向的字段设置为默认值，此时就可以将分配的内存地址赋值给Instance字段了，然而该对象可能还没有初始化，若紧接着另外一个线程来调用getInstance，取到的就是状态不正确的对象，程序就会出错。</p><p>解决办法：<strong>在Instance变量之前加<code>volatile</code>关键字</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton Instance;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">if</span>(Instance == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;<span class="hljs-keyword">if</span>(Instance == <span class="hljs-keyword">null</span>)&#123;Instance = <span class="hljs-keyword">new</span> Singleton();&#125;&#125;&#125;<span class="hljs-keyword">return</span> Instance;&#125;&#125;</code></pre></div><p><strong>静态内部类</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonHolder&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton Instance = <span class="hljs-keyword">new</span> Singleton();&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> SingletonHolder.Instance;&#125;&#125;</code></pre></div><p>这种方式同样利用了类加载机制来保证只创建一个Instance实例，只要应用中不使用内部类，JVM就不会去加载这个单例类，也就不会创建单例对象，从而保证延迟加载和线程安全。</p><p><strong>枚举</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Singleton&#123;Instance;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whateverMethod</span><span class="hljs-params">()</span></span>&#123;&#125;;&#125;</code></pre></div><p>前面四种实现单例模式的方式都有共同的缺点：</p><ul><li><p>需要额外的工作来实现序列化，否则每次反序列化一个序列化的对象时都会创建一个新的实例；</p></li><li><p>可以使用反射强行调用私有构造器</p></li></ul><p>使用枚举除了线程安全和防止反射调用构造器外，还提供了自动序列化机制，防止反序列化的时候创建新的对象。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-页式存储管理</title>
    <link href="/2020/08/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    <url>/2020/08/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>分区式存储管理最大的缺点就是<strong>碎片化问题</strong>严重，<strong>内存利用率低</strong>，究其原因，主要在于<strong>内存连续分配</strong>的限制。<br>分页存储管理的思想：把内存分为一个个相等的小分区，再按照分区大小把进程拆分为一个个小部分。<br>分页存储管理分为：实分页存储管理和虚分页存储管理。</p><h1 id="一、实分页式存储管理"><a href="#一、实分页式存储管理" class="headerlink" title="一、实分页式存储管理"></a>一、实分页式存储管理</h1><p>实分页式存储最大的优点是<strong>内存利用率高</strong>，与目前流行的虚分页存储管理相比，具有<strong>实现简单</strong>，<strong>程序运行快</strong>的优点。</p><h2 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h2><ol><li>将整个系统的内存空间划分为一系列大小相等的块，每一块称为一个物理块，物理页或实页，页架或页帧，可简称为<strong>块</strong>，所有的块按物理地址递增顺序连续编号为0、1、2、……。</li><li>每个作业的地址空间也划分成一系列与内存块一样大小的块，每一块称为一个逻辑页或虚页，也有人叫页面，可简称为<strong>页</strong>。所有的页按照逻辑地址递增顺序连续编号为0、1、2、……。</li><li>一个作业，只要它的总页数不大于内存中的可用块数，系统就可以对它实施分配，<strong>系统装入作业时，以页为单位分配内存</strong>，一页分配一个块，作业所有的页所占用的块可以不连续，系统同时为这个作业建立一个页号与块号的对照表，称为页表。</li><li>每个块的大小是固定的，一般是1/2KB~4KB之间的数值，而且必须是2的幂次。</li></ol><h2 id="2-页表"><a href="#2-页表" class="headerlink" title="2. 页表"></a>2. 页表</h2><p>系统为每一个进程建立一个页表，用于记录页与块之间的对应关系，地址空间有多少页，页表就有多少行，且按照逻辑页中的顺序排列。<br>页表的划分完全是一种系统硬件的行为，一个逻辑地址放到这种地址结构中，自然就分成了页号和页内地址两部分。<br><img src="https://img-blog.csdnimg.cn/20200803214309189.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在分页系统中，允许将作业（进程）的任一页装入到内存中的任一可用的物理块中，但进程的地址空间本来是连续的，若把它分页后装入到不相邻的物理块中，要保证系统仍能正确运行，就要实现从进程的逻辑地址变换为内存的物理地址。<br><img src="https://img-blog.csdnimg.cn/202008032200162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="3-地址映射"><a href="#3-地址映射" class="headerlink" title="3. 地址映射"></a>3. 地址映射</h2><p>在系统中设置地址变换机构，能将用户进程地址空间中的逻辑地址变为内存空间中的物理地址。<br>由于页面和物理块的大小相等，页面偏移地址和块内偏移地址是相同的，无需进行从页面地址到块内地址的转移。<br>页表的作用就是从页号到物理块号的转移，所以地址变换的任务借助于页表来完成的。<br><img src="https://img-blog.csdnimg.cn/20200803221120962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>页号 = 逻辑地址 / 页面长度<br>页内偏移量 = 逻辑地址 % 页面长度</p><h2 id="4-快表"><a href="#4-快表" class="headerlink" title="4. 快表"></a>4. 快表</h2><p>因为页表是存放在内存中的，CPU要存取一个数据，需要访问主存两次。</p><ul><li>第一次访问：访问内存中的页表，找到该页的物理块号，将此块号与页内地址拼接形成物理地址；</li><li>第二次访问：真正访问物理地址，存取其中的内容。</li></ul><p>为了提高存取速度，在地址变换机构中增设一组寄存器，用来存放访问的哪些页表。<br><strong>快表是一种访问和存储速度比内存快很多的高速缓冲器。</strong><br>当进程访问一页时，系统将页号与快表中的所有项进行并行比较，若访问的页在快表中，即可立即进行地址转换。当被访问的页不在快表中时，去内存中查询页表，同时将页表找到的内存块号与虚页号填入快表中。</p><p><img src="https://img-blog.csdnimg.cn/20200803223359335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="5-两级和多级页表"><a href="#5-两级和多级页表" class="headerlink" title="5. 两级和多级页表"></a>5. 两级和多级页表</h2><p>页表如果占用相当大的内存空间，可采用两个方法来解决这一问题：</p><ul><li>采用离散分配方式来解决难以找到一块连续的大内存空间的问题；</li><li>只将当前需要的部分页表项调入内存，其余的页表项仍驻留在磁盘中，需要时再调入。<br><img src="https://img-blog.csdnimg.cn/20200803223845553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><h2 id="6-页的分配与回收"><a href="#6-页的分配与回收" class="headerlink" title="6. 页的分配与回收"></a>6. 页的分配与回收</h2></li></ul><h1 id="二、虚拟存储器"><a href="#二、虚拟存储器" class="headerlink" title="二、虚拟存储器"></a>二、虚拟存储器</h1><h2 id="引入虚拟存储技术的好处"><a href="#引入虚拟存储技术的好处" class="headerlink" title="引入虚拟存储技术的好处"></a>引入虚拟存储技术的好处</h2><ul><li>可以在较小的可用内存中执行较大的用户程序；</li><li>可以提供给用户可用的虚拟内存空间通常大于物理内存；</li><li>可在内存中容纳更多程序并发执行；</li></ul><h2 id="虚拟存储技术的特征"><a href="#虚拟存储技术的特征" class="headerlink" title="虚拟存储技术的特征"></a>虚拟存储技术的特征</h2><ul><li>不连续性：物理内存分配的不连续性，虚拟地址空间使用的不连续性；</li><li>部分交换：与交换技术相比较，虚拟存储的调入和调出是对部分虚拟地址空间进行的；</li><li>大空间：通过物理内存与快速外存相结合，提供大范围的虚拟地址空间；</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTPS核心知识点</title>
    <link href="/2020/08/03/HTTPS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2020/08/03/HTTPS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTPS的实现原理"><a href="#HTTPS的实现原理" class="headerlink" title="HTTPS的实现原理"></a>HTTPS的实现原理</h1><p>HTTPS协议之所以安全是因为HTTPS协议会对传输的数据进行加密，在<strong>内容传输</strong>的加密上使用的是对称加密，在<strong>证书校验</strong>阶段使用非对称加密。</p><p>HTTPS的整体过程分为证书校验阶段和数据传输阶段，具体的交互过程如下：<br>1、客户端发送自己支持的<strong>加密规则</strong>给服务器，代表告诉服务器自己要进行连接了；<br>2、服务器从中选出一套<strong>加密算法</strong>和<strong>hash算法</strong>以及自己的<strong>身份信息</strong>以证书的形式发送给浏览器，证书中包含服务器信息，加密公钥，证书的颁发机构等；<br>3、客户端收到网站的证书后，首先<strong>验证</strong>证书的合法性，可以后浏览器生成一串随机数，并用证书中的公钥进行加密；<br>4、服务器接收到客户端传过来的信息后，首先用私钥解密，验证hash值是否与浏览器发过来的一致，如果一致则说明握手成功。</p><h1 id="什么是对称加密和非对称加密？"><a href="#什么是对称加密和非对称加密？" class="headerlink" title="什么是对称加密和非对称加密？"></a>什么是对称加密和非对称加密？</h1><p>对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是<strong>密钥发送问题</strong>，即如何安全地将密钥发给对方。</p><p>非对称加密指使用一对非对称密钥，即：公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</p><h1 id="为什么数据传输是用对称加密"><a href="#为什么数据传输是用对称加密" class="headerlink" title="为什么数据传输是用对称加密?"></a>为什么数据传输是用对称加密?</h1><p>首先，非对称加密的加解密<strong>效率</strong>非常低，而HTTP的应用场景中通常端与端之间存在大量的交互，非对称加密的效率无法接受;<br>另外，在HTTPS的场景中只有服务端保存了私钥，一对公私钥只能实现<strong>单向</strong>的加解密，所以HTTPS中内容传输加密采取的是对称加密，而不是非对称加密。</p><h1 id="为什么需要CA认证机构颁发证书？"><a href="#为什么需要CA认证机构颁发证书？" class="headerlink" title="为什么需要CA认证机构颁发证书？"></a>为什么需要CA认证机构颁发证书？</h1><p>HTTP协议被认为不安全是因为传输过程中容易被监听者勾线监听，伪造服务器，而HTTPS协议主要解决的便是网络传输的安全性问题。<br>首先我们假设不存在认证机构，任何人都可以制作证书，这带来的安全风险便是经典的”<strong>中间人攻击</strong>“问题。</p><blockquote><p>中间人攻击：</p><ol><li>本地请求被劫持（如<strong>DNS劫持</strong>等），所有请求均发送到中间人的服务器；</li><li>中间人服务器返回中间人自己的证书；</li><li>客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密传输内容进行加密传输；</li><li>中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密；</li><li>中间人以客户端的请求内容再向正规网站发起请求；</li><li>因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据；</li><li>中间人凭借与正规网站建立的对称加密算法对内容进行解密；</li><li>中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输；</li><li>客户端通过与中间人建立的对称加密算法对返回结果数据进行解密。</li></ol></blockquote><p>由于缺少对证书的验证，所以客户端虽然发起的是HTTPS请求，但客户端完全不知道自己的网络已被拦截，传输内容被中间人全部窃取。</p><h1 id="HTTP-和-HTTPS-的区别？"><a href="#HTTP-和-HTTPS-的区别？" class="headerlink" title="HTTP 和 HTTPS 的区别？"></a>HTTP 和 HTTPS 的区别？</h1><ol><li><strong>费用</strong>：HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费；</li><li><strong>资源消耗</strong>：HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议，需要消耗更多的 CPU 和内存资源；</li><li><strong>端口不同</strong>：HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是  80，后者是 443；</li><li><strong>安全性</strong>：HTTP 的连接很简单，是无状态的；HTTPS 协议是由 TSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li></ol><h1 id="HTTPS-的优缺点？"><a href="#HTTPS-的优缺点？" class="headerlink" title="HTTPS 的优缺点？"></a>HTTPS 的优缺点？</h1><p>优点：</p><ol><li>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li><li>HTTPS 协议是由 <code>SSL + HTTP</code>协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性；</li><li>HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li></ol><p>缺点：</p><ol><li>HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电；</li><li>HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</li><li>SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站一般不会用；</li><li>SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗；</li><li>HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP请求过程详解</title>
    <link href="/2020/08/03/HTTP%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/08/03/HTTP%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-浏览器根据域名解析IP地址"><a href="#1-浏览器根据域名解析IP地址" class="headerlink" title="1. 浏览器根据域名解析IP地址"></a>1. 浏览器根据域名解析IP地址</h1><p><img src="https://img-blog.csdnimg.cn/20200610161609454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>浏览器根据访问的域名找到其IP地址，DNS查找过程如下：</p><ol><li><strong>浏览器缓存</strong>：首先搜索浏览器自身的DNS缓存（缓存的时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否具有域名对应的条目，如果有且没有过期则解析到此结束。</li><li><strong>系统缓存</strong>：如果浏览器自身的缓存里面没有找到对应的条目，那么浏览器会搜索操作系统自身的DNS缓存（Hosts文件），如果找到且没有过期则停止搜索，解析到此结束；</li><li>操作系统将这个域名发送给LDNS，也就是<strong>本地区的域名服务器</strong>（完成80%的域名解析工作）；</li><li>如果LDNS没有，则直接到<strong>Root Server</strong>域名服务器请求解析；</li><li>根域名服务器返回给本地域名服务器一个所查询域的<strong>主域名服务器</strong>（gTLD Server）地址；</li><li>本地域名服务器（Local DNS Server）再向上一步返回的gTLD服务器发送请求；</li><li>接受请求的gTLD服务器查找并返回此域名对应的Name Server域名服务器（<strong>当时注册的域名服务器</strong>）的地址；</li><li>Name Server域名服务器会查询存储的域名和IP的映射关系表；</li><li>返回该域名对应的IP和TTL值；</li><li>把解析的结果返回给用户，用户根据TTL值存储在本地系统缓存中，域名解析过程结束。</li></ol><h1 id="2-浏览器与Web服务器建立一个TCP连接"><a href="#2-浏览器与Web服务器建立一个TCP连接" class="headerlink" title="2 浏览器与Web服务器建立一个TCP连接"></a>2 浏览器与Web服务器建立一个TCP连接</h1><h2 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h2><p><img src="https://img-blog.csdnimg.cn/20200803111553979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li>第一次握手：客户端发送网络包，服务端收到了，这样服务端就能得出结论：客户端的发送能力，服务端的接收能力是正常的；</li><li>第二次握手：服务端发包，客户端收到了，这样客户端就能得到结论：服务端的发送和接收能力，客户端的发送和接收能力是正常的，但此时服务端并不知道自己的发送能力以及客户端的接收能力是否正常，所以还需要第三次握手；</li><li>第三次握手：客户端发包，服务端收到，这样服务端得出结论，服务端的发送和客户端的接收能力正常，可以正常通信了。</li></ul><h1 id="3-浏览器给Web服务器发送一个HTTP请求"><a href="#3-浏览器给Web服务器发送一个HTTP请求" class="headerlink" title="3. 浏览器给Web服务器发送一个HTTP请求"></a>3. 浏览器给Web服务器发送一个HTTP请求</h1><p>一个HTTP请求报文由<strong>请求行</strong>（request line），<strong>请求头部</strong>（headers），<strong>空行</strong>（blank line）和<strong>请求数据</strong>（request body）4个部分组成。<br><img src="https://img-blog.csdnimg.cn/20200803141229911.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="3-1-请求行"><a href="#3-1-请求行" class="headerlink" title="3.1 请求行"></a>3.1 请求行</h2><p>请求行分为三个部分：<strong>请求方法</strong>，<strong>请求地址URL</strong>和<strong>HTTP协议版本</strong>，它们之前用空格分隔，例如：GET /index.html HTTP/1.1</p><h3 id="3-1-1请求方法"><a href="#3-1-1请求方法" class="headerlink" title="3.1.1请求方法"></a>3.1.1请求方法</h3><p>HTTP/1.1定义的请求方法有8种：GET（完整请求一个资源），POST（提交表单），PUT（上传文件），DELETE（删除），PATCH，HEAD（仅请求响应首部），OPTIONS（返回请求的资源所支持的方法），TRACE（追求一个资源请求中间所经过的代理），RESTful接口的话一般会用到GET，POST，DELETE，PUT。</p><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页，使用的都是GET方式，GET方法要求服务器<strong>将URL定位的资源放在响应报文的数据部分</strong>，会送给客户端。<br>使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号<code>?</code>代表URL的结尾与请求参数的开始，多个参数之间用<code>&amp;</code>符号分开，不适合传输私密数据，另外传递参数长度也有限制。<br>GET请求不会对服务器产生任何其他影响，仅仅是获取数据。</p><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>允许客户端给服务器提供信息较多，POST方法将请求参数封装在HTTP请求数据中，以<code>名称/值</code>的形式出现，可以传输大量数据，同时参数也不会显示在URL栏中，POST方式大多用于页面的表单中。<br>POST是客户端向服务器提交数据的方法，这种方法会影响服务器，服务器可能根据收到的数据动态创建新的资源，也可能更新原有的资源。</p><h3 id="3-1-2-请求地址URL"><a href="#3-1-2-请求地址URL" class="headerlink" title="3.1.2 请求地址URL"></a>3.1.2 请求地址URL</h3><p>URL：统一资源定位符，是一种资源位置的抽象唯一识别方法。<br>组成：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;<br>端口和路径有时可以省略（HTTP默认端口号是80）<br><img src="https://img-blog.csdnimg.cn/20200803142845620.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="3-1-3-协议版本"><a href="#3-1-3-协议版本" class="headerlink" title="3.1.3 协议版本"></a>3.1.3 协议版本</h3><p>协议版本的格式为：HTTP/主版本号.次版本号，常用的有：HTTP/1.0 和 HTTP/1.1。</p><h2 id="3-2-请求头部"><a href="#3-2-请求头部" class="headerlink" title="3.2 请求头部"></a>3.2 请求头部</h2><p>请求头部<strong>为请求报文添加了一些附加信息</strong>，如：主机名，发送请求的应用程序名称等，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。<br>请求头部的最后会有一个空格，表示请求头部结束，接下来为请求数据。<br><img src="https://img-blog.csdnimg.cn/20200803145204839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="3-3-请求数据"><a href="#3-3-请求数据" class="headerlink" title="3.3 请求数据"></a>3.3 请求数据</h2><p><strong>请求数据不在GET方法中使用，而是在POST方法中使用</strong>，POST方法适用于需要客户填写表单的场合，与请求数据相关的最常使用的请求头部是Content-Type和Content-Length。下面是一个POST方法的请求报文：</p><div class="hljs"><pre><code class="hljs txt">POST 　&#x2F;index.php　HTTP&#x2F;1.1 　　 请求行Host: localhostUser-Agent: Mozilla&#x2F;5.0 (Windows NT 5.1; rv:10.0.2) Gecko&#x2F;20100101 Firefox&#x2F;10.0.2　　请求头Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,&#x2F;;q&#x3D;0.8Accept-Language: zh-cn,zh;q&#x3D;0.5Accept-Encoding: gzip, deflateConnection: keep-aliveReferer: http:&#x2F;&#x2F;localhost&#x2F;Content-Length：25Content-Type：application&#x2F;x-www-form-urlencoded　　空行username&#x3D;aa&amp;password&#x3D;1234　　请求数据</code></pre></div><h1 id="4-服务器端响应HTTP请求，浏览器得到HTML代码"><a href="#4-服务器端响应HTTP请求，浏览器得到HTML代码" class="headerlink" title="4. 服务器端响应HTTP请求，浏览器得到HTML代码"></a>4. 服务器端响应HTTP请求，浏览器得到HTML代码</h1><p>HTTP响应报文由<strong>状态行</strong>（status line），<strong>响应头部</strong>（headers），<strong>空行</strong>（blank line）和<strong>响应数据</strong>（response body）4个部分组成。<br><img src="https://img-blog.csdnimg.cn/20200803145717649.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="4-1-状态行"><a href="#4-1-状态行" class="headerlink" title="4.1 状态行"></a>4.1 状态行</h2><p>状态行由3部分组成，分别为：<strong>协议版本</strong>，<strong>状态码</strong>，<strong>状态信息</strong>。其中协议版本与请求报文一致，状态信息是对状态码的简单描述。<br><img src="https://img-blog.csdnimg.cn/20200803150014704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="4-2-响应头部"><a href="#4-2-响应头部" class="headerlink" title="4.2 响应头部"></a>4.2 响应头部</h2><p><img src="https://img-blog.csdnimg.cn/20200803150037655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="4-3-响应数据"><a href="#4-3-响应数据" class="headerlink" title="4.3 响应数据"></a>4.3 响应数据</h2><p>用于存放需要返回给客户端的数据信息。</p><div class="hljs"><pre><code class="hljs java">HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK　　状态行Date: Sun, <span class="hljs-number">17</span> Mar <span class="hljs-number">2013</span> <span class="hljs-number">08</span>:<span class="hljs-number">12</span>:<span class="hljs-number">54</span> GMT　　响应头部Server: Apache/<span class="hljs-number">2.2</span><span class="hljs-number">.8</span> (Win32) PHP/<span class="hljs-number">5.2</span><span class="hljs-number">.5</span>X-Powered-By: PHP/<span class="hljs-number">5.2</span><span class="hljs-number">.5</span>Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/Expires: Thu, <span class="hljs-number">19</span> Nov <span class="hljs-number">1981</span> <span class="hljs-number">08</span>:<span class="hljs-number">52</span>:<span class="hljs-number">00</span> GMTCache-Control: no-store, no-cache, must-revalidate, post-check=<span class="hljs-number">0</span>, pre-check=<span class="hljs-number">0</span>Pragma: no-cacheContent-Length: <span class="hljs-number">4393</span>Keep-Alive: timeout=<span class="hljs-number">5</span>, max=<span class="hljs-number">100</span>Connection: Keep-AliveContent-Type: text/html; charset=utf-<span class="hljs-number">8</span>　　空行&lt;html&gt;　　响应数据&lt;head&gt;&lt;title&gt;HTTP响应示例&lt;title&gt;&lt;/head&gt;&lt;body&gt;Hello HTTP!&lt;/body&gt;&lt;/html&gt;</code></pre></div><h1 id="5-浏览器解析HTML代码，并请求HTML代码中的资源"><a href="#5-浏览器解析HTML代码，并请求HTML代码中的资源" class="headerlink" title="5. 浏览器解析HTML代码，并请求HTML代码中的资源"></a>5. 浏览器解析HTML代码，并请求HTML代码中的资源</h1><p>浏览器拿到HTML文件后，开始解析HTML代码，遇到静态资源时，就向服务器去请求下载。</p><h1 id="6-关闭TCP连接，浏览器对页面进行渲染呈现给用户"><a href="#6-关闭TCP连接，浏览器对页面进行渲染呈现给用户" class="headerlink" title="6. 关闭TCP连接，浏览器对页面进行渲染呈现给用户"></a>6. 关闭TCP连接，浏览器对页面进行渲染呈现给用户</h1><p>浏览器利用自己内部的工作机制，把请求到的静态资源和HTML代码进行渲染，呈现给用户。</p><p>参考:<br>1、<a href="https://blog.csdn.net/ailunlee/article/details/90600174?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.edu_weight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.edu_weight" target="_blank" rel="noopener">HTTP请求的完全过程</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRU算法</title>
    <link href="/2020/07/29/LRU%E7%AE%97%E6%B3%95/"/>
    <url>/2020/07/29/LRU%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>LRU算法就是一种缓存淘汰策略，全称为Least Recently Used。</p><h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p>力扣第 146 题「LRU缓存机制」就是让你设计数据结构：</p><p>首先要接收一个 <code>capacity</code> 参数作为缓存的最大容量，然后实现两个 API，一个是 <code>put(key, val)</code> 方法存入键值对，另一个是 <code>get(key)</code> 方法获取 <code>key</code> 对应的 <code>val</code>，如果 <code>key</code> 不存在则返回 -1。</p><p>注意：<code>get</code> 和 <code>put</code> 方法必须都是 <code>O(1)</code> 的时间复杂度，我们举个具体例子来看看 LRU 算法怎么工作。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/* 缓存容量为2 */</span>     LRUCache cache = <span class="hljs-keyword">new</span> LRUCache(<span class="hljs-number">2</span>);     <span class="hljs-comment">// 将cache理解为一个队列，假设左边是队头，右边是队尾</span>     <span class="hljs-comment">//最近使用的排在队头，久未使用的排在队尾</span>     <span class="hljs-comment">//圆括号表示键值对（key，value）</span>          cache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);     <span class="hljs-comment">// cache = [(1,1)]</span>          cache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);     <span class="hljs-comment">// cache = [(2,2),(1,1)]</span>          cache.get(<span class="hljs-number">1</span>);     <span class="hljs-comment">// 返回1</span>     <span class="hljs-comment">// cache = [(1,1),(2,2)]</span>          cache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);     <span class="hljs-comment">//cache = [(3,3),(1,1)]</span>     <span class="hljs-comment">//缓存容量已满，需要删除队尾的元素，然后把新的数据插入队头</span>          cache.get(<span class="hljs-number">2</span>);     <span class="hljs-comment">//返回-1</span>          cache.put(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);     <span class="hljs-comment">// cache = [(1,4),(3,3)]</span>          cache.get(<span class="hljs-number">1</span>);     <span class="hljs-comment">//返回4</span></code></pre></div><h1 id="LRU算法设计"><a href="#LRU算法设计" class="headerlink" title="LRU算法设计"></a>LRU算法设计</h1><p>分析上面的操作过程，要让 <code>put</code> 和 <code>get</code> 方法的时间复杂度为 O(1)，我们可以总结出 <code>cache</code> 这个数据结构必要的条件：</p><ol><li><code>cache</code>中的元素必然有时序，以区分最近使用和久未使用的数据，当容量满了之后要删除最久未使用的那个元素；</li><li>我们要在<code>cache</code>中快速找某个<code>key</code>是否已存在，并得到对应的val；</li><li>每次访问 <code>cache</code> 中的某个 <code>key</code>，需要将这个元素变为最近使用的，也就是说 <code>cache</code> 要支持在任意位置快速插入和删除元素；</li></ol><p>综上所述，哈希表查找速度快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢，两者结合形成一种新的数据结构：哈希链表<code>LinkedHashMap</code>。</p><p>LRU缓存算法的核心数据结构就是哈希链表，如下所示：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F30af4fb8bfe13c9ffb55818ccb70cc57b6c0a508.jpg?alt=media" srcset="/img/loading.gif" alt="img"></p><p>借助这个结构，我们来逐一分析上面的 3 个条件：</p><p>1、如果我们每次默认从链表尾部添加元素，那么显然越靠尾部的元素就是最近使用的，越靠头部的元素就是最久未使用的。</p><p>2、对于某一个 <code>key</code>，我们可以通过哈希表快速定位到链表中的节点，从而取得对应 <code>val</code>。</p><p>3、链表显然是支持在任意位置快速插入和删除的，改改指针就行。只不过传统的链表无法按照索引快速访问某一个位置的元素，而这里借助哈希表，可以通过 <code>key</code> 快速映射到任意一个链表节点，然后进行插入和删除。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>首先，把双链表的节点类写出来，为了简化，<code>key</code> 和 <code>val</code> 都认为是 int 类型：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> key, val;    <span class="hljs-keyword">public</span> Node next, prev;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> v)</span> </span>&#123;        <span class="hljs-keyword">this</span>.key = k;        <span class="hljs-keyword">this</span>.val = v;    &#125;&#125;</code></pre></div><p>然后依靠我们的<code>Node</code>类型构建一个双链表，实现几个LRU算法必须的API：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleList</span> </span>&#123;       <span class="hljs-comment">/**</span><span class="hljs-comment">        *头尾虚节点</span><span class="hljs-comment">        */</span>       <span class="hljs-keyword">private</span> Node head,tail;       <span class="hljs-comment">/**</span><span class="hljs-comment">        * 链表元素数</span><span class="hljs-comment">        */</span>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DoubleList</span><span class="hljs-params">()</span> </span>&#123;           <span class="hljs-comment">// 初始化双向链表的数据</span>           head = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);           tail = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);           head.next = tail;           tail.prev = head;           size = <span class="hljs-number">0</span>;       &#125;       <span class="hljs-comment">/**</span><span class="hljs-comment">        * 在链表头部添加节点x</span><span class="hljs-comment">        */</span>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(Node x)</span></span>&#123;           x.next = head.next;           x.prev = head;           head.next.prev = x;           head.next = x;           size++;       &#125;       <span class="hljs-comment">/**</span><span class="hljs-comment">        * 删除链表中的x节点(x一定存在)</span><span class="hljs-comment">        */</span>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node x)</span></span>&#123;           x.next.prev = x.prev;           x.prev.next = x.next;           size--;       &#125;       <span class="hljs-comment">/**</span><span class="hljs-comment">        * 删除链表中最后一个节点，并返回该节点</span><span class="hljs-comment">        */</span>       <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">removeLast</span><span class="hljs-params">()</span></span>&#123;           <span class="hljs-keyword">if</span>(tail.prev == head)&#123;               <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;           &#125;           Node last = tail.prev;           remove(last);           <span class="hljs-keyword">return</span> last;       &#125;       <span class="hljs-comment">/**</span><span class="hljs-comment">        * 返回链表长度</span><span class="hljs-comment">        */</span>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;           <span class="hljs-keyword">return</span> size;       &#125;   &#125;</code></pre></div><p>为什么需要双向链表？</p><p>因为我们需要删除操作，删除一个节点不光要得到该节点本身的指针，也需要操作其前驱节点的指针，而双向链表才能支持查找前驱，保证操作的时间复杂度O(1)。</p><p>注意：我们实现的双链表API只能从头部插入，也就是说靠头部的数据是最近使用的，靠尾部的数据是最久未使用的。</p><p>有了双向链表的实现，我们只需要在LRU算法中把它和哈希表结合起来即可，先搭出代码框架：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span></span>&#123;   <span class="hljs-keyword">private</span> HashMap&lt;Integer, Node&gt; map;   <span class="hljs-keyword">private</span> DoubleList cache;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 容量</span><span class="hljs-comment">     */</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cap;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;        <span class="hljs-keyword">this</span>.cap = cap;        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        cache = <span class="hljs-keyword">new</span> DoubleList();    &#125;</code></pre></div><p>先不着急去实现LRU算法的<code>get</code>和<code>put</code>方法，由于我们要同时维护一个双链表<code>cache</code>和一个哈希表<code>map</code>，很容易漏掉一些操作，比如说删除某个<code>key</code>时，在<code>cache</code>中删除了对应的<code>Node</code>，但是却忘记在<code>map</code>中删除<code>key</code>。</p><p>解决这种问题最好的办法是：在这两种数据结构之上提供一层抽象API。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/** 将某个key提升为最近使用的 */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRecently</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;       Node r = map.get(key);       <span class="hljs-comment">//先从链表中删除该节点</span>       cache.remove(r);       <span class="hljs-comment">//然后在链表头部添加该节点</span>       cache.addFirst(r);    &#125;    <span class="hljs-comment">/** 添加最近使用的元素 */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addRecently</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key,<span class="hljs-keyword">int</span> val)</span></span>&#123;        Node r = <span class="hljs-keyword">new</span> Node(key,val);        cache.addFirst(r);        <span class="hljs-comment">//在map中添加映射关系</span>        map.put(key,r);    &#125;    <span class="hljs-comment">/** 删除某一个key */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;        Node r = map.get(key);        cache.remove(r);        map.remove(r);    &#125;    <span class="hljs-comment">/** 删除最久未使用的元素 */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeLeastRecently</span><span class="hljs-params">()</span></span>&#123;        Node r = cache.removeLast();        <span class="hljs-comment">//删除map中的对应关系</span>        <span class="hljs-keyword">int</span> key = r.key;        map.remove(key);    &#125;</code></pre></div><p>当缓存容量满时，我们除了要删除最后一个<code>Node</code>节点外，还要把<code>map</code>中映射到该节点的<code>key</code>同时删除，而这个<code>key</code>只能由<code>Node</code>得到。</p><p>下面实现<code>get</code>和<code>put</code>方法。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;     <span class="hljs-keyword">if</span>(!map.containsKey(key))&#123;         <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;     &#125;     <span class="hljs-comment">//将该数据提升为最近使用的</span>     makeRecently(key);     <span class="hljs-keyword">return</span> map.get(key).val; &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key,<span class="hljs-keyword">int</span> val)</span></span>&#123;     <span class="hljs-keyword">if</span>(map.containsKey(key))&#123;         <span class="hljs-comment">//先删除掉旧的数据</span>         deleteKey(key);     &#125;     <span class="hljs-keyword">if</span>(cap == cache.size)&#123;         <span class="hljs-comment">//删除最久未使用的数据</span>         removeLeastRecently();     &#125;     <span class="hljs-comment">//新插入的数据为最近使用的数据</span>     addRecently(key,val); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud面试题汇总</title>
    <link href="/2020/07/27/Spring-Cloud%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2020/07/27/Spring-Cloud%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="一、集群、分布式、微服务、SOA概念"><a href="#一、集群、分布式、微服务、SOA概念" class="headerlink" title="一、集群、分布式、微服务、SOA概念"></a>一、集群、分布式、微服务、SOA概念</h1><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>概念：计算机集群简称集群是一种计算机系统，通过一组松散集成的计算机软件或硬件连接起来高度紧密地协作完成计算工作，在某种意义上，它们可以被看做是一台计算机，集群系统中的单个计算机通常称为节点，通常通过局域网连接，集群计算机通常用来改进单个计算机的计算速度和可靠性。</p><p>特点：</p><ul><li>通过多台计算机完成同一个工作，达到更高的效率；</li><li>两台或多台机器，内容、工作过程等完全一样，如果一台不工作，另一台还可以起作用。</li></ul><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>概念：<br>分布式系统是一组计算机，通过网络相互连接传递消息与通信后<strong>协调</strong>它们的行为而形成的系统，组件之间彼此进行交互以实现一个共同的目标。<br>好处：</p><ul><li>模块之间独立，各做各的事情，便于扩展，复用性高；</li><li>高吞吐量，某个任务需要一个机器运行10个小时，将该任务用10台机器的分布式跑（将这个任务拆分为10个小任务），可能两个小时就跑完了。</li></ul><h2 id="SOA（面向服务的架构）"><a href="#SOA（面向服务的架构）" class="headerlink" title="SOA（面向服务的架构）"></a>SOA（面向服务的架构）</h2><p>SOA是一种设计方法，其中包含多个服务，而服务之间通过配合最终会提供一系列功能。一个服务通常以独立的形式存在于操作系统进程中。服务之间通过网络调用，而非采用进程内调用的方式进行通信。</p><h1 id="二、CAP理论"><a href="#二、CAP理论" class="headerlink" title="二、CAP理论"></a>二、CAP理论</h1><p>CAP理论作为分布式系统的基础理论，它描述的是一个分布式系统在以下三个特性中：</p><ul><li>一致性（Consistency）</li><li>可用性（Availability）</li><li>分区容错性（Partition tolerance）</li></ul><p>最多满足其中的两个特性，也就是下图所描述的，分布式系统要么满足CP，要么满足AP，无法同时满足CAP。<br><img src="https://img-blog.csdnimg.cn/20200717114459121.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="什么是一致性、可用性和分区容错性"><a href="#什么是一致性、可用性和分区容错性" class="headerlink" title="什么是一致性、可用性和分区容错性"></a>什么是一致性、可用性和分区容错性</h2><p><strong>分区容错性</strong>：指的是分布式系统中的某个节点或者网络分区出现了故障的时候，整个系统仍能对外提供满足一致性和可用性的服务，也就是说部分故障不影响整体使用。所以分区容错性是必不可少的。<br><strong>可用性</strong>：一直可以正常地做读写操作，简单而言就是客户单一直可以正常访问并得到系统的正常响应，用户角度来看就是不会出现系统操作失败或者访问超时等问题。<br><strong>一致性</strong>：在分布式系统完成某写操作后任何读操作都应该获取到该写操作写入的那个最新的值，相当于要求分布式系统中的各节点时时刻刻都保持数据的一致性。</p><h2 id="如何理解一致性、可用性和分区容错性"><a href="#如何理解一致性、可用性和分区容错性" class="headerlink" title="如何理解一致性、可用性和分区容错性"></a>如何理解一致性、可用性和分区容错性</h2><p>如果我们事先保证了分区容错性，也就意味着即使某个节点出现故障，用户还是可以继续访问，只是用户在访问的过程中就会出现一致性和可用性不能同时满足的情况。<br><img src="https://img-blog.csdnimg.cn/20200717212246793.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>如图假设分布式系统有G1、G2两个节点，初始值都是v0，现在有一个client向系统写入了值v1，这里假设直接写的是节点G1，写完之后client再去读取这个值，这时读到了G2节点，由于G2节点与G1节点失去连接，这时G1节点上的数据还未同步到G2节点，因此客户端读取到的是修改之前的值v0，这就出现了不满足一致性的情况了，相当于<strong>满足了可用性，失去了一致性。</strong></p><p>类似的，如果系统保证了强的一致性，那么在client 写完G1节点后, 而G1向G2节点同步数据出现了问题，这时如果client再去读取G2节点的数据时，client就会一直处于等待状态，因为系统内各节点数据为同步上，需要等同步上才能使用。这就相当于<strong>满足了一致性，而失去了可用性。</strong><br><img src="https://img-blog.csdnimg.cn/2020071721291945.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>考虑多个客户端访问时，一致性和可用性还可以这么理解：假如client1 向G1 修改某个值的时候, 写操作还未完成，client2就发起来对该值的读操作，读的是G2节点，这时如果要满足一致性，那么就得让client2 暂时无法使用，如果要让client2 使用，那么获取到的数据不是最新的，系统就不满足一致性。</p><p>CAP是无法完全兼顾的，从上面的例子也可以看出，我们可以选AP，也可以选CP。但是，要注意的是：不是说选了AP，C就完全抛弃了。不是说选了CP，A就完全抛弃了！<br>在CAP理论中，C所表示的一致性是强一致性(每个节点的数据都是最新版本)，其实一致性还有其他级别的：</p><ul><li>弱一致性：弱一致性是相对于强一致性而言，它不保证总能得到最新的值；</li><li>最终一致性(eventual consistency)：放宽对时间的要求，在被调完成操作响应后的某个时间点，被调多个节点的数据最终达成一致。</li></ul><h1 id="三、Spring-Cloud"><a href="#三、Spring-Cloud" class="headerlink" title="三、Spring Cloud"></a>三、Spring Cloud</h1><h2 id="为什么需要Spring-Cloud？"><a href="#为什么需要Spring-Cloud？" class="headerlink" title="为什么需要Spring Cloud？"></a>为什么需要Spring Cloud？</h2><p>将一个大的项目分解为多个小的模块，这些小的模块组合起来完成功能，但是拆分成多个模块以后，会出现各种各样的问题，而Spring Cloud提供了一整套的解决方案：<br>Spring Cloud的基础功能：</p><ul><li>服务治理：Eureka</li><li>客户端负载均衡：Ribbon</li><li>服务容错保护：Hystrix</li><li>声明式服务调用：Feign</li><li>API网关服务：Zuul</li><li>分布式配置中心：Config</li></ul><p>以及一些其他的高级功能：</p><ul><li>消息总线：Bus</li><li>消息驱动的微服务：Stream</li><li>分布式服务跟踪：Sleuth</li></ul><h1 id="四、Eureka"><a href="#四、Eureka" class="headerlink" title="四、Eureka"></a>四、Eureka</h1><p>Eureka主要是解决子系统之间的通信问题，子系统与子系统之间不是在同一个环境下，所以需要远程调用，远程调用可能就会想到httpClient、webService等这些技术实现，既然是远程调用，就必须知道ip地址，而人为去维护这些静态配置几乎不太现实，所以为了解决微服务架构中的服务实例维护问题（IP地址），产生了大量的服务治理框架和产品，这些框架和产品的实现都围绕着服务注册与服务发现机制来完成对微服务应用实例的自动化管理。在SpringCloud中我们的服务治理框架一般使用的就是Eureka。</p><p><strong>问题重现：</strong><br>现在有A、B、C、D四个服务，它们之间会互相调用(而且IP地址很可能会发生变化)，一旦某个服务的IP地址变了，那服务中的代码要跟着变，手动维护这些静态配置(IP)非常麻烦！Eureka是这样解决上面所说的情况的：<br>创建一个E服务，将A、B、C、D四个服务的信息都注册到E服务上，E服务维护这些已经注册进来的信息：<br><img src="https://img-blog.csdnimg.cn/20200717215646296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>A、B、C、D四个服务都可以拿到Eureka(服务E)那份注册清单。A、B、C、D四个服务互相调用不再通过具体的IP地址，而是通过服务名来调用！</p><ul><li>拿到注册清单—&gt;注册清单上有服务名—&gt;自然就能够拿到服务具体的位置了(IP)。</li><li>其实简单来说就是：代码中通过服务名找到对应的IP地址(IP地址会变，但服务名一般不会变)<br><img src="https://img-blog.csdnimg.cn/20200717215755259.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><h2 id="Eureka细节"><a href="#Eureka细节" class="headerlink" title="Eureka细节"></a>Eureka细节</h2>Eureka专门用于给其他服务注册的称为Eureka Server(服务注册中心)，其余注册到Eureka Server的服务称为Eureka Client。<br><img src="https://img-blog.csdnimg.cn/20200717220006711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在Eureka Server一般我们会这样配置：</li></ul><div class="hljs"><pre><code class="hljs MarkDown">register-with-eureka: false     #false表示不向注册中心注册自己fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</code></pre></div><p>Eureka Client分为服务提供者和服务消费者，但是很有可能某服务既是服务提供者又是服务消费者。<br>如果某个服务配置没有“注册”到Eureka-Server也不用过于惊讶（但是它是可以获取Eureka服务清单的），很有可能只是作者把该服务认作为单纯的服务消费者，单纯的服务消费者无需对外提供服务，也就无需注册到Eureka中了。</p><p>下面是Eureka的治理机制：<br><strong>服务提供者</strong></p><ul><li>服务注册： 启动的时候会通过发送REST请求的方式将自己注册到Eureka Server上，同时带上了自身服务的一些元数据信息；</li><li>服务续约：在注册完服务之后，服务提供者会维护一个心跳用来持续告诉Eureka Server:  “我还活着 ” ；</li><li>服务下线：当服务实例进行正常的关闭操作时，它会触发一个服务下线的REST请求给Eureka Server, 告诉服务注册中心：“我要下线了 ”。</li></ul><p><strong>服务消费者</strong></p><ul><li>获取服务：当我们启动服务消费者的时候，它会发送一个REST请求给服务注册中心，来获取上面注册的服务清单；</li><li>服务调用：服务消费者在获取服务清单后，通过服务名可以获得具体提供服务的实例名和该实例的元数据信息。在进行服务调用的时候，优先访问同处一个Zone中的服务提供方。</li></ul><p><strong>Eureka Server（服务注册中心）</strong></p><ul><li>失效剔除：默认每隔一段时间（默认60秒）将当前清单中超时（默认90秒）没有续约的服务剔除出去；</li><li>自我保护：Eureka Server在运行期间，会统计心跳失败的比例在15分钟之内是否低于85%（通常由于网络不稳定导致），Eureka Server会将当前的实例注册信息保护起来，让这些实例不会过期，尽可能保护这些注册信息。</li></ul><p>最后得到下面这个关系图：<br><img src="https://img-blog.csdnimg.cn/20200717221322768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="五、RestTemplate和Ribbon"><a href="#五、RestTemplate和Ribbon" class="headerlink" title="五、RestTemplate和Ribbon"></a>五、RestTemplate和Ribbon</h1><p>通过Eureka服务治理框架，我们可以通过服务名来获取具体的服务实例的位置了（IP），一般在使用Spring Cloud的时候不需要自己手动创建HttpClient来进行远程调用。可以使用Spring封装好的RestTemplate工具类，使用起来很简单：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 传统的方式，直接显示写死IP是不好的！</span><span class="hljs-comment">//private static final String REST_URL_PREFIX = "http://localhost:8001";</span><span class="hljs-comment">// 服务实例名</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REST_URL_PREFIX = <span class="hljs-string">"http://MICROSERVICECLOUD-DEPT"</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 使用 使用restTemplate访问restful接口非常的简单粗暴无脑。 (url, requestMap,</span><span class="hljs-comment"> * ResponseBean.class)这三个参数分别代表 REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RestTemplate restTemplate;<span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/consumer/dept/add"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(Dept dept)</span> </span>&#123;    <span class="hljs-keyword">return</span> restTemplate.postForObject(REST_URL_PREFIX + <span class="hljs-string">"/dept/add"</span>, dept, Boolean<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;&#125;</code></pre></div><p>为了实现服务的高可用，我们可以将服务提供者集群。比如说，现在一个秒杀系统设计出来了，准备上线了。在11月11号时为了能够支持高并发，我们开多台机器来支持并发量。<br><img src="https://img-blog.csdnimg.cn/20200717223758338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>现在想要这三个秒杀系统合理摊分用户的请求（专业来说就是负载均衡），可能你会想到nginx。<br>其实Spring Cloud也支持的负载均衡功能，只不过它是客户端的负载均衡，这个功能实现就是Ribbon！负载均衡又区分了两种类型：</p><ul><li>客户端负载均衡（Ribbon）<br>服务实例的清单在客户端，客户端进行负载均衡算法分配；<br>客户端可以从Eureka Server中得到一份服务清单，在发送请求时通过负载均衡算法，在多个服务器之间选择一个进行访问。</li><li>服务端负载均衡（Nginx）<br>服务实例的清单在服务端，服务器进行负载均衡算法分配；</li></ul><p><img src="https://img-blog.csdnimg.cn/20200717225330627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="Ribbon细节"><a href="#Ribbon细节" class="headerlink" title="Ribbon细节"></a>Ribbon细节</h2><p>Ribbon是支持负载均衡，默认的负载均衡策略是轮询，我们也是可以根据自己实际的需求自定义负载均衡策略的。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySelfRule</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> IRule <span class="hljs-title">myRule</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//return new RandomRule();// Ribbon默认是轮询，我自定义为随机</span>        <span class="hljs-comment">//return new RoundRobinRule();// Ribbon默认是轮询，我自定义为随机</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RandomRule_ZY();<span class="hljs-comment">// 我自定义为每台机器5次</span>    &#125;&#125;</code></pre></div><p>实现起来也很简单：继承AbstractLoadBalancerRule类，重写public Server choose(ILoadBalancer lb, Object key)即可。</p><h1 id="六、Hystrix"><a href="#六、Hystrix" class="headerlink" title="六、Hystrix"></a>六、Hystrix</h1><p>到目前为止，我们的服务看起来好像挺好的了：能够根据服务名来远程调用其他的服务，可以实现客户端的负载均衡。<br><img src="https://img-blog.csdnimg.cn/20200717230345367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>但是，如果我们在调用多个远程服务时，某个服务出现延迟，会怎么样？？<br><img src="https://img-blog.csdnimg.cn/20200717230401608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在高并发的情况下，由于单个服务的延迟，可能导致所有的请求都处于延迟状态，甚至在几秒钟就使服务处于负载饱和的状态，资源耗尽，直到不可用，最终导致这个分布式系统都不可用，这就是“雪崩”。<br><img src="https://img-blog.csdnimg.cn/20200717230424681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>针对上述问题， Spring Cloud Hystrix实现了<strong>断路器</strong>、<strong>线程隔离</strong>等一系列服务保护功能。</p><ul><li>Fallback(失败快速返回)：当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应， 而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</li><li>资源/依赖隔离(线程池隔离)：它会为每一个依赖服务创建一个独立的线程池，这样就算某个依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响，而不会拖慢其他的依赖服务。</li><li>Hystrix提供几个熔断关键参数：滑动窗口大小（20）、 熔断器开关间隔（5s）、错误率（50%）</li><li>每当20个请求中，有50%失败时，熔断器就会打开，此时再调用此服务，将会直接返回失败，不再调远程服务。</li><li>直到5s之后，重新检测该触发条件，判断是否把熔断器关闭，或者继续打开。</li></ul><p>Hystrix还有请求合并、请求缓存这样强大的功能，在此我就不具体说明了，有兴趣的同学可继续深入学习~</p><h2 id="Hystrix仪表盘"><a href="#Hystrix仪表盘" class="headerlink" title="Hystrix仪表盘"></a>Hystrix仪表盘</h2><p>Hystrix仪表盘：它主要用来实时监控Hystrix的各项指标信息。通过Hystrix Dashboard反馈的实时信息，可以帮助我们快速发现系统中存在的问题，从而及时地采取应对措施。<br>启动时的页面：<br><img src="https://img-blog.csdnimg.cn/20200717230750851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>监控单服务的页面：<br><img src="https://img-blog.csdnimg.cn/20200717230807668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>我们现在的服务是这样的：<br><img src="https://img-blog.csdnimg.cn/20200717230822760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>除了可以开启单个实例的监控页面之外，还有一个监控端点 /turbine.stream是对集群使用的。 从端点的命名中，可以引入Turbine, 通过它来汇集监控信息，并将聚合后的信息提供给 HystrixDashboard 来集中展示和监控。<br><img src="https://img-blog.csdnimg.cn/20200717230833905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="七、Feign"><a href="#七、Feign" class="headerlink" title="七、Feign"></a>七、Feign</h1><p>为了简化我们的开发，Spring Cloud Feign出现了！它基于 Netflix Feign 实现，整合了 Spring Cloud Ribbon 与 Spring Cloud Hystrix,  除了整合这两者的强大功能之外，它还提供了声明式的服务调用(不再通过RestTemplate)。</p><blockquote><p>Feign是一种声明式、模板化的HTTP客户端。在Spring Cloud中使用Feign,<br>我们可以做到使用HTTP请求远程服务时能与调用本地方法一样的编码体验，开发者完全感知不到这是远程方法，更感知不到这是个HTTP请求。</p></blockquote><p>下面就简单看看Feign是怎么优雅地实现远程调用的：<br>服务绑定：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// value ---&gt;指定调用哪个服务</span><span class="hljs-comment">// fallbackFactory---&gt;熔断器的降级提示</span><span class="hljs-meta">@FeignClient</span>(value = <span class="hljs-string">"MICROSERVICECLOUD-DEPT"</span>, fallbackFactory = DeptClientServiceFallbackFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">DeptClientService</span> </span>&#123;    <span class="hljs-comment">// 采用Feign我们可以使用SpringMVC的注解来对服务进行绑定！</span>    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/dept/get/&#123;id&#125;"</span>, method = RequestMethod.GET)    <span class="hljs-function"><span class="hljs-keyword">public</span> Dept <span class="hljs-title">get</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> <span class="hljs-keyword">long</span> id)</span>;    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/dept/list"</span>, method = RequestMethod.GET)    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Dept&gt; <span class="hljs-title">list</span><span class="hljs-params">()</span></span>;    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/dept/add"</span>, method = RequestMethod.POST)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(Dept dept)</span></span>;&#125;Feign中使用熔断器：<span class="hljs-comment">/**</span><span class="hljs-comment"> * Feign中使用断路器</span><span class="hljs-comment"> * 这里主要是处理异常出错的情况(降级/熔断时服务不可用，fallback就会找到这里来)</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span> <span class="hljs-comment">// 不要忘记添加，不要忘记添加</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeptClientServiceFallbackFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FallbackFactory</span>&lt;<span class="hljs-title">DeptClientService</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DeptClientService <span class="hljs-title">create</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DeptClientService() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Dept <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> id)</span> </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Dept().setDeptno(id).setDname(<span class="hljs-string">"该ID："</span> + id + <span class="hljs-string">"没有没有对应的信息,Consumer客户端提供的降级信息,此刻服务Provider已经关闭"</span>)                        .setDb_source(<span class="hljs-string">"no this database in MySQL"</span>);            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Dept&gt; <span class="hljs-title">list</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(Dept dept)</span> </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;;    &#125;&#125;</code></pre></div><p>调用：<br><img src="https://img-blog.csdnimg.cn/20200717231002370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="八、Zuul"><a href="#八、Zuul" class="headerlink" title="八、Zuul"></a>八、Zuul</h1><p>基于上面的学习，我们现在的架构很可能会设计成这样：<br><img src="https://img-blog.csdnimg.cn/20200717231045862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>这样的架构会有两个比较麻烦的问题：</p><ul><li>路由规则与服务实例的维护间题：外层的负载均衡(nginx)需要维护所有的服务实例清单(图上的OpenService)</li><li>签名校验、 登录校验冗余问题：为了保证对外服务的安全性，<br>我们在服务端实现的微服务接口，往往都会有一定的权限校验机制，但我们的服务是独立的，我们不得不在这些应用中都实现这样一套校验逻辑，这就会造成校验逻辑的冗余。</li></ul><p>如下图：<br><img src="https://img-blog.csdnimg.cn/20200717231123144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>每个服务都有自己的IP地址，Nginx想要正确请求转发到服务上，就必须维护着每个服务实例的地址！<br>更是灾难的是：这些服务实例的IP地址还有可能会变，服务之间的划分也很可能会变。<br>购物车和订单模块都需要用户登录了才可以正常访问，基于现在的架构，只能在购物车和订单模块都编写校验逻辑，这无疑是冗余的代码。<br>为了解决上面这些常见的架构问题，API网关的概念应运而生。在SpringCloud中了提供了基于Netfl ix Zuul实现的API网关组件Spring Cloud Zuul。<br>Spring Cloud Zuul是这样解决上述两个问题的：</p><ul><li>SpringCloud Zuul通过与SpringCloud Eureka进行整合，将自身注册为Eureka服务治理下的应用，同时从Eureka中获得了所有其他微服务的实例信息。外层调用都必须通过API网关，使得将维护服务实例的工作交给了服务治理框架自动完成。</li><li>在API网关服务上进行统一调用来对微服务接口做前置过滤，以实现对微服务接口的拦截和校验。</li></ul><p>Zuul天生就拥有线程隔离和断路器的自我保护功能，以及对服务调用的客户端负载均衡功能。也就是说：Zuul也是支持Hystrix和Ribbon。<br>关于Zuul还有很多知识点(由于篇幅问题，这里我就不细说了)：</p><ul><li><p>路由匹配(动态路由)</p></li><li><p>过滤器实现(动态过滤器)</p></li><li><p>默认会过滤掉Cookie与敏感的HTTP头信息(额外配置)</p><h2 id="可能对Zuul的疑问"><a href="#可能对Zuul的疑问" class="headerlink" title="可能对Zuul的疑问"></a>可能对Zuul的疑问</h2><p>Zuul支持Ribbon和Hystrix，也能够实现客户端的负载均衡。我们的Feign不也是实现客户端的负载均衡和Hystrix的吗？既然Zuul已经能够实现了，那我们的Feign还有必要吗？<br><img src="https://img-blog.csdnimg.cn/20200717231623967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>或者可以这样理解：</p></li><li><p>zuul是对外暴露的唯一接口相当于路由的是controller的请求，而Ribbonhe和Fegin路由了service的请求</p></li><li><p>zuul做最外层请求的负载均衡 ，而Ribbon和Fegin做的是系统内部各个微服务的service的调用的负载均衡</p></li></ul><p>有了Zuul，还需要Nginx吗？他俩可以一起使用吗？<br>我的理解：Zuul和Nginx是可以一起使用的(毕竟我们的Zuul也是可以搭成集群来实现高可用的)，要不要一起使用得看架构的复杂度了(业务)<del>~</del></p><h1 id="九、Config"><a href="#九、Config" class="headerlink" title="九、Config"></a>九、Config</h1><p>随着业务的扩展，我们的服务会越来越多，越来越多。每个服务都有自己的配置文件。<br>既然是配置文件，给我们配置的东西，那难免会有些改动的。<br>比如我们的Demo中，每个服务都写上相同的配置文件。万一我们有一天，配置文件中的密码需要更换了，那就得三个都要重新更改。<br><img src="https://img-blog.csdnimg.cn/20200717231641121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在分布式系统中，某一个基础服务信息变更，都很可能会引起一系列的更新和重启，<br>Spring Cloud Config项目是一个解决分布式系统的配置管理方案。它包含了Client和Server两个部分，server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，client通过接口获取数据、并依据此数据初始化自己的应用。<br>简单来说，使用Spring Cloud Config就是将配置文件放到统一的位置管理(比如GitHub)，客户端通过接口去获取这些配置文件。<br>在GitHub上修改了某个配置文件，应用加载的就是修改后的配置文件。<br><img src="https://img-blog.csdnimg.cn/2020071723175164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>SpringCloud Config其他的知识：</p><ul><li>在SpringCloud Config的服务端， 对于配置仓库的默认实现采用了Git，我们也可以配置SVN。</li><li>配置文件内的信息加密和解密</li><li>修改了配置文件，希望不用重启来动态刷新配置，配合Spring  Cloud Bus 使用~</li></ul><p>使用SpringCloud Config可能的疑问：application.yml和 bootstrap.yml区别<br><code>https://www.cnblogs.com/BlogNetSpace/p/8469033.html</code></p><h1 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h1><p>本文主要写了SpringCloud的基础知识，希望大家看完能有所帮助~<br>SpringCloud的资料也很多，我整理一些我认为比较好，想要深入的同学不妨看看下边的资源<del>~</del><br>SpringCloud系列文章参考资料：</p><ul><li>史上最简单的 SpringCloud 教程 |<br>终章<a href="https://blog.csdn.net/forezp/article/details/70148833" target="_blank" rel="noopener">https://blog.csdn.net/forezp/article/details/70148833</a></li><li>Spring<br>Cloud基础教程《程序员DD》<a href="http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</a></li><li>Spring Cloud 系列文章《纯洁的微笑》：<a href="http://www.ityouknow.com/spring-cloud.html" target="_blank" rel="noopener">http://www.ityouknow.com/spring-cloud.html</a></li><li>SpringCloud系列文章：<a href="https://www.cnblogs.com/woshimrf/tag/SpringCloud/" target="_blank" rel="noopener">https://www.cnblogs.com/woshimrf/tag/SpringCloud/</a></li><li>SpringCloud系列文章《狂小白》：<a href="https://www.cnblogs.com/huangjuncong/tag/SpringCloud/" target="_blank" rel="noopener">https://www.cnblogs.com/huangjuncong/tag/SpringCloud/</a></li><li>SpringCloud官方文档：<a href="http://projects.spring.io/spring-cloud/" target="_blank" rel="noopener">http://projects.spring.io/spring-cloud/</a></li><li>Spring Cloud<br>中文文档：<a href="https://springcloud.cc/spring-cloud-dalston.html#_appendix_compendium_of_configuration_properties" target="_blank" rel="noopener">https://springcloud.cc/spring-cloud-dalston.html#_appendix_compendium_of_configuration_properties</a></li></ul><p><strong>参考书籍：</strong><br>《SpringCloud 微服务实战》</p>]]></content>
    
    
    <categories>
      
      <category>微服务分布式架构</category>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty面试题汇总</title>
    <link href="/2020/07/27/Netty%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2020/07/27/Netty%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Netty是什么？"><a href="#1-Netty是什么？" class="headerlink" title="1. Netty是什么？"></a>1. Netty是什么？</h1><p>Netty是一个<strong>异步事件驱动</strong>的网络应用程序框架，用于快速开发可维护性的高性能协议服务器和客户端，Netty是基于NIO的，它封装了JDK的NIO，让我们使用起来更加方便灵活。</p><h1 id="2-Netty的特点是什么？"><a href="#2-Netty的特点是什么？" class="headerlink" title="2. Netty的特点是什么？"></a>2. Netty的特点是什么？</h1><ul><li>高并发：Netty是一款基于NIO开发的网络通信框架，对比于BIO，它的并发性能得到了很大提高。</li><li>传输快：Netty的传输依赖于零拷贝特性，尽量减少不必要的内存拷贝，实现了更高效率的传输。</li><li>封装好：Netty封装了NIO操作的很多细节，提供了易于使用的接口。</li></ul><h1 id="3-Netty有哪些优势？"><a href="#3-Netty有哪些优势？" class="headerlink" title="3. Netty有哪些优势？"></a>3. Netty有哪些优势？</h1><ul><li>使用简单：封装了NIO的很多细节，使用更加简单；</li><li>功能强大：预置了多种编解码功能，支持多种主流协议；</li><li>定制能力强：可以通过ChannelHandler对通信框架进行灵活地扩展；</li><li>性能高：通过与其他业界主流的NIO框架对比，Netty的综合性能最优；</li><li>稳定：Netty修复了已经发现的所有NIO的bug，让开发人员可以专注于业务本身；</li><li>社区活跃：Netty是活跃的开源项目，版本迭代周期短，bug修复速度快。</li></ul><h1 id="4-Netty的应用场景有哪些？"><a href="#4-Netty的应用场景有哪些？" class="headerlink" title="4. Netty的应用场景有哪些？"></a>4. Netty的应用场景有哪些？</h1><ul><li>互联网行业：阿里分布式服务框架：Dubbo，默认使用Netty作为基础通信组件，还有RocketMQ也是使用Netty作为通讯的基础。</li><li>游戏行业：Netty作为高性能的基础通信组件，它本身提供了TCP/UDP和HTTP协议栈，非常方便定制和开发私有协议栈，账号登录服务器，地图服务器之间可以方便的通过Netty进行高性能的通信；</li><li>大数据领域：Hadoop的高性能通信和序列化组件Avro的RPC框架默认采用Netty进行跨界点通信。</li></ul><h1 id="5-Netty高性能表现在哪些方面？"><a href="#5-Netty高性能表现在哪些方面？" class="headerlink" title="5. Netty高性能表现在哪些方面？"></a>5. Netty高性能表现在哪些方面？</h1><ul><li>IO线程模型：同步非阻塞，用最少的资源做更多的事情；</li><li>内存零拷贝：尽量减少不必要的内存拷贝，实现了更高效率的传输；</li><li>内存池设计：申请的内存可以重用，主要指直接内存，内部实现是用一棵二叉查找树管理内存分配情况；</li><li>串行化处理读写：避免使用锁带来的性能开销；</li><li>高性能序列化协议：支持protobuf等高性能序列化协议；</li></ul><h1 id="6-BIO、NIO和AIO的区别？"><a href="#6-BIO、NIO和AIO的区别？" class="headerlink" title="6. BIO、NIO和AIO的区别？"></a>6. BIO、NIO和AIO的区别？</h1><ul><li>BIO：一个连接一个线程，客户端有连接请求时服务器端就需要开启一个线程进行处理，线程开销大；</li><li>伪异步IO：将请求连接放入线程池，一对多；</li><li>NIO：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理；</li><li>AIO：一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理；</li><li>BIO是面向流的，NIO是面向缓冲区的，BIO的各种流是阻塞的，而NIO是非阻塞的，BIO的Stream是单向的,而NIO的channel是双向的;</li><li>NIO的特点：事件驱动模型，单线程处理多任务，非阻塞I/O，I/O读写不再阻塞，而是返回0，基于块的传输比基于流的传输更高效，零拷贝技术、多路IO复用大大提高了Java网络应用的可伸缩性和实用性，基于Reactor线程模型。</li></ul><p>在Reactor模式中，事件分发器等待某个事件或某个操作的发生，事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作，如在Reactor中实现读：注册读就绪事件和相应的事件处理器-&gt;事件分发器等待事件-&gt;事件到来-&gt;激活分发器-&gt;分发器调用事件对应的处理器-&gt;事件处理器完成实际的读操作-&gt;处理读到的数据-&gt;注册新的事件-&gt;然后返还控制权。</p><h1 id="7-NIO的组成？"><a href="#7-NIO的组成？" class="headerlink" title="7. NIO的组成？"></a>7. NIO的组成？</h1><ul><li>Buffer：与channel进行交互，数据从channel读入缓冲区，从缓冲区写入channel中；</li><li>clear方法：使缓冲区为一系列新的通道<strong>读取</strong>或相对放置操作做好准备，它将限制设置为容量大小，将当前位置设置为0；</li><li>flip方法：使缓冲区为一系列新的通道写入或相对获取操作做好准备，它将限制设置为当前位置，然后将当前位置设置为0；</li><li>rewind方法：重读此缓冲区，将position设置为0；</li><li>DirectByteBuffer：可减少一次系统空间到用户空间的拷贝，但Buffer创建和销毁的成本更高，不可控，通常会用内存池来提高性能，直接缓冲区主要分配给那些一首基础系统的本机I/O操作影响的大型、持久的缓冲区，如果数据量比较小的中小应用，可以考虑使用heapBuffer，由JVM进行管理；</li><li>Channel：表示IO源与目标打开的连接，是双向的，但不能直接访问数据，只能与Buffer进行交互；</li><li>Selector：可使一个单独的线程管理多个Channel，open方法可创建Selector，register方法向多路复用器注册通道，可以监听的事件类型：读、写、连接、accept。注册事件后会产生一个SelectionKey：它表示SelectableChannel和Selector之间的注册关系，wakeup方法：使尚未返回的第一个选择操作立即返回。<h1 id="8-Netty的线程模型？"><a href="#8-Netty的线程模型？" class="headerlink" title="8. Netty的线程模型？"></a>8. Netty的线程模型？</h1>Netty的线程模型是基于Reactor模型的。<h2 id="Netty单线程模型"><a href="#Netty单线程模型" class="headerlink" title="Netty单线程模型"></a>Netty单线程模型</h2>Reactor单线程模型，是指所有的I/O操作都在同一个NIO线程上完成，此时NIO线程的职责包括：接收新连接请求，读写操作等。<br><img src="https://img-blog.csdnimg.cn/20200725172205341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在一些小容量应用场景下，可以使用单线程模型，但是对于高负载、高并发的应用场景却不合适，主要原因是：</li><li>一个NIO线程同时处理成百上千的连接，性能上无法支撑，即使NIO线程的CPU负荷达到100%，也无法满足海量消息的编码、解码、读取和发送；</li><li>当NIO线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重了NIO线程的负载，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈；</li><li>可靠性问题：一旦NIO线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障。</li></ul><h2 id="Reactor多线程模型"><a href="#Reactor多线程模型" class="headerlink" title="Reactor多线程模型"></a>Reactor多线程模型</h2><p>Reactor多线程模型与单线程模型最大的区别就是有一组NIO线程来处理连接读写操作，一个NIO线程处理Accept，一个NIO线程可以处理多个连接事件，一个连接事件只能属于一个NIO线程。<br><img src="https://img-blog.csdnimg.cn/20200725173009137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在绝大多数场景下，Reactor多线程模型可以满足性能要求，但是在个别特殊场景下，一个NIO线程负责监听和处理所有的客户端连接可能会存在性能问题。例如并发百万客户端连接，或者服务端需要对客户端握手进行安全认证，但是认证本身非常损耗性能，在这类场景下，单独一个Acceptor线程可能会存在性能不足的问题，为了解决性能问题，产生了第三种Reactor线程模型–主从Reactor多线程模型。</p><h2 id="Reactor主从多线程模型"><a href="#Reactor主从多线程模型" class="headerlink" title="Reactor主从多线程模型"></a>Reactor主从多线程模型</h2><p>主从Reactor线程模型的特点是：服务端用于接收客户端连接的不再是一个单独的NIO线程，而是一个独立的NIO线程池，Acceptor接收到客户端TCP连接请求并处理完成后（可能包含接入认证等），将新创建的SocketChannel注册到I/O线程池的某个I/O线程上，由它负责SocketChannel的读写和编解码工作，<strong>Acceptor线程池仅仅用于客户端的登录，握手和安全认证</strong>，一旦链路建立成功，就将链路注册到后端subReactor线程池的I/O线程上，由I/O线程负责后续的I/O操作。<br><img src="https://img-blog.csdnimg.cn/20200725174138228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="9-TCP粘包-拆包的原因及解决方法？"><a href="#9-TCP粘包-拆包的原因及解决方法？" class="headerlink" title="9. TCP粘包/拆包的原因及解决方法？"></a>9. TCP粘包/拆包的原因及解决方法？</h1><h2 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h2><p>应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象；</p><h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><ul><li>消息定长</li><li>包尾增加特殊字符分割</li></ul><h1 id="10-什么是Netty的零拷贝？"><a href="#10-什么是Netty的零拷贝？" class="headerlink" title="10. 什么是Netty的零拷贝？"></a>10. 什么是Netty的零拷贝？</h1><p>Netty的“零拷贝”主要体现在三个方面：</p><ul><li>Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行socket读写，不需要进行字节缓冲区的二次拷贝，如果使用传统的堆内存（HEAP BUFFERS）进行socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中，相对于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝；</li><li>第二种“零拷贝”的实现是CompositeByteBuf，它对外将多个ByteBuf封装成一个ByteBuf，对外提供统一封装后的ByteBuf接口；</li><li>第三种“零拷贝”就是文件传输，Netty文件传输类DefaultFileRegion通过transferTo方法将文件发送到目标Channel中，很多操作系统直接将文件缓冲区的内容发送到目标Channel中，而不需要通过循环拷贝的方式，这是一种更加高效的传输方式，提升了传输性能，降低了CPU和内存占用，实现了文件传输的“零拷贝”。</li></ul><h1 id="11-Netty中有哪几种重要组件？"><a href="#11-Netty中有哪几种重要组件？" class="headerlink" title="11. Netty中有哪几种重要组件？"></a>11. Netty中有哪几种重要组件？</h1><ul><li><strong>Channel</strong>：Netty网络操作抽象类，它除了包括基本的I/O操作，如bind、connect、read、write等；</li><li><strong>EventLoop</strong>：主要是配合Channel处理I/O操作，用来处理连接的生命周期中所发生的事情；</li><li><strong>ChannelFuture</strong>：Netty框架中所有的I/O操作都是异步的，因此我们需要ChannelFuture的addListener()注册一个ChannelFutureListener监听事件，当操作执行成功或者失败时，监听就会自动触发返回结果；</li><li><strong>ChannelHandler</strong>：充当了所有处理入站和出站数据的逻辑容器，ChannelHandler主要用来处理各种事件，比如：连接，数据接收，异常，数据转换等；</li><li><strong>ChannelPipeline</strong>：为ChannelHandler链提供了容器，当channel创建时，就会被自动分配到它专属的ChannelPipeline，这个关联是永久性的。</li></ul><h1 id="12-Netty发送消息有几种方式？"><a href="#12-Netty发送消息有几种方式？" class="headerlink" title="12. Netty发送消息有几种方式？"></a>12. Netty发送消息有几种方式？</h1><p>Netty有两种发送消息的方式：</p><ul><li>直接写入Channel中，消息从ChannelPipeline当中尾部开始移动；</li><li>写入和ChannelHandler绑定的ChannelHandlerContext中，消息从ChannelPipeline中的下一个ChannelHandler中移动。</li></ul><h1 id="13-默认情况Netty-开启多少线程，何时启动？"><a href="#13-默认情况Netty-开启多少线程，何时启动？" class="headerlink" title="13. 默认情况Netty 开启多少线程，何时启动？"></a>13. 默认情况Netty 开启多少线程，何时启动？</h1><p>Netty默认是CPU处理器数的两倍，bind完之后启动。</p><h1 id="14-了解哪几种序列化协议？"><a href="#14-了解哪几种序列化协议？" class="headerlink" title="14. 了解哪几种序列化协议？"></a>14. 了解哪几种序列化协议？</h1><p>序列化（编码）是将对象序列化为二进制形式（字节数组），主要用于网络传输，数据持久化等，而反序列化（解码）则是将从网络，磁盘等读取的字节数组还原成原始对象，主要用于网络传输对象的解码，以便完成远程调用。</p><p>影响序列化性能的关键因素：序列化后的码流大小（网络带宽的占用）、序列化的性能（CPU资源占用）、是否支持跨语言（异构系统的对接和开发语言切换）。</p><p>Java默认提供的序列化：无法跨语言、序列化后的码流台打、序列化的性能差。</p><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>优点：人机可读性好，可指定元素或特性的名称；<br>缺点：序列化数据只包含数据本身以及类的结构，不包括类型标识和程序集信息；只能序列化公共属性和字段；不能序列化方法，文件庞大，文件格式复杂，传输占带宽；<br>适用场景：当作配置文件存储数据，实时数据转换。</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>一种轻量级的数据交换格式。<br>优点：兼容性高，数据格式比较简单，易于读写，序列化后数据较小，可扩展性好，兼容性好，与XML相比，其协议比较简单，解析速度比较快；<br>缺点：数据的描述性比XML差，不适合性能要求为ms级别的情况，额外空间开销比较大；<br>适用场景：跨防火墙访问、基于Web browser的Ajax请求，传输数据量相对小，实时性要求相对低的服务；</p><h2 id="Fastjson"><a href="#Fastjson" class="headerlink" title="Fastjson"></a>Fastjson</h2><p>采用一种“假定有序快速匹配”的算法。<br>优点：接口简单易用，目前Java语言中最快的Json库；<br>缺点：过于注重快，而偏离了“标准”及功能性，代码质量不高，文档不全；<br>适用场景：协议交互，Web输出，Android客户端</p><h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><p>将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性。<br>优点：序列化后码流小，性能高，结构化数据存储格式（XML、JSON等），通过标识字段的顺序，可以实现协议的前后兼容，结构化的文档更容易管理和维护。<br>缺点：需要依赖与工具生成代码，支持的语言相对较少，官方只支持Java，C++，python；<br>适用场景：对性能要求高的RPC调用，具有良好的跨防火墙的访问属性，适用应用层对象的持久化。</p><h1 id="15-Netty支持哪些心跳类型设置"><a href="#15-Netty支持哪些心跳类型设置" class="headerlink" title="15. Netty支持哪些心跳类型设置"></a>15. Netty支持哪些心跳类型设置</h1><ul><li>readerIdleTime：为读超时时间</li><li>writerIdleTime：为写超时时间</li><li>allIdleTime：所有类型的超时时间</li></ul><h1 id="16-Netty和Tomcat的区别"><a href="#16-Netty和Tomcat的区别" class="headerlink" title="16. Netty和Tomcat的区别"></a>16. Netty和Tomcat的区别</h1><ul><li>作用不同：Tomcat是Servlet容器，可以视为Web服务器，而Netty是异步事件驱动的网络应用程序框架和工具用于简化网络编程，例如：TCP和UDP套接字服务器。</li><li>协议不同：Tomcat是基于http协议的Web服务器，而Netty能通过编程自定义各种协议，因为Netty本身能编码/解码字节流，所以Netty可以实现HTTP服务器，FTP服务器，UDP服务器，RPC服务器，WebSocket服务器，Redis的Proxy服务器，MySQL的Proxy服务器等。</li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务分布式架构</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis面试题汇总</title>
    <link href="/2020/07/27/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2020/07/27/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>Redis是一个使用C语言编写的，开源的高性能<strong>非关系型</strong>的<strong>键值对</strong>数据库。</p><p>Redis可以存储键和五种不同类型的值之间的映射，<strong>键的类型只能为字符串</strong>，值支持五种数据类型：String，List，Set，Hash，ZSet。</p><p>与传统数据库不同的是Redis的数据是存储在<strong>内存</strong>中，所以读写速度非常快，因此Redis被广泛应用在<strong>缓存</strong>方向，每秒可以处理超过10万次读写操作，是已知性能最快的key-value 数据库，另外，Redis也经常用来做<strong>分布式锁</strong>，除此之外，Redis支持<strong>事务</strong>，<strong>持久化</strong>，<strong>LUA脚本</strong>，<strong>LRU驱动事件</strong>，多种<strong>集群</strong>方案。</p><h2 id="Redis有哪些优缺点"><a href="#Redis有哪些优缺点" class="headerlink" title="Redis有哪些优缺点"></a>Redis有哪些优缺点</h2><p>优点：</p><ul><li>读写性能优异，Redis能读的速度是110000次/s，写的速度是81000次/s</li><li>支持数据持久化，支持<code>AOF</code>和<code>RDB</code>两种持久化方式。</li><li>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行；</li><li>数据结构丰富，除了支持String类型的value外，还支持hash，set，zset，list等数据结构；</li><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li></ul><p>缺点：</p><ul><li>数据库容量受到物理内存的限制，<strong>不能做海量数据的高性能读写</strong>，因此Redis适合的场景主要局限于较小数据量的高性能操作和运算上；</li><li>Redis<strong>不具备自动容错和恢复功能</strong>，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或手动切换前端的IP才能恢复；</li><li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引起数据不一致的问题，降低了系统的可用性；</li><li>Redis<strong>在线扩容比较复杂</strong>，当集群容量达到上限时在线扩容会变得很复杂，为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li></ul><h2 id="为什么要用缓存？"><a href="#为什么要用缓存？" class="headerlink" title="为什么要用缓存？"></a>为什么要用缓存？</h2><p>主要从“高性能”和“高并发”这两点来看待这个问题。</p><h3 id="高性能："><a href="#高性能：" class="headerlink" title="高性能："></a>高性能：</h3><p><img src="https://img-blog.csdnimg.cn/2020072609180374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="高并发："><a href="#高并发：" class="headerlink" title="高并发："></a>高并发：</h3><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的。<br><img src="https://img-blog.csdnimg.cn/20200726091913177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="为什么要用Redis而不用map-guava做缓存"><a href="#为什么要用Redis而不用map-guava做缓存" class="headerlink" title="为什么要用Redis而不用map/guava做缓存"></a>为什么要用Redis而不用map/guava做缓存</h2><p>缓存分为<strong>本地缓存</strong>和<strong>分布式缓存</strong>，以Java为例，使用自带的map或者guava实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着JVM的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，<strong>缓存不具有一致性</strong>。</p><p>使用Redis或Memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，<strong>缓存具有一致性</strong>，缺点是需要保持Redis或Memcached服务的高可用，整个程序架构上较为复杂。</p><h2 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h2><ul><li><strong>完全基于内存</strong>，绝大部分请求都是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，查找和操作的时间复杂度都为O(1)；</li><li><strong>数据结构</strong>简单，对数据操作也简单，Redis的数据结构是专门进行设计的；</li><li><strong>采用单线程，避免了不必要的上下文切换和竞争条件</strong>，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，因为没有可能出现死锁而导致的性能消耗；</li><li>使用<strong>多路I/O复用模型</strong>，非阻塞IO；</li><li>使用<strong>底层模型</strong>不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li></ul><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="Redis有哪些数据类型"><a href="#Redis有哪些数据类型" class="headerlink" title="Redis有哪些数据类型"></a>Redis有哪些数据类型</h2><p><img src="https://img-blog.csdnimg.cn/2020072609412168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a>Redis的应用场景</h2><h2 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h2><p><strong>计数器</strong><br>可以对String进行自增自减运算，从而实现计数器功能，Redis这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。<br><strong>缓存</strong><br>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。<br><strong>会话缓存</strong><br>可以使用Redis来统一存储多台应用服务器的会话信息，当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。<br><strong>查找表</strong><br>例如DNS记录就很适合使用Redis进行存储，查找表和缓存类似，也是利用了Redis快速的查找特性，但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。<br><strong>消息队列（发布/订阅功能）</strong><br>List是一个双向链表，可以通过<code>lpush</code>和<code>rpop</code>写入和读取消息，不过最好使用Kafka，RabbitMQ等消息中间件。<br><strong>分布式锁实现</strong><br>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步，可以使用Redis自带的<code>SETNX</code>命令实现分布式锁，除此之外，还可以使用官方提供的<code>RedLock</code>分布式锁实现。<br><strong>其他</strong><br>Set可以实现交集，并集操作，从而实现共同好友等功能，ZSet可以实现有序性操作，从而实现排行榜等功能。</p><h2 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h2><p>Redis相比其他缓存，有一个非常大的优势，就是支持多种数据类型。</p><ul><li>String–适合最简单的k-v存储，类似于Memcached的存储结构，短信验证码，配置信息等，就用这种类型来存储；</li><li>hash–一般key为ID或者唯一标识，value对应的就是详情了，如商品详情，个人信息详情，新闻详情等；</li><li>list–有序，比较适合存储一些有序且数据相对固定的数据，如：省市区表，字典表等，因为list是有序的，适合根据写入的时间来排序，如：消息队列等；</li><li>set–可以简单理解为ID-list模式，如微博中一个人有哪些好友，可以对两个set提供交集，并集，差集操作，例如：查找两个人共同的好友等；</li><li>Sorted Set–是set的增强版本，增加了一个<code>score</code>参数，自动会根据score的值进行排序，比较适合类似于top10等不根据插入的时间来排序的数据。</li></ul><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="什么是Redis持久化"><a href="#什么是Redis持久化" class="headerlink" title="什么是Redis持久化"></a>什么是Redis持久化</h2><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机导致内存数据丢失。</p><h2 id="Redis持久化机制是什么？各自的优缺点？"><a href="#Redis持久化机制是什么？各自的优缺点？" class="headerlink" title="Redis持久化机制是什么？各自的优缺点？"></a>Redis持久化机制是什么？各自的优缺点？</h2><p>Redis提供了两种持久化机制RDB（默认）和AOF机制。</p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB：默认的持久化方式，按照一定的时间将内存的数据以<code>快照</code>的形式保存到磁盘中，对应产生的数据文件为<code>dump.rdb</code>，有两个Redis命令可以用于生成RDB文件，一个是<code>SAVE</code>，另一个是<code>BGSAVE</code>，（SAVE会阻塞Redis服务器进程，直到RDB文件创建完毕，BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程继续处理请求命令）。<br><img src="https://img-blog.csdnimg.cn/20200726100538969.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>优点：</strong></p><ul><li>只有一个文件dump.rdb，方便备份；</li><li>容灾性好，一个文件可以保存到安全的磁盘；</li><li>性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化，使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了Redis的高性能；</li><li>相对于数据集大时，比AOF的启动效率更高；</li></ul><p><strong>缺点：</strong></p><ul><li>数据安全性低，RDB是间隔一段时间进行持久化，如果持久化之间Redis发生故障，会发生数据丢失，所以这种方式更适合数据要求不高的情况；</li></ul><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF持久化（Append Only File）是将Redis执行的每次写命令<strong>记录到单独的日志文件</strong>中，当重启Redis会重新将持久化的日志中文件恢复数据。</p><p><strong>当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。</strong><br><img src="https://img-blog.csdnimg.cn/20200726101403651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>优点：</p><ul><li><strong>数据安全</strong>，AOF持久化可以配置<code>appendfsync</code>属性，有always，每进行一次命令操作就记录到AOF文件中一次；</li><li>通过append模式写文件，即使中途服务器宕机，可以通过<code>redis-check-aof</code>工具解决数据一致性问题；</li><li>AOF机制的rewrite模式（文件过大时会对命令进行合并重写），可以删除其中的某些命令。</li></ul><p>缺点：</p><ul><li>AOF文件比RDB文件大，且恢复速度慢</li><li>数据集大的时候，AOF启动效率低</li></ul><h2 id="如何选择合适的持久化方式"><a href="#如何选择合适的持久化方式" class="headerlink" title="如何选择合适的持久化方式"></a>如何选择合适的持久化方式</h2><ul><li>一般来说，如果是想达到足以媲美PostgreSQL的数据安全性，你应该<strong>同时使用两种持久化功能</strong>，在这种情况下，当Redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集更完整；</li><li>如果你非常关心你的数据，但仍可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化；</li><li>有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照非常便于进行数据库备份，并且RDB恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免AOF程序的bug；</li><li>如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式；</li></ul><h2 id="Redis持久化数据和缓存怎么做扩容"><a href="#Redis持久化数据和缓存怎么做扩容" class="headerlink" title="Redis持久化数据和缓存怎么做扩容"></a>Redis持久化数据和缓存怎么做扩容</h2><ul><li>如果Redis被当做缓存使用，使用<strong>一致性哈希</strong>实现动态扩容缩容；</li><li>如果Redis被当做一个持久化存储使用，必须使用固定的<code>keys-to-nodes</code>映射关系，节点的数量一旦确定不能变化，如果Redis节点需要动态变化，必须使用可以在运行时进行数据再平衡的一套系统，而当前只有<strong>Redis集群</strong>可以做到这样。</li></ul><h1 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h1><h2 id="Redis-key的过期时间和永久有效分别怎么设置"><a href="#Redis-key的过期时间和永久有效分别怎么设置" class="headerlink" title="Redis key的过期时间和永久有效分别怎么设置"></a>Redis key的过期时间和永久有效分别怎么设置</h2><p><code>EXPIRE</code>和<code>PERSIST</code>命令。</p><h2 id="Redis的过期键的删除策略"><a href="#Redis的过期键的删除策略" class="headerlink" title="Redis的过期键的删除策略"></a>Redis的过期键的删除策略</h2><p>Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间，Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。<br>过期策略通常有三种：</p><ul><li><strong>定时过期</strong>：每个设置过期时间的key都需要创建一个定时器，到<strong>过期时间就会立即清除</strong>，该策略可以立即清除过期的数据，对内存很友好，但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</li><li><strong>惰性过期</strong>：只有当访问一个key时，才会判断该key是否已过期，过期就清除，该策略可以最大化的节省CPU资源，却对内存非常不友好，极端情况下可能会出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li><li><strong>定期过期</strong>：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key，该策略是前两者的一个折中方案，通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优 的平衡效果。<br>（expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向进键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间，键空间是指该Redis集群中保存的所有键。）</li></ul><p><strong>Redis同时使用了惰性过期和定期过期两种过期策略。</strong></p><h1 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h1><h2 id="MySQL里有2000w数据，Redis中只有20w的数据，如何保证Redis中的数据都是热点数据"><a href="#MySQL里有2000w数据，Redis中只有20w的数据，如何保证Redis中的数据都是热点数据" class="headerlink" title="MySQL里有2000w数据，Redis中只有20w的数据，如何保证Redis中的数据都是热点数据"></a>MySQL里有2000w数据，Redis中只有20w的数据，如何保证Redis中的数据都是热点数据</h2><p>Redis内存数据集大小上升到一定大小的时候，就会施行<strong>数据淘汰策略</strong>。</p><h2 id="Redis的内存淘汰策略有哪些"><a href="#Redis的内存淘汰策略有哪些" class="headerlink" title="Redis的内存淘汰策略有哪些"></a>Redis的内存淘汰策略有哪些</h2><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p><h3 id="全局的键空间选择性移除"><a href="#全局的键空间选择性移除" class="headerlink" title="全局的键空间选择性移除"></a>全局的键空间选择性移除</h3><ul><li><strong>noeviction</strong>：当内存不足以容纳新写入数据时，<strong>新写入操作会报错</strong>；</li><li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，<strong>移除最近最少使用的key</strong>。</li><li><strong>allkeys-random</strong>：当内存不足以容纳新写入数据时，在键空间中，<strong>随机移除某个key</strong>。</li></ul><h3 id="设置过期时间的键空间选择性移除"><a href="#设置过期时间的键空间选择性移除" class="headerlink" title="设置过期时间的键空间选择性移除"></a>设置过期时间的键空间选择性移除</h3><ul><li><strong>volatile-lru</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，<strong>移除最近最少使用的key</strong>；</li><li><strong>volatile-random</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，<strong>随机移除某个key</strong>；</li><li><strong>volatile-ttl</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，<strong>有更早过期时间的key优先移除</strong>。</li></ul><h2 id="Redis主要消耗什么物理资源"><a href="#Redis主要消耗什么物理资源" class="headerlink" title="Redis主要消耗什么物理资源"></a>Redis主要消耗什么物理资源</h2><p>内存</p><h2 id="Redis的内存用完了会发生什么"><a href="#Redis的内存用完了会发生什么" class="headerlink" title="Redis的内存用完了会发生什么"></a>Redis的内存用完了会发生什么</h2><p>如果达到设置的上限，Redis的<strong>写命令会返回错误信息</strong>（读命令还可以正常返回），或者你可以配置内存淘汰机制，当Redis达到内存上限时会<strong>冲刷掉旧的内容</strong>。</p><h2 id="Redis如何做内存优化"><a href="#Redis如何做内存优化" class="headerlink" title="Redis如何做内存优化"></a>Redis如何做内存优化</h2><p>可以好好利用Hash，list，sorted set，set等集合类型数据，因为通常情况下很多小的key-value可以用更紧凑的方式存放到一起，尽可能使用散列表（hash），散列表使用的内存非常小，所以你应该尽可能地将你的数据模型抽象到一个散列表中，比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面。</p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：</p><ul><li>文件事件：服务器与客户端（或其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li><li>时间事件：Redis服务器中的一些操作需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li></ul><h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>Redis基于<strong>Reactor</strong>模式开发了网络事件处理器，这个处理器被称为<strong>文件事件处理器</strong>，它的组成结构为4部分：<strong>多个套接字</strong>，<strong>IO多路复用程序</strong>，<strong>文件事件分派器</strong>，<strong>事件处理器</strong>。<code>因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型</code>。</p><p><img src="https://upload-images.jianshu.io/upload_images/7368936-fe23b577eef07aa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" srcset="/img/loading.gif" alt="img"></p><ul><li>文件事件处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept），读取（read），写入（write），关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p>虽然<strong>文件事件处理器以单线程方式运行</strong>，但通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了Redis内部单线程设计的简单性。</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化，按顺序执行，事务在执行过程中，不会被其他客户端发送来的命令请求所打断。<br>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><h2 id="Redis事务的概念"><a href="#Redis事务的概念" class="headerlink" title="Redis事务的概念"></a>Redis事务的概念</h2><p>Redis事务的本质是通过<strong>MULTI</strong>，<strong>EXEC</strong>，<strong>WATCH</strong>等一组命令的集合，事务支持一次执行多个命令，一个事务中所有命令都会被序列化，在事务执行过程中，会按照顺序序列化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。<br>总结说：Redis事务就是<strong>一次性</strong>、<strong>顺序性</strong>、<strong>排他性</strong>地执行一个队列中的一系列命令。</p><h2 id="Redis事务的三个阶段"><a href="#Redis事务的三个阶段" class="headerlink" title="Redis事务的三个阶段"></a>Redis事务的三个阶段</h2><ul><li>事务开始MULTI</li><li>命令入队</li><li>事务执行EXEC</li></ul><p>事务执行过程中，如果服务端收到有EXEC,DISCARD,WATCH,MULTI之外的请求，将会把请求放入队列中排队。</p><h2 id="Redis事务相关命令"><a href="#Redis事务相关命令" class="headerlink" title="Redis事务相关命令"></a>Redis事务相关命令</h2><p>Redis事务功能是通过<strong>MULTI</strong>,<strong>EXEC</strong>,<strong>DISCARD</strong>和<strong>WATCH</strong>四个原语实现的，Redis会将一个事务中所有命令序列化，然后按顺序执行。</p><ol><li>Redis不支持回滚，“<strong>Redis在事务失败时不进行回滚，而是继续执行余下的命令</strong>”，所以Redis的内部可以保持简单且快速；</li><li>如果在一个事务中的命令出现错误，那么所有的命令都不会执行；</li><li>如果在一个事务中出现运行错误，那么正确的命令会被执行。</li></ol><p>四个原语：</p><ul><li>WATCH命令是一个乐观锁，可以为Redis事务提供check-and-set（CAS）行为，可以<strong>监控一个或多个键，一旦其中有一个键被修改，之后的事务就都不会执行，监控一直持续到EXEC命令</strong>；</li><li><strong>MULTI命令用于开启一个事务</strong>，它总是返回OK，MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个<strong>队列</strong>中，当EXEC命令被调用时，所有队列中的命令才会被执行。</li><li><strong>EXEC：执行所有事务块内的命令</strong>，返回事务块内所有命令的返回值，按命令执行的先后顺序排列，当操作被打断时，返回空值nil。</li><li>通过调用<strong>DISCARD</strong>，客户端可以清空事务队列，并放弃执行事务，并且客户端会从事务状态中退出。</li><li>UNWATCH命令可以取消WATCH对所有key的监控。</li></ul><h2 id="事务管理（ACID）概述"><a href="#事务管理（ACID）概述" class="headerlink" title="事务管理（ACID）概述"></a>事务管理（ACID）概述</h2><p><strong>原子性（Atomicity）</strong><br>原子性是指事务是一个<strong>不可分割的工作单位</strong>，事务中操作要么都发生，要么都不发生。<br><strong>一致性（Consistency）</strong><br>事务前后数据的完整性必须保持一致。<br><strong>隔离性（Isolation）</strong><br>多个事务并发执行时，一个事务的执行不应影响其他其他事务的执行。<br><strong>持久性（Durability）</strong><br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</p><p>Redis的事务总是具有ACID中的<strong>一致性</strong>和<strong>隔离性</strong>，其他特性是不支持的，当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有持久性。</p><h2 id="Redis事务支持隔离性吗"><a href="#Redis事务支持隔离性吗" class="headerlink" title="Redis事务支持隔离性吗"></a>Redis事务支持隔离性吗</h2><p>Redis是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止，因此<strong>Redis的事务总是带有隔离性的</strong>。</p><h2 id="Redis事务保证原子性吗？支持回滚吗？"><a href="#Redis事务保证原子性吗？支持回滚吗？" class="headerlink" title="Redis事务保证原子性吗？支持回滚吗？"></a>Redis事务保证原子性吗？支持回滚吗？</h2><p>Redis中，单条命令是原子性执行的，但<strong>事务不保证原子性，且没有回滚</strong>，事务中任意命令执行失败，其余的命令仍会被执行。</p><h2 id="Redis事务其他实现"><a href="#Redis事务其他实现" class="headerlink" title="Redis事务其他实现"></a>Redis事务其他实现</h2><ul><li>基于Lua脚本，Redis可以保证脚本内的命令一次性，按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完。</li><li>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成，但这样会需要额外写代码实现，比较繁琐。</li></ul><h1 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h1><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p><img src="https://img-blog.csdnimg.cn/20200726170717531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>哨兵的介绍</strong><br><strong>sentinel</strong>，中文名是哨兵，哨兵是Redis集群机构中非常重要的一个组件，主要有以下功能：</p><ul><li><strong>集群监控</strong>：负责监控Redis中master和slave进程是否正常工作；</li><li><strong>消息通知</strong>：如果某个Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员；</li><li><strong>故障转移</strong>：如果master node挂掉了，会自动转移到slave node上；</li><li><strong>配置中心</strong>：如果故障转移发生了，通知client客户端新的master地址。</li></ul><p><strong>哨兵用于实现Redis集群的高可用</strong>，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p><ul><li>故障转移时，判断一个master node是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式<strong>选举</strong>的问题；</li><li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的。</li></ul><p><strong>哨兵的核心知识</strong></p><ul><li>哨兵至少需要3个实例，来保证自己的健壮性；</li><li>哨兵+Redis主从的部署架构，是不保证数据零丢失的，只能保证Redis集群的高可用性；</li><li>对于哨兵+Redis主从这种复杂的部署架构，尽量在测试环境和生产环境都进行充足的测试和演练。</li></ul><h2 id="官方Redis-Cluster方案（服务端路由查询）"><a href="#官方Redis-Cluster方案（服务端路由查询）" class="headerlink" title="官方Redis Cluster方案（服务端路由查询）"></a>官方Redis Cluster方案（服务端路由查询）</h2><p><img src="https://img-blog.csdnimg.cn/20200726180328364.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="Redis集群模式的工作原理能说一下吗？在集群模式下，Redis的key是如何寻址的？分布式寻址都有哪些算法？了解一致性Hash算法吗？"><a href="#Redis集群模式的工作原理能说一下吗？在集群模式下，Redis的key是如何寻址的？分布式寻址都有哪些算法？了解一致性Hash算法吗？" class="headerlink" title="Redis集群模式的工作原理能说一下吗？在集群模式下，Redis的key是如何寻址的？分布式寻址都有哪些算法？了解一致性Hash算法吗？"></a>Redis集群模式的工作原理能说一下吗？在集群模式下，Redis的key是如何寻址的？分布式寻址都有哪些算法？了解一致性Hash算法吗？</h3><p><strong>简介</strong><br>Redis Cluster是一种服务端Sharding（分片）技术，3.0版本开始正式提供，Redis Cluster并没有使用一致性hash，而是采用slot（槽）的概念，一共分为16384个槽，将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行。</p><p><strong>方案说明</strong></p><ol><li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽区间的数据，默认分配了16384个槽位；</li><li>每份数据分片会存储在多个互为主从的多节点上；</li><li>数据写入先写主节点，再同步到从节点；</li><li>同一分片多个节点间的数据不保持一致性；</li><li>读取数据时，当客户端操作的key没有分配在该节点上时，Redis会返回转向指令，指向正确的节点；</li><li>扩容时需要把旧节点的数据迁移一部分到新节点。</li></ol><p>在Redis cluster架构下，每个Redis要开放两个端口号，比如一个是6379，另一个就是加1w的端口号，如：16379,16379端口号就是用来进行节点间通信的，也就是cluster bus的东西，cluster bus的通信，用来进行故障检测、配置更新、故障转移授权，cluster bus用了另外一种二进制的协议，<code>gossip</code>协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p><p><strong>节点间的内部通信机制</strong><br>集群元数据的维护有两种方式：集中式、gossip协议，Redis cluster节点间采用gossip协议进行通信。</p><p><strong>分布式寻址算法</strong></p><ul><li>hash算法（大量缓存重建）</li><li>一致性hash算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li><li>Redis cluster的hash slot算法</li></ul><p><strong>优点</strong></p><ul><li>无中心架构，支持动态扩容，对业务透明；</li><li>具备Sentinel的监控和自动Failover（故障转移）能力；</li><li>客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可；</li><li>高性能，客户端直连Redis服务，免去了Proxy代理的损耗。</li></ul><p><strong>缺点</strong></p><ul><li>运维也很复杂，数据迁移需要人工干预；</li><li>只能使用0号数据库；</li><li>不支持批量操作；</li><li>分布式逻辑和存储模块耦合等</li></ul><h2 id="基于客户端分配"><a href="#基于客户端分配" class="headerlink" title="基于客户端分配"></a>基于客户端分配</h2><p><img src="https://img-blog.csdnimg.cn/2020072618255133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>简介</strong><br>Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法，其主要思想是<strong>采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上</strong>，Java Redis客户端驱动Jedis，支持Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool。</p><p><strong>优点</strong><br>非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强。</p><p><strong>缺点</strong></p><ul><li>由于Sharding处理放到客户端，规模进一步扩大时给运维带来挑战；</li><li>客户端Shardin<strong>g不支持动态增删节点</strong>，服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整，连接不能共享，当应用规模增大时，资源浪费制约优化。</li></ul><h2 id="基于代理服务器分片"><a href="#基于代理服务器分片" class="headerlink" title="基于代理服务器分片"></a>基于代理服务器分片</h2><p><img src="https://img-blog.csdnimg.cn/20200726183552539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>简介</strong><br>客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发到正确的节点，最后将结果回复给客户端。</p><p><strong>特征</strong></p><ul><li>透明接入，业务程序不用关心后端Redis实例，切换成本低；</li><li>Proxy的逻辑和存储的逻辑是隔离的；</li><li>代理层多了一次转发，性能有所损耗；</li></ul><h2 id="Redis主从架构"><a href="#Redis主从架构" class="headerlink" title="Redis主从架构"></a>Redis主从架构</h2><p>单机的Redis，能够承载的QPS大概就在上万到几万不等，对于缓存来说，一般都是用来支撑<strong>读高并发</strong>的，因此架构做成主从架构，一主多从，<strong>主负责写</strong>，并且将数据复制到其他的slave节点，<strong>从节点负责读</strong>，所有的读请求全部走从节点，这样也可以很轻松实现水平扩容，支撑读高并发。<br><img src="https://img-blog.csdnimg.cn/20200726184208107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</p><p><strong>Redis replication的核心机制</strong></p><ul><li>Redis采用异步方式复制数据到slave节点，不过从Redis2.8开始，slave node会周期性地确认自己每次复制的数据量；</li><li>一个master node是可以配置多个slave node的；</li><li>slave node也可以连接其他的slave node；</li><li>slave node做复制的时候，不会阻塞master node的正常工作，也不会阻塞对自己的查询操作，它会用旧的数据集来提供服务，但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li><li>slave node主要用来进行横向扩容，做读写分离，扩容的slave node可以提高读的吞吐量。</li></ul><p>注意：<strong>如果采用了主从架构，那么建议必须开启master node的持久化</strong>，不建议用slave node作为master node的数据热备，因为那样的话，如果你关闭了master的持久化，可能在master宕机重启的时候数据是空的，然后可能一经过复制，salve node的数据也丢了。</p><p>另外，master的各种备份方案也需要做，万一本地的所有文件丢失了，从备份中挑选一份RDB去恢复master，这样才能确保启动的时候是有数据的，即使采用了后续讲解的高可用机制，slave node可以自动接管master node，但也可能sentinel还没检测到master failure，master node就自动重启了，还是可能导致上面所有的slave node数据被清空。</p><p><strong>Redis主从复制的核心原理</strong><br>当启动一个slave node的时候，它会发送一个<code>PSYNC</code>命令给master node。</p><p>如果这是slave node初次连接到master node，那么会触发一次<code>full resynchronization</code>全量复制，此时master会启动一个后台线程，开始生成一份RDB快照文件；</p><p>同时还会将从客户端client新收到的所有写命令缓存在内存中，RDB文件生成完毕后，master会将这个RDB发送给slave，<strong>slave会先写入本地磁盘，然后再从本地磁盘加载到内存中</strong>；</p><p>接着master会将内存中缓存的写命令发送到slave，slave也会同步这些数据；</p><p>slave node如果跟master node有网络故障，断开了连接，会自动重连，连接之后master node仅会复制给slave部分缺少的数据。<br><img src="https://img-blog.csdnimg.cn/20200727083524293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>过程原理</strong></p><ol><li>当从库和主库建立master-slave关系后，从库会向主库发送SYNC命令；</li><li>主库接收到SYNC命令后会开始在后台保存快照（RDB持久化过程），并将期间接收到的写命令缓存起来；</li><li>当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis；</li><li>从Redis接收到后，会载入快照文件并且执行收到的缓存的命令；</li><li>之后，主Redis每当接收到写命令时都会将命令发送给从Redis，从而保证数据的一致性</li></ol><p><strong>缺点</strong><br>所有的slave节点数据的复制和同步都由master节点来处理，会造成master节点压力太大，可以使用主从从结构来解决。</p><h2 id="Redis集群的主从复制模型是怎么样的"><a href="#Redis集群的主从复制模型是怎么样的" class="headerlink" title="Redis集群的主从复制模型是怎么样的"></a>Redis集群的主从复制模型是怎么样的</h2><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品。</p><h2 id="生产环境中的Redis是怎么部署的"><a href="#生产环境中的Redis是怎么部署的" class="headerlink" title="生产环境中的Redis是怎么部署的"></a>生产环境中的Redis是怎么部署的</h2><p>Redis cluster，10台机器，5台机器部署了Redis主实例，另外5台机器部署了Redis的从实例，每个主实例挂了一个从实例，5个节点对外提供读写服务，每个节点的读写高峰QPS可以达到每秒5万，5台机器最多是25万读写请求/s。</p><p>机器是什么配置？<br>32G内存+8核CPU+1T磁盘，但是分配给Redis进程的是10G，一般线上生产环境，Redis的内存尽量不要超过10G，不然可能会有问题。</p><p>5台机器对外提供读写，一共有50G内存。</p><p>因为每个主实例都挂了一个从实例，任何一个主实例宕机，都会自动故障迁移，Redis从实例会自动变成主实例继续提供读写服务。</p><p>你往内存里写的是什么数据？每条数据的大小是多少？<br>商品数据，每条数据是10kb，100条数据是1mb，10万条数据就是1G，常驻内存的是200万条商品数据，占用内存是20G，仅仅不到总内存的50%，目前高峰期每秒就是3500左右的请求量。</p><h2 id="说说Redis哈希槽的概念"><a href="#说说Redis哈希槽的概念" class="headerlink" title="说说Redis哈希槽的概念"></a>说说Redis哈希槽的概念</h2><p>Redis集群中没有使用一致性hash，而是引入了哈希槽的概念，Redis集群有16384个哈希槽，<strong>每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</strong></p><h2 id="Redis集群会有写操作丢失吗？为什么？"><a href="#Redis集群会有写操作丢失吗？为什么？" class="headerlink" title="Redis集群会有写操作丢失吗？为什么？"></a>Redis集群会有写操作丢失吗？为什么？</h2><p><strong>Redis并不能保证数据的强一致性</strong>，这意味着在实际中集群在特定的条件下可能会丢失写操作。</p><h2 id="Redis集群之间是如何复制的"><a href="#Redis集群之间是如何复制的" class="headerlink" title="Redis集群之间是如何复制的"></a>Redis集群之间是如何复制的</h2><p>异步复制</p><h2 id="Redis集群最大节点个数是多少"><a href="#Redis集群最大节点个数是多少" class="headerlink" title="Redis集群最大节点个数是多少"></a>Redis集群最大节点个数是多少</h2><p>16384</p><h2 id="Redis集群如何选择数据库？"><a href="#Redis集群如何选择数据库？" class="headerlink" title="Redis集群如何选择数据库？"></a>Redis集群如何选择数据库？</h2><p>Redis集群目前无法做数据库选择，默认在0数据库。</p><h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><h2 id="Redis是单线程的，如何提高多核CPU的利用率"><a href="#Redis是单线程的，如何提高多核CPU的利用率" class="headerlink" title="Redis是单线程的，如何提高多核CPU的利用率"></a>Redis是单线程的，如何提高多核CPU的利用率</h2><p>可以在同一个服务器<strong>部署多个Redis的实例</strong>，并把他们当做不同的服务器来使用，在某些时候，无论如何一个服务器是不够的，所以如果想使用多个CPU，可以考虑一下<strong>分区</strong>（sharding）。</p><h2 id="为什么要做Redis分区"><a href="#为什么要做Redis分区" class="headerlink" title="为什么要做Redis分区"></a>为什么要做Redis分区</h2><p><strong>分区可以让Redis管理更大的内存</strong>，Redis将可以使用所有机器的内存，如果没有分区，最多只能使用一台机器的内存，分区使Redis的计算能力通过简单地增加计算机得到成倍提升，Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</p><h2 id="你知道有哪些Redis分区实现方案"><a href="#你知道有哪些Redis分区实现方案" class="headerlink" title="你知道有哪些Redis分区实现方案"></a>你知道有哪些Redis分区实现方案</h2><ul><li><strong>客户端分区</strong>：就是<strong>在客户端已经决定数据会被存储到哪个Redis节点或者从哪个Redis节点读取</strong>，大多数客户端已经实现了客户端分区；</li><li><strong>代理分区</strong>：意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据，代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端，Redis和Memcached的一种代理实现就是Twemproxy；</li><li><strong>查询路由</strong>（Query routing）：客户端随机请求任意一个Redis实例，然后由Redis将请求转发给正确的Redis节点，Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个Redis节点转发到另一个Redis节点，而是在客户端的帮助下直接重定向到正确的Redis节点。</li></ul><h2 id="Redis分区有什么缺点"><a href="#Redis分区有什么缺点" class="headerlink" title="Redis分区有什么缺点"></a>Redis分区有什么缺点</h2><ul><li>涉及多个key的操作通常不会被支持，例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例；</li><li>同时操作多个key，则不能使用Redis事务；</li><li>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集；</li><li>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB/AOF文件；</li><li>分区时动态扩容或缩容可能非常复杂，Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。</li></ul><h1 id="分布式问题"><a href="#分布式问题" class="headerlink" title="分布式问题"></a>分布式问题</h1><h2 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h2><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系，Redis中可以使用<code>SETNX</code>【SET if NOT EXISTS】命令实现分布式锁。</p><p>当且仅当key不存在，将key的值设为value，若给定的key已经存在，则SETNX不做任何动作。</p><p>使用SETNX完成同步锁的流程及事项如下：</p><ul><li>使用SETNX命令获取锁，若返回0（key已经存在，锁已存在）则获取失败，反之获取成功。</li><li>为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个合理的过期时间。</li></ul><ul><li>释放锁，使用DEL命令将锁数据删除。</li></ul><h2 id="如何解决Redis的并发竞争Key问题"><a href="#如何解决Redis的并发竞争Key问题" class="headerlink" title="如何解决Redis的并发竞争Key问题"></a>如何解决Redis的并发竞争Key问题</h2><p>所谓Redis的并发竞争key的问题也就是多个系统同时对一个key进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p><p>推荐一种方案：分布式锁（Zookeeper和Redis都可以实现分布式锁）</p><h2 id="分布式Redis是前期做还是后期规模上来了再做好？为什么？"><a href="#分布式Redis是前期做还是后期规模上来了再做好？为什么？" class="headerlink" title="分布式Redis是前期做还是后期规模上来了再做好？为什么？"></a>分布式Redis是前期做还是后期规模上来了再做好？为什么？</h2><p>既然Redis是如此的轻量，为防止以后的扩容，最好的办法就是一开始就启动较多实例，即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p><p>一开始就多设置几个Redis实例，例如32或64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看这点牺牲是值得的。</p><p>当你的数据不断增长，需要更多的Redis服务器时，你需要做的仅仅是将Redis实例从一台服务器迁移到另外一台服务器而已，一旦你添加了另外一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。</p><h2 id="什么是RedLock"><a href="#什么是RedLock" class="headerlink" title="什么是RedLock"></a>什么是RedLock</h2><p>Redis官方提出的一种权威的基于Redis实现分布式锁的方式名叫Redlock，此种方式比原先的单节点的方式更安全，它可以保证以下特性：</p><ul><li>安全特性：互斥访问，即永远只有一个client能拿到锁；</li><li>避免死锁：最终client都可以拿到锁，不会出现死锁的情况，即使原本锁住某资源的client崩溃了或者出现了网络分区；</li><li>容错性：只要大部分Redis节点存活就可以正常提供服务。</li></ul><h1 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h1><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指缓存同一时间大面积的失效，所以后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p><strong>解决方案</strong></p><ol><li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生；</li><li>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队；</li><li>给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存。</li></ol><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存在某个时间点过期的时候，恰好在这个时间点对这个 key 有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮。</p><p><strong>解决方案</strong></p><ol><li>设置热点数据永不过期；</li><li>加互斥锁</li></ol><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p><strong>解决方案</strong></p><ol><li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30s，这样可以防止攻击用户反复用同一个id暴力攻击；</li><li>采用<strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</li></ol><h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统，这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。</p><p><strong>解决方案</strong></p><ol><li>直接写个缓存刷新页面，上线时手动操作一下；</li><li>数据量不大时，可以在项目启动的时候自动进行加载；</li><li>定时刷新缓存。</li></ol><h2 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h2><p>当访问量剧增，服务出现问题（如：响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务，系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p><p><strong>缓存降级的最终目的是保证核心服务可用</strong>，即使是有损的，而且有些服务是无法降级的（比如加入购物车、结算）。</p><p>在进行降级之前要对系统进行梳理，看看系统是不是可以弃卒保帅，从而梳理出哪些必须誓死保护，哪些可降级；</p><p>服务降级的目的是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题，因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是<strong>Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</strong></p><h2 id="热点数据和冷数据"><a href="#热点数据和冷数据" class="headerlink" title="热点数据和冷数据"></a>热点数据和冷数据</h2><p>热点数据，缓存才有价值。</p><p>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大，频繁修改的数据，看情况考虑使用缓存。</p><p>对于热点数据，比如我们的某IM产品，生日祝福模块等，缓存以后可能读取数十万次。</p><h2 id="缓存热点key"><a href="#缓存热点key" class="headerlink" title="缓存热点key"></a>缓存热点key</h2><p>缓存中的一个key（比如一个促销商品），在某个时间点过期的时候，恰好在这个时间点对这个key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><p><strong>解决方案</strong><br>对缓存查询加锁，如果key不存在就加锁，然后从DB中查询数据并加入缓存，然后解锁，如果其他进程发现有锁就等待，然后等解锁后返回数据或者进入DB查询。</p><h1 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h1><h2 id="Redis支持的Java客户端都有哪些？官方推荐用哪个？"><a href="#Redis支持的Java客户端都有哪些？官方推荐用哪个？" class="headerlink" title="Redis支持的Java客户端都有哪些？官方推荐用哪个？"></a>Redis支持的Java客户端都有哪些？官方推荐用哪个？</h2><p>Redisson、Jedis，官方推荐使用Redisson。</p><h2 id="Redis和Redisson有什么关系？"><a href="#Redis和Redisson有什么关系？" class="headerlink" title="Redis和Redisson有什么关系？"></a>Redis和Redisson有什么关系？</h2><p>Redisson是一个高级的分布式协调Redis客户端，能够帮助用户在分布式环境中轻松实现一些Java的对象。</p><h2 id="Jedis和Redisson对比有什么优缺点？"><a href="#Jedis和Redisson对比有什么优缺点？" class="headerlink" title="Jedis和Redisson对比有什么优缺点？"></a>Jedis和Redisson对比有什么优缺点？</h2><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序，事务，管道，分区等Redis特性，Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="Redis与Memcached的区别"><a href="#Redis与Memcached的区别" class="headerlink" title="Redis与Memcached的区别"></a>Redis与Memcached的区别</h2><ul><li>Memcached所有的值均是简单的字符串，Redis作为其替代者，支持更为丰富的数据类型；</li><li>Redis的速度比Memcached快很多；</li><li>Redis可以持久化其数据</li></ul><h2 id="如何保证缓存与数据库双写时的数据一致性？"><a href="#如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性？"></a>如何保证缓存与数据库双写时的数据一致性？</h2><p>将读请求和写请求串行化，串到一个内存队列中，这样就能保证一定不会出现不一致的情况，串行化之后会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求；</p><p>还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是先更新数据库，然后将旧缓存失效，读取数据的时候，如果缓存不存在，则读取数据库再写缓存。</p><h2 id="Redis常见性能问题和解决方案？"><a href="#Redis常见性能问题和解决方案？" class="headerlink" title="Redis常见性能问题和解决方案？"></a>Redis常见性能问题和解决方案？</h2><ol><li>Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化；</li><li>如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次；</li><li>为了主从复制的速度和连接的稳定性，Slave和Master最好是在同一局域网内；</li><li>尽量避免在压力较大的主库上增加从库；</li><li>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占用大量的CPU和内存资源，导致服务过载，会出现短暂服务暂停现象；</li><li>为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。</li></ol><h2 id="Redis官方为什么不提供Windows版本"><a href="#Redis官方为什么不提供Windows版本" class="headerlink" title="Redis官方为什么不提供Windows版本"></a>Redis官方为什么不提供Windows版本</h2><p>因为目前Linux版本已经相当稳定，而且用户量很大，无须开发windows版本，反而会带来兼容性问题。</p><h2 id="一个字符串类型的值能存储最大容量是多少"><a href="#一个字符串类型的值能存储最大容量是多少" class="headerlink" title="一个字符串类型的值能存储最大容量是多少"></a>一个字符串类型的值能存储最大容量是多少</h2><p>512M</p><h2 id="Redis如何做大量数据插入？"><a href="#Redis如何做大量数据插入？" class="headerlink" title="Redis如何做大量数据插入？"></a>Redis如何做大量数据插入？</h2><p>Redis2.6开始redis-cli支持一种新的被称为之<code>pipe mode</code>的新模式用于执行大量数据插入工作。</p><h2 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</h2><p>使用<code>keys</code>指令可以扫出指定模式的key列表。<br>对方接着追问：如果这个Redis正在给线上的业务提供服务，那使用keys指令会有什么问题？<br>这个时候你要回答Redis的一个关键特性：<strong>Redis是单线程的，keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复</strong>，这个时候可以使用<code>scan</code>指令，<strong>scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，需要在客户端做一次去重操作</strong>，整体花费的时间比直接用keys指令长。</p><h2 id="使用Redis做过异步队列吗？是如何实现的"><a href="#使用Redis做过异步队列吗？是如何实现的" class="headerlink" title="使用Redis做过异步队列吗？是如何实现的"></a>使用Redis做过异步队列吗？是如何实现的</h2><p>使用<strong>list</strong>类型保存数据消息，rpush生产消息，lpop消费消息，当lpop没有消息时，可以sleep一段时间，然后再检查有没有消息，如果不想sleep的话，可以使用blpop，在没有消息的时候，会一直阻塞，直到消息的到来，<strong>Redis可以通过发布/订阅模式来实现一个生产者多个消费者</strong>。</p><h2 id="Redis如何实现延时队列"><a href="#Redis如何实现延时队列" class="headerlink" title="Redis如何实现延时队列"></a>Redis如何实现延时队列</h2><p>使用Sorted Set，使用时间戳做score，消息内容作为key，调用zadd来生产消息，消费者使用zrangbyscore获取n秒之前的数据做轮询处理。</p><h2 id="Redis回收进程如何工作"><a href="#Redis回收进程如何工作" class="headerlink" title="Redis回收进程如何工作"></a>Redis回收进程如何工作</h2><ol><li>一个客户端运行了新的命令，添加了新的数据；</li><li>Redis检查内存使用情况，如果大于maxmemory的限制，则根据设定好的策略进行回收；</li><li>一个新的命令被执行，等等；</li><li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收到边界以下。</li></ol><p>如果一个命令的结果导致大量内存被使用，不用多久内存限制就会被这个内存使用量超越。</p><h2 id="Redis回收使用的是什么算法"><a href="#Redis回收使用的是什么算法" class="headerlink" title="Redis回收使用的是什么算法"></a>Redis回收使用的是什么算法</h2><p>LRU算法。 </p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud 开篇</title>
    <link href="/2020/07/19/Spring-Cloud-%E5%BC%80%E7%AF%87/"/>
    <url>/2020/07/19/Spring-Cloud-%E5%BC%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="一、集群、分布式、微服务、SOA概念"><a href="#一、集群、分布式、微服务、SOA概念" class="headerlink" title="一、集群、分布式、微服务、SOA概念"></a>一、集群、分布式、微服务、SOA概念</h1><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>概念：计算机集群简称集群是一种计算机系统，通过一组松散集成的计算机软件或硬件连接起来高度紧密地协作完成计算工作，在某种意义上，它们可以被看做是一台计算机，集群系统中的单个计算机通常称为节点，通常通过局域网连接，集群计算机通常用来改进单个计算机的计算速度和可靠性。</p><p>特点：</p><ul><li>通过多台计算机完成同一个工作，达到更高的效率；</li><li>两台或多台机器，内容、工作过程等完全一样，如果一台不工作，另一台还可以起作用。</li></ul><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>概念：<br>分布式系统是一组计算机，通过网络相互连接传递消息与通信后<strong>协调</strong>它们的行为而形成的系统，组件之间彼此进行交互以实现一个共同的目标。<br>好处：</p><ul><li>模块之间独立，各做各的事情，便于扩展，复用性高；</li><li>高吞吐量，某个任务需要一个机器运行10个小时，将该任务用10台机器的分布式跑（将这个任务拆分为10个小任务），可能两个小时就跑完了。</li></ul><h2 id="SOA（面向服务的架构）"><a href="#SOA（面向服务的架构）" class="headerlink" title="SOA（面向服务的架构）"></a>SOA（面向服务的架构）</h2><p>SOA是一种设计方法,其中包含多个服务，而服务之间通过配合最终会提供一系列功能。一个服务通常以独立的形式存在于操作系统进程中。服务之间通过网络调用，而非采用进程内调用的方式进行通信。</p><h1 id="二、CAP理论"><a href="#二、CAP理论" class="headerlink" title="二、CAP理论"></a>二、CAP理论</h1><p>CAP理论作为分布式系统的基础理论,它描述的是一个分布式系统在以下三个特性中：</p><ul><li>一致性（Consistency）</li><li>可用性（Availability）</li><li>分区容错性（Partition tolerance）</li></ul><p>最多满足其中的两个特性，也就是下图所描述的，分布式系统要么满足CP，要么满足AP，无法同时满足CAP。<br><img src="https://img-blog.csdnimg.cn/20200717114459121.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="什么是一致性、可用性和分区容错性"><a href="#什么是一致性、可用性和分区容错性" class="headerlink" title="什么是一致性、可用性和分区容错性"></a>什么是一致性、可用性和分区容错性</h2><p><strong>分区容错性</strong>：指的是分布式系统中的某个节点或者网络分区出现了故障的时候，整个系统仍能对外提供满足一致性和可用性的服务，也就是说部分故障不影响整体使用。所以分区容错性是必不可少的。<br><strong>可用性</strong>：一直可以正常地做读写操作，简单而言就是客户单一直可以正常访问并得到系统的正常响应，用户角度来看就是不会出现系统操作失败或者访问超时等问题。<br><strong>一致性</strong>：在分布式系统完成某写操作后任何读操作都应该获取到该写操作写入的那个最新的值，相当于要求分布式系统中的各节点时时刻刻都保持数据的一致性。</p><h2 id="如何理解一致性、可用性和分区容错性"><a href="#如何理解一致性、可用性和分区容错性" class="headerlink" title="如何理解一致性、可用性和分区容错性"></a>如何理解一致性、可用性和分区容错性</h2><p>如果我们事先保证了分区容错性，也就意味着即使某个节点出现故障，用户还是可以继续访问，只是用户在访问的过程中就会出现一致性和可用性不能同时满足的情况。<br><img src="https://img-blog.csdnimg.cn/20200717212246793.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>如图假设分布式系统有G1、G2两个节点，初始值都是v0，现在有一个client向系统写入了值v1，这里假设直接写的是节点G1，写完之后client再去读取这个值，这时读到了G2节点，由于G2节点与G1节点失去连接，这时G1节点上的数据还未同步到G2节点，因此客户端读取到的是修改之前的值v0，这就出现了不满足一致性的情况了，相当于<strong>满足了可用性，失去了一致性。</strong></p><p>类似的，如果系统保证了强的一致性，那么在client 写完G1节点后, 而G1向G2节点同步数据出现了问题，这时如果client再去读取G2节点的数据时，client就会一直处于等待状态，因为系统内各节点数据为同步上，需要等同步上才能使用。这就相当于<strong>满足了一致性，而失去了可用性。</strong><br><img src="https://img-blog.csdnimg.cn/2020071721291945.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>考虑多个客户端访问时，一致性和可用性还可以这么理解：假如client1 向G1 修改某个值的时候, 写操作还未完成，client2就发起来对该值的读操作，读的是G2节点，这时如果要满足一致性，那么就得让client2 暂时无法使用，如果要让client2 使用，那么获取到的数据不是最新的，系统就不满足一致性。</p><p>CAP是无法完全兼顾的，从上面的例子也可以看出，我们可以选AP，也可以选CP。但是，要注意的是：不是说选了AP，C就完全抛弃了。不是说选了CP，A就完全抛弃了！<br>在CAP理论中，C所表示的一致性是强一致性(每个节点的数据都是最新版本)，其实一致性还有其他级别的：</p><ul><li>弱一致性：弱一致性是相对于强一致性而言，它不保证总能得到最新的值；</li><li>最终一致性(eventual consistency)：放宽对时间的要求，在被调完成操作响应后的某个时间点，被调多个节点的数据最终达成一致。</li></ul><h1 id="三、Spring-Cloud"><a href="#三、Spring-Cloud" class="headerlink" title="三、Spring Cloud"></a>三、Spring Cloud</h1><h2 id="为什么需要Spring-Cloud？"><a href="#为什么需要Spring-Cloud？" class="headerlink" title="为什么需要Spring Cloud？"></a>为什么需要Spring Cloud？</h2><p>将一个大的项目分解为多个小的模块，这些小的模块组合起来完成功能，但是拆分成多个模块以后，会出现各种各样的问题，而Spring Cloud提供了一整套的解决方案：<br>Spring Cloud的基础功能：</p><ul><li>服务治理：Eureka</li><li>客户端负载均衡：Ribbon</li><li>服务容错保护：Hystrix</li><li>声明式服务调用：Feign</li><li>API网关服务：Zuul</li><li>分布式配置中心：Config</li></ul><p>以及一些其他的高级功能：</p><ul><li>消息总线：Bus</li><li>消息驱动的微服务：Stream</li><li>分布式服务跟踪：Sleuth</li></ul><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p>Eureka主要是解决子系统之间的通信问题，子系统与子系统之间不是在同一个环境下，所以需要远程调用，远程调用可能就会想到httpClient、webService等这些技术实现，既然是远程调用，就必须知道ip地址，而人为去维护这些静态配置几乎不太现实，所以为了解决微服务架构中的服务实例维护问题（IP地址），产生了大量的服务治理框架和产品，这些框架和产品的实现都围绕着服务注册与服务发现机制来完成对微服务应用实例的自动化管理。在SpringCloud中我们的服务治理框架一般使用的就是Eureka。</p><p><strong>问题重现：</strong><br>现在有A、B、C、D四个服务，它们之间会互相调用(而且IP地址很可能会发生变化)，一旦某个服务的IP地址变了，那服务中的代码要跟着变，手动维护这些静态配置(IP)非常麻烦！Eureka是这样解决上面所说的情况的：<br>创建一个E服务，将A、B、C、D四个服务的信息都注册到E服务上，E服务维护这些已经注册进来的信息：<br><img src="https://img-blog.csdnimg.cn/20200717215646296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>A、B、C、D四个服务都可以拿到Eureka(服务E)那份注册清单。A、B、C、D四个服务互相调用不再通过具体的IP地址，而是通过服务名来调用！</p><ul><li>拿到注册清单—&gt;注册清单上有服务名—&gt;自然就能够拿到服务具体的位置了(IP)。</li><li>其实简单来说就是：代码中通过服务名找到对应的IP地址(IP地址会变，但服务名一般不会变)<br><img src="https://img-blog.csdnimg.cn/20200717215755259.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><h3 id="Eureka细节"><a href="#Eureka细节" class="headerlink" title="Eureka细节"></a>Eureka细节</h3>Eureka专门用于给其他服务注册的称为Eureka Server(服务注册中心)，其余注册到Eureka Server的服务称为Eureka Client。<br><img src="https://img-blog.csdnimg.cn/20200717220006711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在Eureka Server一般我们会这样配置：</li></ul><div class="hljs"><pre><code class="hljs MarkDown">register-with-eureka: false     #false表示不向注册中心注册自己fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</code></pre></div><p>Eureka Client分为服务提供者和服务消费者，但是很有可能某服务既是服务提供者又是服务消费者。<br>如果某个服务配置没有“注册”到Eureka-Server也不用过于惊讶（但是它是可以获取Eureka服务清单的），很有可能只是作者把该服务认作为单纯的服务消费者，单纯的服务消费者无需对外提供服务，也就无需注册到Eureka中了。</p><p>下面是Eureka的治理机制：<br><strong>服务提供者</strong></p><ul><li>服务注册： 启动的时候会通过发送REST请求的方式将自己注册到Eureka Server上，同时带上了自身服务的一些元数据信息；</li><li>服务续约：在注册完服务之后，服务提供者会维护一个心跳用来持续告诉Eureka Server:  “我还活着 ” ；</li><li>服务下线：当服务实例进行正常的关闭操作时，它会触发一个服务下线的REST请求给Eureka Server, 告诉服务注册中心：“我要下线了 ”。</li></ul><p><strong>服务消费者</strong></p><ul><li>获取服务：当我们启动服务消费者的时候，它会发送一个REST请求给服务注册中心，来获取上面注册的服务清单；</li><li>服务调用：服务消费者在获取服务清单后，通过服务名可以获得具体提供服务的实例名和该实例的元数据信息。在进行服务调用的时候，优先访问同处一个Zone中的服务提供方。</li></ul><p><strong>Eureka Server（服务注册中心）</strong></p><ul><li>失效剔除：默认每隔一段时间（默认60秒）将当前清单中超时（默认90秒）没有续约的服务剔除出去；</li><li>自我保护：Eureka Server在运行期间，会统计心跳失败的比例在15分钟之内是否低于85%（通常由于网络不稳定导致），Eureka Server会将当前的实例注册信息保护起来，让这些实例不会过期，尽可能保护这些注册信息。</li></ul><p>最后得到下面这个关系图：<br><img src="https://img-blog.csdnimg.cn/20200717221322768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="RestTemplate和Ribbon"><a href="#RestTemplate和Ribbon" class="headerlink" title="RestTemplate和Ribbon"></a>RestTemplate和Ribbon</h2><p>通过Eureka服务治理框架，我们可以通过服务名来获取具体的服务实例的位置了（IP），一般在使用Spring Cloud的时候不需要自己手动创建HttpClient来进行远程调用。可以使用Spring封装好的RestTemplate工具类，使用起来很简单：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 传统的方式，直接显示写死IP是不好的！</span><span class="hljs-comment">//private static final String REST_URL_PREFIX = "http://localhost:8001";</span><span class="hljs-comment">// 服务实例名</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REST_URL_PREFIX = <span class="hljs-string">"http://MICROSERVICECLOUD-DEPT"</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 使用 使用restTemplate访问restful接口非常的简单粗暴无脑。 (url, requestMap,</span><span class="hljs-comment"> * ResponseBean.class)这三个参数分别代表 REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RestTemplate restTemplate;<span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/consumer/dept/add"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(Dept dept)</span> </span>&#123;    <span class="hljs-keyword">return</span> restTemplate.postForObject(REST_URL_PREFIX + <span class="hljs-string">"/dept/add"</span>, dept, Boolean<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;&#125;</code></pre></div><p>为了实现服务的高可用，我们可以将服务提供者集群。比如说，现在一个秒杀系统设计出来了，准备上线了。在11月11号时为了能够支持高并发，我们开多台机器来支持并发量。<br><img src="https://img-blog.csdnimg.cn/20200717223758338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>现在想要这三个秒杀系统合理摊分用户的请求（专业来说就是负载均衡），可能你会想到nginx。<br>其实Spring Cloud也支持的负载均衡功能，只不过它是客户端的负载均衡，这个功能实现就是Ribbon！负载均衡又区分了两种类型：</p><ul><li>客户端负载均衡（Ribbon）<br>服务实例的清单在客户端，客户端进行负载均衡算法分配；<br>客户端可以从Eureka Server中得到一份服务清单，在发送请求时通过负载均衡算法，在多个服务器之间选择一个进行访问。</li><li>服务端负载均衡（Nginx）<br>服务实例的清单在服务端，服务器进行负载均衡算法分配；</li></ul><p><img src="https://img-blog.csdnimg.cn/20200717225330627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="Ribbon细节"><a href="#Ribbon细节" class="headerlink" title="Ribbon细节"></a>Ribbon细节</h3><p>Ribbon是支持负载均衡，默认的负载均衡策略是轮询，我们也是可以根据自己实际的需求自定义负载均衡策略的。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySelfRule</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> IRule <span class="hljs-title">myRule</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//return new RandomRule();// Ribbon默认是轮询，我自定义为随机</span>        <span class="hljs-comment">//return new RoundRobinRule();// Ribbon默认是轮询，我自定义为随机</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RandomRule_ZY();<span class="hljs-comment">// 我自定义为每台机器5次</span>    &#125;&#125;</code></pre></div><p>实现起来也很简单：继承AbstractLoadBalancerRule类，重写public Server choose(ILoadBalancer lb, Object key)即可。</p><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p>到目前为止，我们的服务看起来好像挺好的了：能够根据服务名来远程调用其他的服务，可以实现客户端的负载均衡。<br><img src="https://img-blog.csdnimg.cn/20200717230345367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>但是，如果我们在调用多个远程服务时，某个服务出现延迟，会怎么样？？<br><img src="https://img-blog.csdnimg.cn/20200717230401608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在高并发的情况下，由于单个服务的延迟，可能导致所有的请求都处于延迟状态，甚至在几秒钟就使服务处于负载饱和的状态，资源耗尽，直到不可用，最终导致这个分布式系统都不可用，这就是“雪崩”。<br><img src="https://img-blog.csdnimg.cn/20200717230424681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>针对上述问题， Spring Cloud Hystrix实现了断路器、线程隔离等一系列服务保护功能。</p><ul><li>Fallback(失败快速返回)：当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应， 而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</li><li>资源/依赖隔离(线程池隔离)：它会为每一个依赖服务创建一个独立的线程池，这样就算某个依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响，而不会拖慢其他的依赖服务。</li><li>Hystrix提供几个熔断关键参数：滑动窗口大小（20）、 熔断器开关间隔（5s）、错误率（50%）</li><li>每当20个请求中，有50%失败时，熔断器就会打开，此时再调用此服务，将会直接返回失败，不再调远程服务。</li><li>直到5s之后，重新检测该触发条件，判断是否把熔断器关闭，或者继续打开。</li></ul><p>Hystrix还有请求合并、请求缓存这样强大的功能，在此我就不具体说明了，有兴趣的同学可继续深入学习~</p><h3 id="Hystrix仪表盘"><a href="#Hystrix仪表盘" class="headerlink" title="Hystrix仪表盘"></a>Hystrix仪表盘</h3><p>Hystrix仪表盘：它主要用来实时监控Hystrix的各项指标信息。通过Hystrix Dashboard反馈的实时信息，可以帮助我们快速发现系统中存在的问题，从而及时地采取应对措施。<br>启动时的页面：<br><img src="https://img-blog.csdnimg.cn/20200717230750851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>监控单服务的页面：<br><img src="https://img-blog.csdnimg.cn/20200717230807668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>我们现在的服务是这样的：<br><img src="https://img-blog.csdnimg.cn/20200717230822760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>除了可以开启单个实例的监控页面之外，还有一个监控端点 /turbine.stream是对集群使用的。 从端点的命名中，可以引入Turbine, 通过它来汇集监控信息，并将聚合后的信息提供给 HystrixDashboard 来集中展示和监控。<br><img src="https://img-blog.csdnimg.cn/20200717230833905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>为了简化我们的开发，Spring Cloud Feign出现了！它基于 Netflix Feign 实现，整合了 Spring Cloud Ribbon 与 Spring Cloud Hystrix,  除了整合这两者的强大功能之外，它还提供了声明式的服务调用(不再通过RestTemplate)。</p><blockquote><p>Feign是一种声明式、模板化的HTTP客户端。在Spring Cloud中使用Feign,<br>我们可以做到使用HTTP请求远程服务时能与调用本地方法一样的编码体验，开发者完全感知不到这是远程方法，更感知不到这是个HTTP请求。</p></blockquote><p>下面就简单看看Feign是怎么优雅地实现远程调用的：<br>服务绑定：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// value ---&gt;指定调用哪个服务</span><span class="hljs-comment">// fallbackFactory---&gt;熔断器的降级提示</span><span class="hljs-meta">@FeignClient</span>(value = <span class="hljs-string">"MICROSERVICECLOUD-DEPT"</span>, fallbackFactory = DeptClientServiceFallbackFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">DeptClientService</span> </span>&#123;    <span class="hljs-comment">// 采用Feign我们可以使用SpringMVC的注解来对服务进行绑定！</span>    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/dept/get/&#123;id&#125;"</span>, method = RequestMethod.GET)    <span class="hljs-function"><span class="hljs-keyword">public</span> Dept <span class="hljs-title">get</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> <span class="hljs-keyword">long</span> id)</span>;    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/dept/list"</span>, method = RequestMethod.GET)    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Dept&gt; <span class="hljs-title">list</span><span class="hljs-params">()</span></span>;    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/dept/add"</span>, method = RequestMethod.POST)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(Dept dept)</span></span>;&#125;Feign中使用熔断器：<span class="hljs-comment">/**</span><span class="hljs-comment"> * Feign中使用断路器</span><span class="hljs-comment"> * 这里主要是处理异常出错的情况(降级/熔断时服务不可用，fallback就会找到这里来)</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span> <span class="hljs-comment">// 不要忘记添加，不要忘记添加</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeptClientServiceFallbackFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FallbackFactory</span>&lt;<span class="hljs-title">DeptClientService</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DeptClientService <span class="hljs-title">create</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DeptClientService() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Dept <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> id)</span> </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Dept().setDeptno(id).setDname(<span class="hljs-string">"该ID："</span> + id + <span class="hljs-string">"没有没有对应的信息,Consumer客户端提供的降级信息,此刻服务Provider已经关闭"</span>)                        .setDb_source(<span class="hljs-string">"no this database in MySQL"</span>);            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Dept&gt; <span class="hljs-title">list</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(Dept dept)</span> </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;;    &#125;&#125;</code></pre></div><p>调用：<br><img src="https://img-blog.csdnimg.cn/20200717231002370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h2><p>基于上面的学习，我们现在的架构很可能会设计成这样：<br><img src="https://img-blog.csdnimg.cn/20200717231045862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>这样的架构会有两个比较麻烦的问题：</p><ul><li>路由规则与服务实例的维护间题：外层的负载均衡(nginx)需要维护所有的服务实例清单(图上的OpenService)</li><li>签名校验、 登录校验冗余问题：为了保证对外服务的安全性，<br>我们在服务端实现的微服务接口，往往都会有一定的权限校验机制，但我们的服务是独立的，我们不得不在这些应用中都实现这样一套校验逻辑，这就会造成校验逻辑的冗余。</li></ul><p>如下图：<br><img src="https://img-blog.csdnimg.cn/20200717231123144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>每个服务都有自己的IP地址，Nginx想要正确请求转发到服务上，就必须维护着每个服务实例的地址！<br>更是灾难的是：这些服务实例的IP地址还有可能会变，服务之间的划分也很可能会变。<br>购物车和订单模块都需要用户登录了才可以正常访问，基于现在的架构，只能在购物车和订单模块都编写校验逻辑，这无疑是冗余的代码。<br>为了解决上面这些常见的架构问题，API网关的概念应运而生。在SpringCloud中了提供了基于Netfl ix Zuul实现的API网关组件Spring Cloud Zuul。<br>Spring Cloud Zuul是这样解决上述两个问题的：</p><ul><li>SpringCloud Zuul通过与SpringCloud Eureka进行整合，将自身注册为Eureka服务治理下的应用，同时从Eureka中获得了所有其他微服务的实例信息。外层调用都必须通过API网关，使得将维护服务实例的工作交给了服务治理框架自动完成。</li><li>在API网关服务上进行统一调用来对微服务接口做前置过滤，以实现对微服务接口的拦截和校验。</li></ul><p>Zuul天生就拥有线程隔离和断路器的自我保护功能，以及对服务调用的客户端负载均衡功能。也就是说：Zuul也是支持Hystrix和Ribbon。<br>关于Zuul还有很多知识点(由于篇幅问题，这里我就不细说了)：</p><ul><li><p>路由匹配(动态路由)</p></li><li><p>过滤器实现(动态过滤器)</p></li><li><p>默认会过滤掉Cookie与敏感的HTTP头信息(额外配置)</p><h3 id="可能对Zuul的疑问"><a href="#可能对Zuul的疑问" class="headerlink" title="可能对Zuul的疑问"></a>可能对Zuul的疑问</h3><p>Zuul支持Ribbon和Hystrix，也能够实现客户端的负载均衡。我们的Feign不也是实现客户端的负载均衡和Hystrix的吗？既然Zuul已经能够实现了，那我们的Feign还有必要吗？<br><img src="https://img-blog.csdnimg.cn/20200717231623967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>或者可以这样理解：</p></li><li><p>zuul是对外暴露的唯一接口相当于路由的是controller的请求，而Ribbonhe和Fegin路由了service的请求</p></li><li><p>zuul做最外层请求的负载均衡 ，而Ribbon和Fegin做的是系统内部各个微服务的service的调用的负载均衡</p></li></ul><p>有了Zuul，还需要Nginx吗？他俩可以一起使用吗？<br>我的理解：Zuul和Nginx是可以一起使用的(毕竟我们的Zuul也是可以搭成集群来实现高可用的)，要不要一起使用得看架构的复杂度了(业务)<del>~</del></p><h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><p>随着业务的扩展，我们的服务会越来越多，越来越多。每个服务都有自己的配置文件。<br>既然是配置文件，给我们配置的东西，那难免会有些改动的。<br>比如我们的Demo中，每个服务都写上相同的配置文件。万一我们有一天，配置文件中的密码需要更换了，那就得三个都要重新更改。<br><img src="https://img-blog.csdnimg.cn/20200717231641121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在分布式系统中，某一个基础服务信息变更，都很可能会引起一系列的更新和重启，<br>Spring Cloud Config项目是一个解决分布式系统的配置管理方案。它包含了Client和Server两个部分，server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，client通过接口获取数据、并依据此数据初始化自己的应用。<br>简单来说，使用Spring Cloud Config就是将配置文件放到统一的位置管理(比如GitHub)，客户端通过接口去获取这些配置文件。<br>在GitHub上修改了某个配置文件，应用加载的就是修改后的配置文件。<br><img src="https://img-blog.csdnimg.cn/2020071723175164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>SpringCloud Config其他的知识：</p><ul><li>在SpringCloud Config的服务端， 对于配置仓库的默认实现采用了Git，我们也可以配置SVN。</li><li>配置文件内的信息加密和解密</li><li>修改了配置文件，希望不用重启来动态刷新配置，配合Spring  Cloud Bus 使用~</li></ul><p>使用SpringCloud Config可能的疑问：application.yml和 bootstrap.yml区别<br><code>https://www.cnblogs.com/BlogNetSpace/p/8469033.html</code></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要写了SpringCloud的基础知识，希望大家看完能有所帮助~<br>SpringCloud的资料也很多，我整理一些我认为比较好，想要深入的同学不妨看看下边的资源<del>~</del><br>SpringCloud系列文章参考资料：</p><ul><li>史上最简单的 SpringCloud 教程 |<br>终章<a href="https://blog.csdn.net/forezp/article/details/70148833" target="_blank" rel="noopener">https://blog.csdn.net/forezp/article/details/70148833</a></li><li>Spring<br>Cloud基础教程《程序员DD》<a href="http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</a></li><li>Spring Cloud 系列文章《纯洁的微笑》：<a href="http://www.ityouknow.com/spring-cloud.html" target="_blank" rel="noopener">http://www.ityouknow.com/spring-cloud.html</a></li><li>SpringCloud系列文章：<a href="https://www.cnblogs.com/woshimrf/tag/SpringCloud/" target="_blank" rel="noopener">https://www.cnblogs.com/woshimrf/tag/SpringCloud/</a></li><li>SpringCloud系列文章《狂小白》：<a href="https://www.cnblogs.com/huangjuncong/tag/SpringCloud/" target="_blank" rel="noopener">https://www.cnblogs.com/huangjuncong/tag/SpringCloud/</a></li><li>SpringCloud官方文档：<a href="http://projects.spring.io/spring-cloud/" target="_blank" rel="noopener">http://projects.spring.io/spring-cloud/</a></li><li>Spring Cloud<br>中文文档：<a href="https://springcloud.cc/spring-cloud-dalston.html#_appendix_compendium_of_configuration_properties" target="_blank" rel="noopener">https://springcloud.cc/spring-cloud-dalston.html#_appendix_compendium_of_configuration_properties</a></li></ul><p><strong>参考书籍：</strong><br>《SpringCloud 微服务实战》</p>]]></content>
    
    
    <categories>
      
      <category>微服务分布式架构</category>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UML类图</title>
    <link href="/2020/07/16/UML%E7%B1%BB%E5%9B%BE/"/>
    <url>/2020/07/16/UML%E7%B1%BB%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="从一个示例开始"><a href="#从一个示例开始" class="headerlink" title="从一个示例开始"></a>从一个示例开始</h1><p><img src="https://img-blog.csdnimg.cn/20200716160742366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li>车的类图结构为<abstract>，表示车是一个抽象类；</li><li>它有两个继承类：小汽车和自行车；他们之间的关系为<strong>实现</strong>关系，使用带空心箭头的虚线表示；</li><li>小汽车和SUV之间是<strong>继承</strong>关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；</li><li>小汽车和发动机是<strong>组合</strong>关系，使用带实心箭头的实现表示；</li><li>学生和班级之间是<strong>聚合</strong>关系，使用带空心箭头的实线表示；</li><li>学生与身份证之间是<strong>关联</strong>关系，使用一根实线表示；</li><li>学生上学需要用到自行车，与自行车是一种<strong>依赖</strong>关系，使用带箭头的虚线表示。</li></ul><h1 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h1><h2 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h2><p>继承关系为is-a的关系：两个对象之间如果可以用is-a(是一种)来表示，就是继承关系。<br>eg：自行车是车，猫是动物（车和动物在这里都是实体类）<br>泛化关系用一条带空心箭头的直线表示，下图为A继承自B；<br><img src="https://img-blog.csdnimg.cn/2020071616144259.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>最终代码中，泛化关系表现为继承非抽象类；</p><h2 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h2><p>实现关系用一条带空心箭头的虚线表示：<br>eg：<br><img src="https://img-blog.csdnimg.cn/20200716161730211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>实现关系表现为继承抽象类或者实现接口；</p><h2 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h2><p>聚合关系用一条带空心菱形的直线表示：如下图表示A聚合到B上，或者说B由A组成；<br><img src="https://img-blog.csdnimg.cn/20200716161948489.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义，例如一个部门由多名员工组成。<br>与组合关系不同的是，<strong>整体和部分不是强依赖</strong>的，即使整体不存在了，部门仍然存在；例如：部门撤销了，人员不会消失，他们依然存在。</p><h2 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h2><p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B：<br><img src="https://img-blog.csdnimg.cn/20200716162301184.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在；例如：公司不存在了，则部门也不存在。</p><h2 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h2><p>关联关系是用一条直线表示，它描述不同类的对象之间的结构关系，它是一种<strong>静态关系</strong>，通常与运行状态无关，一般由常识等因素决定的，用来定义对象之间静态的、天然的结构，所以关联关系是一种“强关联”的关系。<br>比如：乘车人和车票之间就是一种关联关系；<br>关联关系默认不强调方向，表示对象相互知道，如果特别强调方向，如下图，表示A知道B，但B不知道A。<br><img src="https://img-blog.csdnimg.cn/20200716162752286.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p>依赖关系是用一套带箭头的虚线表示的，如下图表示A依赖于B；它描述<strong>一个对象在运行期间会用到另一个对象</strong>的关系；<br><img src="https://img-blog.csdnimg.cn/20200716163159390.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>与关联关系不同的是，它是一种<strong>临时性</strong>的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；</p><p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该<strong>保持单向依赖</strong>，杜绝双向依赖的产生；</p><p>注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-Map</title>
    <link href="/2020/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Map/"/>
    <url>/2020/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Map/</url>
    
    <content type="html"><![CDATA[<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map是“原生”接口，没有继承任何接口。<br><img src="https://img-blog.csdnimg.cn/20200716101921637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>其内部有一个内部接口：<code>Entry</code>，用于操作Map集合中的key，<strong>因为Map集合没有继承Iterator接口，自己无法遍历集合中所有的元素，所以需要将所有的key封装到Set集合中进行遍历。</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-comment">// 集合大小</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">// 判断集合是否为空</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">// 判断集合中是否存在key</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsKey</span><span class="hljs-params">(Object key)</span></span>;     <span class="hljs-comment">// 判断集合中是否存在value</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsValue</span><span class="hljs-params">(Object value)</span></span>;     <span class="hljs-comment">// 获取元素：获取键为key的元素</span>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span></span>;     <span class="hljs-comment">// 插入元素</span>    <span class="hljs-function">V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span></span>;     <span class="hljs-comment">// 删除元素</span>    <span class="hljs-function">V <span class="hljs-title">remove</span><span class="hljs-params">(Object key)</span></span>;     <span class="hljs-comment">// 插入多个元素</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">putAll</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span></span>;     <span class="hljs-comment">// 清空集合</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">// map集合中key的集合，Set类型</span>    <span class="hljs-function">Set&lt;K&gt; <span class="hljs-title">keySet</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">// map集合中value的集合</span>    <span class="hljs-function">Collection&lt;V&gt; <span class="hljs-title">values</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">// 返回Map集合中的所有key</span>    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();     <span class="hljs-comment">// Entry内部接口</span>    <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;                <span class="hljs-function">K <span class="hljs-title">getKey</span><span class="hljs-params">()</span></span>;         <span class="hljs-function">V <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>;         <span class="hljs-function">V <span class="hljs-title">setValue</span><span class="hljs-params">(V value)</span></span>;         <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span></span>;         <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;    &#125;     <span class="hljs-comment">// 判断两个map集合是否相等</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span></span>;     <span class="hljs-comment">// 计算当前map集合的hash值</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><ul><li>TreeMap：基于红黑树实现，实现了SortedMap接口；</li><li>HashMap：基于哈希表实现，元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来；可以将null作为一个表的key或value。</li><li>HashTable：遗留类，线程安全，不允许将null作为key使用，推荐使用ConcurrentHashMap。</li><li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</li></ul><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>为了便于理解，以下源码分析以JDK1.7为主。</p><h2 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h2><p>内部包含了一个entry类型的数组table。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Entry[] table;</code></pre></div><p>Entry存储着<strong>键值对</strong>，是一个链表，即数组中的每个位置都被当成一个桶，一个桶存放一个链表，HashMap使用<code>拉链法</code>来解决冲突，同一个链表中存放哈希值相同的Entry。<br><img src="https://img-blog.csdnimg.cn/20200716103919668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-keyword">final</span> K key;    V value;    Entry&lt;K,V&gt; next;    <span class="hljs-keyword">int</span> hash;    Entry(<span class="hljs-keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;        value = v;        next = n;        key = k;        hash = h;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> key;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> value;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">setValue</span><span class="hljs-params">(V newValue)</span> </span>&#123;        V oldValue = value;        value = newValue;        <span class="hljs-keyword">return</span> oldValue;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Map.Entry))            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        Map.Entry e = (Map.Entry)o;        Object k1 = getKey();        Object k2 = e.getKey();        <span class="hljs-keyword">if</span> (k1 == k2 || (k1 != <span class="hljs-keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;            Object v1 = getValue();            Object v2 = e.getValue();            <span class="hljs-keyword">if</span> (v1 == v2 || (v1 != <span class="hljs-keyword">null</span> &amp;&amp; v1.equals(v2)))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> getKey() + <span class="hljs-string">"="</span> + getValue();    &#125;&#125;</code></pre></div><h2 id="2-拉链法的工作原理"><a href="#2-拉链法的工作原理" class="headerlink" title="2. 拉链法的工作原理"></a>2. 拉链法的工作原理</h2><div class="hljs"><pre><code class="hljs java">HashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();map.put(<span class="hljs-string">"K1"</span>, <span class="hljs-string">"V1"</span>);map.put(<span class="hljs-string">"K2"</span>, <span class="hljs-string">"V2"</span>);map.put(<span class="hljs-string">"K3"</span>, <span class="hljs-string">"V3"</span>);</code></pre></div><ul><li>新建一个HashMap，默认大小为16；</li><li>插入&lt;K1,V1&gt;键值对，先计算K1的hashCode 为115，通过取模计算得到所在桶下标为3；</li><li>插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，通过取模计算得到所在桶下标为6；</li><li>插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，通过取模计算得到所在桶下标为6，插在&lt;K2,V2&gt; 前面。</li></ul><p>注意：JDk1.8以前链表的插入是以<strong>头插法</strong>方式进行的，例如上面的&lt;K3,V3&gt;不是插在&lt;K2,V2&gt;后面，而是插在链表头部。</p><p>查找需要分为两步进行：</p><ul><li>计算键值对所在的桶；</li><li>在链表上顺序查找，时间复杂度跟链表的长度成正比。<br><img src="https://img-blog.csdnimg.cn/20200716111853171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><h2 id="3-put操作"><a href="#3-put操作" class="headerlink" title="3. put操作"></a>3. put操作</h2></li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<span class="hljs-keyword">if</span> (table == EMPTY_TABLE) &#123;    inflateTable(threshold);    &#125;     <span class="hljs-comment">// 键为 null 单独处理</span>    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>)    <span class="hljs-keyword">return</span> putForNullKey(value);    <span class="hljs-keyword">int</span> hash = hash(key);    <span class="hljs-comment">// 确定桶下标</span>    <span class="hljs-keyword">int</span> i = indexFor(hash, table.length);    <span class="hljs-comment">//先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为value</span>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-keyword">null</span>; e = e.next) &#123;        Object k;        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;            V oldValue = e.value;            e.value = value;            e.recordAccess(<span class="hljs-keyword">this</span>);            <span class="hljs-keyword">return</span> oldValue;        &#125;    &#125;     modCount++;    <span class="hljs-comment">// 插入新键值对</span>    addEntry(hash, key, value, i);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p>注意：HashMap允许插入键为null的键值对，但是因为无法调用null的hashCode()方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放，<strong>HashMap使用第0个桶存放键为null的键值对</strong>。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> V <span class="hljs-title">putForNullKey</span><span class="hljs-params">(V value)</span> </span>&#123;    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="hljs-number">0</span>]; e != <span class="hljs-keyword">null</span>; e = e.next) &#123;        <span class="hljs-keyword">if</span> (e.key == <span class="hljs-keyword">null</span>) &#123;            V oldValue = e.value;            e.value = value;            e.recordAccess(<span class="hljs-keyword">this</span>);            <span class="hljs-keyword">return</span> oldValue;        &#125;    &#125;     modCount++;    addEntry(<span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, value, <span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">int</span> bucketIndex)</span> </span>&#123;    <span class="hljs-keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="hljs-keyword">null</span> != table[bucketIndex])) &#123;        resize(<span class="hljs-number">2</span> * table.length);        hash = (<span class="hljs-keyword">null</span> != key) ? hash(key) : <span class="hljs-number">0</span>;        bucketIndex = indexFor(hash, table.length);    &#125;     createEntry(hash, key, value, bucketIndex);&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">int</span> bucketIndex)</span> </span>&#123;    Entry&lt;K,V&gt; e = table[bucketIndex];    <span class="hljs-comment">// 头插法，链表头部指向新的键值对</span>    table[bucketIndex] = <span class="hljs-keyword">new</span> Entry&lt;&gt;(hash, key, value, e);    size++;&#125; Entry(<span class="hljs-keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;    value = v;    next = n;    key = k;    hash = h;&#125;</code></pre></div><h2 id="4-确定桶下标"><a href="#4-确定桶下标" class="headerlink" title="4. 确定桶下标"></a>4. 确定桶下标</h2><p>很多操作都需要先确定一个键值对所在的桶下标。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">int</span> hash = hash(key);<span class="hljs-keyword">int</span> i = indexFor(hash,table.length);</code></pre></div><h3 id="4-1-计算hash值"><a href="#4-1-计算hash值" class="headerlink" title="4.1 计算hash值"></a>4.1 计算hash值</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object k)</span> </span>&#123;    <span class="hljs-keyword">int</span> h = hashSeed;    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != h &amp;&amp; k <span class="hljs-keyword">instanceof</span> String) &#123;        <span class="hljs-keyword">return</span> sun.misc.Hashing.stringHash32((String) k);    &#125;     h^= k.hashCode();    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span>    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span>    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);&#125;</code></pre></div><h3 id="4-2-取模"><a href="#4-2-取模" class="headerlink" title="4.2 取模"></a>4.2 取模</h3><p>令x = 1&lt;&lt;4，即x的2的4次方，它具有以下性质：</p><div class="hljs"><pre><code class="hljs java">x : <span class="hljs-number">00010000</span>x-<span class="hljs-number">1</span> : <span class="hljs-number">00001111</span></code></pre></div><p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p><div class="hljs"><pre><code class="hljs java">y : <span class="hljs-number">10110010</span>x-<span class="hljs-number">1</span> : <span class="hljs-number">00001111</span>y&amp;(x-<span class="hljs-number">1</span>) : <span class="hljs-number">00000010</span></code></pre></div><p>这个性质和y对x取模效果是一样的：</p><div class="hljs"><pre><code class="hljs java">y : <span class="hljs-number">10110010</span>x : <span class="hljs-number">00010000</span>y%x : <span class="hljs-number">00000010</span></code></pre></div><p>当x为2的n次方时，<code>y%x == y &amp; (x-1)</code>，而位运算的代价比求模运算小得多，因此在进行这种计算时用位运算的话能带来更高的性能。</p><p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> length)</span> </span>&#123;    <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);&#125;</code></pre></div><h2 id="5-扩容-基本原理"><a href="#5-扩容-基本原理" class="headerlink" title="5. 扩容-基本原理"></a>5. 扩容-基本原理</h2><p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此平均查找次数的复杂度为 O(N/M)<br>为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。<br>HashMap 采用动态扩容来根据当前的 N 值（键值对的数量）来调整 M 值（table容量capacity），使得空间效率和时间效率都能得到保证。<br>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</p><ul><li>capacity：table的容量大小，默认为16，必须保证capacity为2的n次方；</li><li>size：键值对数量；</li><li>threshold：size的临界值，当size大于等于threshold就必须进行扩容操作；</li><li>loadFactory：装载因子，table能够使用的比例，threshold = capacity*loadFactory</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">16</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<span class="hljs-keyword">transient</span> Entry[] table;<span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;<span class="hljs-keyword">int</span> threshold;<span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;<span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;</code></pre></div><p>从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">int</span> bucketIndex)</span> </span>&#123;    Entry&lt;K,V&gt; e = table[bucketIndex];    table[bucketIndex] = <span class="hljs-keyword">new</span> Entry&lt;&gt;(hash, key, value, e);    <span class="hljs-keyword">if</span> (size++ &gt;= threshold)    resize(<span class="hljs-number">2</span> * table.length);&#125;</code></pre></div><p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newCapacity)</span> </span>&#123;    Entry[] oldTable = table;    <span class="hljs-keyword">int</span> oldCapacity = oldTable.length;    <span class="hljs-keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;        threshold = Integer.MAX_VALUE;        <span class="hljs-keyword">return</span>;    &#125;     Entry[] newTable = <span class="hljs-keyword">new</span> Entry[newCapacity];    transfer(newTable);    table = newTable;    threshold = (<span class="hljs-keyword">int</span>)(newCapacity * loadFactor);&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Entry[] newTable)</span> </span>&#123;    Entry[] src = table;    <span class="hljs-keyword">int</span> newCapacity = newTable.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; src.length; j++) &#123;        Entry&lt;K,V&gt; e = src[j];        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;            src[j] = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">do</span> &#123;                Entry&lt;K,V&gt; next = e.next;                <span class="hljs-keyword">int</span> i = indexFor(e.hash, newCapacity);                e.next = newTable[i];                newTable[i] = e;                e = next;            &#125; <span class="hljs-keyword">while</span> (e != <span class="hljs-keyword">null</span>);        &#125;    &#125;&#125;</code></pre></div><h2 id="6-扩容-重新计算桶下标"><a href="#6-扩容-重新计算桶下标" class="headerlink" title="6. 扩容-重新计算桶下标"></a>6. 扩容-重新计算桶下标</h2><p>在进行扩容时，需要把键值对重新放到对应的桶上，HashMap使用了一个特殊的机制，可以降低重新计算桶下标的操作。<br>假设原数组长度capacity为16，扩容之后new capacity为32：</p><div class="hljs"><pre><code class="hljs java">capacity : <span class="hljs-number">00010000</span><span class="hljs-keyword">new</span> capacity : <span class="hljs-number">00100000</span></code></pre></div><p>对于一个key，它的哈希值如果在第n位上为0，那么取模得到的结果和之前的一样；如果为1，那么得到的结果为原来的结果+2的n-1次方。</p><h2 id="7-计算数组容量"><a href="#7-计算数组容量" class="headerlink" title="7. 计算数组容量"></a>7. 计算数组容量</h2><p>HashMap构造函数允许用户传入的容量不是2的n次方，因为它可以自动地将传入的容量转换为2的n次方。<br>先考虑如何求一个数的掩码，对于10010000，它的掩码为11111111，可以使用以下方法得到：</p><div class="hljs"><pre><code class="hljs java">mask |= mask &gt;&gt; <span class="hljs-number">1</span> <span class="hljs-number">11011000</span>mask |= mask &gt;&gt; <span class="hljs-number">2</span> <span class="hljs-number">11111110</span>mask |= mask &gt;&gt; <span class="hljs-number">4</span> <span class="hljs-number">11111111</span></code></pre></div><p>mask+1 是大于原始数字的最小的 2 的 n 次方。</p><div class="hljs"><pre><code class="hljs java">num <span class="hljs-number">10010000</span>mask+<span class="hljs-number">1</span> <span class="hljs-number">100000000</span></code></pre></div><p>以下是 HashMap 中计算数组容量的代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;&#125;</code></pre></div><h2 id="8-链表转红黑树"><a href="#8-链表转红黑树" class="headerlink" title="8. 链表转红黑树"></a>8. 链表转红黑树</h2><p>从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树。</p><h2 id="9-与-HashTable-的比较"><a href="#9-与-HashTable-的比较" class="headerlink" title="9. 与 HashTable 的比较"></a>9. 与 HashTable 的比较</h2><ul><li>HashTable 使用 synchronized 来进行同步。</li><li>HashMap 可以插入键为 null 的 Entry。</li><li>HashMap 的迭代器是 fail-fast 迭代器。</li><li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li></ul><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h2 id="1-存储结构-1"><a href="#1-存储结构-1" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashEntry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;    <span class="hljs-keyword">final</span> K key;    <span class="hljs-keyword">volatile</span> V value;    <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt; next;&#125;</code></pre></div><p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了<strong>分段锁</strong>（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//Segment 继承自 ReentrantLock。</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Segment</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">2249069246763182397L</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_SCAN_RETRIES =        Runtime.getRuntime().availableProcessors() &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">64</span> : <span class="hljs-number">1</span>;    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> threshold;   <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments;</code></pre></div><p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="hljs-number">16</span>;</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200716141400885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="2-size-操作"><a href="#2-size-操作" class="headerlink" title="2. size 操作"></a>2. size 操作</h2><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* The number of elements. Accessed only either within locks</span><span class="hljs-comment">* or among other volatile reads that maintain visibility.</span><span class="hljs-comment">*/</span><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> count;</code></pre></div><p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。<br>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。<br>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。<br>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Number of unsynchronized retries in size and containsValue</span><span class="hljs-comment"> * methods before resorting to locking. This is used to avoid</span><span class="hljs-comment"> * unbounded retries if tables undergo continuous modification</span><span class="hljs-comment"> * which would make it impossible to obtain an accurate result.</span><span class="hljs-comment">*/</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RETRIES_BEFORE_LOCK = <span class="hljs-number">2</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// Try a few times to get accurate count. On failure due to</span>    <span class="hljs-comment">// continuous async changes in table, resort to locking.</span>    <span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="hljs-keyword">this</span>.segments;    <span class="hljs-keyword">int</span> size;    <span class="hljs-keyword">boolean</span> overflow; <span class="hljs-comment">// true if size overflows 32 bits</span>    <span class="hljs-keyword">long</span> sum; <span class="hljs-comment">// sum of modCounts</span>    <span class="hljs-keyword">long</span> last = <span class="hljs-number">0L</span>; <span class="hljs-comment">// previous sum</span>    <span class="hljs-keyword">int</span> retries = -<span class="hljs-number">1</span>; <span class="hljs-comment">// first iteration isn't retry</span>    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-comment">// 超过尝试次数，则对每个 Segment 加锁</span>        <span class="hljs-keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; segments.length; ++j)            ensureSegment(j).lock(); <span class="hljs-comment">// force creation</span>        &#125;         sum = <span class="hljs-number">0L</span>;        size = <span class="hljs-number">0</span>;        overflow = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; segments.length; ++j) &#123;            Segment&lt;K,V&gt; seg = segmentAt(segments, j);            <span class="hljs-keyword">if</span> (seg != <span class="hljs-keyword">null</span>) &#123;                sum += seg.modCount;                <span class="hljs-keyword">int</span> c = seg.count;                <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">0</span> || (size += c) &lt; <span class="hljs-number">0</span>)                overflow = <span class="hljs-keyword">true</span>;                &#125;            &#125;             <span class="hljs-comment">// 连续两次得到的结果一致，则认为这个结果是正确的</span>            <span class="hljs-keyword">if</span> (sum == last)            <span class="hljs-keyword">break</span>;            last = sum;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; segments.length; ++j)            segmentAt(segments, j).unlock();        &#125;    &#125;     <span class="hljs-keyword">return</span> overflow ? Integer.MAX_VALUE : size;&#125;</code></pre></div><h2 id="3-JDK-1-8-的改动"><a href="#3-JDK-1-8-的改动" class="headerlink" title="3. JDK 1.8 的改动"></a>3. JDK 1.8 的改动</h2><p>JDK 1.7 使用分段锁机制<code>Segment + HashEntry + ReentrantLock</code>来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与Segment 数量相等。<br>JDK 1.8 使用了<code>Node + CAS + Synchronized</code>来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。</p><ul><li>JDK1.8的实现降低锁的粒度，JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry，而JDK1.8锁的粒度就是HashEntry（首节点）</li><li>JDK1.8版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用synchronized来进行同步，所以不需要分段锁的概念，也就不需要Segment这种数据结构了，由于粒度的降低，实现的复杂度也增加了；</li><li>JDK1.8使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表，这样形成一个最佳拍档。</li></ul><h2 id="4-为什么-ConcurrentHashMap-的读操作不需要加锁？"><a href="#4-为什么-ConcurrentHashMap-的读操作不需要加锁？" class="headerlink" title="4. 为什么 ConcurrentHashMap 的读操作不需要加锁？"></a>4. 为什么 ConcurrentHashMap 的读操作不需要加锁？</h2><h4 id="get操作源码"><a href="#get操作源码" class="headerlink" title="get操作源码"></a>get操作源码</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//会发现源码中没有一处加了锁</span><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-keyword">int</span> n, eh; K ek;    <span class="hljs-keyword">int</span> h = spread(key.hashCode()); <span class="hljs-comment">//计算hash</span>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;        (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//读取首节点的Node元素</span>        <span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123; <span class="hljs-comment">//如果该节点就是首节点就返回</span>            <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))                <span class="hljs-keyword">return</span> e.val;        &#125;        <span class="hljs-comment">//hash值为负值表示正在扩容，这个时候查的是ForwardingNode的find方法来定位到nextTable来</span>        <span class="hljs-comment">//eh=-1，说明该节点是一个ForwardingNode，正在迁移，此时调用ForwardingNode的find方法去nextTable里找。</span>        <span class="hljs-comment">//eh=-2，说明该节点是一个TreeBin，此时调用TreeBin的find方法遍历红黑树，由于红黑树有可能正在旋转变色，所以find里会有读写锁。</span>        <span class="hljs-comment">//eh&gt;=0，说明该节点下挂的是一个链表，直接遍历该链表即可。</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-keyword">null</span> ? p.val : <span class="hljs-keyword">null</span>;        <span class="hljs-comment">//既不是首节点也不是ForwardingNode，那就往下遍历</span>        <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;                ((ek = e.key) == key || (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek))))                <span class="hljs-keyword">return</span> e.val;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p>get没有加锁的话，ConcurrentHashMap是如何保证读到的数据不是脏数据的呢？</p><h4 id="volatile登场"><a href="#volatile登场" class="headerlink" title="volatile登场"></a>volatile登场</h4><p>对于可见性，<strong>Java提供了volatile关键字来保证可见性、有序性。</strong>但不保证原子性。<br>普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p><ul><li>volatile关键字对于基本类型的修改可以在随后对多个线程的读保持一致，但是对于引用类型如数组，实体bean，仅仅保证引用的可见性，但并不保证引用内容的可见性。。</li><li>禁止进行指令重排序。</li></ul><p>背景：为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。</p><ul><li>如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。</li><li>在多处理器下，为了保证各个处理器的缓存是一致的，就会实现<strong>缓存一致性协议</strong>，当某个CPU在写数据时，如果发现操作的变量是共享变量，则会通知其他CPU告知该变量的缓存行是无效的，因此其他CPU在读取该变量时，发现其无效会重新从主存中加载数据。<br><img src="https://img-blog.csdnimg.cn/2020071614550957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></li></ul><p><strong>总结下来：</strong><br>第一：使用volatile关键字会强制将修改的值<strong>立即写入主存；</strong><br>第二：使用volatile关键字的话，当线程2进行修改时，会<strong>导致线程1的工作内存中缓存变量的缓存行无效</strong>；<br>第三：由于线程1的工作内存中缓存行无效，所以线程1再次读取变量的值时会去主存读取。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * The array of bins. Lazily initialized upon first insertion.</span><span class="hljs-comment">     * Size is always a power of two. Accessed directly by iterators.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] table;</code></pre></div><p>volatile int array[10]是指array的地址是volatile的而不是数组元素的值是volatile的.</p><h4 id="用volatile修饰的Node"><a href="#用volatile修饰的Node" class="headerlink" title="用volatile修饰的Node"></a>用volatile修饰的Node</h4><p>get操作可以无锁是由于<strong>Node的元素<code>val</code>和指针<code>next</code>是用volatile修饰的</strong>，在多线程环境下线程A修改节点的val或者新增节点的时候是对线程B可见的。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;    <span class="hljs-keyword">final</span> K key;    <span class="hljs-comment">//可以看到这些都用了volatile修饰</span>    <span class="hljs-keyword">volatile</span> V val;    <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next;    Node(<span class="hljs-keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;        <span class="hljs-keyword">this</span>.hash = hash;        <span class="hljs-keyword">this</span>.key = key;        <span class="hljs-keyword">this</span>.val = val;        <span class="hljs-keyword">this</span>.next = next;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span>       </span>&#123; <span class="hljs-keyword">return</span> key; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span>     </span>&#123; <span class="hljs-keyword">return</span> val; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span>   </span>&#123; <span class="hljs-keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">"="</span> + val; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">setValue</span><span class="hljs-params">(V value)</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;        Object k, v, u; Map.Entry&lt;?,?&gt; e;        <span class="hljs-keyword">return</span> ((o <span class="hljs-keyword">instanceof</span> Map.Entry) &amp;&amp;                (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="hljs-keyword">null</span> &amp;&amp;                (v = e.getValue()) != <span class="hljs-keyword">null</span> &amp;&amp;                (k == key || k.equals(key)) &amp;&amp;                (v == (u = val) || v.equals(u)));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Virtualized support for map.get(); overridden in subclasses.</span><span class="hljs-comment">     */</span>    <span class="hljs-function">Node&lt;K,V&gt; <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, Object k)</span> </span>&#123;        Node&lt;K,V&gt; e = <span class="hljs-keyword">this</span>;        <span class="hljs-keyword">if</span> (k != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">do</span> &#123;                K ek;                <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;                    ((ek = e.key) == k || (ek != <span class="hljs-keyword">null</span> &amp;&amp; k.equals(ek))))                    <span class="hljs-keyword">return</span> e;            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div><p>既然volatile修饰数组对get操作没有效果，那加在数组上的volatile的目的是什么呢？<br>其实就是为了<strong>使得Node数组在扩容的时候对其他线程具有可见性而加的volatile</strong>。</p><p><strong>总结</strong></p><ul><li><p>在1.8中ConcurrentHashMap的get操作全程不需要加锁，这也是它比其他并发集合比如hashtable、用<code>Collections.synchronizedMap()</code>包装的hashmap安全效率高的原因之一。</p></li><li><p><strong>get操作全程不需要加锁是因为Node的成员val是用volatile修饰的，和数组用volatile修饰没有关系。</strong></p></li><li><p><strong>数组用volatile修饰主要是保证在数组扩容的时候保证可见性。</strong></p></li></ul><h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>继承自HashMap，因此具有和HashMap一样的快速查找特性；</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedHashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span></code></pre></div><p><strong>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* The head (eldest) of the doubly linked list.</span><span class="hljs-comment">*/</span><span class="hljs-keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;<span class="hljs-comment">/**</span><span class="hljs-comment">* The tail (youngest) of the doubly linked list.</span><span class="hljs-comment">*/</span><span class="hljs-keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</code></pre></div><p>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> accessOrder;</code></pre></div><p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeInsertion</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123; &#125;</code></pre></div><h2 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess()"></a>afterNodeAccess()</h2><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; e)</span> </span>&#123;     LinkedHashMap.Entry&lt;K,V&gt; last;    <span class="hljs-keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;        LinkedHashMap.Entry&lt;K,V&gt; p =        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;        p.after = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (b == <span class="hljs-keyword">null</span>)&#123;             head = a;        &#125;        <span class="hljs-keyword">else</span>&#123;            b.after = a;                   &#125;        <span class="hljs-keyword">if</span> (a != <span class="hljs-keyword">null</span>)&#123;            a.before = b;        &#125;                <span class="hljs-keyword">else</span>&#123;            last = b;        &#125;        <span class="hljs-keyword">if</span> (last == <span class="hljs-keyword">null</span>)&#123;            head = p;        &#125;        <span class="hljs-keyword">else</span> &#123;            p.before = last;            last.after = p;        &#125;         tail = p;        ++modCount;    &#125;&#125;</code></pre></div><h2 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion()"></a>afterNodeInsertion()</h2><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最久未使用的节点，也就是链表首部节点 first。<br>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeInsertion</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;    <span class="hljs-comment">// possibly remove eldest</span>    LinkedHashMap.Entry&lt;K,V&gt; first;    <span class="hljs-keyword">if</span> (evict &amp;&amp; (first = head) != <span class="hljs-keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;        K key = first.key;        removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);    &#125;&#125;</code></pre></div><p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre></div><h2 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h2><p>以下是使用 LinkedHashMap 实现的一个 LRU 缓存：</p><ul><li>设定最大缓存空间 MAX_ENTRIES 为 3；</li><li>使用 LinkedHashMap 的构造函数将<code>accessOrder</code>设置为 true，开启 LRU 顺序；</li><li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_ENTRIES = <span class="hljs-number">3</span>;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeEldestEntry</span><span class="hljs-params">(Map.Entry eldest)</span> </span>&#123;        <span class="hljs-keyword">return</span> size() &gt; MAX_ENTRIES;    &#125;     LRUCache() &#123;        <span class="hljs-keyword">super</span>(MAX_ENTRIES, <span class="hljs-number">0.75f</span>, <span class="hljs-keyword">true</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    LRUCache&lt;Integer, String&gt; cache = <span class="hljs-keyword">new</span> LRUCache&lt;&gt;();    cache.put(<span class="hljs-number">1</span>, <span class="hljs-string">"a"</span>);    cache.put(<span class="hljs-number">2</span>, <span class="hljs-string">"b"</span>);    cache.put(<span class="hljs-number">3</span>, <span class="hljs-string">"c"</span>);    cache.get(<span class="hljs-number">1</span>);    cache.put(<span class="hljs-number">4</span>, <span class="hljs-string">"d"</span>);    System.out.println(cache.keySet());&#125;</code></pre></div><h1 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h1><h2 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h2><p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。<br>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">Object</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span></code></pre></div><h2 id="ConcurrentCache"><a href="#ConcurrentCache" class="headerlink" title="ConcurrentCache"></a>ConcurrentCache</h2><p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。<br>ConcurrentCache 采取的是分代缓存：</p><ul><li>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；</li><li>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。</li><li>当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。</li><li>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm中，利用虚拟机回收掉一部分不经常使用的对象。</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentCache</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;K, V&gt; eden;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;K, V&gt; longterm;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcurrentCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;        <span class="hljs-keyword">this</span>.size = size;        <span class="hljs-keyword">this</span>.eden = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(size);        <span class="hljs-keyword">this</span>.longterm = <span class="hljs-keyword">new</span> WeakHashMap&lt;&gt;(size);    &#125;         <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(K k)</span> </span>&#123;        V v = <span class="hljs-keyword">this</span>.eden.get(k);        <span class="hljs-keyword">if</span> (v == <span class="hljs-keyword">null</span>) &#123;            v = <span class="hljs-keyword">this</span>.longterm.get(k);        &#125;        <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">this</span>.eden.put(k, v);        &#125;         <span class="hljs-keyword">return</span> v;    &#125;         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(K k, V v)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eden.size() &gt;= size) &#123;            <span class="hljs-keyword">this</span>.longterm.putAll(<span class="hljs-keyword">this</span>.eden);            <span class="hljs-keyword">this</span>.eden.clear();        &#125;         <span class="hljs-keyword">this</span>.eden.put(k, v);    &#125;&#125;</code></pre></div><h1 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h1><p>TreeMap集合是基于<strong>红黑树</strong>实现，实现SortedMap接口。该集合最重要的特点就是<strong>可排序</strong>，该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。</p><p>TreeMap继承了Map的性质，同时其树结构又可以进行元素排序，用处很大。</p><h1 id="如何选择合适的Map？"><a href="#如何选择合适的Map？" class="headerlink" title="如何选择合适的Map？"></a>如何选择合适的Map？</h1><ul><li><p>HashMap可实现快速存储和检索，但其缺点是包含的元素是无序的，这会导致它在存在大量迭代的情况下表现不佳。</p></li><li><p>LinkedHashMap保留了HashMap的优势，且其包含的元素是有序的，它在有大量迭代的情况下表现更好；</p></li><li><p>TreeMap能便捷地实现其内部元素的各种排序，但其一般性能比前两种Map要差。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>Map</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot核心知识点</title>
    <link href="/2020/07/10/Spring-Boot%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2020/07/10/Spring-Boot%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="什么是Spring-Boot"><a href="#什么是Spring-Boot" class="headerlink" title="什么是Spring Boot"></a>什么是Spring Boot</h2><p>Spring Boot是Spring开源组织下的子项目，是Spring组件一站式解决方案，主要是简化了使用Spring的难度，简省了繁重的配置，提供了各种启动器，方便开发者快速上手。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>容易上手，提升开发效率，为 Spring 开发提供一个更快、更广泛的入门体验。</li><li>开箱即用，远离繁琐的配置。</li><li>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</li><li>没有代码生成，也不需要XML配置。</li><li>避免大量的 Maven 导入和各种版本冲突。</li></ul><p>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？<br>启动类上面的注解是<strong>@SpringBootApplication</strong>，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p><ul><li>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</li><li>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能：<br>@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</li><li>@ComponentScan：Spring组件扫描。</li></ul><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="什么是JavaConfig？"><a href="#什么是JavaConfig？" class="headerlink" title="什么是JavaConfig？"></a>什么是JavaConfig？</h2><p>Spring JavaConfig是Spring社区的产品，它提供了一种纯Java方法来配置Spring IoC容器。因此，它有助于避免使用XML配置。使用JavaConfig 的优点是：</p><ul><li><p><strong>面向对象的配置</strong>。由于配置在JavaConfig中定义为类，因此用户可以充分利用Java中面向对象的功能。一个配置类可以子类化另一个，覆盖其@Bean方法等。</p></li><li><p><strong>减少或消除XML配置</strong>。已经证明了基于依赖注入原理的外部化配置的好处。但是，许多开发人员不希望在XML和Java之间来回切换。JavaConfig为开发人员提供了一种纯Java方法来配置Spring容器，该容器在概念上类似于XML配置。在技术上可以仅使用JavaConfig配置类来配置容器，但是在实践中，许多人发现将JavaConfig与XML混合匹配是理想的。</p></li><li><p><strong>类型安全和重构友好</strong>。JavaConfig提供了一种类型安全的方法来配置Spring容器。由于Java5.0支持泛型，现在可以按类型而不是按名称检索bean，而不需要任何强制转换或基于字符串的查找。</p></li></ul><h2 id="Spring-Boot自动配置原理是什么"><a href="#Spring-Boot自动配置原理是什么" class="headerlink" title="Spring Boot自动配置原理是什么"></a>Spring Boot自动配置原理是什么</h2><p>1、当Spring Boot启动的时候，就从主方法里面进行启动<br><img src="https://img-blog.csdnimg.cn/20200710101037566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>它主要是加载了<code>@SpringBootApplication</code>注解主配置类，主配置类里边最主要的功能就是SpringBoot开启了一个<code>@EnableAutoConfiguration</code>注解实现自动配置功能。<br><img src="https://img-blog.csdnimg.cn/20200710101253888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>2、@EnableAutoConfiguration主要利用了一个<code>EnableAutoConfigurationImportSelector</code>选择器给Spring容器中来导入一些组件。<br><img src="https://img-blog.csdnimg.cn/20200710101436552.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>3、导入的组件<br>通过查看EnableAutoConfigurationImportSelector的父类<code>selectImports</code>中的<code>selectImports（）</code>方法查看具体导入了哪些组件？<br>在selectImports这个方法里面主要有一个configurations，并且这个configurations最终会被返回。<br><img src="https://img-blog.csdnimg.cn/20200710101813789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>configurations用来获取候选的配置：<br><img src="https://img-blog.csdnimg.cn/20200710101836972.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>作用就是利用<code>SpringFactoriesLoader.loadFactoryNames</code>从类路径下得到一些资源。<br>4、那么得到哪些资源呢？<br>它是扫描java.jar包类路径下的<code>META-INF/spring.factories</code>这个文件<br><img src="https://img-blog.csdnimg.cn/20200710102130303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>那么扫描到的这些文件作用是把这个文件的urls拿到之后遍历每一个url，最终把这些文件整成一个properties对象。<br><img src="https://img-blog.csdnimg.cn/2020071010225564.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>然后它从properties对象里边获取一些值，用这些获取到的值来加载我们最终要返回的这个结果，这个结果就是我们要交给Spring容器中的所有组件，这个factoryClassNames就是我们传过来的Class的类名。<br>而传过来的Class是调用这个<code>getSpringFactoriesLoaderFactoryClass()</code>这个方法，得到从properties中获取到EnableAutoConfiguration.class类名对应的值，然后把它们添加在容器中。<br><img src="https://img-blog.csdnimg.cn/20200710112151709.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>5、Spring jar包的META-INF下的<code>spring.factories</code>这个文件找到配置所有EnableAutoConfiguration的值加入到Spring容器中，每一个xxxAutoConfiguration类都是容器中的一个组件，并都加入到容器中。<br>加入到容器中之后的作用就是用它们来做自动配置，这就是Springboot自动配置之源，也就是自动配置的开始，只有这些自动配置类进入到容器中以后，接下来这个自动配置类才开始进行启动；<br>6、每一个自动配置类进行自动配置功能</p><p>以一个自动配置类HttpEncodingAutoConfiguration（HTTP的编码自动配置）为例来解释SpringBoot的自动配置原理：<br>1). 这个HttpEncodingAutoConfiguration类上面标注了一大堆的注解：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>    <span class="hljs-comment">//表示这是一个配置类，类似于以前编写的配置文件一样，也可以给容器中添加组件</span><span class="hljs-meta">@EnableConfigurationProperties</span>(HttpEncodingProperties<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span><span class="hljs-class">//启用<span class="hljs-title">ConfigurationProperties</span>功能：</span><span class="hljs-class">//这个<span class="hljs-title">ConfigurationProperties</span>里面引入了一个类，这个类就是启用指定类的<span class="hljs-title">ConfigurationProperties</span>功能,</span><span class="hljs-class">//有了这个@<span class="hljs-title">EnableConfigurationPropertie</span>注解以后相当于把配置文件中对应值就和这个<span class="hljs-title">HttpEncodingProperties</span>.<span class="hljs-title">class</span>类绑定起来了。</span><span class="hljs-class"></span><span class="hljs-class">@<span class="hljs-title">ConditionalOnWebApplication</span> </span><span class="hljs-class">//判断当前是不是<span class="hljs-title">web</span>应用，@<span class="hljs-title">Conditional</span>是<span class="hljs-title">spring</span>底层，根据不同的条件来进行自己不同的条件判断，如果满足指定的条件，那么整个配置类里边的配置才会生效。</span><span class="hljs-class"></span><span class="hljs-class">@<span class="hljs-title">ConditionalOnClass</span>(<span class="hljs-title">CharacterEncodingFilter</span>.<span class="hljs-title">class</span>)</span><span class="hljs-class">//判断当前项目里边有没有<span class="hljs-title">CharacterEncodingFilter</span>这个类，该类是<span class="hljs-title">Springmvc</span>中乱码解决的过滤器。</span><span class="hljs-class"></span><span class="hljs-class">@<span class="hljs-title">ConditionalOnProperty</span>(<span class="hljs-title">prefix</span> </span>= <span class="hljs-string">"spring.http.encoding"</span>, value = <span class="hljs-string">"enabled"</span>, matchIfMissing = <span class="hljs-keyword">true</span>)<span class="hljs-comment">//@ConditionalOnProperty注解是来判断配置文件中是否存在某个配置，就是是否存在spring.http.encoding.enabled这个配置，</span><span class="hljs-comment">//matchIfMissing = true即使配置文件中不配置spring.http.encoding.enabled=true这个属性，也是默认生效的</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span> </span>&#123;</code></pre></div><p>点进去HttpEncodingProperties这个类，发现这个HttpEncodingProperties类上面标注了@ConfigurationProperties注解<br><img src="https://img-blog.csdnimg.cn/20200710114825931.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>xxx.Properties配置文件中该配置什么，是根据HttpEncodingProperties这个类中定义的属性来定的。<br>7、这个HttpEncodingProperties类就是根据当前不同的条件判断，决定这个配置类是否生效。<br>如果一旦生效了，所有的配置类都成功了，就给容器中添加各种组件，这些组件的属性是从对应的properties类中获取的，而这properties类里边的每一个属性又是和配置文件绑定的；<br>这个HttpEncodingAutoConfiguration只有一个有参构造器，在只有一个有参构造器的情况下，参数的值就会从容器中拿。<br>8、而容器中它怎么去拿到呢？<br>相当于是前面的这个@EnableConfigurationProperties(HttpEncodingProperties.class) 注解，这个@EnableConfigurationProperties注解的作用就是<strong>把HttpEncodingProperties.class和配置文件进行绑定起来并把HttpEncodingProperties加入到容器中</strong>。<br>接下来这个自动配置类，通过一个有参构造器把这个属性拿到，而这个属性已经和SpringBoot映射了，接下来要用什么编码，就是去HttpEncodingProperties这个类里边获取对应的属性。</p><p>用好SpringBoot只要把握这几点：</p><ul><li>SpringBoot启动会加载大量的自动配置类，我们首先要做的就是检查我们需要的功能SpringBoot有没有帮我们写好自动配置类：</li><li>如果有就再来看这个自动配置类中到底配置了哪些组件，Springboot自动配置类里边只要我们要用的组件有，我们就不需要再来配置了；</li><li>但是如果说没有我们所需要的组件，那么我们就需要自己来写一个配置类来把我们相应的组件配置起来。</li><li>给容器中自动配置类添加组件的时候，会从properties类中获取某些属性，而这些属性我们就可以在配置文件指定这些属性的值。</li></ul><h2 id="Spring-Boot配置加载顺序"><a href="#Spring-Boot配置加载顺序" class="headerlink" title="Spring Boot配置加载顺序"></a>Spring Boot配置加载顺序</h2><p>SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成<strong>互补配置</strong><br>1.命令行参数<br>所有的配置都可以在命令行上进行指定</p><div class="hljs"><pre><code class="hljs java">java -jar spring-boot-<span class="hljs-number">02</span>-config-<span class="hljs-number">02</span>-<span class="hljs-number">0.0</span><span class="hljs-number">.1</span>-SNAPSHOT.jar --server.port=<span class="hljs-number">8087</span> --server.context-path=/abc</code></pre></div><p>多个配置用空格分开； –配置项=值<br>2.来自java:comp/env的JNDI属性<br>3.Java系统属性（System.getProperties()）<br>4.操作系统环境变量<br>5.RandomValuePropertySource配置的random.<em>属性值<br>*</em>由jar包外向jar包内进行寻找；<br>优先加载带profile**<br>6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件<br>7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件<br>再来加载不带profile<br>8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件<br>9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件<br>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar<br><img src="https://img-blog.csdnimg.cn/20200710120932504.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>10.@Configuration注解类上的@PropertySource<br>11.通过SpringApplication.setDefaultProperties指定的默认属性</p><h2 id="什么是YAML"><a href="#什么是YAML" class="headerlink" title="什么是YAML"></a>什么是YAML</h2><p>YAML 是一种数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</p><h2 id="YAML配置的好处"><a href="#YAML配置的好处" class="headerlink" title="YAML配置的好处"></a>YAML配置的好处</h2><ol><li>支持注释</li><li>良好的层级结构</li><li>格式松散</li><li>书写方便</li></ol><p>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</p><h2 id="Spring-Boot核心配置文件是什么？说说它们之间的区别？"><a href="#Spring-Boot核心配置文件是什么？说说它们之间的区别？" class="headerlink" title="Spring Boot核心配置文件是什么？说说它们之间的区别？"></a>Spring Boot核心配置文件是什么？说说它们之间的区别？</h2><p>spring boot 核心配置文件是bootstrap和application<br>1.加载顺序上的区别</p><ul><li>bootstrap.yml（bootstrap.properties）先加载</li><li>application.yml（application.properties）后加载</li><li>在 Spring Boot 中有两种上下文，一种是 bootstrap, 另外一种是 application, bootstrap是应用程序的父上下文，也就是说 bootstrap 加载优先于 applicaton。bootstrap主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。这两个上下文共用一个环境，它是任何Spring应用程序的外部属性的来源。bootstrap里面的属性会优先加载，它们默认也不能被本地相同配置覆盖。</li></ul><p>2.bootstrap和application 的应用场景。</p><ul><li>bootstrap.yml 和application.yml 都可以用来配置参数。</li><li>bootstrap.yml 可以理解成<strong>系统级别</strong>的一些参数配置，这些参数一般是不会变动的。</li><li>application.yml 可以用来定义<strong>应用级别</strong>的，主要用于 Spring Boot 项目的自动化配置。</li></ul><p>bootstrap 配置文件有以下几个应用场景：</p><ul><li>使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap<br>配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；</li><li>一些固定的不能被覆盖的属性</li><li>一些加密/解密的场景；</li></ul><h2 id="什么是-Spring-Profiles？"><a href="#什么是-Spring-Profiles？" class="headerlink" title="什么是 Spring Profiles？"></a>什么是 Spring Profiles？</h2><p>Spring Profiles允许用户根据配置文件（dev，test，prod等）来注册bean。因此，当应用程序在开发中运行时，只有某些bean可以加载，而在生产环境中，某些其他bean可以加载。假设我们的要求是Swagger文档仅适用于QA环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot使得使用配置文件非常简单。</p><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h2 id="如何实现Spring-Boot应用程序的安全性"><a href="#如何实现Spring-Boot应用程序的安全性" class="headerlink" title="如何实现Spring Boot应用程序的安全性"></a>如何实现Spring Boot应用程序的安全性</h2><p>为了实现Spring Boot的安全性，我们使用spring-boot-starter-security依赖项，并且进行相关安全配置，配置类必须扩展WebSecurityConfigurerAdapter，并覆盖其方法。</p><h2 id="比较Spring-Security和Shiro的优缺点"><a href="#比较Spring-Security和Shiro的优缺点" class="headerlink" title="比较Spring Security和Shiro的优缺点"></a>比较Spring Security和Shiro的优缺点</h2><ol><li>Shiro比Spring Security更容易理解、使用；</li><li>Spring Security有更好的社区支持；</li><li>Apache Shiro在处理密码学方面有一个额外的模块；</li><li>Spring Security对Spring结合较好，如果项目中没有用到Spring，建议用Shiro；</li><li>Shiro功能强大，且简单、灵活，不跟任何的框架或者容器绑定，可以独立运行；</li></ol><h2 id="Spring-Boot-解决跨域问题"><a href="#Spring-Boot-解决跨域问题" class="headerlink" title="Spring Boot 解决跨域问题"></a>Spring Boot 解决跨域问题</h2><p>跨域可以在前端通过JSONP(JSON with Padding)来解决，但是JSONP只可以发送GET请求，在RESTful风格的应用中显得很鸡肋。<br>因此推荐在后端通过<strong>CORS</strong>（Cross-origin resource sharing，跨域资源共享） 来解决跨域问题。<br><strong>跨域问题产生的根源是浏览器的“同源策略”。</strong><br>1、同源策略<br>所谓同源，是指协议、域名以及端口要相同，同源策略是浏览器最核心、最基础的安全功能。</p><p>2、CORS解决方案<br>它是一个W3C标准，是一份浏览器技术的规范，提供了Web服务从不同网域传来沙盒脚本的方法，以避开浏览器的同源策略。<br>这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口，然后重写addCorsMappings方法解决跨域问题。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorsConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> </span>&#123;        registry.addMapping(<span class="hljs-string">"/**"</span>)                .allowedOrigins(<span class="hljs-string">"*"</span>)                .allowCredentials(<span class="hljs-keyword">true</span>)                .allowedMethods(<span class="hljs-string">"GET"</span>, <span class="hljs-string">"POST"</span>, <span class="hljs-string">"PUT"</span>, <span class="hljs-string">"DELETE"</span>, <span class="hljs-string">"OPTIONS"</span>)                .maxAge(<span class="hljs-number">3600</span>);    &#125;&#125;</code></pre></div><p>项目中前后端分离部署，所以需要解决跨域的问题。<br>我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。<br>当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。<br>我们知道<strong>一个http请求，先走filter，到达servlet后才进行拦截器的处理</strong>，如果我们把cors放在filter里，就可以优先于权限拦截器执行。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorsConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CorsFilter <span class="hljs-title">corsFilter</span><span class="hljs-params">()</span> </span>&#123;        CorsConfiguration corsConfiguration = <span class="hljs-keyword">new</span> CorsConfiguration();        corsConfiguration.addAllowedOrigin(<span class="hljs-string">"*"</span>);        corsConfiguration.addAllowedHeader(<span class="hljs-string">"*"</span>);        corsConfiguration.addAllowedMethod(<span class="hljs-string">"*"</span>);        corsConfiguration.setAllowCredentials(<span class="hljs-keyword">true</span>);        UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = <span class="hljs-keyword">new</span> UrlBasedCorsConfigurationSource();        urlBasedCorsConfigurationSource.registerCorsConfiguration(<span class="hljs-string">"/**"</span>, corsConfiguration);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CorsFilter(urlBasedCorsConfigurationSource);    &#125;&#125;</code></pre></div><h2 id="什么是-CSRF-攻击？"><a href="#什么是-CSRF-攻击？" class="headerlink" title="什么是 CSRF 攻击？"></a>什么是 CSRF 攻击？</h2><p>CSRF 代表跨站请求伪造。这是一种网络攻击方式，利用网站对于用户网页浏览器的信任，挟持用户当前已登录的web应用程序，去执行并非用户本意的操作。</p><p>CSRF攻击实例：</p><ol><li>用户登录、浏览正规但是具有漏洞的网站webA，webA通过用户的验证，并在用户的浏览器中产生Cookie；</li><li>攻击者webB通过在webA中添加图片链接等方式诱导用户访问网站webB；</li><li>在用户被诱导到webB后，webB会利用用户的浏览器访问第三方网站webA，并发出操作请求（用户自身并不知情）；</li><li>用户的浏览器根据webB的要求，带着之前产生的Cookie访问webA；</li><li>网站webA接收到用户浏览器的请求，webA无法分辨请求由何处发出，由于浏览器访问时带上用户的Cookie，因此webA会响应浏览器的请求，如此一来，攻击网站webB就达到了模拟用户操作的目的。</li></ol><h1 id="整合第三方项目"><a href="#整合第三方项目" class="headerlink" title="整合第三方项目"></a>整合第三方项目</h1><h2 id="什么是WebSocket"><a href="#什么是WebSocket" class="headerlink" title="什么是WebSocket"></a>什么是WebSocket</h2><p><img src="https://img-blog.csdnimg.cn/20200710152146412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>WebSocket是一种在<strong>单个TCP连接</strong>上进行<strong>全双工通讯</strong>的网络通信协议，因为HTTP协议的通信只能由客户端发起，在某些特殊的场景下，如：聊天室，假如用HTTP协议，那么只能轮询获取服务端有没有消息，而WebSocket是<strong>双向</strong>的，客户端和服务端都可以进行消息发送，另外WebSocket是全双工的，客户端和服务端通信相互独立；WebSocket 消息数据交换要比HTTP开销更小，效率更高。</p><h2 id="什么是Spring-Data"><a href="#什么是Spring-Data" class="headerlink" title="什么是Spring Data"></a>什么是Spring Data</h2><p>Spring Data是Spring的一个子项目，用于<strong>简化数据库访问</strong>，支持NoSQL和关系数据存储，其主要目标是使数据库的访问变得方便快捷。</p><h2 id="什么是-FreeMarker-模板？"><a href="#什么是-FreeMarker-模板？" class="headerlink" title="什么是 FreeMarker 模板？"></a>什么是 FreeMarker 模板？</h2><p>FreeMarker 是一款模板引擎： 即一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。</p><h2 id="什么是Apache-kafka"><a href="#什么是Apache-kafka" class="headerlink" title="什么是Apache kafka"></a>什么是Apache kafka</h2><p>Apache Kafka 是一个分布式数据流处理平台，可以实时发布、订阅、存储和处理数据流。它设计为处理多种来源的数据流，并将它们交付到多个消费者。简而言之，它可以移动大量数据，不仅是从 A 点移到 B 点，而是能从 A 到 Z 的多个点移到任何您想要的位置，并且可以同时进行。<br>Apache Kafka 可以取代传统的企业级消息传递系统。它最初是 Linkedin 为处理每天 1.4 万亿条消息而开发的一个内部系统，现已成为应用于各式各样企业需求的开源数据流处理解决方案。</p><h2 id="什么是Swagger"><a href="#什么是Swagger" class="headerlink" title="什么是Swagger"></a>什么是Swagger</h2><p>Swagger 广泛用于可视化 API，使用 Swagger UI 为前端开发人员提供在线沙箱。Swagger 是用于生成 RESTful Web 服务的可视化表示的工具，规范和完整框架实现。它使文档能够与服务器相同的速度更新。当通过 Swagger 正确定义时，消费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger 消除了调用服务时的猜测。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？"><a href="#如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？" class="headerlink" title="如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？"></a>如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</h2><p>使用DEV工具来实现，Spring Boot有一个开发工具（DevTools）模块，会将文件更改自动部署到服务器，无需重新启动服务器，消除了每次手动部署更改的需要，以此来提高开发人员的生产力。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h2 id="Spring-Boot中的starter到底是什么"><a href="#Spring-Boot中的starter到底是什么" class="headerlink" title="Spring Boot中的starter到底是什么"></a>Spring Boot中的starter到底是什么</h2><ul><li>首先它提供了一个自动化配置类（xxxAutoConfiguration），在这个配置类中通过条件注解来决定一个配置是否生效；</li><li>然后提供一系列默认配置，允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来。</li></ul><h2 id="spring-boot-starter-parent-有什么用"><a href="#spring-boot-starter-parent-有什么用" class="headerlink" title="spring-boot-starter-parent 有什么用 ?"></a>spring-boot-starter-parent 有什么用 ?</h2><ul><li>定义了Java编译版本为1.8</li><li>使用UTF-8格式编码</li><li>提供Dependency Management进行项目依赖的版本管理</li><li>默认的资源过滤和插件管理</li></ul><h2 id="Spring-Boot-打成的-jar-和普通的-jar-有什么区别"><a href="#Spring-Boot-打成的-jar-和普通的-jar-有什么区别" class="headerlink" title="Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?"></a>Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</h2><p>Spring Boot项目最终打包成的jar是可执行的jar，这种jar可以直接通过<code>Java -jar xxx.jar</code>命令来运行，这种jar不可以作为普通的jar被其他项目依赖，即使依赖了也无法使用其中的类。<br>Spring Boot的jar无法被其他项目依赖，主要还是它跟普通jar的结构不同，普通的jar包，解压后直接就是包名，包里就是我们的代码，而Spring Boot打包成的可执行jar解压后，在<code>\BOOT-INF\classes</code>目录下才是我们的代码，因此无法直接被引用。</p><h2 id="微服务分布式session共享解决方案"><a href="#微服务分布式session共享解决方案" class="headerlink" title="微服务分布式session共享解决方案"></a>微服务分布式session共享解决方案</h2><ol><li><p>tomcat的session共享<br>优点：不需要额外开发，只需搭建tomcat集群即可<br>缺点：tomcat 是全局session复制，集群内每个tomcat的session完全同步（也就是任何时候都完全一样的) 在大规模应用的时候，用户过多，集群内tomcat数量过多，session的全局复制会导致集群性能下降， 因此，tomcat的数量不能太多，而且依赖tomcat容器移植性不好(所以不采用)</p></li><li><p>cookie同步session 如JWT(json web token)<br>这种完全把客户的登陆信息保存在客户端的cookie中，每次请求带着cookie中的Token<br>优点：由于完全舍弃了session 会减轻服务器端的压力<br>缺点：是把信息暴露在外，就算有加密算法还是存在安全问题；禁止使用cookie的情况下无效。</p></li><li><p><strong>redis 集中管理session(常用)</strong><br>优点：redis为内存数据库，读写效率高，并可在集群环境下做高可用</p></li></ol><h2 id="Spring-Boot-中如何实现定时任务"><a href="#Spring-Boot-中如何实现定时任务" class="headerlink" title="Spring Boot 中如何实现定时任务 ?"></a>Spring Boot 中如何实现定时任务 ?</h2><p>定时任务也是一个常见的需求，Spring Boot 中对于定时任务的支持主要还是来自 Spring 框架。</p><p>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 <strong>@Scheduled</strong> 注解，另一个则是使用第三方框架 <strong>Quartz</strong>。</p><ul><li>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</li><li>使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。</li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务分布式架构</category>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis核心知识点</title>
    <link href="/2020/07/10/MyBatis%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2020/07/10/MyBatis%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是MyBatis"><a href="#1-什么是MyBatis" class="headerlink" title="1. 什么是MyBatis"></a>1. 什么是MyBatis</h2><ul><li>MyBatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不用花费精力去处理加载驱动、创建连接、创建statement（Java执行数据库操作的一个重要接口）等繁杂的过程，程序员直接编写原生态SQL，可以严格控制SQL执行性能，灵活度高。</li><li>MyBatis可以使用xml或注解来配置和映射原生信息，将POJO映射成数据库中的记录，避免了几乎所有的JDBC代码和手动设置参数以及获取结果集；</li><li>通过xml文件或注解的方式将要执行的各种statement配置起来，并通过Java对象和statement中的SQL动态参数进行映射生成最终执行的SQL语句，最后由MyBatis框架执行SQL并将结果映射为Java对象并返回。（从执行SQL到返回result的过程）</li></ul><h2 id="2-MyBatis的优点"><a href="#2-MyBatis的优点" class="headerlink" title="2. MyBatis的优点"></a>2. MyBatis的优点</h2><ul><li>基于SQL语句编程，灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在xml中，<strong>解除了SQL与程序代码的耦合</strong>，便于统一管理，提供xml标签，支持编写动态SQL语句，并<strong>可重用</strong>；</li><li>与JDBC相比，减少了代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；</li><li>很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库，MyBatis都支持）；</li><li>能够与Spring很好的集成；</li><li>提供映射标签，支持对象与数据库的ORM字段关系映射，支持对象关系组件维护。</li></ul><h2 id="3-MyBatis框架的缺点"><a href="#3-MyBatis框架的缺点" class="headerlink" title="3. MyBatis框架的缺点"></a>3. MyBatis框架的缺点</h2><p>（1）SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</p><p>（2）SQL语句依赖于数据库，导致数据库<strong>移植性差</strong>，不能随意更换数据库。</p><h2 id="4-MyBatis框架适用场合"><a href="#4-MyBatis框架适用场合" class="headerlink" title="4. MyBatis框架适用场合"></a>4. MyBatis框架适用场合</h2><ul><li>MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案；</li><li>一般用在对性能的要求很高，或者需求变化较多的项目，如：互联网项目</li></ul><h2 id="5-MyBatis和Hibernate有哪些不同"><a href="#5-MyBatis和Hibernate有哪些不同" class="headerlink" title="5. MyBatis和Hibernate有哪些不同"></a>5. MyBatis和Hibernate有哪些不同</h2><ul><li>MyBatis不是一个完全的ORM框架，需要程序员自己编写SQL语句</li><li>MyBatis直接编写原生态SQL，可以严格控制SQL执行性能，灵活度高，非常适合对关系型数据模型要求不高的软件开发，但是MyBatis无法做到数据库无关性，如果需要实现多种数据库的软件，则需要自定义多套SQL映射文件，工作量大；</li><li>Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，使用Hibernate开发可以节省很多代码，提高效率。</li></ul><h2 id="6-和-的区别是什么"><a href="#6-和-的区别是什么" class="headerlink" title="6. #{}和${}的区别是什么"></a>6. #{}和${}的区别是什么</h2><p>#{}是占位符，用来预编译处理，${}是拼接符，用来字符串替换；<br>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值（<strong>PreparedStatement对象可以防止SQL注入，Statement不能防止SQL注入</strong>）；<br>Mybatis在处理${}时，就是把${}替换成变量的值；<br><strong>使用#{}可以有效的防止SQL注入，提高系统安全性</strong></p><blockquote><p>预编译：<br>SQL 预编译指的是数据库驱动在发送 SQL 语句和参数给 DBMS 之前对 SQL 语句进行编译，这样 DBMS 执行 SQL 时，就不需要重新编译。<br>为什么需要预编译？<br>JDBC 中使用对象 PreparedStatement 来抽象预编译语句，使用预编译。预编译阶段可以优化 SQL 的执行。预编译之后的 SQL 多数情况下可以直接执行，DBMS 不需要再次编译，越复杂的SQL，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。同时预编译语句对象可以重复利用。把一个 SQL 预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个SQL，可以直接使用这个缓存的 PreparedState 对象。Mybatis默认情况下，将对所有的 SQL 进行预编译。</p></blockquote><blockquote><p>PrepareStatement对象防止sql注入的方式是把用户非法输入的单引号用\反斜杠做了转义，从而达到了防止sql注入的目的。</p></blockquote><h2 id="7-当实体类中的属性名和表中的字段名不一样-，怎么办-？"><a href="#7-当实体类中的属性名和表中的字段名不一样-，怎么办-？" class="headerlink" title="7. 当实体类中的属性名和表中的字段名不一样 ，怎么办 ？"></a>7. 当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</h2><p>第1种： 通过在查询的sql语句中定义字段名的<strong>别名</strong>，让字段名的别名和实体类的属性名一致。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”selectorder”</span> <span class="hljs-attr">parametertype</span>=<span class="hljs-string">”int”</span> <span class="hljs-attr">resultetype</span>=<span class="hljs-string">”me.gacl.domain.order”</span>&gt;</span>    select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;; <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>第2种： 通过&lt;resultMap&gt;来映射字段名和实体类属性名的一一对应的关系。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getOrder"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"orderresultmap"</span>&gt;</span>       select * from orders where order_id=#&#123;id&#125;   <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">”me.gacl.domain.order”</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”orderresultmap”</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">!–用id属性来映射主键字段–</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">”id”</span> <span class="hljs-attr">column</span>=<span class="hljs-string">”order_id”</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span> = <span class="hljs-string">“orderno”</span> <span class="hljs-attr">column</span> =<span class="hljs-string">”order_no”/</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">”price”</span> <span class="hljs-attr">column</span>=<span class="hljs-string">”order_price”</span> /&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">reslutMap</span>&gt;</span></code></pre></div><h2 id="8-模糊查询like语句该怎么写"><a href="#8-模糊查询like语句该怎么写" class="headerlink" title="8. 模糊查询like语句该怎么写?"></a>8. 模糊查询like语句该怎么写?</h2><p>第1种：在Java代码中添加sql通配符。</p><div class="hljs"><pre><code class="hljs java">string wildcardname = “%smi%”;list&lt;name&gt; names = mapper.selectlike(wildcardname); &lt;select id=”selectlike”&gt; select * from foo where bar like #&#123;value&#125;&lt;/select&gt;</code></pre></div><p>第2种：<strong>在sql语句中拼接通配符，会引起sql注入</strong></p><div class="hljs"><pre><code class="hljs xml">string wildcardname = “smi”;list<span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span> names = mapper.selectlike(wildcardname); <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”selectlike”</span>&gt;</span>     select * from foo where bar like "%"$&#123;value&#125;"%"<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>第3种：”%”#{question}”%” ，注意：因为#{…}解析成sql语句时候，会在变量外侧自动加单引号’ ‘，所以这里 % 需要使用双引号” “，不能使用单引号 ’ ‘，不然会查不到任何结果。<br>第4种：<strong>CONCAT(‘%’,#{question},‘%’)</strong> 使用CONCAT()函数，推荐<br>第5种：使用bind标签</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"listUserLikeUsername"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"com.jourwon.pojo.User"</span>&gt;</span>　　<span class="hljs-tag">&lt;<span class="hljs-name">bind</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"pattern"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"'%' + username + '%'"</span> /&gt;</span>　　select id,sex,age,username,password from person where username LIKE #&#123;pattern&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><h2 id="9-通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"><a href="#9-通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="9. 通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"></a>9. 通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</h2><p>Dao接口即Mapper接口。接口的全限名，就是映射文件中的namespace的值；接口的方法名，就是映射文件中Mapper的Statement的id值；接口方法内的参数，就是传递给sql的参数。</p><p>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个<strong>MapperStatement</strong>。在Mybatis中，每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签，都会被解析为一个MapperStatement对象。</p><p>Mapper接口里的方法，是不能重载的，因为是使用 <strong>全限名+方法名</strong> 的保存和寻找策略。Mapper 接口的工作原理是<strong>JDK动态代理</strong>，Mybatis运行时会使用JDK动态代理为Mapper接口生成代理对象proxy，代理对象会拦截接口方法，转而执行MapperStatement所代表的sql，然后将sql执行结果返回。</p><h2 id="10-Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#10-Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="10. Mybatis是如何进行分页的？分页插件的原理是什么？"></a>10. Mybatis是如何进行分页的？分页插件的原理是什么？</h2><p> Mybatis使用<strong>RowBounds</strong>对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p><h2 id="11-Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#11-Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="11. Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>11. Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h2><p>第一种是使用&lt;resultMap&gt;标签，逐一定义数据库列名和对象属性名之间的映射关系。</p><p>第二种是使用sql列的别名功能，<strong>将列的别名书写为对象属性名</strong>。</p><p>有了列名与属性名的映射关系后，Mybatis通过<strong>反射</strong>创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p><h2 id="12-如何执行批量插入"><a href="#12-如何执行批量插入" class="headerlink" title="12. 如何执行批量插入?"></a>12. 如何执行批量插入?</h2><p>首先创建一个简单的insert语句：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”insertname”</span>&gt;</span>       insert into names (name) values (#&#123;value&#125;) <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></code></pre></div><p>然后在Java代码中像下面执行批处理插入：</p><div class="hljs"><pre><code class="hljs java">list&lt;string&gt; names = <span class="hljs-keyword">new</span> arraylist();  names.add(“fred”);  names.add(“barney”);  names.add(“betty”);  names.add(“wilma”);   <span class="hljs-comment">// 注意这里 executortype.batch</span>  sqlsession sqlsession = sqlsessionfactory.opensession(executortype.batch);  <span class="hljs-keyword">try</span> &#123;   namemapper mapper = sqlsession.getmapper(namemapper<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;   <span class="hljs-keyword">for</span> (string name : names) &#123;       mapper.insertname(name);   &#125;   sqlsession.commit();  &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;   e.printStackTrace();   sqlSession.rollback();    <span class="hljs-keyword">throw</span> e;   &#125;   <span class="hljs-keyword">finally</span> &#123;       sqlsession.close();  &#125;</code></pre></div><blockquote><p>Mybatis内置的ExecutorType有3种，默认为simple,该模式下它为每个语句的执行创建一个新的预处理语句，单条提交sql；而batch模式重复使用已经预处理的语句，并且批量执行所有更新语句，显然batch性能将更优； 但batch模式也有自己的问题，比如在Insert操作时，在事务没有提交之前，是没有办法获取到自增的id，这在某些情形下是不符合业务要求的。</p></blockquote><h2 id="13-如何获取自动生成的主键值"><a href="#13-如何获取自动生成的主键值" class="headerlink" title="13. 如何获取自动生成的主键值"></a>13. 如何获取自动生成的主键值</h2><p>insert方法总是返回一个int值，这个值代表的是插入的行数。<br>如果采用自增长策略，自动生成的键值在insert方法执行完后可以被设置到传入的参数对象中，如：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”insertname”</span> <span class="hljs-attr">usegeneratedkeys</span>=<span class="hljs-string">”true”</span> <span class="hljs-attr">keyproperty</span>=<span class="hljs-string">”id”</span>&gt;</span>     insert into names (name) values (#&#123;name&#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs java">name name = <span class="hljs-keyword">new</span> name();name.setname(“fred”); <span class="hljs-keyword">int</span> rows = mapper.insertname(name);<span class="hljs-comment">// 完成后,id已经被设置到对象中</span>system.out.println(“rows inserted = ” + rows);system.out.println(“generated key value = ” + name.getid());</code></pre></div><h2 id="14-在mapper中如何传递多个参数"><a href="#14-在mapper中如何传递多个参数" class="headerlink" title="14. 在mapper中如何传递多个参数?"></a>14. 在mapper中如何传递多个参数?</h2><p>第一种：<br>DAO层的函数</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-title">UserselectUser</span><span class="hljs-params">(String name,String area)</span></span>;</code></pre></div><p>对应的xml,#{0}代表接收的是dao层中的第一个参数，#{1}代表dao层中第二参数，更多参数依次往后加即可。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectUser"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"BaseResultMap"</span>&gt;</span>      select *  fromuser_user_t   whereuser_name = #&#123;0&#125; anduser_area=#&#123;1&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>第二种： 使用 @param 注解</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">usermapper</span> </span>&#123;   <span class="hljs-function">user <span class="hljs-title">selectuser</span><span class="hljs-params">(@param(“username”)</span> string username,@<span class="hljs-title">param</span><span class="hljs-params">(“hashedpassword”)</span> string hashedpassword)</span>;&#125;</code></pre></div><p>然后,就可以在xml中像下面这样使用(推荐封装为一个map,作为单个参数传递给mapper):</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”selectuser”</span> <span class="hljs-attr">resulttype</span>=<span class="hljs-string">”user”</span>&gt;</span>         select id, username, hashedpassword         from some_table         where username = #&#123;username&#125;         and hashedpassword = #&#123;hashedpassword&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>第三种：多个参数封装成map</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<span class="hljs-comment">//映射文件的命名空间.SQL片段的ID，就可以调用对应的映射文件中的SQL</span><span class="hljs-comment">//由于我们的参数超过了两个，而方法中只有一个Object参数收集，因此我们使用Map集合来装载我们的参数</span>Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap();     map.put(<span class="hljs-string">"start"</span>, start);     map.put(<span class="hljs-string">"end"</span>, end);     <span class="hljs-keyword">return</span> sqlSession.selectList(<span class="hljs-string">"StudentID.pagination"</span>, map); &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;     e.printStackTrace();     sqlSession.rollback();    <span class="hljs-keyword">throw</span> e; &#125;<span class="hljs-keyword">finally</span>&#123; MybatisUtil.closeSqlSession();</code></pre></div><h2 id="15-Mybatis动态sql有什么用？执行原理？有哪些动态sql？"><a href="#15-Mybatis动态sql有什么用？执行原理？有哪些动态sql？" class="headerlink" title="15. Mybatis动态sql有什么用？执行原理？有哪些动态sql？"></a>15. Mybatis动态sql有什么用？执行原理？有哪些动态sql？</h2><p>Mybatis动态sql可以在Xml映射文件内以标签的形式编写动态sql，执行原理是<strong>根据表达式的值，完成逻辑判断并动态拼接sql的功能</strong>。</p><p>Mybatis提供了9种动态sql标签：trim | where | set | foreach | if | choose | when | otherwise | bind。</p><h2 id="16-Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？"><a href="#16-Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？" class="headerlink" title="16. Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？"></a>16. Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</h2><p><strong>&lt;resultMap&gt;</strong>：映射管理器，用于解决实体类中属性和表字段名不相同的问题</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--id为映射管理器的唯一标识,通过该值引用--&gt;</span><span class="hljs-comment">&lt;!--type标识需要映射的实体类,别名不区分大小写--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userMap"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"user"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 主键字段的对应 property对应实体类属性 column对应表字段 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userId"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>        <span class="hljs-comment">&lt;!--非主键字段的对应--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userName"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"username"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userSex"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sex"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></code></pre></div><p><strong>&lt;sql&gt;</strong>：可以重用的SQL语句，可以被其他语句引用</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userColumns"</span>&gt;</span>id,username,password<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectUsers"</span> <span class="hljs-attr">paramertType</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"hashmap"</span>&gt;</span>select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">"userColumns"</span>/&gt;</span>from some_table<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p><strong>&lt;include&gt;</strong>：引入sql片段<br><strong>&lt;selectKey&gt;</strong>：为不支持自增的主键生成策略标签<br>加上动态sql的9个标签</p><h2 id="17-Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#17-Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="17. Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a>17. Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h2><p>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；</p><p>原因就是<strong>namespace+id是作为Map&lt;String, MapperStatement&gt;的key使用的</strong>，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p><h2 id="18-为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#18-为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="18. 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>18. 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h2><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p><h2 id="19-一对一、一对多的关联查询-？"><a href="#19-一对一、一对多的关联查询-？" class="headerlink" title="19. 一对一、一对多的关联查询 ？"></a>19. 一对一、一对多的关联查询 ？</h2><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.lcb.mapping.userMapper"</span>&gt;</span>      <span class="hljs-comment">&lt;!--association  一对一关联查询 --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getClass"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"ClassesResultMap"</span>&gt;</span>          select * from class c,teacher t where c.teacher_id=t.t_id and c.c_id=#&#123;id&#125;      <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.lcb.user.Classes"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"ClassesResultMap"</span>&gt;</span>          <span class="hljs-comment">&lt;!-- 实体类的字段名和数据表的字段名映射 --&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"c_id"</span>/&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"c_name"</span>/&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"teacher"</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">"com.lcb.user.Teacher"</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"t_id"</span>/&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"t_name"</span>/&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>        <span class="hljs-comment">&lt;!--collection  一对多关联查询 --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getClass2"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"ClassesResultMap2"</span>&gt;</span>          select * from class c,teacher t,student s where c.teacher_id=t.t_id and c.c_id=s.class_id and c.c_id=#&#123;id&#125;      <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.lcb.user.Classes"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"ClassesResultMap2"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"c_id"</span>/&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"c_name"</span>/&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"teacher"</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">"com.lcb.user.Teacher"</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"t_id"</span>/&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"t_name"</span>/&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"student"</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">"com.lcb.user.Student"</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"s_id"</span>/&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"s_name"</span>/&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><h2 id="20-MyBatis实现一对一（多）有几种方式-具体怎么操作的？"><a href="#20-MyBatis实现一对一（多）有几种方式-具体怎么操作的？" class="headerlink" title="20. MyBatis实现一对一（多）有几种方式?具体怎么操作的？"></a>20. MyBatis实现一对一（多）有几种方式?具体怎么操作的？</h2><p>有联合查询和嵌套查询两种方式：</p><ul><li>联合查询是几个表联合查询,只查询一次, 通过在resultMap里面配置association（collection）节点配置一对一的类就可以完成；</li><li>嵌套查询是先查一个表，根据这个表里面的结果的外键id，去再另外一个表里面查询数据,也是通过association（collection）配置，但另外一个表的查询通过select属性配置。</li></ul><h2 id="21-Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#21-Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="21. Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>21. Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h2><p>答：Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载<code>lazyLoadingEnabled=true|false</code>。</p><p>它的原理是，使用<strong>CGLIB</strong>创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p><h2 id="22-MyBatis的一级、二级缓存："><a href="#22-MyBatis的一级、二级缓存：" class="headerlink" title="22. MyBatis的一级、二级缓存："></a>22. MyBatis的一级、二级缓存：</h2><p>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p><p>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache的HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置&lt;cache/&gt; ；</p><p>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear 掉并重新更新，如果开启了二级缓存，则只根据配置判断是否刷新。</p><h2 id="23-什么是MyBatis的接口绑定？有哪些实现方式？"><a href="#23-什么是MyBatis的接口绑定？有哪些实现方式？" class="headerlink" title="23.  什么是MyBatis的接口绑定？有哪些实现方式？"></a>23.  什么是MyBatis的接口绑定？有哪些实现方式？</h2><p>接口绑定，就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定, 我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。</p><p>接口绑定有两种实现方式:</p><ul><li>一种是通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；</li><li>另外一种就是通过xml里面写SQL来绑定,<br>在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。当Sql语句比较简单时候,用注解绑定, 当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多。</li></ul><h2 id="24-使用MyBatis的mapper接口调用时有哪些要求？"><a href="#24-使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="24. 使用MyBatis的mapper接口调用时有哪些要求？"></a>24. 使用MyBatis的mapper接口调用时有哪些要求？</h2><p>①  Mapper接口方法名和mapper.xml中定义的每个sql的id相同；<br>②  Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同；<br>③  Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同；<br>④  Mapper.xml文件中的namespace即是mapper接口的类路径。</p><h2 id="25-MyBatis编程步骤是什么样的？"><a href="#25-MyBatis编程步骤是什么样的？" class="headerlink" title="25. MyBatis编程步骤是什么样的？"></a>25. MyBatis编程步骤是什么样的？</h2><p>1、创建 SqlSessionFactory<br>2、通过 SqlSessionFactory 创建 SqlSession<br>3、通过 sqlsession 执行数据库操作<br>4、调用 sqlsession .commit()提交事务<br>5、调用 sqlsession .close()关闭会话</p><h2 id="26-MyBatis的工作原理"><a href="#26-MyBatis的工作原理" class="headerlink" title="26. MyBatis的工作原理"></a>26. MyBatis的工作原理</h2><p><img src="https://img-blog.csdnimg.cn/20200710203154672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>    mybatis应用程序通过SqlSessionFactoryBuilder从mybatis-config.xml配置文件（也可以用Java文件配置的方式，需要添加@Configuration）来构建SqlSessionFactory（SqlSessionFactory是线程安全的）；<br>    然后，SqlSessionFactory的实例直接开启一个SqlSession，再通过SqlSession实例获得Mapper对象并运行Mapper映射的SQL语句，完成对数据库的CRUD和事务提交，之后关闭SqlSession。<br>说明：SqlSession是单线程对象，因为它是非线程安全的，是持久化操作的独享对象，类似jdbc中的Connection，底层就封装了jdbc连接。</p><p>详细流程如下：<br>    1、加载mybatis全局配置文件（数据源、mapper映射文件等），解析配置文件，MyBatis基于XML配置文件生成Configuration，和一个个MappedStatement（包括了参数映射配置、动态SQL语句、结果映射配置），其对应着&lt;select | update | delete | insert&gt;标签项。<br>    2、SqlSessionFactoryBuilder通过Configuration对象生成SqlSessionFactory，用来开启SqlSession。<br>    3、SqlSession对象完成和数据库的交互：<br>    a、用户程序调用mybatis接口层api（即Mapper接口中的方法）<br>    b、SqlSession通过调用api的Statement ID找到对应的MappedStatement对象<br>    c、通过Executor（负责动态SQL的生成和查询缓存的维护）将MappedStatement对象进行解析，sql参数转化、动态sql拼接，生成jdbc Statement对象<br>    d、JDBC执行sql。<br>    e、借助MappedStatement中的结果映射关系，将返回结果转化成HashMap、JavaBean等存储结构并返回。</p><h2 id="27-MyBatis的功能架构"><a href="#27-MyBatis的功能架构" class="headerlink" title="27. MyBatis的功能架构"></a>27. MyBatis的功能架构</h2><p>Mybatis的功能架构分为三层：</p><ul><li>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</li><li>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</li><li>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。<br><img src="https://img-blog.csdnimg.cn/20200710203604956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></li></ul>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring核心知识点</title>
    <link href="/2020/07/09/Spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2020/07/09/Spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h1><h2 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h2><p>Spring是一个轻量级的Java开发框架，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题，<strong>简化Java开发</strong>，其设计理念是通过IoC容器实现对象耦合关系的管理，从而实现<strong>解耦</strong>。</p><h2 id="Spring的优缺点"><a href="#Spring的优缺点" class="headerlink" title="Spring的优缺点"></a>Spring的优缺点</h2><p>优点：</p><ul><li>方便解耦，简化开发（将所有对象的创建和依赖关系的维护交给Spring管理）</li><li>AOP编程的支持（方便实现对程序进行权限拦截、运行监控等功能）</li><li>声明式事务的支持（只要通过配置就可以完成对事务的管理，无需手动编程）</li><li>方便程序的测试（Junit4支持，通过注解方便测试Spring程序）</li><li>方便集成各种优秀框架（MyBatis、Redis等）</li><li>降低JavaEE API的使用难度</li></ul><p>缺点：</p><ul><li>Spring依赖反射，影响性能</li><li>使用门槛较高</li><li>配置较复杂</li></ul><h2 id="Spring由哪些模块组成"><a href="#Spring由哪些模块组成" class="headerlink" title="Spring由哪些模块组成"></a>Spring由哪些模块组成</h2><p><img src="https://img-blog.csdnimg.cn/20200709145013402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li>Core：提供了框架的基本组成部分，包括<strong>控制反转</strong>和<strong>依赖注入</strong>功能；</li><li>Beans：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean；</li><li>Context：Spring上下文，向Spring框架提供上下文信息，其他程序也可以通过Context访问Spring的Bean资源。</li><li>JDBC：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析， 用于简化JDBC</li><li>AOP：提供面向切面的编程实现，可以自定义拦截器、切点等；</li><li>Web：Web开发相关的组件</li><li>Test：为测试提供支持</li></ul><h2 id="Spring框架中的设计模式"><a href="#Spring框架中的设计模式" class="headerlink" title="Spring框架中的设计模式"></a>Spring框架中的设计模式</h2><ol><li>工厂模式：BeanFactory创建对象的实例</li><li>单例模式：Bean默认是单例模式</li><li>代理模式：AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</li><li>模板方法模式：用来解决代码重复的问题，如：JpaTemplate，RestTemplate</li><li>观察者模式：当一个对象的状态发生改变时，所有依赖于它的对象都能得到通知，如监听器功能。</li></ol><h1 id="Spring控制反转（IoC）"><a href="#Spring控制反转（IoC）" class="headerlink" title="Spring控制反转（IoC）"></a>Spring控制反转（IoC）</h1><h2 id="什么是Spring-IoC容器"><a href="#什么是Spring-IoC容器" class="headerlink" title="什么是Spring IoC容器"></a>什么是Spring IoC容器</h2><p>控制反转是将传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理，所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，实现了<strong>解耦</strong>。</p><p>Spring IoC负责创建对象，并管理这些对象的整个生命周期。</p><h2 id="Spring-IoC的实现机制"><a href="#Spring-IoC的实现机制" class="headerlink" title="Spring IoC的实现机制"></a>Spring IoC的实现机制</h2><p>工厂模式+反射机制</p><h2 id="IoC容器的加载流程-refresh方法"><a href="#IoC容器的加载流程-refresh方法" class="headerlink" title="IoC容器的加载流程(refresh方法)"></a>IoC容器的加载流程(refresh方法)</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>&#123;    Object var1 = <span class="hljs-keyword">this</span>.startupShutdownMonitor;    <span class="hljs-comment">// 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span>    <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>.startupShutdownMonitor) &#123;                <span class="hljs-comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span>        <span class="hljs-keyword">this</span>.prepareRefresh();                <span class="hljs-comment">// 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span>        <span class="hljs-comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span>        <span class="hljs-comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span>        ConfigurableListableBeanFactory beanFactory = <span class="hljs-keyword">this</span>.obtainFreshBeanFactory();                <span class="hljs-comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span>        <span class="hljs-keyword">this</span>.prepareBeanFactory(beanFactory);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span>            <span class="hljs-comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span>            <span class="hljs-comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span>            <span class="hljs-comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span>            <span class="hljs-keyword">this</span>.postProcessBeanFactory(beanFactory);                        <span class="hljs-comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法</span>            <span class="hljs-keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);                        <span class="hljs-comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span>            <span class="hljs-comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span>            <span class="hljs-comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机</span>            <span class="hljs-keyword">this</span>.registerBeanPostProcessors(beanFactory);                     <span class="hljs-comment">// 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了    </span>            <span class="hljs-keyword">this</span>.initMessageSource();                        <span class="hljs-comment">// 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span>            <span class="hljs-keyword">this</span>.initApplicationEventMulticaster();                        <span class="hljs-comment">// 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说</span>         <span class="hljs-comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span>            <span class="hljs-keyword">this</span>.onRefresh();                        <span class="hljs-comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span>            <span class="hljs-keyword">this</span>.registerListeners();                        <span class="hljs-comment">// 重点，重点，重点</span>            <span class="hljs-comment">// 初始化所有的 singleton beans</span>            <span class="hljs-comment">//（lazy-init 的除外）</span>            <span class="hljs-keyword">this</span>.finishBeanFactoryInitialization(beanFactory);                        <span class="hljs-comment">// 最后，广播事件，ApplicationContext 初始化完成，不展开</span>            <span class="hljs-keyword">this</span>.finishRefresh();        &#125; <span class="hljs-keyword">catch</span> (BeansException var9) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logger.isWarnEnabled()) &#123;                <span class="hljs-keyword">this</span>.logger.warn(<span class="hljs-string">"Exception encountered during context initialization - cancelling refresh attempt: "</span> + var9);            &#125;            <span class="hljs-comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span>            <span class="hljs-keyword">this</span>.destroyBeans();            <span class="hljs-keyword">this</span>.cancelRefresh(var9);            <span class="hljs-comment">// 把异常往外抛</span>            <span class="hljs-keyword">throw</span> var9;        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">this</span>.resetCommonCaches();        &#125;    &#125;&#125;</code></pre></div><h3 id="1-加锁"><a href="#1-加锁" class="headerlink" title="1. 加锁"></a>1. 加锁</h3><p>首先是一个synchronized加锁，不然你先调用一次refresh()，然后这次还没处理完，有调用一次，就会乱套。</p><h3 id="2-prepareRefresh"><a href="#2-prepareRefresh" class="headerlink" title="2. prepareRefresh()"></a>2. prepareRefresh()</h3><p>做准备工作，记录容器的启动时间，标记“已启动”状态，处理配置文件中的占位符。</p><h3 id="3-注册BeanDefinition到BeanFactory"><a href="#3-注册BeanDefinition到BeanFactory" class="headerlink" title="3. 注册BeanDefinition到BeanFactory"></a>3. 注册BeanDefinition到BeanFactory</h3><div class="hljs"><pre><code class="hljs java">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</code></pre></div><p>将配置文件解析成一个个Bean，并且注册到BeanFactory中，注意这里只是注册进去，并没有初始化。</p><h4 id="注册实现原理"><a href="#注册实现原理" class="headerlink" title="注册实现原理"></a>注册实现原理</h4><p><strong>BeanDefinition(Bean定义)</strong></p><p>在IOC实现中，我们在XML中描述的Bean信息最后都将保存至BeanDefinition对象中，xml-bean中设置的属性最后都会体现在BeanDefinition中，如：</p><p><img src="https://upload-images.jianshu.io/upload_images/18628873-7553de4d8ddfbb11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1136/format/webp" srcset="/img/loading.gif" alt="img"></p><p><strong>BeanDefinitionRegistry(Bean注册器)</strong></p><p>xml-bean中的id作为当前Bean的存储key注册到了BeanDefinitionRegistry注册器中，name作为别名key注册到了AliasRegistry注册中心，最后都是指向其对应的BeanDefinition。</p><p><strong>BeanDefinitionReader（Bean定义读取）</strong></p><p>BeanDefinition中存储了xml-bean信息，而BeanDefinitionRegister基于ID和name保存了Bean的定义，下图是从xml-Bean到BeanDefinition然后再注册至BeanDefinitionRegister的整个过程。</p><p><img src="https://upload-images.jianshu.io/upload_images/18628873-50f575074eb4c65c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/687/format/webp" srcset="/img/loading.gif" alt="img"></p><p>从上图可以看出，Bean的定义是由BeanDefinitionReader从xml中读取配置并构建出BeanDefinition，然后再基于别名注册BeanDefinitionRegister中。</p><h3 id="4-prepareBeanFactory（beanFactory）"><a href="#4-prepareBeanFactory（beanFactory）" class="headerlink" title="4. prepareBeanFactory（beanFactory）"></a>4. prepareBeanFactory（beanFactory）</h3><p>设置BeanFactory的类加载器，然后添加几个BeanPostProcessor，手动注册几个特殊的bean，这里都是Spring里面的特殊处理。</p><h3 id="5-postProcessBeanFactory（beanFactory）"><a href="#5-postProcessBeanFactory（beanFactory）" class="headerlink" title="5. postProcessBeanFactory（beanFactory）"></a>5. postProcessBeanFactory（beanFactory）</h3><p>提供给子类的扩展点，到这里所有的Bean都加载，注册完成了，但是都还没有初始化，具体的子类可以在这步的时候添加一些特殊的BeanFactoryPostProcessor的实现类，来完成一些其他的操作。</p><p><strong>BeanPostProcessor接口</strong>：如果我们想在Spring容器中完成Bean实例化、配置以及其他初始化方法前后要添加一些自己逻辑处理，我们需要定义一个或多个BeanPostProcessor接口实现类，然后注册到Spring IOC容器中。</p><h3 id="6-执行容器中实现的BeanFactoryPostProcessor的子类（如果有的话）"><a href="#6-执行容器中实现的BeanFactoryPostProcessor的子类（如果有的话）" class="headerlink" title="6. 执行容器中实现的BeanFactoryPostProcessor的子类（如果有的话）"></a>6. 执行容器中实现的BeanFactoryPostProcessor的子类（如果有的话）</h3><div class="hljs"><pre><code class="hljs java">invokeBeanFactoryPostProcessors(beanFactory);</code></pre></div><p>这个方法是调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法；</p><h3 id="7-后置处理器的实现BeanPostProcessors"><a href="#7-后置处理器的实现BeanPostProcessors" class="headerlink" title="7. 后置处理器的实现BeanPostProcessors"></a>7. 后置处理器的实现BeanPostProcessors</h3><div class="hljs"><pre><code class="hljs java">registerBeanPostProcessors(beanFactory);</code></pre></div><p>这个方法注册 BeanPostProcessor 的实现类，和上面的BeanFactoryPostProcessor 是有区别的，这个方法调用的其实是PostProcessorRegistrationDelegate类的registerBeanPostProcessors方法；这个类里面有个内部类BeanPostProcessorChecker，BeanPostProcessorChecker里面有两个方法<strong>postProcessBeforeInitialization和postProcessAfterInitialization</strong>，这两个方法分别在 Bean 初始化之前和初始化之后得到执行。</p><h3 id="8-国际化"><a href="#8-国际化" class="headerlink" title="8. 国际化"></a>8. 国际化</h3><div class="hljs"><pre><code class="hljs java">initMessageSource();</code></pre></div><h3 id="9-初始化事件广播器"><a href="#9-初始化事件广播器" class="headerlink" title="9. 初始化事件广播器"></a>9. 初始化事件广播器</h3><div class="hljs"><pre><code class="hljs java">initApplicationEventMulticaster();</code></pre></div><h3 id="10-初始化一些特殊的Bean"><a href="#10-初始化一些特殊的Bean" class="headerlink" title="10. 初始化一些特殊的Bean"></a>10. 初始化一些特殊的Bean</h3><div class="hljs"><pre><code class="hljs java">onRefresh();</code></pre></div><p>方法初始化一些特殊的 Bean（在初始化 singleton beans 之前）</p><h3 id="11-注册事件监听器"><a href="#11-注册事件监听器" class="headerlink" title="11. 注册事件监听器"></a>11. 注册事件监听器</h3><div class="hljs"><pre><code class="hljs java">registerListeners();</code></pre></div><p>方法注册事件监听器，监听器需要实现 ApplicationListener 接口</p><h3 id="12-初始化Bean"><a href="#12-初始化Bean" class="headerlink" title="12. 初始化Bean"></a>12. 初始化Bean</h3><div class="hljs"><pre><code class="hljs java">finishBeanFactoryInitialization(beanFactory);</code></pre></div><p>初始化所有的 singleton beans（单例bean），懒加载（non-lazy-init）的除外（spring默认不是懒加载，如果设定了懒加载，则bean的初始化由getbean方法触发）。</p><p>从调用过程可以总结出以下几点：</p><ol><li>调用BeanFactory.getBean() 会触发Bean的实例化。</li><li>2.DefaultSingletonBeanRegistry 中缓存了单例Bean</li><li>3.Bean的创建与初始化是由AbstractAutowireCapableBeanFactory 完成的。</li></ol><h3 id="13-广播事件，告诉上下文，容器已经创建好，随时可以调用"><a href="#13-广播事件，告诉上下文，容器已经创建好，随时可以调用" class="headerlink" title="13. 广播事件，告诉上下文，容器已经创建好，随时可以调用"></a>13. 广播事件，告诉上下文，容器已经创建好，随时可以调用</h3><div class="hljs"><pre><code class="hljs java">finishRefresh();</code></pre></div><p>方法是最后一步，广播事件，ApplicationContext 初始化完成。</p><h2 id="IoC容器的加载过程简单概括："><a href="#IoC容器的加载过程简单概括：" class="headerlink" title="IoC容器的加载过程简单概括："></a>IoC容器的加载过程简单概括：</h2><ol><li>刷新预处理</li><li>将配置信息解析，注册到BeanFactory</li><li>设置bean的类加载器</li><li>如果有第三方想再bean加载注册完成后，初始化前做点什么(例如修改属性的值，修改bean的scope为单例或者多例。)，提供了相应的模板方法，后面还调用了这个方法的实现，并且把这些个实现类注册到对应的容器中</li><li>初始化当前的事件广播器</li><li>初始化所有的bean。（懒加载不执行这一步）</li><li>广播applicationcontext初始化完成。</li></ol><h2 id="BeanFactory和FactoryBean"><a href="#BeanFactory和FactoryBean" class="headerlink" title="BeanFactory和FactoryBean"></a>BeanFactory和FactoryBean</h2><ul><li>BeanFactory：以Factory结尾，是spring中比较原始的Factory，如XMLBeanFactory就是一种典型的BeanFactory，表示它是一个工厂类，又称IoC容器或对象工厂，所有的Bean都是由BeanFactory（IoC容器）来进行管理；</li><li>FactoryBean：以Bean结尾，表示它是一个Bean，不同于普通Bean的是：FactoryBean能生产或修饰对象生成的工厂Bean，它的实现与设计模式中的工厂模式和修饰器模式类似。</li></ul><h2 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h2><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。<br><strong>区别：</strong><br>依赖关系：</p><ul><li><p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p></li><li><p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p><ul><li>继承MessageSource，因此支持国际化（i18n）。</li><li>统一的资源文件访问方式。</li><li>提供在监听器中注册bean的事件。</li><li>同时加载多个配置文件。</li><li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li></ul></li></ul><p>加载方式：</p><ul><li>BeanFactory采用的是<strong>延迟加载</strong>的形式来注入Bean</li><li>ApplicationContext在容器启动时一次性创建所有的Bean。这样在容器启动时，就可以发现Spring中存在的配置错误，但是不足之处在于占用内存空间，从而导致程序启动较慢。</li></ul><p>创建方式：</p><ul><li>BeanFactory通常以<strong>编程</strong>的方式被创建</li><li>ApplicationContext还能以<strong>声明</strong>的方式创建，如使用ContextLoader。</li></ul><h2 id="ApplicationContext通常的实现是什么？"><a href="#ApplicationContext通常的实现是什么？" class="headerlink" title="ApplicationContext通常的实现是什么？"></a>ApplicationContext通常的实现是什么？</h2><ul><li>FileSystemXmlApplicationContext：通过程序在初始化的时候，导入Bean配置文件，然后得到Bean实例。</li><li>ClassPathXmlApplicationContext：从类路径下的xml文件中加载bean的配置文件；</li><li>XmlWebApplicationContext：在B/S系统中,通常在web.xml初始化bean的配置文件，然后由WebAppliCationContextUtil得到ApplicationContext</li></ul><h2 id="什么是依赖注入（DI）"><a href="#什么是依赖注入（DI）" class="headerlink" title="什么是依赖注入（DI）"></a>什么是依赖注入（DI）</h2><p>依赖注入（Dependency Injection，DI），是组件之间依赖关系由容器在运行期决定，即由容器动态地将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了<strong>提升组件重用的频率</strong>，并为系统搭建一个<strong>灵活</strong>、<strong>可扩展</strong>的平台。通过依赖注入机制，只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。<br><strong>依赖注入是实现控制反转的方法和手段。</strong></p><h2 id="依赖注入的常见实现方式"><a href="#依赖注入的常见实现方式" class="headerlink" title="依赖注入的常见实现方式"></a>依赖注入的常见实现方式</h2><ul><li><p>setter注入</p></li><li><p>构造方法注入</p></li><li><p>注解注入</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;    <span class="hljs-comment">// 使用注解自动注入</span>    <span class="hljs-meta">@Autowired</span>()    <span class="hljs-keyword">private</span> UserService userService;    <span class="hljs-comment">// do something</span>&#125;<span class="hljs-comment">// 创建依赖对象</span><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;   <span class="hljs-comment">// do something </span>&#125;</code></pre></div></li></ul><h1 id="Spring-Beans"><a href="#Spring-Beans" class="headerlink" title="Spring Beans"></a>Spring Beans</h1><h2 id="Bean的5种作用域"><a href="#Bean的5种作用域" class="headerlink" title="Bean的5种作用域"></a>Bean的5种作用域</h2><ul><li>singleton：bean在每个Spring ioc 容器中只有一个实例。</li><li>prototype：一个bean的定义可以有多个实例。</li><li>request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring<br>ApplicationContext情形下有效。</li><li>session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li><li>global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li></ul><p>对于有状态的bean使用prototype，对于无状态的bean则使用singleton。</p><blockquote><p>有状态就是有数据存储功能，有状态对象就是有实例变量的对象，可以保存数据，是非线程安全的，所以要使用prototype保证安全；</p><p>无状态就是一次操作，不能保存数据，无状态对象就是没有实例变量的对象，线程安全，因此使用singleton性能更好。</p></blockquote><h3 id="Spring配置bean实例化有哪些方式？"><a href="#Spring配置bean实例化有哪些方式？" class="headerlink" title="Spring配置bean实例化有哪些方式？"></a>Spring配置bean实例化有哪些方式？</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-number">1</span>）使用类构造器实例化(默认无参数)&lt;bean id="bean1" class="cn.itcast.spring.b_instance.Bean1"&gt;&lt;/bean&gt;<span class="hljs-number">2</span>）使用静态工厂方法实例化(简单工厂模式)<span class="hljs-comment">//下面这段配置的含义：调用Bean2Factory的getBean2方法得到bean2</span>&lt;bean id=<span class="hljs-string">"bean2"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"cn.itcast.spring.b_instance.Bean2Factory"</span> factory-method=<span class="hljs-string">"getBean2"</span>&gt;&lt;/bean&gt;<span class="hljs-number">3</span>）使用实例工厂方法实例化(工厂方法模式)<span class="hljs-comment">//先创建工厂实例bean3Facory，再通过工厂实例创建目标bean实例</span>&lt;bean id=<span class="hljs-string">"bean3Factory"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"cn.itcast.spring.b_instance.Bean3Factory"</span>&gt;&lt;/bean&gt;&lt;bean id=<span class="hljs-string">"bean3"</span> factory-bean=<span class="hljs-string">"bean3Factory"</span> factory-method=<span class="hljs-string">"getBean3"</span>&gt;&lt;/bean&gt;</code></pre></div><h3 id="Spring配置bean实例化有哪些方式"><a href="#Spring配置bean实例化有哪些方式" class="headerlink" title="Spring配置bean实例化有哪些方式"></a>Spring配置bean实例化有哪些方式</h3><p>1）使用类构造器实例化(默认无参数)</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bean1"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.itcast.spring.b_instance.Bean1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>2）使用静态工厂方法实例化(简单工厂模式)<br>下面这段配置的含义：调用Bean2Factory的getBean2方法得到bean2</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bean2"</span> </span><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">"cn.itcast.spring.b_instance.Bean2Factory"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"getBean2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>3）使用实例工厂方法实例化(工厂方法模式)<br>先创建工厂实例bean3Facory，再通过工厂实例创建目标bean实例</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bean3Factory"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.itcast.spring.b_instance.Bean3Factory"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bean3"</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"bean3Factory"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"getBean3"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><h2 id="Spring如何解决线程并发问题"><a href="#Spring如何解决线程并发问题" class="headerlink" title="Spring如何解决线程并发问题"></a>Spring如何解决线程并发问题</h2><p>在Spring中，绝大部分Bean都可以声明为singleton作用域（不是线程安全的），因为Spring对一些Bean中非线程安全状态采用<strong>ThreadLocal</strong>进行处理，解决线程安全问题。<br>ThreadLocal会为每个线程提供一个独立的变量副本，从而隔离多个线程对数据的访问冲突，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><ol><li>实例化：Spring对Bean进行实例化；</li><li>属性赋值：Spring将值和Bean的引用注入到Bean对应的属性中；</li><li>初始化：<ul><li>如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，此处传递的就是Spring配置文件中Bean的id值；</li><li>如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory(setBeanFactory(BeanFactory)传递的是Spring工厂自身（可以用这个方式来获取其它Bean，只需在Spring配置文件中配置一个普通的Bean就可以）；</li><li>如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文（同样这个方式也可以实现步骤4的内容，但比4更好，因为ApplicationContext是BeanFactory的子接口，有更多的实现方法）；</li><li>如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术；</li><li>如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。</li><li>如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法；</li></ul></li><li>销毁：当容器关闭时，调用Bean的销毁方法（A：使用配置文件指定的destroy-method属性；B：实现org.springframwork.bean.factory.DisposeableBean接口）</li></ol><p>注意：Spring 容器可以管理 singleton 作用域下 bean 的生命周期，在此作用域下，Spring 能够精确地知道bean何时被创建，何时初始化完成，以及何时被销毁。而<strong>对于 prototype 作用域的bean，Spring只负责创建</strong>，当容器创建了 bean 的实例后，bean 的实例就交给了客户端的代码管理，Spring容器将不再跟踪其生命周期，并且不会管理那些被配置成prototype作用域的bean的生命周期。  </p><h2 id="Bean生命周期方法"><a href="#Bean生命周期方法" class="headerlink" title="Bean生命周期方法"></a>Bean生命周期方法</h2><p>bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。相应的注解是@PostConstruct和@PreDestroy。</p><h2 id="Bean注入属性有几种方式？"><a href="#Bean注入属性有几种方式？" class="headerlink" title="Bean注入属性有几种方式？"></a>Bean注入属性有几种方式？</h2><p>接口注入、构造器注入、set注入。</p><h2 id="Component-和-Bean-有什么区别？"><a href="#Component-和-Bean-有什么区别？" class="headerlink" title="@Component 和 @Bean 有什么区别？"></a>@Component 和 @Bean 有什么区别？</h2><p>它们的作用对象不同：@Component 作用于类，而 @Bean 注解作用于方法。</p><p>@Component 通常是通过类路径扫描来自动侦测和装配对象到 Spring 容器中，比如 @ComponentScan 注解就是定义扫描路径中的类装配到 Spring 的 Bean 容器中；</p><p>@Bean 注解是告诉 Spring 这是某个类的实例，当我需要用它时把它给我，@Bean 注解比 @Component 注解自定义性更强，很多地方我们只能通过 @Bean 注解来注册 Bean，比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean 来实现。</p><h2 id="使用-Autowired注解自动装配的过程是怎样的？"><a href="#使用-Autowired注解自动装配的过程是怎样的？" class="headerlink" title="使用@Autowired注解自动装配的过程是怎样的？"></a>使用@Autowired注解自动装配的过程是怎样的？</h2><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config /&gt;。</p><p>在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p><ul><li>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</li><li>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</li><li>如果上述查找的结果为空，那么会抛出异常。解决方法是使用required=false。</li></ul><h1 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h1><p>@Required 注解有什么作用<br>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。示例：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@Required</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;        <span class="hljs-keyword">this</span>.name=name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> string <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;&#125;</code></pre></div><h2 id="Autowired和-Resource之间的区别"><a href="#Autowired和-Resource之间的区别" class="headerlink" title="@Autowired和@Resource之间的区别"></a>@Autowired和@Resource之间的区别</h2><p>@Autowired可用于：构造函数、成员变量、Setter方法<br>@Autowired和@Resource之间的区别</p><ul><li>@Autowired默认是按照<strong>类型</strong>装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</li><li>@Resource默认是按照<strong>名称</strong>来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</li></ul><h2 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h2><p>用来标识 http 请求地址与 Controller 类的方法之间的映射，可以注释到类上，也可以注释到方法上。</p><h1 id="Spring数据访问"><a href="#Spring数据访问" class="headerlink" title="Spring数据访问"></a>Spring数据访问</h1><h2 id="Spring-DAO有什么用"><a href="#Spring-DAO有什么用" class="headerlink" title="Spring DAO有什么用"></a>Spring DAO有什么用</h2><p>Spring DAO（数据访问对象）使得JDB、Hibernate或JDO这样的数据访问技术更容易以一种统一的方式工作，使得用户容易在持久层技术之间切换，而无需考虑捕获每种技术不同的异常。</p><h2 id="JdbcTemplate是什么"><a href="#JdbcTemplate是什么" class="headerlink" title="JdbcTemplate是什么"></a>JdbcTemplate是什么</h2><p>JdbcTemplate类提供了很多便利的方法解决诸如把数据库数据编程基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p><h2 id="Spring的事务管理"><a href="#Spring的事务管理" class="headerlink" title="Spring的事务管理"></a>Spring的事务管理</h2><p>事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。</p><p>Spring有自己的事务管理机制，一般是使用TransactionManager进行管理，可以通过Spring的注入来完成此功能，Spring提供了几个有关事务处理的类：</p><ul><li>TransactionDefinition：事务属性定义；</li><li>TransactionStatus：代表了当前事务，可以提交、回滚；</li><li>PlatformTransactionManager：Spring提供用于管理事务的基础接口，其下有一个实现的抽象类AbstractPlatformTransactionManager，我们使用的事务管理类如：DataSourceTransactionManager等都是这个类的子类。</li></ul><p>一般事务定义步骤：</p><div class="hljs"><pre><code class="hljs java">TransactionDefinition td = newTransactionDefinition();TransactionStatus ts = transactionManager.getTransaction(td);<span class="hljs-keyword">try</span>&#123;     <span class="hljs-comment">//do sth</span>    transactionManager.commit(ts);&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;    transactionManager.rollback(ts);&#125;</code></pre></div><h2 id="Spring支持的事务管理类型及其实现方式"><a href="#Spring支持的事务管理类型及其实现方式" class="headerlink" title="Spring支持的事务管理类型及其实现方式"></a>Spring支持的事务管理类型及其实现方式</h2><p>Spring支持两种类型的事务管理：</p><ul><li>编程式事务管理：通过编程的方式管理事务，灵活但难以维护；</li><li><strong>声明式事务管理</strong>：将业务代码和事务管理分离，只需用注解或xml配置文件来管理事务，非侵入性。</li></ul><p>声明式事务管理建立在AOP上，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或加入一个事务，执行完目标方法之后根据执行的情况进行提交或回滚。</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><ul><li>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，可以读到未提交的内容；</li><li>READ-COMMITTED(读取已提交)： 通过“快照读”的机制，保证只能读到已经提交的内容；</li><li>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，因为事务开启后，不允许进行“修改，删除”操作；</li><li>SERIALIZABLE(可串行化)：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，但是效率太差，性能开销也大，几乎不使用。</li></ul><h2 id="事务的传播属性"><a href="#事务的传播属性" class="headerlink" title="事务的传播属性"></a>事务的传播属性</h2><p>　<strong>PROPAGATION_REQUIRED</strong> – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。<br>　<strong>PROPAGATION_SUPPORTS</strong> – 支持当前事务，如果当前没有事务，就以非事务方式执行。<br>　<strong>PROPAGATION_MANDATORY</strong> – 支持当前事务，如果当前没有事务，就抛出异常。<br>　<strong>PROPAGATION_REQUIRES_NEW</strong> – 新建事务，如果当前存在事务，把当前事务挂起。<br>　<strong>PROPAGATION_NOT_SUPPORTED</strong> – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>　<strong>PROPAGATION_NEVER</strong> – 以非事务方式执行，如果当前存在事务，则抛出异常。<br>　<strong>PROPAGATION_NESTED</strong>–如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED</p><h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><p>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，用于<strong>将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块</strong>，这个模块被命名为“<strong>切面</strong>”（Aspect），以减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于<strong>权限认证</strong>、日志、事务处理等。AOP底层原理就是动态代理的实现。</p><h2 id="AOP的名词解释"><a href="#AOP的名词解释" class="headerlink" title="AOP的名词解释"></a>AOP的名词解释</h2><ul><li><strong>通知（Advice）</strong>：在切面的某个特定的连接点（Joinpoint）上执行的动作。通知有各种类型，其中包扩 “around”， “before” 和 “after”等通知。<br>通知的类型将在后面部分进行讨论。许多AOP框架，包括Spring，都是以拦截器做通知模型， 并维护一个以连接点为中心的拦截器链。</li><li><strong>连接点（JoinPoint）</strong>：Spring<strong>允许</strong>你使用通知的地方，一般是方法前后；</li><li><strong>切入点（Pointcut）</strong>：连接点是可以使用通知的地方，而切入点是你<strong>想要</strong>使用通知的地方；</li><li><strong>切面（Aspect）</strong>：<strong>通知</strong>和<strong>切入点</strong>的结合，通知说明了<strong>干什么和什么时候干</strong>（时间是通过方法名中的before、after、around等确定的），切入点说明了<strong>在哪干</strong>（指定使用通知的方法）；</li><li><strong>目标（target）</strong>：被通知的对象，也就是真正的业务逻辑，被通知的对象可以在毫不知情的情况下，被织入切面，而自己专注于业务本身的逻辑；</li><li><strong>织入（weaving）</strong>：把切面应用到目标对象来创建新的代理对象的过程；</li></ul><h2 id="Spring-AOP和AspectJ-AOP有什么区别"><a href="#Spring-AOP和AspectJ-AOP有什么区别" class="headerlink" title="Spring AOP和AspectJ AOP有什么区别"></a>Spring AOP和AspectJ AOP有什么区别</h2><p><strong>AOP实现的关键在于代理模式</strong>，AOP代理主要分为静态代理和动态代理，静态代理的代表是AspectJ，动态代理则有Spring AOP和CGLIB。<br>区别：</p><ul><li>AspectJ是静态代理的增强，AOP框架会在<strong>编译阶段</strong>生成AOP代理类，因此也称为编译时增强，它会在编译阶段将Aspect（切面）织入到Java字节码中，运行的时候就是增强后的AOP对象。</li><li>Spring AOP使用的动态代理，AOP框架不会去修改字节码，而是每次<strong>运行时</strong>在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</li></ul><p>静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说<strong>AspectJ的静态代理方式具有更好的性能</strong>，但是<strong>AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理</strong>。</p><h2 id="静态代理、JDK动态代理、CGLIB动态代理"><a href="#静态代理、JDK动态代理、CGLIB动态代理" class="headerlink" title="静态代理、JDK动态代理、CGLIB动态代理"></a>静态代理、JDK动态代理、CGLIB动态代理</h2><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>建一个接口，接口中定义相应（代理对象和目标对象都要实现）的方法。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Subject</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>目标类（实现上述接口）</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span></span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tset</span><span class="hljs-params">()</span></span>&#123;System.out.printin(<span class="hljs-string">"target method"</span>);&#125;&#125;</code></pre></div><p>代理类（实现上述接口）</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span></span>&#123;<span class="hljs-keyword">private</span> RealSubject realSubject;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Proxy</span><span class="hljs-params">(RealSubject realSubject)</span></span>&#123;<span class="hljs-keyword">this</span>.realSubject = realSubject;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        System.out.printin(<span class="hljs-string">"Before"</span>);        <span class="hljs-keyword">try</span>&#123;        realSubject.test();        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;            System.out.println(<span class="hljs-string">"ex:"</span>+e.getmessage());            <span class="hljs-keyword">throw</span> e;        &#125;<span class="hljs-keyword">finally</span>&#123;        System.out.println(<span class="hljs-string">"After"</span>);        &#125;    &#125;&#125;</code></pre></div><p>客户端调用</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        <span class="hljs-comment">//通过接口</span>        Subject subject = <span class="hljs-keyword">new</span> Proxy(<span class="hljs-keyword">new</span> RealSubject());        subject.test();    &#125;&#125;</code></pre></div><p>静态代理缺点：不灵活，<strong>重复代码多</strong>。静态代理的代表是AspectJ，AspectJ是静态代理的增强，AOP框架会在<strong>编译阶段</strong>生成AOP代理类，因此也称为<strong>编译时增强</strong>，它会在编译阶段将Aspect（切面）织入到Java字节码中，运行的时候就是增强后的AOP对象。</p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理只提供<strong>接口</strong>的代理，不支持类的代理，核心<code>InvocationHandler</code>接口和<code>Proxy</code>类，InvocationHandler 通过<code>invoke()</code>方法<strong>反射</strong>来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，<strong>Proxy利用 InvocationHandler动态创建一个符合某一接口的实例, 生成目标类的代理对象。</strong></p><ul><li><p>类：java.lang.reflect.Proxy（通过该类动态生成代理类）</p></li><li><p>代理类实现接口：InvocationHandler</p></li><li><p>JDK动态代理只能基于接口动态代理。</p></li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdkProxySubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span></span>&#123;    <span class="hljs-comment">//引入要代理的真实对象</span>    <span class="hljs-keyword">private</span> RealSubject realSubject;    <span class="hljs-comment">//用构造器注入目标方法，给我们要代理的真实对象赋初值</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JdkProxySubject</span><span class="hljs-params">(RealSubject realSubject)</span></span>&#123;    <span class="hljs-keyword">this</span>.realSubject=realSubject;    &#125;    <span class="hljs-comment">//实现接口的方法</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy,Method method,Object[] args)</span><span class="hljs-keyword">throws</span> Throwable</span>&#123;        System.out.println(<span class="hljs-string">"before"</span>);        Object result = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span>&#123;        <span class="hljs-comment">//调用目标方法</span>        <span class="hljs-comment">//利用反射构造目标对象</span>        <span class="hljs-comment">//当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span>        result=method.invoke(realSubject,args);        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;            System.out.println(<span class="hljs-string">"ex:"</span>+e.getMessage());            <span class="hljs-keyword">throw</span> e;         &#125;<span class="hljs-keyword">finally</span>&#123;        System.out.println(<span class="hljs-string">"after"</span>);        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre></div><p>客户端调用（使用Proxy）</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span></span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;    <span class="hljs-comment">//使用Proxy构造对象</span>    <span class="hljs-comment">//参数</span>    <span class="hljs-comment">//java泛型需要转换一下</span>    <span class="hljs-comment">/* 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数</span><span class="hljs-comment">    * 第一个参数 getClassLoader() ，我们这里使用Client这个类的ClassLoader对象来加载我们的代理对象</span><span class="hljs-comment">    * 第二个参数表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了</span><span class="hljs-comment">    * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上</span><span class="hljs-comment">    */</span>         Subject subject = (Subject) java.lang.reflect.Proxy.newProxyInstance(Client.class.getClassLoader(),new Class[]&#123;Subject.class&#125;,new JdkProxySubject(new RralSubject()));    <span class="hljs-comment">//调用方法</span>    subject.test;    &#125;&#125;</code></pre></div><h4 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h4><p>过程：调用Proxy.newProxyInstance生成代理类的实现类；</p><p>InvocationHandler接口：</p><p>每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个hadler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的invoke()方法来进行调用:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function">Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable</span>&#123;&#125;</code></pre></div><ul><li>proxy:　　指代我们所代理的那个真实对象</li><li>method:　指代的是我们所要调用真实对象的某个方法的Method对象</li><li>args:　　   指代的是调用真实对象某个方法时接受的参数</li></ul><p>Proxy类：</p><p>Proxy这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，我们经常使用的是newProxyInstance()这个方法，这个方法的作用是得到一个动态的代理对象，其接收三个参数：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">newProxyInstance</span><span class="hljs-params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException</span>&#123;&#125;</code></pre></div><ul><li>loader：一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载；</li><li>interfaces：一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口，这样我就能调用这组接口中的方法；</li><li>h：一个InvocationHandler对象，表示当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上。</li></ul><h3 id="CGLIB代理"><a href="#CGLIB代理" class="headerlink" title="CGLIB代理"></a>CGLIB代理</h3><p><strong>如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。</strong>CGLIB（Code Generation Library）是一个代码生成的类库，可以在运行时动态地生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过<strong>继承</strong>的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p><p>代理类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span></span>&#123;<span class="hljs-comment">//主要的方法拦截类，它是Callback接口的子接口，需要用户实现</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object obj,Method method,Object[] args,MethodProxy proxy )</span><span class="hljs-keyword">throws</span> Throwable</span>&#123;        System.out.println(<span class="hljs-string">"before cglib"</span>);        Object result = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span>&#123;            <span class="hljs-comment">//利用反射创建代理对象 </span>            result = proxy.invokeSuper(obj,args);        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;            System.out.println(<span class="hljs-string">"ex:"</span>+e.getMessage());            <span class="hljs-keyword">throw</span> e;        &#125;<span class="hljs-keyword">finally</span>&#123;        System.out.println(<span class="hljs-string">"after cglib"</span>);        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre></div><p>调用类：</p><div class="hljs"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        <span class="hljs-comment">// 主要的增强类</span>        Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();        <span class="hljs-comment">//  目标类 , 设置父类，被增强的类</span>        enhancer.setSuperclass(RealSubject<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-comment">// 回调对象</span>        enhancer.setCallback(<span class="hljs-keyword">new</span> CglibMethodInterceptor());        <span class="hljs-comment">//生成代理类对象，用cglibProxy来增强RealSubject</span>        Subject subject = enhancer.create();        subject.test();    &#125;&#125;</code></pre></div><h4 id="原理解析-1"><a href="#原理解析-1" class="headerlink" title="原理解析"></a>原理解析</h4><p>Cglib是一个优秀的动态代理框架，它的底层使用ASM在内存中动态的生成被代理类的子类，使用CGLIB即使代理类没有实现任何接口也可以实现动态代理功能。CGLIB具有简单易用，它的<strong>运行速度要远远快于JDK的Proxy动态代理</strong>：<br>CGLIB的核心类：</p><ul><li>net.sf.cglib.proxy.Enhancer – 主要的增强类</li><li>net.sf.cglib.proxy.MethodInterceptor – 主要的方法拦截类，它是Callback接口的子接口，需要用户实现</li><li>net.sf.cglib.proxy.MethodProxy – JDK的java.lang.reflect.Method类的代理类，可以方便的实现对源对象方法的调用,如使用：</li></ul><div class="hljs"><pre><code class="hljs java">Object o = methodProxy.invokeSuper(proxy, args);<span class="hljs-comment">//虽然第一个参数是被代理对象，也不会出现死循环的问题。</span></code></pre></div><h2 id="Spring通知类型"><a href="#Spring通知类型" class="headerlink" title="Spring通知类型"></a>Spring通知类型</h2><p>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中，代理封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean，当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。<br>Spring切面有5种类型的通知：</p><ul><li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li><li>后置通知（After）：在目标方法完成之后调用通知，不关心方法的输出结果；</li><li>返回通知（After-returning）：在目标方法成功执行之后调用通知；</li><li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li><li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li></ul>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
      <category>Spring框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库</title>
    <link href="/2020/07/07/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2020/07/07/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库基础知识"><a href="#数据库基础知识" class="headerlink" title="数据库基础知识"></a>数据库基础知识</h1><h2 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a>什么是SQL？</h2><p>结构化查询语言（Structured Query Language）：数据查询语言，用于存取数据、查询、更新和管理关系数据库系统。</p><h2 id="数据库三大范式："><a href="#数据库三大范式：" class="headerlink" title="数据库三大范式："></a>数据库三大范式：</h2><p>第一范式：每个列都不可再拆分；<br>第二范式：在第一范式的基础上，非主键列<strong>完全</strong>依赖于主键，而不能依赖于主键的一部分；<br>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键；</p><p>2NF：非主键列是否完全依赖于主键，还是依赖于主键的一部分；3NF：非主键列是直接依赖于主键，还是直接依赖于非主键列。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p><strong>整数类型</strong>，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。</p><p><strong>int(20)表示显示字符的长度为20，但是仍占4个字节存储。</strong></p><h2 id="char与varchar的区别"><a href="#char与varchar的区别" class="headerlink" title="char与varchar的区别"></a>char与varchar的区别</h2><p>char的特点：</p><ul><li>char表示定长字符串，长度固定；</li><li>如果插入数据的长度小于char的固定长度时，则用空格填充；（存取快）</li><li>最多能存放的字符个数为255</li></ul><p>varchar的特点：</p><ul><li>可变长字符串；</li><li>插入的数据有多长，就按照多长来存储；（存取慢）</li><li>最多能存放的字符个数为65536</li><li>varchar(50）表示最多存放50个字符</li></ul><p><strong>日期和时间类型</strong>，尽量使用timestamp，空间效率高于datetime，<br>用整数保存时间戳通常不方便处理。<br>如果需要存储微秒，可以使用bigint存储。</p><h1 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h1><h2 id="MySQL存储引擎MyISAM与InnoDB区别"><a href="#MySQL存储引擎MyISAM与InnoDB区别" class="headerlink" title="MySQL存储引擎MyISAM与InnoDB区别"></a>MySQL存储引擎MyISAM与InnoDB区别</h2><p>存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</p><ul><li>InnoDB：InnoDB存储引擎提供了对数据库ACID的支持，具有提交、回滚和崩溃恢复能力的事务安全存储引擎，主索引是<strong>聚簇索引</strong>，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。并且还提供了行级锁和外键的约束，支持哈希索引，不支持全文索引。它的设计目标就是处理大数据容量的数据库系统。</li><li>MyISAM：<strong>不提供事务的支持</strong>，<strong>表级锁</strong>，不支持行级锁和外键，支持全文索引，不支持哈希索引，适合一些CMS（内容管理系统）作为后台数据库使用，但是使用大并发、重负荷生产系统上，显得力不从心。</li></ul><p><strong>比较</strong></p><ul><li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li><li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li><li>外键：InnoDB 支持外键。</li><li>备份：InnoDB 支持在线热备份。</li><li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li><li>其它特性：MyISAM 支持压缩表和空间数据索引。<br><img src="https://img-blog.csdnimg.cn/20200706155336383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><blockquote><p><strong>ACID事务：</strong></p><ul><li>原子性（事务是一个不可分割的工作单位，事务中的操作要么都发生、要么都不发生）；</li><li>一致性（事务前后数据的完整性必须保持一致）；</li><li>隔离性（多个用户并发访问数据库时，数据库为每个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离）；</li><li>持久性（一个事务一旦被提交，它对数据库中的数据的改变是永久性的，接下来即使数据库发生故障，也不应该对其有任何影响）</li></ul></blockquote></li></ul><h2 id="InnoDB引擎的4大特性"><a href="#InnoDB引擎的4大特性" class="headerlink" title="InnoDB引擎的4大特性"></a>InnoDB引擎的4大特性</h2><ul><li><strong>插入缓存</strong>：每次插入先判断插入的非聚集索引页是否存在缓存池中，如果在则直接插入，如果不在，先放到Buffer中，再按照一定的频率进行合并操作，将多个插入合并到一个操作中，目的是为了<strong>减少随机IO带来性能损耗</strong>；</li><li><strong>二次写（doublewrite）</strong>：<br><img src="https://img-blog.csdnimg.cn/20200706103052907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>doublewrite用来缓存InnoDB的数据页从InnoDB buffer pool中flush之后并写入到数据文件之前，所以当操作系统或者数据库进程在数据页写到磁盘的过程中崩溃，InnoDB可以从doublewrite缓存中找到数据页的备份而执行crash恢复。</li><li><strong>自适应哈希索引</strong>：InnoDB存储引擎会监控二级索引的查找，如果发现某二级索引被频繁访问，二级索引会成为热数据，建立哈希索引来提高访问速度，自适应哈希索引通过缓存池的B+树构造。</li><li><strong>预读</strong>：分为线性预读和随机预读，线性预读着眼于将下一个extent提前读取到buffer pool中，而随机预读着眼于将当前extent中的剩余的page提前读取到buffer pool中。</li></ul><h2 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h2><p>默认使用InnoDB</p><ul><li>MyISAM：以读写插入为主的应用程序，如：博客系统、新闻门户网站；</li><li>InnoDB：更新（删除）操作频率高的场合，或者要保证数据的完整性，并发量高，要求支持事务和外键，比如OA（自动化办公系统）。</li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>索引是一种特殊的文件（相当于目录，不过占用物理空间），包含着对数据表中所有记录的引用指针，是数据库管理系统中一个排序的数据结构，以协调快速查询、更新数据库表中数据。<strong>索引的实现通常是B树或变种的B+树</strong>。</p><h2 id="索引的使用场景（重点）"><a href="#索引的使用场景（重点）" class="headerlink" title="索引的使用场景（重点）"></a>索引的使用场景（重点）</h2><p><strong>where</strong></p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">-- 增加一个没有建立索引的字段</span><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> innodb1 <span class="hljs-keyword">add</span> sex <span class="hljs-built_in">char</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">-- 按sex检索时可选的索引为null</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">from</span> innodb1 <span class="hljs-keyword">where</span> sex=<span class="hljs-string">'男'</span>;</code></pre></div><p><strong>order by</strong><br>对没有建立索引的字段使用order by排序时，会将查询到的所有数据使用外部排序，这个操作是很影响性能的，因为需要将查询涉及到所有数据从磁盘中读到内存。<br>如果该字段有建立索引，由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用取出索引表某个范围内的索引对应的数据，而不用取出所有数据进行排序再返回某个范围内的数据。</p><p><strong>join</strong><br>对join语句匹配关于（on）涉及的字段建立索引能够提高效率。</p><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p><strong>普通索引：</strong>基本的索引类型，没有唯一性的限制，允许为NULL</p><ul><li><code>ALTER TABLE table_name ADD INDEX index_name (column);</code>创建普通索引</li><li><code>ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);</code>创建组合索引</li></ul><p><strong>唯一索引：</strong>数据列不允许重复，允许为NULL，一个表允许多个列创建唯一索引；</p><ul><li><code>ALTER TABLE table_name ADD UNIQUE (column);</code>创建唯一索引</li><li><code>ALTER TABLE table_name ADD UNIQUE (column1,column2);</code>创建唯一组合索引</li></ul><p><strong>主键索引：</strong>数据列不允许重复，不允许为NULL，一个表只能有一个主键；</p><p><strong>全文索引：</strong>（InnoDB不支持）</p><ul><li><code>ALTER TABLE table_name ADD FULLTEXT (column);</code></li></ul><h2 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h2><p>把无序的数据变成有序的查询。</p><ol><li>把创建了索引的列的内容进行排序</li><li>对排序结果生成倒排表</li><li>在倒排表内容上拼上数据地址链</li><li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li></ol><h2 id="创建索引的原则（非常重要）"><a href="#创建索引的原则（非常重要）" class="headerlink" title="创建索引的原则（非常重要）"></a>创建索引的原则（非常重要）</h2><ol><li>对于查询频率高的字段创建索引；</li><li>对排序、分组、联合查询频率高的字段创建索引；</li><li>索引的数目不宜太多（占用物理内存）；</li><li>如果需要将多个列设置索引时，可以采用多列索引；</li><li>选择唯一性索引（id）；</li><li>尽量使用数据量少的索引（char的类型）；</li><li>尽量使用前缀索引；</li><li>删除不再使用或者很少使用的索引；</li><li>对于定义为text、image和bit的数据类型的列不要建立索引；</li></ol><blockquote><p><strong>前缀索引</strong><br>语法：index(field(10))<br>前提：前缀的标识度高</p></blockquote><h2 id="创建索引的三种方式"><a href="#创建索引的三种方式" class="headerlink" title="创建索引的三种方式"></a>创建索引的三种方式</h2><p>第一种方式：在执行<code>CREATE TABLE</code>时创建索引</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user_index2 (<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> auto_increment PRIMARY <span class="hljs-keyword">KEY</span>,first_name <span class="hljs-built_in">VARCHAR</span> (<span class="hljs-number">16</span>),last_name <span class="hljs-built_in">VARCHAR</span> (<span class="hljs-number">16</span>),id_card <span class="hljs-built_in">VARCHAR</span> (<span class="hljs-number">18</span>),information <span class="hljs-built_in">text</span>,<span class="hljs-keyword">KEY</span> <span class="hljs-keyword">name</span> (first_name, last_name),FULLTEXT <span class="hljs-keyword">KEY</span> (information),<span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">KEY</span> (id_card));</code></pre></div><p>第二种方式： 使用<code>ALTER TABLE</code>命令去增加索引</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> index_name (column_list);</code></pre></div><p>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p><p>第三种方式：使用<code>CREATE INDEX</code>命令创建</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function">CREATE INDEX index_name ON <span class="hljs-title">table_name</span> <span class="hljs-params">(column_list)</span></span>;</code></pre></div><p>CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</p><h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><p>根据索引名删除普通索引、唯一索引、全文索引：<code>alter table 表名 drop KEY 索引名</code></p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> user_index <span class="hljs-keyword">drop</span> <span class="hljs-keyword">KEY</span> <span class="hljs-keyword">name</span>;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> user_index <span class="hljs-keyword">drop</span> <span class="hljs-keyword">KEY</span> id_card;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> user_index <span class="hljs-keyword">drop</span> <span class="hljs-keyword">KEY</span> information;</code></pre></div><p>注意：如果主键自增长，那么需要先取消自增长再删除：（通常不会删除主键，因为设计主键一定要与业务逻辑无关）</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> user_index<span class="hljs-comment">-- 重新定义字段</span><span class="hljs-keyword">MODIFY</span> <span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span>,<span class="hljs-keyword">drop</span> PRIMARY <span class="hljs-keyword">KEY</span></code></pre></div><h2 id="Hash索引和B-树索引的区别"><a href="#Hash索引和B-树索引的区别" class="headerlink" title="Hash索引和B+树索引的区别"></a>Hash索引和B+树索引的区别</h2><p>hash索引底层就是hash表，进行查找时，调用一次hash函数就能获得相应的键值，之后进行回表查询获得实际数据。<br>B+树底层实现是<strong>多路平衡查找树</strong>，对于每次查询都是从根节点出发，查找到叶子结点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。<br><strong>区别：</strong></p><ul><li>hash索引进行等值查询更快，但是<strong>无法进行范围查询</strong>（hash函数的不可预测性）</li><li>hash索引不支持使用索引进行排序</li><li>hash索引不支持模糊查询以及多列索引的最左前缀匹配</li><li>hash索引任何时候都避免不了<strong>回表查询</strong></li><li>hash索引虽然在<strong>等值查询上较快</strong>，但是<strong>不稳定</strong>，<strong>性能不可预测</strong>，当某个键值存在大量重复的时候，发生<strong>hash碰撞</strong>，此时效率可能极差。<h2 id="数据库为什么使用B-树而不是B树"><a href="#数据库为什么使用B-树而不是B树" class="headerlink" title="数据库为什么使用B+树而不是B树"></a>数据库为什么使用B+树而不是B树</h2></li><li><strong>B树只适合随机检索</strong>，而B+树同时支持随机检索和<strong>顺序检索</strong>；</li><li>B+树<strong>空间利用率更高</strong>，可减少I/O次数，磁盘读写代价更低；</li><li>B+树的<strong>查询效率更加稳定</strong>；</li><li>B+树的叶子结点使用指针顺序连接在一起，只要<strong>遍历叶子结点就可以实现整棵树的遍历</strong>；</li><li>增删文件时，效率更高。<h2 id="数据库为什么不使用红黑树实现索引？"><a href="#数据库为什么不使用红黑树实现索引？" class="headerlink" title="数据库为什么不使用红黑树实现索引？"></a>数据库为什么不使用红黑树实现索引？</h2>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：<br>（一）更少的查找次数<br>平衡树查找操作的时间复杂度和<strong>树高 h</strong> 相关，O(h)=O(logdN)，其中 d 为每个节点的<strong>出度</strong>。<br>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。<br>（二）利用磁盘预读特性<br>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，速度会非常快。<br>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以<strong>页</strong>为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。<h2 id="什么是聚簇索引？"><a href="#什么是聚簇索引？" class="headerlink" title="什么是聚簇索引？"></a>什么是聚簇索引？</h2></li><li>聚簇索引：将数据存储与索引放到一起，找到索引也就找到了数据；</li><li>非聚簇索引：将数据存储与索引分开。</li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="什么是数据库事务"><a href="#什么是数据库事务" class="headerlink" title="什么是数据库事务"></a>什么是数据库事务</h2><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行结果必须使数据库从一种一致性状态变到另一种一致性状态，事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><h2 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h2><ul><li>原子性：事务是最小的执行单元，不允许分割，事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li>一致性：执行事务前后，数据的完整性保持一致，比如转账前后金额总数不变。</li><li>隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li>持久性：一个事务被提交之后，它对数据库中数据的改变是持久的；</li></ul><h2 id="什么是脏读？不可重复读？幻读？"><a href="#什么是脏读？不可重复读？幻读？" class="headerlink" title="什么是脏读？不可重复读？幻读？"></a>什么是脏读？不可重复读？幻读？</h2><ul><li>脏读：一个事务读取了另一个事务未提交的数据操作结果；</li><li>不可重复读：事务 T1 读取某一数据后，事务 T2 对其做了修改，当事务 T1 再次读该数据时得到与前一次不同的值。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</li><li>幻读：事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据或者缺少了第一次查询中出现的数据。</li></ul><p>不可重复读和幻读的区别：不可重复读的重点是<strong>修改</strong>，幻读的重点在于新增或是删除。</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><ul><li>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，可以读到未提交的内容；</li><li>READ-COMMITTED(读取已提交)： 通过“快照读”的机制，保证只能读到已经提交的内容；</li><li>REPEATABLE-READ(可重复读)：  对同一字段的多次读取结果都是一致的，因为事务开启后，不允许进行“修改，删除”操作；</li><li>SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，但是效率太差，性能开销也大，几乎不使用。</li></ul><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="数据库中为什么会有锁"><a href="#数据库中为什么会有锁" class="headerlink" title="数据库中为什么会有锁"></a>数据库中为什么会有锁</h2><p>当数据库有并发访问事务的时候，可能会产生数据的不一致，这时候需要一些机制（锁）来保证访问的次序。</p><h2 id="隔离级别和锁的关系"><a href="#隔离级别和锁的关系" class="headerlink" title="隔离级别和锁的关系"></a>隔离级别和锁的关系</h2><ul><li>READ-UNCOMMITTED(读取未提交)： 读取数据不需要加共享锁；</li><li>READ-COMMITTED(读取已提交)： 读操作需要加共享锁，但是在语句执行完以后释放共享锁；</li><li>REPEATABLE-READ(可重复读)：读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须<strong>等待事务执行完毕以后才释放共享锁</strong>；</li><li>SERIALIZABLE(可串行化)：锁定整个范围的键，并且一直持有锁，直到事务完成。</li></ul><h2 id="按照锁的粒度分数据库锁有哪些？"><a href="#按照锁的粒度分数据库锁有哪些？" class="headerlink" title="按照锁的粒度分数据库锁有哪些？"></a>按照锁的粒度分数据库锁有哪些？</h2><p>MyISAM和InnoDB存储引擎使用的锁：</p><ul><li>MyISAM采用表级锁(table-level locking)。</li><li>InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</li></ul><p><strong>行级锁</strong>：行级锁是MySQL中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁，行级锁能大大减少数据库操作的冲突，其加锁粒度最小，但加锁的开销也最大，行级锁分为共享锁（读锁）和排他锁（写锁）。<br>特点：<strong>开销大</strong>，加锁慢，会出现<strong>死锁</strong>；发生锁冲突的概率最低，并发度也最高；</p><p><strong>表级锁</strong>：MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持，最常使用的MyISAM和InnoDB都支持表级锁定，表级锁定分为共享锁和排他锁。<br>特点：开销小，加锁快，不会出现死锁，锁定粒度大，出现锁冲突的概率最高，并发度最小。</p><p><strong>页级锁</strong>：介于两者之间</p><h2 id="行级锁的实现"><a href="#行级锁的实现" class="headerlink" title="行级锁的实现"></a>行级锁的实现</h2><p>InnoDB是基于索引来完成行级锁</p><h2 id="什么是死锁，产生死锁的必要条件，如何解决死锁"><a href="#什么是死锁，产生死锁的必要条件，如何解决死锁" class="headerlink" title="什么是死锁，产生死锁的必要条件，如何解决死锁"></a>什么是死锁，产生死锁的必要条件，如何解决死锁</h2><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p><p>产生死锁的必要条件：<br>1、互斥使用：即当资源被一个线程使用时，其他线程无法使用；<br>2、不可抢占：资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放；<br>3、请求与保持：当资源请求者在请求其他的资源的同时保持对原有资源的占有。<br>4、循环等待：即存在一个等待队列，P1占有P2的资源，P2占有P3的资源，P3占有P1的资源，这样就形成了等待环路。</p><p>解决死锁的方法：<br>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会；<br>2、在同一个事务中，尽量做到一次锁定所需要的所有资源，减少死锁产生的概率；<br>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p><h1 id="视图（View）"><a href="#视图（View）" class="headerlink" title="视图（View）"></a>视图（View）</h1><h2 id="什么是视图？为什么要用视图？"><a href="#什么是视图？为什么要用视图？" class="headerlink" title="什么是视图？为什么要用视图？"></a>什么是视图？为什么要用视图？</h2><p>视图本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值形式存在。行和列数据来自定义视图的查询索引用基本表，并且在具体引用视图时动态生成。</p><p>视图使开发者只关心感性的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。</p><ol><li>创建表</li></ol><div class="hljs"><pre><code class="hljs sql">mysql&gt; CREATE TABLE t (qty INT, price INT);Query OK, 0 rows affected (0.09 sec)mysql&gt; INSERT INTO t VALUES(3, 50), (5, 60);Query OK, 2 rows affected (0.01 sec)Records: 2  Duplicates: 0  Warnings: 0mysql&gt; SELECT * FROM t;+<span class="hljs-comment">------+-------+</span>| qty  | price |+<span class="hljs-comment">------+-------+</span>|    3 |    50 ||    5 |    60 |+<span class="hljs-comment">------+-------+</span>2 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre></div><ol start="2"><li>创建视图</li></ol><div class="hljs"><pre><code class="hljs sql">mysql&gt; CREATE VIEW v AS SELECT qty, price, qty*price AS value FROM t;Query OK, 0 rows affected (0.01 sec)</code></pre></div><ol start="3"><li>查看视图</li></ol><div class="hljs"><pre><code class="hljs sql">mysql&gt; SELECT * FROM v;+<span class="hljs-comment">------+-------+-------+</span>| qty  | price | value |+<span class="hljs-comment">------+-------+-------+</span>|    3 |    50 |   150 ||    5 |    60 |   300 |+<span class="hljs-comment">------+-------+-------+</span>2 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)对于视图的查询也可以加上过滤条件:mysql&gt; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> v <span class="hljs-keyword">WHERE</span> qty = <span class="hljs-number">5</span>;+<span class="hljs-comment">------+-------+-------+| qty  | price | value |+------+-------+-------+|    5 |    60 |   300 |+------+-------+-------+1 row in set (0.00 sec)</span></code></pre></div><ol start="4"><li>查看当前库下的所有视图</li></ol><div class="hljs"><pre><code class="hljs sql">mysql&gt; show full tables where table_type like 'VIEW';+<span class="hljs-comment">----------------+------------+</span>| Tables_in_test | Table_type |+<span class="hljs-comment">----------------+------------+</span>| v              | VIEW       || vw_01          | VIEW       |+<span class="hljs-comment">----------------+------------+</span>2 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre></div><ol start="5"><li>基于其他的视图来创建视图</li></ol><div class="hljs"><pre><code class="hljs sql">mysql&gt; select * from vw_01;  #vw_01是一个视图.+<span class="hljs-comment">---+------+</span>| a | b    |+<span class="hljs-comment">---+------+</span>| 1 | NULL || 2 | NULL || 3 | NULL || 4 | NULL |+<span class="hljs-comment">---+------+</span>4 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)mysql&gt; <span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> v01 <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> a,b <span class="hljs-keyword">from</span> vw_01;  <span class="hljs-comment">#基于视图来创建视图,也就是说,视图定义中的SELECT查询的是另外的视图.</span>Query OK, 0 rows affected (0.02 sec)mysql&gt; select * from v01;+<span class="hljs-comment">---+------+</span>| a | b    |+<span class="hljs-comment">---+------+</span>| 1 | NULL || 2 | NULL || 3 | NULL || 4 | NULL |+<span class="hljs-comment">---+------+</span>4 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre></div><h2 id="什么是游标"><a href="#什么是游标" class="headerlink" title="什么是游标"></a>什么是游标</h2><p>游标是系统为用户开设的一个数据缓冲区，<strong>存放SQL语句的执行结果</strong>，它可以定位到结果集中的某一行，对数据进行读写，也可以移动游标定位到你需要的行进行数据操作，是面向集合的数据库管系统和面向行的程序设计之间的桥梁。</p><h1 id="存储过程与函数"><a href="#存储过程与函数" class="headerlink" title="存储过程与函数"></a>存储过程与函数</h1><h2 id="什么是存储过程，有什么优缺点？"><a href="#什么是存储过程，有什么优缺点？" class="headerlink" title="什么是存储过程，有什么优缺点？"></a>什么是存储过程，有什么优缺点？</h2><p>存储过程是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，存储在数据库中，经过第一次编译后再次调用时不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。</p><p><strong>优点：</strong></p><ol><li>预编译过、执行效率高；</li><li>代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯；</li><li>安全性高，执行存储过程需要有一定权限的用户；</li><li>存储过程可以重复使用，减少数据库开发人员的工作量</li></ol><p><strong>缺点：</strong><br>1、调试麻烦<br>2、移植问题<br>3、重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译</p><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><h2 id="什么是触发器，触发器的使用场景有哪些？"><a href="#什么是触发器，触发器的使用场景有哪些？" class="headerlink" title="什么是触发器，触发器的使用场景有哪些？"></a>什么是触发器，触发器的使用场景有哪些？</h2><p>触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程，触发器是指一段代码，当触发某个事件时，自动执行这些代码。<br>使用场景：</p><ul><li>可以通过 数据库中的相关表实现级联更改；</li><li>实时监控某张表中的某个字段的更改而需要做出相应的处理；</li><li>生成某些业务的编号；</li></ul><h1 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h1><h2 id="SQL语句主要分为哪几类"><a href="#SQL语句主要分为哪几类" class="headerlink" title="SQL语句主要分为哪几类"></a>SQL语句主要分为哪几类</h2><p>数据定义语言DDL：CREATE、DROP、ALTER(修改)<br>数据查询语言DQL：SELECT<br>数据操纵语言DML：INSERT、UPDATE、DELETE<br>数据控制功能DCL：GRANT、REVOKE、COMMIT、ROLLBACK</p><h2 id="超键、候选键、主键、外键分别是什么"><a href="#超键、候选键、主键、外键分别是什么" class="headerlink" title="超键、候选键、主键、外键分别是什么"></a>超键、候选键、主键、外键分别是什么</h2><ul><li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键，一个属性可以作为一个超键，多个属性组合在一起可以作为一个超键，超键包含候选键和主键。</li><li>候选键：是最小超键，即没有冗余元素的超键</li><li>主键：数据库表中对存储数据对象予以唯一和完整标识的数据的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）；</li><li>外键：在一个表中存在的另一个表的主键称为此表的外键。</li></ul><h2 id="SQL约束有哪几种"><a href="#SQL约束有哪几种" class="headerlink" title="SQL约束有哪几种"></a>SQL约束有哪几种</h2><ul><li>NOT NULL：非空</li><li>UNIQUE：不能重复</li><li>PRIMARY KEY：不能重复，且在表中只允许出现一次；</li><li>FOREIGN KEY：预防破坏表之间连接的动作，也能防止非法数据插入外键列；</li><li>CHECK：控制字段的值范围</li></ul><h2 id="五种关联查询"><a href="#五种关联查询" class="headerlink" title="五种关联查询"></a>五种关联查询</h2><ul><li>内连接（INNER JOIN）</li><li>外连接（LEFT JOIN/RIGHT JOIN）</li><li>联合查询（UNION与UNION ALL）</li><li>全连接（FULL JOIN）</li><li>交叉连接（CROSS JOIN）</li></ul><p><strong>内连接</strong>：多表中同时符合某种条件的数据记录的集合</p><div class="hljs"><pre><code class="hljs java">①等值连接: on a.id = b.id②不等值连接 : on a.id &gt; b.id③自连接: select * from a as a1 inner join a as a2 on a.id = a2.pid[自连接就是自己连接自己 条件id和pid]</code></pre></div><blockquote><p>INNER JOIN 可以缩写为 JOIN</p></blockquote><p><strong>外连接</strong>：</p><ul><li>左外连接： 以左表为主,先查询出左表,按照ON之后关联条件匹配右表,没有匹配到的用NULL填充</li><li>右外连接： 以右表为主,先查询出右表,按照ON之后关联条件匹配左表,没有匹配到的用NULL填充</li></ul><p><strong>联合查询</strong>：</p><div class="hljs"><pre><code class="hljs java">SELECT * FROM A UNION SELECT * FROM B UNION ...</code></pre></div><p>将多个结果集集中在一起，UNION前的结果为基准，注意的是联合查询的列数要相等， 相同的记录行会合并，如果使用UNION ALL，不会合并重复的记录行，效率方面UNION ALL高于UNION。</p><p><strong>全连接</strong><br>MySQL不支持全连接</p><p><strong>交叉连接</strong><br><code>SELECT * FROM A,B(,C)</code>或者<code>SELECT * FROM A CROSS JOIN B (CROSS JOIN C)</code><br>没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用交叉连接</p><h2 id="什么是子查询"><a href="#什么是子查询" class="headerlink" title="什么是子查询"></a>什么是子查询</h2><ol><li>条件：一条SQL语句的查询结果作为另一条查询语句的条件或查询结果</li><li>嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询</li></ol><h2 id="MySQL中in和exists区别"><a href="#MySQL中in和exists区别" class="headerlink" title="MySQL中in和exists区别"></a>MySQL中in和exists区别</h2><p><strong>exists</strong><br>exists关键字后面的参数是一个任意的子查询，系统对子查询进行运算以<strong>判断它是否返回行</strong>，如果至少返回一行，那么exists的结果为true，此时外层的查询语句将进行查询；如果子查询没有返回任何行，那么exists的结果为false，此时外层语句将不进行查询。</p><p><strong>in</strong><br>in关键字进行子查询时，内存查询语句仅仅<strong>返回一个数据列</strong>，这个数据列的值将提供给外层查询语句进行比较操作。</p><p>注意：外层查询表小于子查询表，用exists，外层循环表大于子循环表，用in，如果外层循环表跟子查询表差不多，无所谓。</p><h2 id="UNION和UNION-ALL的区别"><a href="#UNION和UNION-ALL的区别" class="headerlink" title="UNION和UNION ALL的区别"></a>UNION和UNION ALL的区别</h2><ul><li>使用UNION ALL，不会合并重复的记录行</li><li>UNION ALL的效率要高于UNION</li></ul><h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h2 id="如何定位及优化SQL语句的性能问题？"><a href="#如何定位及优化SQL语句的性能问题？" class="headerlink" title="如何定位及优化SQL语句的性能问题？"></a>如何定位及优化SQL语句的性能问题？</h2><p>对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用<strong>执行计划</strong>，MySQL提供了<code>explain</code>命令来查看语句的执行计划，<strong>对于查询语句，最重要的优化方式就是使用索引</strong>，而<strong>执行计划，就是显示数据库引擎对SQL语句的执行情况</strong>，其中包括：是否使用索引，使用什么索引，使用的索引的相关信息等。</p><h2 id="SQL的生命周期"><a href="#SQL的生命周期" class="headerlink" title="SQL的生命周期"></a>SQL的生命周期</h2><ul><li>应用服务器与数据库服务器建立一个连接</li><li>数据库进程拿到请求sql</li><li>解析并生成执行计划，执行</li><li>读取数据到内存并进行逻辑处理</li><li>通过步骤一的连接，发送结果到客户端</li><li>关闭连接，释放资源<br><img src="https://img-blog.csdnimg.cn/20200707095337285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><h2 id="超大分页如何处理"><a href="#超大分页如何处理" class="headerlink" title="超大分页如何处理"></a>超大分页如何处理</h2>解决超大分页主要依靠缓存，可预测性的提前查到内容，缓存至Redis等k-v数据库中，直接返回即可。</li></ul><h2 id="LIMIT（分页）"><a href="#LIMIT（分页）" class="headerlink" title="LIMIT（分页）"></a>LIMIT（分页）</h2><p>LIMIT子句可以被用于强制SELECT语句返回指定的记录数，LIMIT接受一个或两个数字参数，第一个参数指定第一个返回记录行等待偏移量，第二个参数指定返回记录行的最大数目，初始记录行的偏移量是0。</p><div class="hljs"><pre><code class="hljs sql">mysql&gt; SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15</code></pre></div><p>为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：</p><div class="hljs"><pre><code class="hljs sql">mysql&gt; SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.</code></pre></div><p>在需要排序的列后面加上<code>DESC</code>，表示是倒序排列。</p><h2 id="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"><a href="#关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？" class="headerlink" title="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"></a>关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</h2><blockquote><p>慢查询日志：<br>用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。<br>开启慢查询日志：set GLOBAL slow_query_log = on<br>设置临界时间：set long_query_time=0.5</p></blockquote><p>慢查询优化：</p><ul><li>首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了需要结果并不需要的列，对语句进行分析以及重写；</li><li>分析语句的执行计划，获得其索引的使用情况，看能否通过修改语句或索引，来提高索引命中率；</li><li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，看能否进行分表。</li></ul><h2 id="主键使用自增ID还是UUID"><a href="#主键使用自增ID还是UUID" class="headerlink" title="主键使用自增ID还是UUID"></a>主键使用自增ID还是UUID</h2><p>推荐使用自增ID，性能上更好，如果使用UUID，可能会造成非常多的数据插入，数据移动，然后会产生很多内存碎片，造成插入性能的下降。</p><h2 id="字段值为什么要求定义为not-null"><a href="#字段值为什么要求定义为not-null" class="headerlink" title="字段值为什么要求定义为not null"></a>字段值为什么要求定义为not null</h2><p>null值会占用更多的字节，且会在程序中造成很多与预期不符的情况</p><h2 id="如果要存储用户的密码散列，应该使用什么字段进行存储"><a href="#如果要存储用户的密码散列，应该使用什么字段进行存储" class="headerlink" title="如果要存储用户的密码散列，应该使用什么字段进行存储"></a>如果要存储用户的密码散列，应该使用什么字段进行存储</h2><p>密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</p><h1 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h1><h2 id="为什么要优化"><a href="#为什么要优化" class="headerlink" title="为什么要优化"></a>为什么要优化</h2><ul><li><p>系统的吞吐量瓶颈往往出现在数据库的访问速度上；</p></li><li><p>随着应用程序的运行，数据库中的数据会越来越多，处理时间相应变慢；</p></li><li><p>数据是存放在磁盘上的，读写速度无法和内存比</p><h2 id="面试题：给我说说平时是如何优化MySQL的？"><a href="#面试题：给我说说平时是如何优化MySQL的？" class="headerlink" title="面试题：给我说说平时是如何优化MySQL的？"></a>面试题：给我说说平时是如何优化MySQL的？</h2><ol><li><strong>explain</strong><br>在MySQL优化的时候，使用<strong>explain</strong>查看SQL的执行计划<br><img src="https://img-blog.csdnimg.cn/20200804091529648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200804091629670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></li><li><strong>SQL语句中IN包含的值不应过多</strong><br>MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。建议对于连续的数值，能用between就不要用in，再或者使用连接来替换。</li><li><strong>SELECT语句务必指明字段名称</strong><br>SELECT *增加很多不必要的消耗（cpu、io、内存、网络带宽）；<br>增加了使用覆盖索引的可能性；</li><li><strong>当只需要一条数据的时候，使用limit1</strong><br>这是为了使EXPLAIN中type列达到const类型</li><li><strong>如果排序字段没有用到索引，就尽量少排序</strong></li><li><strong>如果限制条件中其他字段没有索引，尽量少用or</strong></li><li><strong>尽量使用union all代替union</strong><br>union和union all的差异主要是前者需要将结果集合并后再进行唯一性过滤操作；<br>这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟。<br>当然，union all的前提条件是两个结果集没有重复数据。</li><li><strong>不使用order by rand()</strong></li><li><strong>分区in和exists</strong><br>in 适合于外表大而内表小的情况。exists适合于外表小而内表大的情况。   </li><li><strong>区分not in 和 not exists</strong><br>推荐使用not exists，不仅仅是效率问题，not in可能存在逻辑问题。</li><li><strong>使用合理的分页以提高分页效率</strong></li><li><strong>分段查询</strong></li><li><strong>避免在where字句中对字段进行null值判断</strong></li><li><strong>不建议使用%前缀模糊查询</strong><br>例如：LIKE “%name”或者LIKE “%name%”；<br>这种查询会导致索引失效而进行全表扫描；但是可以使用LIKE “name%”。</li><li><strong>避免在where子句中对字段进行表达式操作</strong></li><li><strong>避免隐式类型转换</strong></li><li><strong>对于联合索引来说，要遵守最左前缀法则</strong> </li><li><strong>必要时可以使用force index来强制查询某个索引</strong></li><li><strong>注意范围查询语句</strong></li><li><strong>关于JOIN优化</strong><br>LEFT JOIN A表为驱动表<br>INNER JOIN MySQL会自动找出那个数据少的表作用驱动表<br>RIGHT JOIN B表为驱动表<br>尽量使用inner join，避免left join<br>参与联合查询的表至少为2张表，一般都存在大小之分。<br>如果连接方式是inner join，在没有其他过滤条件的情况下MySQL会自动选择小表作为驱动表；<br>但是left join在驱动表的选择上遵循的是左边驱动右边的原则，即left join左边的表名为驱动表。<br>合理利用索引：<br>被驱动表的索引字段作为on的限制字段。<br>利用小表去驱动大表<br>如果能够减少驱动表的话，减少嵌套循环中的循环次数，以减少 IO总量及CPU运算的次数。<h2 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h2></li></ol></li><li><p>将字段很多的表分解为多个表</p></li><li><p>增加中间表来提高查询效率</p></li><li><p>合理的加入冗余字段来提高查询速度</p></li></ul><h2 id="大表如何优化"><a href="#大表如何优化" class="headerlink" title="大表如何优化"></a>大表如何优化</h2><ul><li>限制数据的查询范围</li><li>读写分离</li><li>使用缓存</li><li>分库分表</li></ul><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="分库分表的原因"><a href="#分库分表的原因" class="headerlink" title="分库分表的原因"></a>分库分表的原因</h3><p>单库的数据量越来越大，查询所需的时间越来越多；<br>单库发生意外时，需要修复的是所有数据，而多库中的一个库发生意外时，只需要修复一个库。</p><h3 id="分库分表的常用策略"><a href="#分库分表的常用策略" class="headerlink" title="分库分表的常用策略"></a>分库分表的常用策略</h3><p>垂直切分：<br>根据业务的不同，将原有多个字段的表拆分为多个表。<br><img src="https://img-blog.csdnimg.cn/2020070711101293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>水平切分：<br>将所有数据分散在多个表中<br><img src="https://img-blog.csdnimg.cn/20200707111054698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="分库分表需要解决的问题"><a href="#分库分表需要解决的问题" class="headerlink" title="分库分表需要解决的问题"></a>分库分表需要解决的问题</h3><p>1、事务问题：<br>解决办法：可以使用分布式事务或由应用程序和数据库共同控制；<br>2、跨节点Join问题<br>解决办法：分两次查询，在第一次查询的结果集中找出关联数据的id，根据这些id发起第二次请求得到关联数据；<br>3、跨节点的count、order by、group by以及聚合函数问题<br>解决办法：分别在各个节点上得到结果后在应用程序端进行合并<br>4、数据迁移，容量规划，扩容等问题<br>解决办法：利用对2的倍数取余具有<strong>向前兼容</strong>的特性（如对4取余跟对2取余结果相同）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩展规模和分表数量都有限制。<br>5、事务<br>解决办法：基于Best Efforts 1PC模式，实现在一个时间周期内达到最终一致性。<br>6、ID问题<br>因为数据库一旦被切分到多个物理节点上，我们将不能再依赖数据库自身的主键生成机制，因为在某个分区数据库自生成的ID无法保证在全局上是唯一的。<br>解决办法：结合数据库维护一个Sequence表</p><h2 id="MySQL的复制原理以及流程"><a href="#MySQL的复制原理以及流程" class="headerlink" title="MySQL的复制原理以及流程"></a>MySQL的复制原理以及流程</h2><p>主从复制：将主数据库中的DDL和DML操作通过二进制日志（binlog）传输到从数据库上，然后将这些日志重新执行，从而使得从数据库的数据跟主数据库的数据保持一致。</p><p><strong>主从复制的作用</strong></p><ol><li>主数据库出现问题，可以切换到从数据库</li><li>可以进行数据库层面的读写分离</li><li>可以在从数据库上进行日常备份</li></ol><p><strong>MySQL主从复制解决的问题</strong></p><ul><li>数据分布：可以在不同地理位置进行数据备份</li><li>负载均衡：降低单个服务器的压力</li><li>高可用和故障切换：避免单点失败</li><li>升级测试：可以用更高版本的MySQL作为从库</li></ul><p><img src="https://img-blog.csdnimg.cn/2020080409005457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM浅析</title>
    <link href="/2020/07/01/JVM%E6%B5%85%E6%9E%90/"/>
    <url>/2020/07/01/JVM%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><h2 id="JVM的主要组成部分及作用"><a href="#JVM的主要组成部分及作用" class="headerlink" title="JVM的主要组成部分及作用"></a>JVM的主要组成部分及作用</h2><p><img src="https://img-blog.csdnimg.cn/20200630215753963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>JVM主要由四个部分组成：</p><div class="hljs"><pre><code>1. 类加载器（ClassLoader）2. 运行时数据区（Runtime Data Area）3. 执行引擎（Execution Engine）4. 本地库接口（Native Interface）</code></pre></div><p>各组件的作用：首先通过<strong>编译器</strong>把 Java 代码转换成字节码，<strong>类加载器</strong>（ClassLoader）再把字节码加载到内存中，将其放在<strong>运行时数据区</strong>（Runtime data area）的<strong>方法区</strong>内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器<strong>执行引擎</strong>（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的<strong>本地库接口</strong>（Native Interface）来实现整个程序的功能。</p><h2 id="Java程序运行机制步骤"><a href="#Java程序运行机制步骤" class="headerlink" title="Java程序运行机制步骤"></a>Java程序运行机制步骤</h2><p><img src="https://img-blog.csdnimg.cn/20200630222445455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li>首先利用IDE集成开发工具编写Java源代码，源文件的后缀名为.java</li><li>编译器(javac)将源代码编译成字节码文件，后缀名.class</li><li>解释器（java命令）运行字节码</li></ul><p><strong>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。</strong></p><h2 id="JVM运行时数据区"><a href="#JVM运行时数据区" class="headerlink" title="JVM运行时数据区"></a>JVM运行时数据区</h2><p><img src="https://img-blog.csdnimg.cn/20200630223135269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li><strong>程序计数器</strong>：<strong>字节码解释器</strong>工作就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成；</li><li><strong>Java虚拟机栈</strong>：生命周期和线程一致，每个方法在执行时都会创建一个<strong>栈帧</strong>，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用直到执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程；</li><li><strong>本地方法栈</strong>：与Java虚拟机栈不同的是，Java虚拟机栈是为执行Java方法（字节码）服务，而本地方法栈是为虚拟机使用到的本地方法服务。<br>Java虚拟机栈和本地方法栈都有可能抛出StackOverFlowError【线程请求的栈深度大于虚拟机所允许的深度】和OutOfMemoryError【如果虚拟机可以动态扩展，而扩展时无法申请到足够的内存】。</li><li><strong>Java堆</strong>：主要用来存放对象实例和数组，垃圾回收的主要区域；</li><li><strong>方法区</strong>：用来存放已被加载的<strong>类信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>即时编译器编译后的代码</strong>等数据；</li><li><strong>运行时常量池</strong>：方法区的一部分，编译器生成的<strong>字面量</strong>和<strong>符号引用</strong>会在类加载后放入这个区域。</li></ul><h2 id="堆栈的区别"><a href="#堆栈的区别" class="headerlink" title="堆栈的区别"></a>堆栈的区别</h2><ul><li>可见度：堆线程共享，栈线程私有；</li><li>存储内容：堆中主要存放对象实例，数组，栈中主要存放基本数据类型，对象的引用；</li><li>作用：栈主要解决程序的运行问题，堆主要解决的是数据的存储问题；</li><li>内存分配：堆是不连续的，分配的内存是在运行期确定的，大小不固定，栈是连续的，分配的内存大小要在编译期确定，大小固定。</li></ul><h1 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h1><h2 id="对象创建的几种方式"><a href="#对象创建的几种方式" class="headerlink" title="对象创建的几种方式"></a>对象创建的几种方式</h2><ul><li>使用new关键字</li><li>使用Class的newInstance方法</li><li>使用Constructor类的newInstance方法</li><li>使用clone方法</li><li>使用反序列化</li></ul><h2 id="对象创建的主要流程"><a href="#对象创建的主要流程" class="headerlink" title="对象创建的主要流程"></a>对象创建的主要流程</h2><p>虚拟机遇到一条new指令时，先检查常量池是否已经加载相应的类，如果没有，必须先执行相应的<code>类加载</code>，类加载通过后，接下来<code>分配内存</code>，若Java堆中内存是绝对规整的，使用“<strong>指针碰撞</strong>”方式分配内存；如果不是规整的，就从空闲列表中分配，叫做“<strong>空闲列表</strong>”方式。划分内存时还需要考虑一个<code>并发问题</code>，也有两种方式：<strong>CAS同步处理</strong>或者<strong>本地线程分配缓冲</strong>，然后内存空间初始化操作，接着是做一些必要的<code>对象设置</code>，最后执行&lt;init&gt;方法。</p><p><img src="https://img-blog.csdnimg.cn/20200701163823266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200701164113114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>Java程序需要通过 JVM 栈上的引用访问堆中的具体对象。对象的访问方式取决于 JVM 虚拟机的实现。目前主流的访问方式有 <strong>句柄</strong> 和 <strong>直接指针</strong> 两种方式。</p><blockquote><p>指针： 指向对象，代表一个对象在内存中的起始地址。<br>句柄： 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（<strong>句柄不发生变化，指向固定内存地址</strong>），再由对象的指针指向对象的真实内存地址。</p></blockquote><p><strong>句柄访问</strong><br>Java堆中划分出一块内存来作为句柄池，Java栈的局部变量表中存储对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息，具体构造如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200701164940774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>优势：引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。</p><p><strong>直接指针</strong><br>如果使用直接指针访问，引用中存储的直接就是对象地址，那么Java堆对象内部的布局中就必须考虑如何放置访问类型数据的相关信息。<br>优势：<strong>速度更快，节省了一次指针定位的时间开销</strong>。由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。</p><h1 id="内存溢出异常"><a href="#内存溢出异常" class="headerlink" title="内存溢出异常"></a>内存溢出异常</h1><h2 id="Java会存在内存泄漏吗？"><a href="#Java会存在内存泄漏吗？" class="headerlink" title="Java会存在内存泄漏吗？"></a>Java会存在内存泄漏吗？</h2><p>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中，虽然Java由GC垃圾回收机制，不再被使用的对象会被GC自动回收，但是还是存在内存泄漏问题，比如：</p><ul><li>长生命周期的对象持有短生命周期对象的引用，尽管短生命周期已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收。</li><li>监听器：释放对象的时候没有删除监听器；</li><li>各种连接：比如数据库连接（dataSourse.getConnection()），网络连接(socket) 和 IO 连接，除非其显式的调用了其 close() 方法将其连接关闭，否则是不会自动被 GC 回收的；</li></ul><h2 id="什么情况下会发生堆内存溢出，栈内存溢出？"><a href="#什么情况下会发生堆内存溢出，栈内存溢出？" class="headerlink" title="什么情况下会发生堆内存溢出，栈内存溢出？"></a>什么情况下会发生堆内存溢出，栈内存溢出？</h2><ul><li>栈溢出：栈是线程私有的，它的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息，栈溢出就是方法执行创建的栈帧超过了栈的深度。</li><li>堆溢出：不断的创建对象所致。</li></ul><p>堆中主要存储的是对象，如果不断的new对象则会导致堆中的空间溢出。</p><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><h2 id="Java中都有哪些引用类型"><a href="#Java中都有哪些引用类型" class="headerlink" title="Java中都有哪些引用类型"></a>Java中都有哪些引用类型</h2><ul><li>强引用：发生GC的时候不会回收</li><li>软引用：在发生内存溢出之前会被回收</li><li>弱引用：在下一次GC时会被回收</li><li>虚引用：又称幽灵引用，无法通过虚引用来获得对象，主要用于在GC时返回一个通知</li></ul><h2 id="JVM的永久代中会发生垃圾回收吗？"><a href="#JVM的永久代中会发生垃圾回收吗？" class="headerlink" title="JVM的永久代中会发生垃圾回收吗？"></a>JVM的永久代中会发生垃圾回收吗？</h2><p>垃圾回收不会发生在永久代，如果永久代满了或是超过了临界值，会触发完全垃圾回收（Full GC），另外，Java8中已经移除了永久代，改为元空间，而且元空间不存在Java虚拟机中，而是保存在本地内存。</p><h2 id="分代收集下的年轻代和老年代采用的垃圾回收算法"><a href="#分代收集下的年轻代和老年代采用的垃圾回收算法" class="headerlink" title="分代收集下的年轻代和老年代采用的垃圾回收算法"></a>分代收集下的年轻代和老年代采用的垃圾回收算法</h2><p><strong>新生代</strong>：主要以<strong>复制算法</strong>为主</p><p><strong>老年代</strong>：主要以<strong>标记整理</strong>为主</p><ul><li>在年轻代中经历了N次垃圾回收仍然存活的对象就会被放到老年代中，因此，可以认为老年代中存放的都是一些生命周期比较长的对象；</li><li>老年代内存比年轻代内存大很多，当老年代内存满时会触发Major GC（Full GC）。</li></ul><h2 id="详细介绍一下CMS垃圾回收器"><a href="#详细介绍一下CMS垃圾回收器" class="headerlink" title="详细介绍一下CMS垃圾回收器"></a>详细介绍一下CMS垃圾回收器</h2><p>CMS 是英文 Concurrent Mark-Sweep 的简称，并发收集，是<strong>以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器</strong>。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。</p><p>CMS 使用的是<strong>标记-清除</strong>的算法实现的，所以在GC的时候会产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 <strong>Serial Old</strong> 回收器进行垃圾清除，此时的性能将会被降低。（<strong>为什么选择Serial Old 作为CMS的后备方案而不选择多线程并行的Parallel Old，原因在于Serial Old可以和年轻代的三种搭配使用，而Parallel Old只能和Parallel Scavenge搭配使用。</strong>）</p><p>CMS回收的过程：</p><ul><li><p>初始标记：（<code>stop-the-world</code>）标记GCRoots可以直接关联的对象；</p></li><li><p>并发标记：完成余下的GCRoots Tracing标记（用户线程和GC线程并发执行）；</p></li><li><p>重新标记：（<code>stop-the-world</code>）修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录；</p></li><li><p>并发清除：执行清除操作，和用户线程并发执行；</p></li></ul><p>注意：初始标记和重新标记的时候需要暂停其他应用程序。</p><h1 id="JVM自动内存管理机制"><a href="#JVM自动内存管理机制" class="headerlink" title="JVM自动内存管理机制"></a>JVM自动内存管理机制</h1><p>JVM自动内存管理机制，主要包括内存回收和内存分配。</p><h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p>对于内存回收机制主要围绕“哪些内存需要回收？”，“什么时候回收？”，“如何回收？”三个问题来展开。</p><h3 id="1-哪些内存需要回收？"><a href="#1-哪些内存需要回收？" class="headerlink" title="1. 哪些内存需要回收？"></a>1. 哪些内存需要回收？</h3><p>不可能再被任何途径使用的对象需要被回收。</p><p><strong>怎么判断对象是否可以被回收？</strong></p><p>判断一个对象是否还可以再被引用的方法有：（1）引用计数法，（2）可达性分析</p><ul><li>引用计数法：给对象维护一个计数器，每次被引用计数器的值+1，每次引用被释放，计数器的值-1，当计数器的值为0时，认为它不可能再被引用了；（相互引用造成内存泄漏）</li></ul><ul><li>可达性分析：从GCRoots向下搜索，走过的路径为引用链，当一个对象到GCRoots没有任何引用链相连则证明对象不可用。</li></ul><h3 id="2-什么时候回收？"><a href="#2-什么时候回收？" class="headerlink" title="2. 什么时候回收？"></a>2. 什么时候回收？</h3><h4 id="2-1-新生代的回收时机"><a href="#2-1-新生代的回收时机" class="headerlink" title="2.1 新生代的回收时机"></a>2.1 新生代的回收时机</h4><p>新的对象需要在Eden区申请内存，但Eden区没有足够的连续空间分配给对象会触发一次Minor GC；</p><h4 id="2-2-老年代的回收时机"><a href="#2-2-老年代的回收时机" class="headerlink" title="2.2 老年代的回收时机"></a>2.2 老年代的回收时机</h4><p>从新生代过来的对象需要在老年代申请空间，但老年代没有足够的连续空间来分配，会触发一次Major GC（Full GC）</p><h3 id="3-如何回收？"><a href="#3-如何回收？" class="headerlink" title="3. 如何回收？"></a>3. 如何回收？</h3><h4 id="3-1-回收算法"><a href="#3-1-回收算法" class="headerlink" title="3.1 回收算法"></a>3.1 回收算法</h4><ul><li>复制算法：把内存空间划分为两个相等的区域，每次只使用其中一个区域，垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后将当前使用区域的可回收对象进行回收。<br>优点：按顺序分配内存即可，实现简单，运行高效，不用考虑内存碎片；<br>缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制；</li><li>标记-清除算法：标记无用对象，然后进行清除回收<br>优点：实现简单，不需要对象进行移动；<br>缺点：标记、清除过程效率低，会产生大量不连续的内存碎片；</li><li>标记-整理算法：在标记可回收的对象后将所有存活的对象压缩到内存的一端，使它们紧凑地排列在一起，然后对端边界以外的内存进行回收，回收后，已用和未用的内存都各自一边。<br>优点：解决了标记-清理算法存在的内存碎片问题<br>缺点：仍需要进行局部对象移动，一定程度上降低了效率</li><li>分代收集算法：针对不同情况采用不同的垃圾回收算法。</li></ul><h4 id="3-2-垃圾收集器"><a href="#3-2-垃圾收集器" class="headerlink" title="3.2 垃圾收集器"></a>3.2 垃圾收集器</h4><p><img src="https://img-blog.csdnimg.cn/20200701183738540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li><li>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li><li>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；</li><li>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li><li>CMS(Concurrent Mark Sweep)收集器（<strong>标记-清除算法</strong>）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li><li>G1(Garbage First)收集器 (<strong>标记-整理算法</strong>)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：<strong>G1回收的范围是整个Java堆</strong>(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li></ul><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>对象的内存分配主要在堆上进行，对于新对象主要分配在Eden区，少数情况也会直接分配到老年代。</p><h3 id="1-1-对象优先在Eden区分配"><a href="#1-1-对象优先在Eden区分配" class="headerlink" title="1.1 对象优先在Eden区分配"></a>1.1 对象优先在Eden区分配</h3><ul><li>年轻代内存按照8：1：1的比例分为一个Eden区和两个Survivor(Survivor0、Survivor1)区，大部分对象在Eden区中生成，回收时先将Eden区存活对象复制到一个Survivor0区，然后清空Eden区，当这个Survivor0区也存满了时，则将Eden区和Survivor0区存活的对象复制到另一个Survivor1区，然后清空Eden区和这个Survivor0区，此时Survivor0区是空的，然后将Survivor0区和Survivor1区交换，即保持Survivor1区为空，如此往复。</li><li>当Survivor1区不足以存放Eden区和Survivor0区存活的对象时，则将存活对象直接放到老年代，若是老年代也满了，就会触发一次Full GC（Major GC），年轻代和老年代都进行回收。</li><li>年轻代发生的GC叫做Minor GC，Minor GC发生的频率比较高（不一定等Eden区满了才触发）</li><li>每次从Survivor0到Survivor1移动存活的对象，年龄就加1，当年龄到达15时（默认值），升级为老年代；</li></ul><h3 id="1-2-大对象直接进入老年代"><a href="#1-2-大对象直接进入老年代" class="headerlink" title="1.2 大对象直接进入老年代"></a>1.2 大对象直接进入老年代</h3><p>-XX：PretenureSizeThreshold参数设置对象大小阈值，大于这个值的对象直接进入老年代；</p><h3 id="1-3-长期存活的对象直接进入老年代"><a href="#1-3-长期存活的对象直接进入老年代" class="headerlink" title="1.3 长期存活的对象直接进入老年代"></a>1.3 长期存活的对象直接进入老年代</h3><p>Survivor区中的对象每熬过一次Minor GC，年龄就增加1岁，-XX：MaxTenuringThreshold设置年龄阈值，达到阈值的对象直接进入老年代。</p><h3 id="1-4-年龄相同对象所占空间超过Survivor区的一半，则大于等于这个年龄的对象直接进入老年代。"><a href="#1-4-年龄相同对象所占空间超过Survivor区的一半，则大于等于这个年龄的对象直接进入老年代。" class="headerlink" title="1.4 年龄相同对象所占空间超过Survivor区的一半，则大于等于这个年龄的对象直接进入老年代。"></a>1.4 年龄相同对象所占空间超过Survivor区的一半，则大于等于这个年龄的对象直接进入老年代。</h3><h3 id="1-5-空间分配担保"><a href="#1-5-空间分配担保" class="headerlink" title="1.5 空间分配担保"></a>1.5 空间分配担保</h3><p>当新生代采用Eden、Survivor式的复制算法时需要老年代对其进行内存担保（因为minor GC时，如果Survivor1区的容量不足以接纳Survivor0区+Eden区的对象，则他们将全部进入老年代）</p><p>Minor GC之前先检查是否可以确保此次GC的安全，先检查老年代的最大可用连续空间是否大于新生代所有对象的总空间，如果成立则可以确保此次minor GC是安全的，如果不成立，检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于尝试一次minor GC， 否则进行一次Full GC。</p><h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><h2 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a>Java类加载机制</h2><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的Java类型。<br>注意：类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类，如果一次性加载所有类，那么会占用很大的内存。</p><p>类的加载方式有两种：</p><ol><li>隐式加载，程序在运行过程中遇到new等方式生成对象时，隐式调用类加载器来加载对应的类到JVM中；</li><li>显式加载：通过class.forName()等方法显式加载需要加载的类。</li></ol><h2 id="类的生命周期（前5个步骤是类加载过程）"><a href="#类的生命周期（前5个步骤是类加载过程）" class="headerlink" title="类的生命周期（前5个步骤是类加载过程）"></a>类的生命周期（前5个步骤是类加载过程）</h2><p><img src="https://img-blog.csdnimg.cn/20200701191958528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="加载："><a href="#加载：" class="headerlink" title="加载："></a>加载：</h3><p>完成以下三件事：</p><ul><li>通过类的全限定名获取定义该类的二进制字节流；</li><li><strong>将该字节流表示的静态存储结构转换为方法区的运行时存储结构；</strong></li><li>在内存中生成一个代表该类的Class对象，作为方法区中该类各种数据的访问入口；</li></ul><p>获取二进制字节流有以下几种方式：</p><ul><li>从ZIP包读取，常见的有：JAR，WAR</li><li>从网络中获取，如：Applet</li><li>运行时计算生成，如：动态代理技术，使用<code>ProxyGenerator.generateProxyClass</code>的代理类的二进制字节流；</li><li>由其他文件生成，JSP</li><li>从数据库中读取</li></ul><h3 id="验证："><a href="#验证：" class="headerlink" title="验证："></a>验证：</h3><p>确保Class文件的字节流中包含的信息是符合当前虚拟机的要求，不会危害虚拟机自身的安全。</p><p>验证阶段大致会完成下面4个阶段的检验动作：</p><ul><li><strong>文件格式验证</strong>：<strong>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理</strong>，其目的是保证输入的字节流能正确地解析并存储于方法区之内；</li><li><strong>元数据验证</strong>：对字节码描述的信息进行语义分析，以<strong>保证其描述的信息符合Java语言规范的要求</strong>，其主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息；</li></ul><ul><li><p><strong>字节码校验</strong>：通过数据流和控制流分析，确定程序语义是否是合法的、符合逻辑，<strong>保证被校验类的方法在运行时不会做出危害虚拟机安全的事件</strong>。</p></li><li><p><strong>符号引用验证</strong>：发生在虚拟机将符号引用转化为直接引用的时候，可以看作是对类自身以外（常量池中的各种符合引用）的信息进行匹配性校验，其目的是<strong>确保解析动作能正常执行。</strong></p></li></ul><h3 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h3><p>为<strong>类变量</strong>分配内存并设置初始值，使用的是方法区的内存。<br>注意：这里的内存分配仅包括类变量，不包括实例变量，实例变量会在对象实例化时随着对象一起被分配在堆中，其次这里的初始值“通常情况”下是数据类型的零值。<strong>类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。</strong>（单例实现，为什么非静态方法中不能引用静态方法，等等）</p><h3 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h3><p><strong>将常量池的符号引用替换为直接引用的过程。</strong></p><ul><li>符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中；</li></ul><ul><li>直接引用：可以是直接指向目标的指针，相对偏移量或一个能间接定位到目标的句柄，直接引用是和虚拟机实现的内存布局相关的，引用的目标一定存在于内存中。</li></ul><h3 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h3><p>初始化阶段才是真正开始执行类中定义的Java程序代码，<strong>初始化阶段是虚拟机执行类构造器方法的过程</strong>，并且根据程序去初始化类变量和其他资源。<br>注意的是：静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<span class="hljs-keyword">static</span> &#123;i = <span class="hljs-number">0</span>; <span class="hljs-comment">// 给变量赋值可以正常编译通过</span>System.out.print(i); <span class="hljs-comment">// 这句编译器会提示“非法向前引用”</span>&#125; <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;&#125;</code></pre></div><p>使用：</p><p>卸载：</p><h2 id="什么是类加载器，类加载器有哪些？"><a href="#什么是类加载器，类加载器有哪些？" class="headerlink" title="什么是类加载器，类加载器有哪些？"></a>什么是类加载器，类加载器有哪些？</h2><p>虚拟机设计团队把类加载阶段中“<strong>通过一个类的全限定名来获取描述此类的二进制字节流</strong>”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类，实现这个动作的代码模块称为“类加载器”。</p><p>类加载器负责加载所有的类，其为所有被载入内存中的类生成一个<code>java.lang.Class</code>实例对象。一旦一个类被加载入JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，<strong>一个类用其全限定类名和其类加载器作为其唯一标识</strong>。</p><p>主要有以下四种类加载器：</p><ol><li><strong>启动类加载器</strong>(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。</li><li><strong>扩展类加载器</strong>(Extension ClassLoader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li><li><strong>系统类加载器</strong>（Application ClassLoader）：它负责加载用户类路径（ClassPath）上所指定的类库。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li><li><strong>用户自定义类加载器</strong>，通过继承 java.lang.ClassLoader类的方式实现。</li></ol><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确定在JVM中的唯一性，每个类加载器都有一个独立的类名称空间，类加载器就是根据指定的全限定名称将class文件加载到JVM内存，然后再转化为java.lang.Class对象。<br><img src="https://upload-images.jianshu.io/upload_images/5982616-aad63782162c9ae5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/942/format/webp" srcset="/img/loading.gif" alt="img"><br><strong>双亲委派模型</strong>：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成(<strong>注意：这里的父子关系一般是通过组合关系来实现的，而不是继承实现的)</strong>，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p><p>双亲委派模型的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，例如类java.lang.Object，它存放在rt.jar之中，<strong>无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载</strong>，因此Object类在程序的各种类加载器环境中都是同一个类，相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会有多个不同的Object类，应用程序也将会变得一片混乱。</p><p>如果用户编写了一个与rt.jar类库中已有类重名的Java类，将会发现可以正常编译，但是永远无法被加载运行。即使自定义了自己的类加载器，强行用defineClass()方法去加载一个以“java.lang”开头的类也不会成功，会收到一个由虚拟机抛出的异常。</p><h3 id="双亲委派模型被破坏的情况"><a href="#双亲委派模型被破坏的情况" class="headerlink" title="双亲委派模型被破坏的情况"></a>双亲委派模型被破坏的情况</h3><ul><li>解决历史遗留问题：双亲委派模型是在JDK1.2之后才被引入的，而类加载器和抽象类<code>java.lang.ClassLoader</code>则是JDK1.0时候就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK1.2之后的java.lang.ClassLoader添加了一个新的proceted方法findClass()，在此之前，用户去继承java.lang.ClassLoader的唯一目的就是重写loadClass()方法，因为虚拟在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的loadClass()。JDK1.2之后已不再提倡用户再去覆盖loadClass()方法，应当<strong>把自己的类加载逻辑写到findClass()方法中</strong>，在loadClass()方法的逻辑里，如果父类加载器加载失败，则会调用自己的findClass()方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派模型的。</li><li>自身缺陷：父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器。</li><li>用户对程序的动态性追求：例如OSGi的出现。在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为网状结构。</li></ul><h1 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h1><h2 id="说一下-JVM-调优的工具？"><a href="#说一下-JVM-调优的工具？" class="headerlink" title="说一下 JVM 调优的工具？"></a>说一下 JVM 调优的工具？</h2><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 <code>jconsole</code> 和<code>jvisualvm</code>这两款视图监控工具。</p><ul><li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li><li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li></ul><h2 id="常用的-JVM-调优的参数都有哪些？"><a href="#常用的-JVM-调优的参数都有哪些？" class="headerlink" title="常用的 JVM 调优的参数都有哪些？"></a>常用的 JVM 调优的参数都有哪些？</h2><p>-Xms2g：初始化堆大小为 2g；<br>-Xmx2g：堆最大内存为 2g；<br>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；<br>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；<br>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；<br>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；<br>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；<br>-XX:+PrintGC：开启打印 gc 信息；<br>-XX:+PrintGCDetails：打印 gc 详细信息。</p><h2 id="了解过JVM调优没，基本思路是什么？"><a href="#了解过JVM调优没，基本思路是什么？" class="headerlink" title="了解过JVM调优没，基本思路是什么？"></a>了解过JVM调优没，基本思路是什么？</h2><h3 id="1-监控GC的状态"><a href="#1-监控GC的状态" class="headerlink" title="1. 监控GC的状态"></a>1. 监控GC的状态</h3><p>使用各种JVM工具，查看当前日志，分析当前JVM参数设置，并且分析当前堆内存快照和GC日志，根据实际的各区域内存划分和GC执行时间，判断是否进行优化。</p><p>举个例子：系统崩溃前的一些现象：</p><p>每次垃圾回收的时间越来越长，由之前的10ms延长到50ms左右，Full GC的时间也由之前的0.5s延长到4,5s，Full GC的次数越来越多，最频繁时不到1分钟就进行一次Full GC，老年代的内存越来越大，并且每次Full GC后老年代没有内存被释放，之后系统会无法响应新的请求，逐渐达到OutOfMemoryError的临界值，这个时候就需要分析JVM内存快照dump。</p><h3 id="2-生成堆的dump文件"><a href="#2-生成堆的dump文件" class="headerlink" title="2. 生成堆的dump文件"></a>2. 生成堆的dump文件</h3><p>通过JMX的MBean生成当前的Heap信息，大小为一个3G（整个堆的大小）的hprof文件，如果没有启动JMX可以通过Java的jmap命令来生成该文件。</p><h3 id="3-分析dump文件"><a href="#3-分析dump文件" class="headerlink" title="3. 分析dump文件"></a>3. 分析dump文件</h3><p>借助高配置的Linux，使用Visual VM IBM HeapAnalyzer JDK自带的Hprof工具 Mat（Eclipse专门的静态内存分析工具）打开分析。</p><h3 id="4-分析结果，判断是否需要优化"><a href="#4-分析结果，判断是否需要优化" class="headerlink" title="4. 分析结果，判断是否需要优化"></a>4. 分析结果，判断是否需要优化</h3><p>如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化，如果GC时间超过1~3s，或者频繁GC，则必须优化。</p><h3 id="5-调整GC类型和内存分配"><a href="#5-调整GC类型和内存分配" class="headerlink" title="5. 调整GC类型和内存分配"></a>5. 调整GC类型和内存分配</h3><p>如果内存分配过大或过小，或者采用的GC收集器比较慢，则应该优先调整这些参数，并且先找1台或几台机器进行beta，然后将优化过的机器和没有优化过的机器进行性能对比，并有针对性的作出最后选择。</p><h3 id="6-不断的分析和调整"><a href="#6-不断的分析和调整" class="headerlink" title="6. 不断的分析和调整"></a>6. 不断的分析和调整</h3><p>通过不断的试验，分析并找到最合适的参数，并将这些参数应用到所有服务器。</p>]]></content>
    
    
    <categories>
      
      <category>JVM规范</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程</title>
    <link href="/2020/06/28/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2020/06/28/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="形成死锁的四个必要条件是什么"><a href="#形成死锁的四个必要条件是什么" class="headerlink" title="形成死锁的四个必要条件是什么"></a>形成死锁的四个必要条件是什么</h2><ol><li><strong>互斥</strong>：线程对于所分配到的资源具有排他性，即一个资源只能被一个线程占用，直到该线程释放；</li><li><strong>请求与保持</strong>：一个线程因请求被占用资源而发生阻塞时，对已获得的资源保持不放；</li><li><strong>不剥夺</strong>：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源；</li><li><strong>循环等待</strong>：当发生死锁时，所等待的线程必定会形成一个环路，造成永久阻塞。</li></ol><h2 id="创建线程的4种方式"><a href="#创建线程的4种方式" class="headerlink" title="创建线程的4种方式"></a>创建线程的4种方式</h2><ol><li>继承Thread类</li><li>实现Runnable接口</li><li>实现Callable接口</li><li>使用Executors工具类创建线程池</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 方法一：继承Thread</span><span class="hljs-comment">     */</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"继承Thread的线程正在工作"</span>);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 方法二：实现Runnable</span><span class="hljs-comment">     */</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"实现Runnable的线程正在工作"</span>);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 方法三：实现Callable</span><span class="hljs-comment">     */</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt;</span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"实现Callable的线程正在工作"</span>);            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 方法四：利用Executors工具类创建线程池</span><span class="hljs-comment">     */</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"Executors创建的线程池正在工作"</span>);        &#125;    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//创建线程</span>        MyThread myThread = <span class="hljs-keyword">new</span> MyThread();        MyRunnable myRunnable = <span class="hljs-keyword">new</span> MyRunnable();        Thread thread = <span class="hljs-keyword">new</span> Thread(myRunnable);        FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> MyCallable());        Thread callableThread = <span class="hljs-keyword">new</span> Thread(futureTask);        ExecutorService executorService = Executors.newSingleThreadExecutor();        MyRunnable2 myRunnable2 = <span class="hljs-keyword">new</span> MyRunnable2();        <span class="hljs-comment">//开启线程</span>        myThread.start();        thread.start();        callableThread.start();        executorService.execute(myRunnable2);    &#125;&#125;</code></pre></div><h2 id="线程的状态和基本操作"><a href="#线程的状态和基本操作" class="headerlink" title="线程的状态和基本操作"></a>线程的状态和基本操作</h2><p><img src="https://img-blog.csdnimg.cn/20200629002850167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ol><li><p><strong>新建(new)</strong>：新创建了一个线程对象。</p></li><li><p><strong>可运行(runnable)</strong>：线程对象创建后，当调用线程对象的start()方法，该线程处于就绪状态，等待被线程调度选中，获取cpu的使用权。</p></li><li><p><strong>运行(running)</strong>：可运行状态(runnable)的线程获得了CPU时间片（timeslice），执行程序代码。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p></li><li><p><strong>阻塞(block)</strong>：处于运行状态中的线程由于某种原因，暂时放弃对 CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被 CPU 调用以进入到运行状态。</p><p>阻塞的情况分三种：</p><ul><li>等待阻塞：运行状态中的线程执行 wait()方法，JVM会把该线程放入等待队列(waitting queue)中，使本线程进入到等待阻塞状态； </li><li>同步阻塞：线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)，则JVM会把该线程放入锁池(lock pool)中，线程会进入同步阻塞状态； </li><li>其他阻塞: 通过调用线程的 sleep()或 join()或发出了 I/O 请求时，线程会进入到阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。</li></ul></li><li><p><strong>死亡(dead)</strong>：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p></li></ol><h2 id="sleep-和-wait-有什么区别？"><a href="#sleep-和-wait-有什么区别？" class="headerlink" title="sleep() 和 wait() 有什么区别？"></a>sleep() 和 wait() 有什么区别？</h2><ul><li><strong>类的不同</strong>：sleep() 是 <code>Thread</code>线程类的静态方法，wait() 是<code>Object</code>类的方法。</li><li><strong>是否释放锁</strong>：sleep() 不释放锁；wait() 释放锁。</li><li><strong>用途不同</strong>：wait 通常被用于<strong>线程间交互/通信</strong>，sleep 通常被用于<strong>暂停执行</strong>。</li><li><strong>用法不同</strong>：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法，当然也可以使用wait(long timeout)超时后线程会自动苏醒。sleep() 方法执行完成后，线程会自动苏醒。</li></ul><h2 id="为什么要将wait-方法放在while循环中"><a href="#为什么要将wait-方法放在while循环中" class="headerlink" title="为什么要将wait()方法放在while循环中"></a>为什么要将wait()方法放在while循环中</h2><p>因为处于等待状态的线程可能会收到错误警报和<strong>伪唤醒</strong>，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。</p><h2 id="Thread类的yield方法有什么作用？"><a href="#Thread类的yield方法有什么作用？" class="headerlink" title="Thread类的yield方法有什么作用？"></a>Thread类的yield方法有什么作用？</h2><p>使当前线程从运行状态转为就绪状态，以便给相同优先级或更高优先级的线程运行的机会。</p><h2 id="sleep-和yield-方法为什么是静态的？"><a href="#sleep-和yield-方法为什么是静态的？" class="headerlink" title="sleep()和yield()方法为什么是静态的？"></a>sleep()和yield()方法为什么是静态的？</h2><p>Thread类的sleep()和yield()方法都为静态方法，说明<strong>只有正在执行的线程才能执行</strong>，在其他处于等待状态的线程上调用这些方法是没有意义的，如果设置为非静态的，那么程序员就可能错误的认为可以在其他非运行线程上调用这些方法。</p><h2 id="sleep、yield、join、wait的比较"><a href="#sleep、yield、join、wait的比较" class="headerlink" title="sleep、yield、join、wait的比较"></a>sleep、yield、join、wait的比较</h2><ol><li><p>Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程进入阻塞，但不释放对象锁，<strong>millis后线程自动苏醒进入可运行状态</strong>。</p><p>作用：给其它线程执行机会的最佳方式。</p></li><li><p>Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的cpu时间片，由运行状态变会可运行状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。</p></li><li><p>t.join()/t.join(long millis)，<strong>让调用该方法的线程在执行完run()方法后，再执行join方法后面的代码</strong>。具体而言，可以通过线程t的join()方法来等待线程t的结束，或者使用线程t的join(millis)方法来等待线程t的结束，但最多只等待2ms。</p></li><li><p>obj.wait()，当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。依靠notify()/notifyAll()唤醒或者wait(long timeout)，timeout时间到自动唤醒。</p></li><li><p>obj.notify()唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。</p></li></ol><h2 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait(),notify(),notifyAll()"></a>wait(),notify(),notifyAll()</h2><ul><li>如果一个线程调用了对象的wait()方法，那么线程便会进入该对象的等待池中，等待池中的线程不会去竞争该对象的锁；</li><li>notifyAll()会唤醒所有的线程，notify()只会唤醒一个线程；</li><li>notifyAll()调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争，notify()只会唤醒一个线程，具体唤醒哪个线程由虚拟机控制。</li></ul><h2 id="wait和notify底层实现原理"><a href="#wait和notify底层实现原理" class="headerlink" title="wait和notify底层实现原理"></a>wait和notify底层实现原理</h2><h3 id="wait方法实现"><a href="#wait方法实现" class="headerlink" title="wait方法实现"></a>wait方法实现</h3><p><code>lock.wait()</code>方法最终通过ObjectMonitor的<code>void wait(jlong millis, bool interruptable, TRAPS);</code>实现：</p><blockquote><p>ObjectMonitor对象中有两个队列：<em>WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表；</em></p><p><strong>_WaitSet ** ：处于wait状态的线程，会被加入到wait set；<br>**_EntryList</strong>：处于等待锁block状态的线程，会被加入到entry set；</p></blockquote><p>1、将当前线程封装成<code>ObjectWaiter</code>对象<code>node</code>；</p><p><img src="https://upload-images.jianshu.io/upload_images/2184951-d16fa7f94db04e84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/946/format/webp" srcset="/img/loading.gif" alt="img"></p><blockquote><p> ObjectWaiter对象是双向链表结构，保存了_thread（当前线程）以及当前的状态TState等数据， 每个等待锁的线程都会被封装成ObjectWaiter对象。</p></blockquote><p>2、通过<code>ObjectMonitor::AddWaiter</code>方法将node添加到<code>_WaitSet</code>列表中；</p><p><img src="https://upload-images.jianshu.io/upload_images/2184951-fa3bc34beba6a1a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/577/format/webp" srcset="/img/loading.gif" alt="img"></p><p>3、通过<code>ObjectMonitor::exit</code>方法释放当前的ObjectMonitor对象，这样其它竞争线程就可以获取该ObjectMonitor对象。</p><p><img src="https://upload-images.jianshu.io/upload_images/2184951-7393ef92ea5759e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/653/format/webp" srcset="/img/loading.gif" alt="img"></p><p>4、最终底层的park方法会挂起线程；</p><h3 id="notify方法实现"><a href="#notify方法实现" class="headerlink" title="notify方法实现"></a>notify方法实现</h3><p><code>lock.notify()</code>方法最终通过ObjectMonitor的<code>void notify(TRAPS)</code>实现：<br>1、如果当前_WaitSet为空，即没有正在等待的线程，则直接返回；<br>2、通过<code>ObjectMonitor::DequeueWaiter</code>方法，获取_WaitSet列表中的第一个ObjectWaiter节点，实现也很简单。<br><strong>这里需要注意的是，在jdk的notify方法注释是随机唤醒一个线程，其实是第一个ObjectWaiter节点</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/2184951-1d95fe3cd98f6614.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/676/format/webp" srcset="/img/loading.gif" alt="img"></p><p>3、根据不同的策略，将取出来的ObjectWaiter节点，加入到_EntryList或则通过<code>Atomic::cmpxchg_ptr</code>指令进行自旋操作cxq有兴趣的同学可以看objectMonitor::notify方法；</p><h3 id="notifyAll方法实现"><a href="#notifyAll方法实现" class="headerlink" title="notifyAll方法实现"></a>notifyAll方法实现</h3><p><code>lock.notifyAll()</code>方法最终通过ObjectMonitor的<code>void notifyAll(TRAPS)</code>实现：<br>通过for循环取出_WaitSet的ObjectWaiter节点，并根据不同策略，加入到EntryList或则进行自旋操作。</p><p>从JVM的方法实现中，可以发现：notify和notifyAll并不会释放所占有的ObjectMonitor对象，其实真正释放ObjectMonitor对象的时间点是在执行monitorexit指令，一旦释放ObjectMonitor对象了，entry set中ObjectWaiter节点所保存的线程就可以开始竞争ObjectMonitor对象进行加锁操作了。</p><h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>线程中断并不会使线程立即退出，而是给线程发送一个通知，告知目标线程，有人希望你退出了。至于目标线程接到通知后如何处理，则完全由目标线程自行决定。</p><ul><li>Thread.interrupt()方法是一个实例方法，它通知目标线程中断，也就是设置中断标志位，表明当前线程已经被中断了；</li><li>Thread.isInterrupted()方法也是实例方法，它通过检查中断标志位来判断当前线程是否被中断；</li><li>Thread.interrupted()方法是静态方法，它也用来判断当前线程是否被中断，但是同时也会清除当前线程的中断标志位状态。</li></ul><h2 id="线程同步和互斥"><a href="#线程同步和互斥" class="headerlink" title="线程同步和互斥"></a>线程同步和互斥</h2><ul><li>当一个线程对共享的数据进行操作时，应使之成为一个“原子操作”，即在没有完成相关操作之前，不允许其他线程打断它，否则就会破坏数据的完整性，这就是线程的同步；</li><li>线程互斥是指对于共享的进程资源，当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用该资源的线程释放资源；</li><li>线程互斥可以看成是一种特殊的线程同步。</li></ul><h2 id="Java锁有哪些种类，以及区别"><a href="#Java锁有哪些种类，以及区别" class="headerlink" title="Java锁有哪些种类，以及区别"></a>Java锁有哪些种类，以及区别</h2><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png" srcset="/img/loading.gif" alt="img"></p><h3 id="1-乐观锁VS悲观锁"><a href="#1-乐观锁VS悲观锁" class="headerlink" title="1. 乐观锁VS悲观锁"></a>1. 乐观锁VS悲观锁</h3><p>对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改，Java中，synchronized关键字和Lock的实现类都都是悲观锁；</p><p>乐观锁则认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了数据，如果这个数据没有被更新，当前线程将自己修改的数据成功写入，如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（比如报错或者自动重试），乐观锁在Java中是通过CAS实现的，Java原子类中的递增操作就通过CAS自旋实现。</p><p>悲观锁适合写多读少的场景，乐观锁适合读多写少的场景。</p><blockquote><p>CAS：全称为Compare And Swap，需要涉及到三个操作数：</p><ul><li>需要读写的内存值V；</li><li>进行比较的值A;</li><li>要写入的值B；</li></ul><p>当且仅当V的值等于A时，CAS通过原子方式将新值B来更新V的值，否则不会执行任何操作。</p><p>ABA问题：CAS需要在操作值的时候检查内存值是否发生变化，没有变化才会更新内存值，但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有变，实际上是有变化的。</p><p>解决办法：J.U.C 包提供了一个带有标记的原子引用类 <strong>AtomicStampedReference</strong> 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。</p></blockquote><h3 id="2-自旋锁VS适应性自旋锁"><a href="#2-自旋锁VS适应性自旋锁" class="headerlink" title="2. 自旋锁VS适应性自旋锁"></a>2. 自旋锁VS适应性自旋锁</h3><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理时间，在很多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费有可能比用户代码执行的时间还要长，如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。这个等待的过程就是让当前线程自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。</p><p>自旋等待虽然避免了线程切换的开销，但是它仍占用处理器时间，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源，所以自旋等待的时间必然有一定的限度，超过该限度后应该挂起线程。</p><p>自旋锁的实现原理同样也是CAS。</p><p><strong>自适应自旋锁是自旋的时间（次数）不再固定</strong>，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。相反，如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时可能将省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><h3 id="3-无锁VS偏向锁VS轻量级锁VS重量级锁"><a href="#3-无锁VS偏向锁VS轻量级锁VS重量级锁" class="headerlink" title="3. 无锁VS偏向锁VS轻量级锁VS重量级锁"></a>3. 无锁VS偏向锁VS轻量级锁VS重量级锁</h3><p>这四种锁是指锁的状态，专门针对<code>synchronized</code>的，且锁的状态只能升级不能降级。</p><h4 id="为什么synchronized能实现线程同步？"><a href="#为什么synchronized能实现线程同步？" class="headerlink" title="为什么synchronized能实现线程同步？"></a>为什么synchronized能实现线程同步？</h4><p>在回答这个问题之前，我们需要先了解两个重要概念：<strong>Java对象头</strong>和<strong>Monitor</strong></p><p><strong>Java对象头</strong></p><p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，以HotSpot虚拟机为例，其对象头主要包括两部分数据：<strong>Mark Word（标记字段）</strong>，<strong>Klass Pointer（类型指针）</strong></p><ul><li>Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息，在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</li><li>Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li></ul><p><strong>Monitor</strong></p><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象，每个Java对象都有一把看不见的锁，称为内部锁或者Monitor锁。Monitor是线程私有的数据结构，里面的Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>无锁就是没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功；</p><p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源，如果没有冲突就修改成功，否则就会继续循环尝试。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁，偏向锁是指一段同步代码一直被一个线程所访问，那么该线程在进入和退出同步块时不再通过CAS操作来加锁和解锁，而是直接获取锁，降低获取锁的代价。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁能够提升程序性能的依据是“<strong>对绝大部分的锁，在整个同步周期内都不存在竞争</strong>”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</p><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为<strong>自旋锁</strong>的优化手段。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p><p><strong>综上：偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作，而轻量级锁是通过CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能；重量级锁是将除了拥有锁的线程以外的线程都阻塞。</strong></p><h3 id="4-公平锁VS非公平锁"><a href="#4-公平锁VS非公平锁" class="headerlink" title="4. 公平锁VS非公平锁"></a>4. 公平锁VS非公平锁</h3><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁，公平锁的优点是等待锁的线程不会饿死，缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><p>非公平锁是在还没进入队列之前可以与队列中的线程竞争尝试获取锁，获取不到才会进入等待队列的队尾等待，但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所有非公平锁有可能出现后申请锁的线程先获取锁的场景，<strong>非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高</strong>，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程，缺点是处于等待队列中的线程有可能会饿死，或者等很久才会获得锁。</p><p>公平锁的lock方法在进行CAS判断时多了一个<strong>hasQueuedPredecessors()</strong>方法，它会在AQS队列中没有线程的情况下才会申请锁，而不像非公平锁一样，非公平锁不管AQS里是否有排队的线程就直接申请锁。</p><h3 id="5-独享锁VS共享锁"><a href="#5-独享锁VS共享锁" class="headerlink" title="5. 独享锁VS共享锁"></a>5. 独享锁VS共享锁</h3><p>独享锁也叫排它锁，是指该锁一次只能被一个线程所持有，如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁，获得排它锁的线程既能读数据又能修改数据，JDK中的synchronized和JUC中Lock的实现类就是独享锁；</p><p>共享锁是指该锁可被多个线程所持有，如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁，获得共享锁的线程只能读数据，不能修改数据。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><ul><li>协程（Coroutines）是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。</li></ul><ul><li>协程既不是进程也不是线程，协程仅仅是一个特殊的函数。</li><li>一个线程内的多个协程虽然可以切换，但是<strong>多个协程是串行执行</strong>的，只能在一个线程内运行，没法利用CPU多核能力。</li><li>协程和进程一样，切换是存在上下文切换问题的，协程的切换内容是硬件上下文，切换内存保存在用户自己的变量中，协程的切换过程只有用户态，因此切换效率高。</li></ul><h2 id="一个进程内的线程数量的限制是什么？"><a href="#一个进程内的线程数量的限制是什么？" class="headerlink" title="一个进程内的线程数量的限制是什么？"></a>一个进程内的线程数量的限制是什么？</h2><p>创建一个线程会占用多少内存，<strong>取决于分配给线程的调用栈大小</strong>，可以用<code>ulimit -s</code>命令来查看大小，Linux默认情况下启动一个子线程需要分配10MB的线程栈空间，为了降低进程内存占用，就必须将默认值修改，在Windows下该默认值一般为1MB，通过修改编译选项可以修改。</p><p>进程最多可以创建的线程数是根据分配给调用栈的大小，以及操作系统（32位和64位不同）共同决定的。</p><h1 id="并发理论"><a href="#并发理论" class="headerlink" title="并发理论"></a>并发理论</h1><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="线程间如何实现通信以及如何同步？"><a href="#线程间如何实现通信以及如何同步？" class="headerlink" title="线程间如何实现通信以及如何同步？"></a>线程间如何实现通信以及如何同步？</h3><ul><li>线程之间的通信机制有两种：<strong>共享内存</strong>和<strong>消息传递</strong>；</li><li>在共享内存的并发模型中，线程之间通过写-读内存中的公共状态来隐式进行通信，而在消息传递的模型中，线程之间必须通过明确的发送消息来显式进行通信；</li><li>Java采用的是<strong>共享内存</strong>的方式来实现通信，通过synchronized和lock关键字加锁的方式来实现同步。</li></ul><h3 id="谈谈你对Java内存模型的理解"><a href="#谈谈你对Java内存模型的理解" class="headerlink" title="谈谈你对Java内存模型的理解"></a>谈谈你对Java内存模型的理解</h3><p>处理器和内存处理速度不是同数量级，所以需要在中间建立中间层，也就是高速缓存，这会引出缓存一致性问题。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory），有可能操作同一位置引起各自缓存不一致，这时候需要约定协议在保证一致性。<br> Java 内存模型(Java  Memory  Model，JMM)：屏蔽掉了各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致性的内存访问效果。</p><p><img src="https://img-blog.csdnimg.cn/2020070120310313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="Java内存区域和Java内存模型区别"><a href="#Java内存区域和Java内存模型区别" class="headerlink" title="Java内存区域和Java内存模型区别"></a>Java内存区域和Java内存模型区别</h3><p><strong>Java内存区域：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200629144605499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li>方法区<br>主要用于存储已被虚拟机加载的<strong>类信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、即时编译器编译后的代码等数据，方法区里面有一个运行时常量池，用于存放编译器生成的各种<strong>字面量</strong>和<strong>符号引用</strong>。</li><li>JVM堆<br>主要用于存放对象实例，是垃圾收集器管理的主要区域。</li><li>程序计数器<br>代表了当前线程所执行的字节码行号指示器。</li><li>虚拟机栈<br>代表了Java方法执行的内存模型，每个方法执行时都会创建一个栈帧来存储方法的变量表、操作数栈、动态链接方法、返回值、返回地址等信息，每个方法从调用到结束对应了一个栈帧在虚拟机栈中的入栈和出栈过程。</li><li>本地方法栈<br>和本地方法有关。</li></ul><p><strong>Java内存模型：</strong><br>是一种抽象的概念，并不真实存在，用于定义程序中各个变量的访问方式。<br><img src="https://img-blog.csdnimg.cn/20200629145620207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>JVM运行程序的实体是线程，每个线程创建时，JVM都会为其创建一个工作内存，用于存储<strong>线程私有</strong>的数据，而<strong>JVM内存模型中规定所有变量都存储在主内存中，</strong>主内存是共享内存区域，所有线程都可以访问，但<strong>线程对变量的操作必须在工作内存中进行</strong>。<br>因此<strong>首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本，因为无法访问其他线程的工作线程，所以线程之间的通信必须通过主内存来完成。</strong></p><h3 id="JMM存在的必要性"><a href="#JMM存在的必要性" class="headerlink" title="JMM存在的必要性"></a>JMM存在的必要性</h3><p>如果存在两个线程同时对一个主内存中的实例对象的变量进行操作就有可能诱发线程安全问题，JMM定义了一组规则，通过这组规则来决定一个线程对共享变量的写入何时对另一个线程可见，JMM是围绕着程序执行的原子性，有序性，可见性展开的，对于原子问题，JMM自身提供了对基本数据类型读写操作的原子类型，可见性问题可以通过synchronized或者volatile关键字来解决，Happens-before原则也保证了多线程环境下两个操作间的可见性、有序性，同时volatile还能禁止指令重排，synchronized和Lock操作来实现有序性。</p><h2 id="as-if-serial规则和happens-before规则"><a href="#as-if-serial规则和happens-before规则" class="headerlink" title="as-if-serial规则和happens-before规则"></a>as-if-serial规则和happens-before规则</h2><blockquote><p>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。</p><p>as-if-serial语义和happens-before都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</p></blockquote><h3 id="happens-before规则："><a href="#happens-before规则：" class="headerlink" title="happens-before规则："></a>happens-before规则：</h3><p>happens-before是Java内存模型最核心的概念，在设计Java内存模型时，需要考虑两个关键因素：程序员对内存模型的使用以及编译器和处理器对内存模型的实现。程序员希望内存模型易于理解、易于编程，因此希望基于一个强内存模型来编写代码；而编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。</p><p>happens-before规则的目的就是为程序员提供足够强的内存可见性保证，同时对编译器和处理器的限制尽可能地放松。</p><p><strong>happens-before定义:</strong><br>1、如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前；<br>2、两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序执行，<strong>只要重排序的结果与按照happens-before执行的结果一致，那么JMM允许这种重排序</strong>。</p><p><strong>happens-before规则有哪些：</strong></p><ul><li>程序顺序原则：同一个线程内必须按照代码顺序执行；</li><li>锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁；</li><li>volatile规则：volitile变量的“写”先发生于“读”</li><li>线程启动规则：线程的start()方法先于它的每个动作</li><li>线程终止规则：线程的所有操作先于线程的结束</li><li>线程中断规则：对线程interrupt()方法的调用先于被中断线程的代码检测到中断事件的发生</li><li>传递性：A先于B，B先于C，那么A必然先于C。</li></ul><h1 id="并发关键字"><a href="#并发关键字" class="headerlink" title="并发关键字"></a>并发关键字</h1><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="synchronized关键字的三种使用方式"><a href="#synchronized关键字的三种使用方式" class="headerlink" title="synchronized关键字的三种使用方式"></a>synchronized关键字的三种使用方式</h3><ul><li>修饰实例方法</li><li>修饰静态方法</li><li>修饰代码块</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedUseTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * synchronized修饰实例方法</span><span class="hljs-comment">     */</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountSync</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;                increase();            &#125;            <span class="hljs-comment">//使用同步代码块进行同步操作，所对象是instance</span>            <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)&#123;            sum++;            &#125;            &#125;        &#125;<span class="hljs-comment">//如果修饰的是实例方法，那么只有同一对象实例绑定的不同线程访问才能输出正确结果</span><span class="hljs-comment">//如果修饰的是类方法，只要是当前类下的实例，都能正常得到正确结果</span>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span> </span>&#123;            sum++;        &#125;    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        AccountSync instance = <span class="hljs-keyword">new</span> AccountSync();        Thread t1 = <span class="hljs-keyword">new</span> Thread(instance);        Thread t2 = <span class="hljs-keyword">new</span> Thread(instance);<span class="hljs-comment">//</span>        t1.start();        t2.start();        t1.join();        t2.join();        System.out.println(sum);    &#125;&#125;</code></pre></div><h3 id="synchronized底层语义原理"><a href="#synchronized底层语义原理" class="headerlink" title="synchronized底层语义原理"></a>synchronized底层语义原理</h3><ul><li>Java虚拟机中的同步是基于<strong>进入和退出管程(Monitor)对象</strong>实现的。</li><li>在JVM中，对象在内存中的布局分为：对象头、实例数据和对齐填充三部分，实例数据用来存放类的属性数据信息，Java对象头中就存放了synchronized使用的锁对象；</li><li>synchronized修饰的<strong>代码块</strong>的实现使用的是<code>monitorenter</code>和 <code>monitorexit</code>指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置。</li><li>synchronized修饰的<strong>方法</strong>通过<code>ACC_SYNCHRONIZED</code>标识来指明该方法是一个同步方法，JVM通过该ACC_SYNCHRONIZED访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</li><li>重入锁是因为底层维护了一个计数器，当计数器值为0时，表明该锁未被任何线程所持有，其他线程可以竞争获得锁。</li></ul><h3 id="使用synchronized关键字实现单例模式"><a href="#使用synchronized关键字实现单例模式" class="headerlink" title="使用synchronized关键字实现单例模式"></a>使用synchronized关键字实现单例模式</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonBySynchronized</span> </span>&#123;<span class="hljs-comment">//因为指令重排的特性，所以这里必须加volatile修饰</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> SingletonBySynchronized uniqueInstance;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SingletonBySynchronized</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonBySynchronized <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(uniqueInstance == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">synchronized</span> (SingletonBySynchronized<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>&#123;                <span class="hljs-keyword">if</span>(uniqueInstance == <span class="hljs-keyword">null</span>)&#123;                    uniqueInstance = <span class="hljs-keyword">new</span> SingletonBySynchronized();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> uniqueInstance;    &#125;&#125;</code></pre></div><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><p><strong>锁消除</strong><br>通过<strong>逃逸分析</strong>来对检测出不可能存在竞争的共享数据的锁进行消除，如果堆上的共享数据不可能逃逸出去被其他线程访问到，那么就可以把它们当做私有数据来对待，从而消除锁。</p><p><strong>偏向锁</strong><br>偏向锁是JDK6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作，耗时)的代价而引入偏向锁。</p><p>偏向锁的核心思想是：如果一个线程获得了锁，那么锁就进入偏向模式，此时<strong>Mark Word</strong> 的结构也变为偏向锁结构，<strong>当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提高程序的性能。</strong></p><p>所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这种场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p><p><strong>轻量级锁</strong><br>轻量级锁能够提升程序性能的依据是“<strong>对绝大部分的锁，在整个同步周期内都不存在竞争</strong>”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是<strong>线程交替执行同步块</strong>的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</p><p><strong>自旋锁</strong><br>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。</p><p>这是因为<strong>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时如果所有等待的线程都进入阻塞队列，那么会产生用户态和内核态切换的问题，造成的开销非常大</strong>，因此可以在synchronized 的边界做忙循环（自旋），如果循环多次还没有获得锁再阻塞，由于忙循环也要占用CPU时间，所以自旋锁只适用于共享数据的锁定状态很短的场景。</p><p><strong>锁粗化</strong><br>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。如果一串零碎的操作都是对同一个对象加锁，可以将加锁的范围扩展，提高性能。</p><h3 id="线程中断与synchronized"><a href="#线程中断与synchronized" class="headerlink" title="线程中断与synchronized"></a>线程中断与synchronized</h3><p>“中断”是指线程在运行过程中打断其运行，在Java中，提供了3个有关线程中断的方法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//中断线程（实例方法）</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> Thread.interrupt(); <span class="hljs-comment">//判断线程是否被中断（实例方法）</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> Thread.isInterrupted(); <span class="hljs-comment">//判断线程是否被中断并清除当前中断状态（静态方法）</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> Thread.interrupted();</code></pre></div><p>当一个线程处于被阻塞状态或者试图执行一个阻塞操作时，使用<code>Thread.interrupt()</code>方法可以中断该线程，此时将抛出一个InterruptedException异常，同时中断状态将会被复位（由中断状态变为非中断状态）</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterruptSleepThread</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        Thread t1 = <span class="hljs-keyword">new</span> Thread()&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;                        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);                        System.out.println(<span class="hljs-string">"没有进入中断"</span>);                    &#125;                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    System.out.println(<span class="hljs-string">"Interrupted When Sleep"</span>);                    <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">this</span>.isInterrupted();                    System.out.println(<span class="hljs-string">"interrupt:"</span>+interrupted);                &#125;            &#125;        &#125;;        t1.start();        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);        t1.interrupt();    &#125;&#125;</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200629214856960.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>如果是运行期非阻塞状态的线程，那么直接调用Thread.interrupt()中断线程是不会得到响应的，因为处于非阻塞状态的线程需要手动进行检测并结束程序，如下所示：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterruptSleepThread</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        Thread t1 = <span class="hljs-keyword">new</span> Thread()&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isInterrupted()) &#123;                        System.out.println(<span class="hljs-string">"线程中断"</span>);                        <span class="hljs-keyword">break</span>;                    &#125;                &#125;                System.out.println(<span class="hljs-string">"已跳出循环，线程中断"</span>);            &#125;        &#125;;        t1.start();        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);        t1.interrupt();    &#125;&#125;</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200629215407767.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>总结：</strong></p><ul><li>当线程处于阻塞状态或者试图执行一个阻塞操作时，我们可以使用实例方法interrupt()进行线程中断，执行中断操作后将抛出interruptException异常（该异常必须捕获，无法向外抛出），并将中断状态复位；</li><li>当线程处于运行状态时，我们也可以调用实例方法interrupt()进行线程中断，但同时必须手动判断中断状态，并编写中断线程的代码(结束run方法的代码)</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>Java提供了volatile关键字来保证<strong>内存可见性</strong>和<strong>禁止指令重排</strong>，volatile提供happens-before的保证，确保一个线程的修改能对其他线程是可见的，当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p><p><strong>volatile不能保证原子性，所以一般与CAS结合使用</strong>；</p><h3 id="volatile原理，为什么能保证共享变量可见性"><a href="#volatile原理，为什么能保证共享变量可见性" class="headerlink" title="volatile原理，为什么能保证共享变量可见性"></a>volatile原理，为什么能保证共享变量可见性</h3><p>为了提高处理器的执行速度，在处理器和内存之间增加了多级缓存来提升，因为多级缓存就有可能导致缓存数据不一致问题。</p><p>对于volatile变量，当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中，根据缓存一致性协议：<strong>每个处理器通过嗅探在总线上传播的数据来检查自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器要对这个数据进行修改操作的时候，就会强制重新从系统内存里把数据读到处理器缓存中。</strong></p><h3 id="volatile如何禁止指令重排"><a href="#volatile如何禁止指令重排" class="headerlink" title="volatile如何禁止指令重排"></a>volatile如何禁止指令重排</h3><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入<strong>内存屏障</strong>来禁止特定类型的处理器重排序，有下面四种策略：</p><ul><li><p>在每个volatile写操作的前面插入一个StoreStore屏障</p><p>保证在volatile写之前，其前面的所有普通写操作已经对任意处理器可见了。</p></li><li><p>在每个volatile写操作的后面插入一个StoreLoad屏障</p><p>避免volatile写与后面可能有的volatile读/写操作重排序；</p></li><li><p>在每个volatile读操作的后面插入一个LoadLoad屏障</p><p>用来禁止处理器把上面的volatile读与下面的普通读重排序</p></li><li><p>在每个volatile读操作的后面插入一个LoadStore屏障</p><p>禁止处理器把上面的volatile读与下面的普通写重排序</p></li></ul><h2 id="synchronized和volatile的区别是什么"><a href="#synchronized和volatile的区别是什么" class="headerlink" title="synchronized和volatile的区别是什么"></a>synchronized和volatile的区别是什么</h2><p>synchronized表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程；<br>volatile表示变量在CPU的寄存器中是不确定的，必须从主存中读取，保证多线程环境下变量的可见性，以及禁止指令重排序。</p><p>主要区别如下：</p><ul><li>volatile是变量修饰符；synchronized可以修饰类，方法，变量，代码块；</li><li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性；</li><li>volatile不会造成线程的阻塞，synchronized可能会造成线程的阻塞；</li><li>volatile标记的变量不会被编译器优化，synchronized标记的变量可以被编译器优化；</li></ul><h2 id="final和并发的关系"><a href="#final和并发的关系" class="headerlink" title="final和并发的关系"></a>final和并发的关系</h2><p>不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p><h1 id="Lock体系"><a href="#Lock体系" class="headerlink" title="Lock体系"></a>Lock体系</h1><h2 id="Synchronized与Lock的区别"><a href="#Synchronized与Lock的区别" class="headerlink" title="Synchronized与Lock的区别"></a>Synchronized与Lock的区别</h2><p><strong>存在层次：</strong></p><ul><li><p>synchronized属于JVM层面；</p></li><li><p>Lock是一个接口，属于JDK层面；</p></li></ul><p><strong>锁的释放：</strong></p><ul><li><p>synchronized一旦获取锁的线程执行完同步代码，会自动释放锁，当线程发生异常也会释放锁；</p></li><li><p>Lock必须在finally中手动释放锁，不然容易造成线程死锁；</p></li></ul><p><strong>锁的获取：</strong></p><ul><li>synchronized中，假设A线程获得锁，B线程等待，如果A线程阻塞，B线程会一直等待；</li><li>Lock有多个获取锁的方式，可以通过tryLock来尝试获取锁，线程可以不用一直等待；</li></ul><p><strong>锁状态：</strong></p><ul><li>synchronnized：无法判断</li><li>Lock：可以判断</li></ul><p><strong>锁类型：</strong></p><ul><li>synchronized：可重入，不可中断，非公平</li><li>Lock：可重入，可判断，可公平</li></ul><p><strong>性能：</strong></p><ul><li>synchronized：少量同步</li><li>Lock：可以提高多个线程进行读操作的效率（通过readwriteLock实现读写分离），在资源竞争不是很激烈的情况下，synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；ReentrantLock还提供有时间限制的同步，可以被中断的同步等。</li></ul><h2 id="Lock和synchronized的比较"><a href="#Lock和synchronized的比较" class="headerlink" title="Lock和synchronized的比较"></a>Lock和synchronized的比较</h2><p>Lock接口比同步方法和同步代码块提供了更具扩展性的锁操作，主要优势有：</p><ol><li>可以使锁更公平</li><li>可以使线程在等待锁的时候<strong>响应中断</strong>；</li><li>可以让线程<strong>尝试获取锁</strong>，并在无法获取锁的时候立即返回或者等待一段时间；<ol start="4"><li>能够<strong>超时获取</strong>锁，在指定的截止时间之前获取锁，如果截止时间到了仍未获取锁，则返回；</li><li>可以在不同的范围，以不同的顺序获取和释放锁</li></ol></li></ol><h2 id="乐观锁如何实现"><a href="#乐观锁如何实现" class="headerlink" title="乐观锁如何实现"></a>乐观锁如何实现</h2><p>1、使用<strong>版本标识</strong>来确定读到的数据与提交时的数据是否一致，提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略；<br>2、CAS，当多个线程尝试使用CAS同时修改同一个变量时，只有其中一个线程能更新变量的值，而其他线程都失败，失败的线程并不会被挂起，而是被告知这次竞争失败了，可以再次尝试。CAS操作包含三个操作数–需要读取的内存位置（V）、进行比较的预期原值（A）和拟写入的新值（B），<strong>如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置的值更新为新值B，否则处理器不做任何操作</strong>。</p><h2 id="CAS会产生什么问题"><a href="#CAS会产生什么问题" class="headerlink" title="CAS会产生什么问题"></a>CAS会产生什么问题</h2><p><strong>1、ABA问题：</strong><br>JDK1.5的atomic包里提供了一个类<code>AtomicStampedReference</code>来解决ABA问题;<br><strong>2、循环时间长开销大：</strong><br>对于资源竞争严重的情况，CAS自旋的概率比较大，会浪费很多CPU资源，效率低于synchronized；<br><strong>3、只能保证一个共享变量的原子操作：</strong><br>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候可以使用锁。</p><h2 id="死锁、活锁、饥饿的区别"><a href="#死锁、活锁、饥饿的区别" class="headerlink" title="死锁、活锁、饥饿的区别"></a>死锁、活锁、饥饿的区别</h2><ul><li>死锁：是指两个或以上的线程在执行过程中，因为争夺资源而造成的一种相互等待的现象，若无外力作用，它们都将无法推进下去；</li><li>活锁：处于活锁的实体在不断的改变状态，活锁有可能自行解开；</li><li>饥饿：一个或者多个线程因为种种原因无法获得所需的资源，导致一直无法执行的状态。主要原因是：高优先级线程吞噬所有的低优先级线程的CPU时间，线程在等待一个本身也处于等待完成的对象，线程被永久阻塞在一个等待进入同步块的状态。</li></ul><h2 id="AQS（AbstractQueuedSynchronizer）"><a href="#AQS（AbstractQueuedSynchronizer）" class="headerlink" title="AQS（AbstractQueuedSynchronizer）"></a>AQS（AbstractQueuedSynchronizer）</h2><p>AQS又称<strong>队列同步器</strong>，是一个用来<strong>构建锁或其他同步组件的基础框架</strong>。我们常用的比如：ReentrantLock、Semphore、ReentrantReadWriteLock、FutureTask等基础类库都是基于AQS实现的。</p><p><strong>原理：</strong><br>AQS的核心思想是：<strong>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态；如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p><p><strong>AQS对资源的共享方式：</strong></p><ul><li>Exclusive(独占)：只有一个线程能执行,又可以分为公平锁和非公平锁</li><li>Share(共享)：多个线程可同时执行，如Semaphore/CountDownLatch等。</li></ul><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>ReadWriteLock是一个读写锁接口，读写锁是用来提升并发程序性能的锁分离技术，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读与读之间不会互斥，读与写，写与读，写与写之间才会互斥，提升了读写的性能。</p><h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="为什么要使用ConcurrentHashMap？"><a href="#为什么要使用ConcurrentHashMap？" class="headerlink" title="为什么要使用ConcurrentHashMap？"></a>为什么要使用ConcurrentHashMap？</h3><p>因为多线程会导致HashMap的<strong>Entry链表形成环型数据结构</strong>，一旦形成环型数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。</p><p>而使用HashTable因为是对整张表加锁，效率非常低下。</p><h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><p>ConcurrentHashMap 是一个 <strong>Segment 数组</strong>，Segment是ConcurrentHashMap的静态内部类，它通过<strong>继承 ReentrantLock 来进行加锁（分段锁）</strong>，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p><p>ConcurrentHashMap 默认有 16 个 Segment，所以最多可以同时支持 16 个线程并发写，这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</p><p>每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p><p>Segment内部持有一个<strong>HashEntry数组</strong>（哈希表），并且保证所有对该数组的增删改查方法都是线程安全的。我们通过<code>segmentForHash</code>方法获取分段锁的位置，再根据<code>entryForHash</code>方法获取元素的位置。如果当前元素位置有值，则采用<strong>头插法</strong>的方式将数据插入链表头部。</p><h4 id="扩容操作："><a href="#扩容操作：" class="headerlink" title="扩容操作："></a>扩容操作：</h4><p><strong>判断是否需要扩容：</strong>在插入元素前会先判断Segment里的HashEntry数组是否超过阈值（threshold），如果超过阈值，则对数组进行扩容。值得一提的是，Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断是否已经到达容量的，如果达到了就进行扩容，但是很有可能扩容之后没有新元素再插入，这时HashMap就进行了一次无效的扩容。</p><p><strong>如何扩容：</strong>在扩容的时候，首先会创建一个容量是原来容量两倍的数组，然后将原来数组里的元素进行再散列后插入到新的数组里。为了高效，ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment扩容。</p><h3 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h3><p>引入了红黑树，同时抛弃了原有的Segment锁，采用<code>Node+CAS+synchronized</code>来保证并发安全性，这样使得锁的粒度更小，并发程度更高。</p><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p><strong>设计思想：</strong></p><ul><li>读写分离，读和写分开</li><li>最终一致性</li><li>使用另外开辟空间的思路来解决并发冲突</li></ul><p><strong>优缺点：</strong><br>优点：<br>当多个迭代器同时遍历和修改这个列表时，不会抛出<code>ConcurrentModificationException</code>。在CopyOnWriteArrayList 中，<strong>写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。</strong><br>缺点：</p><ul><li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 <code>young gc</code>或者<code>full gc</code>。</li><li><strong>不能用于实时读的场景</strong>，像拷贝数组、新增元素都需要时间，所以调用一个 <code>set</code>操作后，读取到数据可能还是旧的，虽然CopyOnWriteArrayList 能做到最终一致性,但是没法满足实时性要求。</li><li>由于实际使用中可能没法保证 CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次 add/set 都要重新复制数组，这个代价实在太高了。在高性能的互联网应用中，这种操作分分钟引起故障。</li></ul><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal与线程同步机制不同，线程同步机制是多个线程共享同一变量，而<strong>ThreadLocal是为每个线程创建一个单独的变量副本，故而每个线程都可以独立地改变自己所拥有的变量副本，而不会影响其他线程所对应的副本</strong>，可以这么说，ThreadLocal为多线程环境下变量问题提供了另外一种解决思路。</p><p>ThreadLocal定义了四个方法：</p><ul><li>get()：返回此线程局部变量的当前线程副本中的值；</li><li>initialValue()：返回此线程局部变量的当前线程的“初始值”；</li><li>remove()：移除此线程局部变量的当前线程的值；</li><li>set(T value)：将此线程局部变量的当前线程副本中的值设置为指定值，<strong>采用的是开放地址法</strong>。</li></ul><p>ThreadLocal内部还有一个静态内部类<code>ThreadLocalMap</code>，它提供了一种用<strong>键值对</strong>方式存储每一个线程的变量副本的方法，key为当前ThreadLocal对象，value则是对应线程的变量副本，ThreadLocal定义的四个方法都是对ThreadLocalMap来进行操作，ThreadLocal实例本身并不存储值，它只是提供了一个在当前线程中找到副本值的key。</p><p><img src="https://img-blog.csdnimg.cn/20200630103553512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>ThreadLocal的内存泄漏问题</strong><br>每个Thread都有一个ThreadLocal.ThreadLocalMap的map，该map的key为ThreadLocal实例，它为一个弱引用，我们知道弱引用有利于GC回收。当ThreadLocal的key == null时，GC就会回收这部分空间，但是value却不一定能够被回收，因为它还与Current Thread存在一个强引用关系，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200630105440645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>由于存在这个强引用关系，会导致value无法回收。如果这个线程对象不会销毁，那么这个强引用关系则会一直存在，就会出现内存泄漏情况。<br><strong>解决方法：</strong><br>在ThreadLocalMap中的setEntry()、getEntry()，如果遇到key == null的情况，会对value设置为null。当然我们也可以在使用完ThreadLocal方法后调用remove()方法进行处理。</p><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>阻塞队列是一个支持两个附加操作的队列，在队列为空时，获取元素的线程会等待队列变为非空，当队列满时，存储元素的线程会等待队列可用。</p><p>阻塞队列使用最经典的场景就是 socket 客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h2><p>因为在面向对象编程中，创建和销毁对象很费时，为了提高程序效率，可以利用线程池来减少创建和销毁对象的次数。</p><p>线程池就是实现创建若干个可执行的线程放入一个容器中，需要的时候从池中获取线程，使用完毕后放回池中，从而减少了线程的创建和销毁带来的开销。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Executor</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span></span>;&#125;</code></pre></div><p>Executors是一个工具类，提供了一些<strong>静态工厂方法</strong>用于生成一些常用的线程池，如：</p><ul><li><p><strong>newSingleThreadExecutor</strong>：创建一个单线程的线程池，这个线程池只有一个线程在工作，保证所有任务的执行顺序按照任务的提交顺序执行；</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService            (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                                    <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));    &#125;</code></pre></div></li><li><p><strong>newFixedThreadPool</strong>：创建固定大小的线程池，线程池的大小一旦到达固定值，就会保持不变，适合在服务器上使用（性能好）。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,                                     <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                                     <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());   &#125;</code></pre></div></li><li><p><strong>newCachedThreadPool</strong>：创建一个可缓存的线程池，线程池的线程数量可以随着任务数自行加减，线程池的大小由JVM决定，这里使用的是异步队列SynchronousQueue，而且是非公平的；</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,                                      <span class="hljs-number">60L</span>, TimeUnit.SECONDS,                                      <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());    &#125;</code></pre></div></li><li><p><strong>newScheduledThreadPool</strong>：创建一个大小无限的线程池，此线程池支持<strong>定时以及周期性执行任务</strong>的需求。</p></li></ul><h2 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h2><ul><li>降低资源消耗：减少线程创建，销毁带来的开销；</li><li>提高响应速度：能够提高系统资源的使用率；</li><li>提高线程的可管理性：线程资源很宝贵，如果随意创建线程，会带来一些不好的影响，利用线程池可以进行统一的分配、调度和监控；</li><li>附加功能：提供定时执行、单线程、并发数控制等功能。</li></ul><h2 id="线程池的主要处理流程"><a href="#线程池的主要处理流程" class="headerlink" title="线程池的主要处理流程"></a>线程池的主要处理流程</h2><ol><li>判断<strong>核心线程池</strong>是否已满，如果不是，则创建一个新的工作线程来执行任务；</li><li>如果核心线程池满了，判断<strong>工作队列</strong>是否已经满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里；</li><li>如果工作队列满了，判断<strong>线程池</strong>是否已满，如果线程池没满，创建线程执行任务；</li><li>如果线程池也满了，就按照<strong>饱和策略</strong>来处理无法执行的任务。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200630140201518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2><ul><li>RUNNING：正常状态</li><li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务</li><li>STOP：不接受新的任务提交，也不再处理等待队列中的任务，同时还中断正在执行任务的线程 ；</li><li>TIDYING：</li><li>TERMINATED：执行terminated()方法以后</li></ul><h2 id="Executor和Executors的区别"><a href="#Executor和Executors的区别" class="headerlink" title="Executor和Executors的区别"></a>Executor和Executors的区别</h2><ul><li>Executors工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求</li><li>Executor接口对象能够执行我们的线程任务</li><li>ExecutorSerivice接口继承了Executor接口并扩展了功能，主要是我们能获得任务执行的状态并且可以获得任务的返回值</li><li>Future表示异步计算的结果，它提供了检查计算是否完成的方法，以等待计算的完成，可以使用get()方法来获取计算的结果。</li></ul><h2 id="线程池中submit-和execute-方法的区别"><a href="#线程池中submit-和execute-方法的区别" class="headerlink" title="线程池中submit()和execute()方法的区别"></a>线程池中submit()和execute()方法的区别</h2><ul><li>接收参数：execute只能执行Runnable类型的任务，submit可以执行Runnable和Callable类型的任务；</li><li>返回值：submit方法可以返回持有计算结果的Future对象，而execute没有</li><li>异常处理：submit更方便异常处理</li></ul><h2 id="ThreadPoolExecutor和Executors的区别"><a href="#ThreadPoolExecutor和Executors的区别" class="headerlink" title="ThreadPoolExecutor和Executors的区别"></a>ThreadPoolExecutor和Executors的区别</h2><p>《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，这是因为：</p><ul><li>newFixedThreadPool 和 newSingleThreadExecutor:<br>主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。</li><li>newCachedThreadPool 和 newScheduledThreadPool:<br>主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM。</li></ul><p>而T<strong>hreaPoolExecutor创建线程池方式只有一种，就是走它的构造函数，参数自己指定，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</strong></p><h2 id="ThreadPoolExecutor构造函数的参数分析"><a href="#ThreadPoolExecutor构造函数的参数分析" class="headerlink" title="ThreadPoolExecutor构造函数的参数分析"></a>ThreadPoolExecutor构造函数的参数分析</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit,</span></span><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><span class="hljs-function"><span class="hljs-params">                          RejectedExecutionHandler handler)</span> </span>&#123;    <span class="hljs-keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,         Executors.defaultThreadFactory(), handler);&#125;</code></pre></div><p><strong>核心参数</strong></p><ul><li><strong>corePoolSize</strong> ：核心线程数，线程数定义了最小可以同时运行的线程数量。</li><li><strong>maximumPoolSize</strong> ：线程池中允许存在的工作线程的最大数量；</li><li><strong>workQueue</strong>：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被存放在队列中。<ul><li>ArrayBlockingQueue：是一个基于数组结构的<strong>有界阻塞</strong>队列，此队列按FIFO（先进先出）原则对元素进行排序。</li><li>LinkedBlockingQueue：一个基于链表结构的<strong>无界阻塞</strong>队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li><li>PriorityBlockingQueue：一个具有优先级的无届阻塞队列。</li></ul></li></ul><p><strong>其他参数</strong></p><ul><li><strong>keepAliveTime</strong>：线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime才会被回收销毁；</li><li><strong>unit</strong> ：keepAliveTime 参数的时间单位。</li><li><strong>threadFactory</strong>：为线程池提供创建新线程的线程工厂；</li><li><strong>handler</strong> ：线程池任务队列超过 maxinumPoolSize 之后的拒绝策略。</li></ul><h2 id="ThreadPoolExecutor饱和策略"><a href="#ThreadPoolExecutor饱和策略" class="headerlink" title="ThreadPoolExecutor饱和策略"></a>ThreadPoolExecutor饱和策略</h2><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经满了时，就会触发饱和策略，主要有：</p><ul><li><code>ThreadPoolExecutor.AbortPolicy</code>：抛出RejectedExecutionException来拒绝新任务的处理。（默认使用）</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：通过增加队列容量来不丢弃任何一个任务请求，会降低新任务提交的速度，影响整体性能。</li><li><code>ThreadPoolExecutor.DiscardPolicy</code>：不处理新任务，直接丢弃掉。</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>： 此策略将丢弃最早的未处理的任务请求。</li></ul><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>一个可取消的异步计算，FutureTask提供了对Future的基本实现，可以调用方法去开始或取消一个计算，可以查询计算是否完成并且获取计算结果。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FutureTaskDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, TimeoutException, ExecutionException </span>&#123;        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);        FutureTask&lt;String&gt; heatUpWaterFuture = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                System.out.println(<span class="hljs-string">"烧开水"</span>);                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);                System.out.println(<span class="hljs-string">"烧水用时："</span>+(System.currentTimeMillis()-startTime)+<span class="hljs-string">"ms"</span>);                <span class="hljs-keyword">return</span> <span class="hljs-string">"ok"</span>;            &#125;        &#125;);        FutureTask&lt;String&gt; cookMealsFuture = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                System.out.println(<span class="hljs-string">"煮饭"</span>);                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);                System.out.println(<span class="hljs-string">"煮饭用时："</span>+(System.currentTimeMillis()-startTime)+<span class="hljs-string">"ms"</span>);                <span class="hljs-keyword">return</span> <span class="hljs-string">"ok"</span>;            &#125;        &#125;);        executorService.submit(heatUpWaterFuture);        executorService.submit(cookMealsFuture);        System.out.println(<span class="hljs-string">"炒菜"</span>);        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);        System.out.println(<span class="hljs-string">"菜炒好了"</span>);        <span class="hljs-keyword">if</span>(heatUpWaterFuture.get(<span class="hljs-number">50</span>,TimeUnit.SECONDS) == <span class="hljs-string">"ok"</span>                &amp;&amp; cookMealsFuture.get(<span class="hljs-number">50</span>,TimeUnit.SECONDS) == <span class="hljs-string">"ok"</span>)&#123;            System.out.println(<span class="hljs-string">"开饭了"</span>);        &#125;        <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();        System.out.println(<span class="hljs-string">"做饭用时："</span>+ (endTime-startTime) + <span class="hljs-string">"ms"</span>);                System.exit(<span class="hljs-number">0</span>);    &#125;&#125;</code></pre></div><p>在实际开发过程中，<strong>将那些耗时较长，且可以并行的操作都封装成一个FutureTask</strong>，该类提供了Future的基本实现，提供了启动和取消计算、查询计算是否完成以及检索计算结果的方法。<br>FutureTask的实现是基于 AbstractQueuedSynchronizer，FutureTask 声明了一个内部私有的继承于 AQS 的子类 Sync，对 FutureTask 所有公有方法的调用都会委托给这个内部子类。</p><p>当FutureTask处于未启动或者已启动的状态时，调用FutureTask对象的get方法将会导致调用线程阻塞，当FutureTask处于已完成的状态时，调用FutureTask的get 方法会立即返回调用结果或者抛出异常。</p><p>当FutureTask处于未启动状态时，调用FutureTask对象的cancel方法将导致线程永远不会被执行，当FutureTask处于已启动状态时，调用FutureTask对象cancel（true）方法将以中断执行此任务的线程的方式来试图停止此任务，调用cancel（false）方法将不会对正在进行的任务产生任何影响；当FutureTask处于已完成状态时，调用FutureTask对象的cancel方法将会返回false。</p><h1 id="原子操作类atomicXXX的原理"><a href="#原子操作类atomicXXX的原理" class="headerlink" title="原子操作类atomicXXX的原理"></a>原子操作类atomicXXX的原理</h1><p>AtomicInteger类主要利用<code>CAS</code>+<code>volatile</code>和native方法来保证原子操作，避免了使用synchronized带来的高开销，执行效率大大提高。<br>部分源码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> valueOffset;<span class="hljs-keyword">static</span> &#123;<span class="hljs-keyword">try</span> &#123;valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField("value"));&#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(ex); &#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> value;</code></pre></div><p>CAS的原理是拿期望的值和原本的一个值做比较，如果相同则更新成新的值，UnSafe类的objectFieldOffset()方法是一个本地方法，用来拿到“原来的值”的内存地址，返回值是valueOffset，另外value是一个volatile变量，保证任何时刻线程总能拿到该变量的最新值。</p><h1 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch与CyclicBarrier都是用于<strong>控制并发的工具类</strong>，都可以理解成维护的就是一个计数器。</p><p>要实现主线程等待所有线程完成，可以使用<code>join()</code>用于让当前执行线程等待join线程执行结束，其实现原理是不停检查join线程是否存活，如果join线程存活，则让当前线程永远等待，join线程终止后，线程的this.notifyAll()方法会在JVM中被调用。</p><p>在CountDownLatch类内部定义了一个Sync内部类，这个内部类就是继承自<code>AbstractQueuedSynchronizer</code>的，并且重写了方法<code>tryAcquireShared</code>和<code>tryReleaseShared</code>。例如当调用 <code>awit()</code>方法时，CountDownLatch 会调用内部类Sync 的 <code>acquireSharedInterruptibly()</code> 方法，然后在这个方法中会调用 <code>tryAcquireShared</code> 方法，这个方法就是 CountDownLatch 的内部类 Sync 里重写的 AbstractQueuedSynchronizer 的方法。调用 <code>countDown()</code> 方法同理。</p><p>这种方式是使用 AbstractQueuedSynchronizer 的标准化方式，大致分为两步：</p><p>1、内部持有继承自 AbstractQueuedSynchronizer 的对象 Sync；</p><p>2、并在 Sync 内重写 AbstractQueuedSynchronizer类的protected部分或全部方法，这些方法包括如下几个：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();&#125;</code></pre></div><p>之所以要求子类重写这些方法，是为了让使用者（这里的使用者指 CountDownLatch 等）可以在其中加入自己的判断逻辑，例如 CountDownLatch 在 <code>tryAcquireShared</code>中加入了判断，判断 state 是否不为0，如果不为0，才符合调用条件。</p><p><code>tryAcquire</code>和<code>tryRelease</code>是对应的，前者是独占模式获取，后者是独占模式释放。</p><p><code>tryAcquireShared</code>和<code>tryReleaseShared</code>是对应的，前者是共享模式获取，后者是共享模式释放。</p><p>我们看到 CountDownLatch 重写的方法 tryAcquireShared 实现如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;    <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;&#125;</code></pre></div><p>判断 state 值是否为0，为0 返回1，否则返回 -1。state 值是 AbstractQueuedSynchronizer 类中的一个 volatile 变量。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;</code></pre></div><p>在 CountDownLatch 中这个 state 值就是计数器，在调用 await 方法的时候，将值赋给 state 。</p><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>CyclicBarrier让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被拦截的线程才会继续运行，可以用于多线程计算数据，最后合并计算结果的场景。</p><p><strong>区别：</strong></p><ul><li>CountDownLatch一般用于<strong>某个线程A等待一个或多个线程执行完任务之后，它才执行</strong>；而CyclicBarrier一般用于<strong>一组线程互相等待至某个状态，然后这一组线程再同时执行</strong>；CountDownLatch强调一个线程等待多个线程完成某件事情。CyclicBarrier是多个线程互等，等大家都完成，再携手共进。</li><li>调用CountDownLatch的countDown方法后，当前线程并不会阻塞，会继续往下执行；而调用CyclicBarrier的await方法，会阻塞当前线程，直到CyclicBarrier指定的线程全部都到达了指定点的时候，才能继续往下执行；</li><li>CountDownLatch方法比较少，操作比较简单，而CyclicBarrier提供的方法更多，比如能够通过getNumberWaiting()，isBroken()这些方法获取当前多个线程的状态，并且CyclicBarrier的构造方法可以传入barrierAction，指定当所有线程都到达时执行的业务功能；</li><li>CountDownLatch是不能复用的（计数器只能使用一次），而CyclicLatch是可以复用的（计数器可以使用reset()方法重置）。</li></ul><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore 就是一个信号量，它的作用是<strong>限制某段代码块的并发数</strong>（允许多个线程同时访问），Semaphore有一个构造函数，可以传入一个 int 型整数 n，表示某段代码最多只有 n 个线程可以访问，如果超出了 n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入，通过协调各个线程，以保证合理的使用公共资源，可以用来做流量控制。</p><h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>Exchanger是一个用于<strong>线程间协作</strong>的工具类，<strong>用于两个线程间交换数据</strong>。它提供了一个交换的同步点，在这个同步点两个线程能够交换数据。交换数据是通过exchange方法来实现的，如果一个线程先执行exchange方法，那么它会同步等待另一个线程也执行exchange方法，这个时候两个线程就都达到了同步点，两个线程就可以交换数据。</p><p>参考资料</p><p><a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/11/15/java-lock.html</a></p>]]></content>
    
    
    <categories>
      
      <category>语言相关</category>
      
      <category>Java进阶</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java异常</title>
    <link href="/2020/06/28/Java%E5%BC%82%E5%B8%B8/"/>
    <url>/2020/06/28/Java%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="Java异常架构"><a href="#Java异常架构" class="headerlink" title="Java异常架构"></a>Java异常架构</h1><p><img src="https://img-blog.csdnimg.cn/20200628160645434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h1><h2 id="捕获异常（try-catch）"><a href="#捕获异常（try-catch）" class="headerlink" title="捕获异常（try-catch）"></a>捕获异常（try-catch）</h2><p>如果知道如何处理该异常，就通过try…catch…来捕获异常，根据不同的异常进行不同的处理。</p><h2 id="声明异常（throws，必须处理）"><a href="#声明异常（throws，必须处理）" class="headerlink" title="声明异常（throws，必须处理）"></a>声明异常（throws，必须处理）</h2><p>如果不知道如何处理该异常，可以将该异常继续传递下去，此时可以在该异常出现的<strong>方法签名处</strong>使用<strong>throws</strong>关键字来声明可能抛出的异常。<br>注意：</p><ul><li>非受检异常（Error，RuntimeException或它们的子类）不可使用throws关键字来声明要抛出的异常；</li><li><strong>受检查异常：要么用 try … catch… 捕获，要么用 throws 声明抛出，交给父类处理。</strong></li><li>子类方法声明抛出的异常类型应该是父类方法声明抛出的异常类型的子类或相同，子类方法声明抛出的异常不允许比父类方法声明抛出的异常多</li></ul><h2 id="抛出异常（throw，不是必须处理）"><a href="#抛出异常（throw，不是必须处理）" class="headerlink" title="抛出异常（throw，不是必须处理）"></a>抛出异常（throw，不是必须处理）</h2><p>在<strong>方法内</strong>，用throw来抛出一个Throwable类型的异常。一旦遇到到throw语句，后面的代码将不被执行。然后，便是进行异常处理——包含该异常的try-catch最终处理，也可以向上层抛出。注意我们只能抛出Throwable类和其子类的对象。</p><h2 id="Throw和Throws的区别是什么？"><a href="#Throw和Throws的区别是什么？" class="headerlink" title="Throw和Throws的区别是什么？"></a>Throw和Throws的区别是什么？</h2><ul><li>throw关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受检异常和非受检异常都可以被抛出；</li><li>throws关键字用在方法声明上，可以声明多个异常，用来标识该方法可能抛出的异常列表，一个方法用throws标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理该异常的代码，否则也要在方法签名中用throws关键字声明相应的异常。</li></ul>]]></content>
    
    
    <categories>
      
      <category>语言相关</category>
      
      <category>Java基础</category>
      
      <category>Java异常体系</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java异常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合</title>
    <link href="/2020/06/28/Java%E9%9B%86%E5%90%88/"/>
    <url>/2020/06/28/Java%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h1><h2 id="集合和数组的区别"><a href="#集合和数组的区别" class="headerlink" title="集合和数组的区别"></a>集合和数组的区别</h2><ul><li>数组的长度是固定的；集合是可变长的；</li><li>数组中可以存储基本数据类型，也可以存储区引用数据类型；集合只能存储引用数据类型</li><li>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型</li></ul><h2 id="集合框架底层数据结构"><a href="#集合框架底层数据结构" class="headerlink" title="集合框架底层数据结构"></a>集合框架底层数据结构</h2><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul><li>ArrayList：Object数组</li><li>Vector：Object数组</li><li>LinkedList：双向循环链表</li></ul><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul><li>HashSet（无序，唯一）：基于HashMap实现，底层采用HashMap来保存元素</li><li>LinkedHashSet：LinkedHashSet继承于HashSet，并且其内部是通过LinkedHashMap来实现的。</li><li>TreeSet（有序，唯一）：红黑树</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li>HashMap：JDK1.8之前HashMap由<strong>数组+链表</strong>组成，数组是HashMap的主体，链表是为了解决哈希冲突而存在的（<strong>拉链法</strong>），JDK1.8以后当链表长度大于阈值8时，将链表转化为红黑树，以减少搜索时间；</li><li>LinkedHashMap：继承自HashMap，所以它的底层仍然是基于拉链式散列结构（即由数组+链表或红黑树）组成，不过在此基础上增加了一条<strong>双向链表</strong>，使得上面的结果可以<strong>保持键值对的插入顺序</strong>，同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li></ul><h2 id="哪些集合类是线程安全的？"><a href="#哪些集合类是线程安全的？" class="headerlink" title="哪些集合类是线程安全的？"></a>哪些集合类是线程安全的？</h2><ul><li>vector：效率低，不建议使用；</li><li>stack：继承自vector</li><li>Hashtable：</li><li>ConcurrentHashMap</li><li>Enumeration：枚举</li></ul><h2 id="Java集合的快速失效机制“fail-fast”"><a href="#Java集合的快速失效机制“fail-fast”" class="headerlink" title="Java集合的快速失效机制“fail-fast”"></a>Java集合的快速失效机制“fail-fast”</h2><p>“fail-fast”是Java集合的一种错误检测机制，当<strong>多个线程对集合进行结构上的改变操作</strong>时，就有可能产生fail-fast机制。</p><p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个<code>modCount</code>变量，集合在被遍历期间如果内容发生变化，就会改变modCount的值。<br>每当迭代器使用hasNext()/next()遍历下一个元素之前，都会检测modCount变量是否为预期的值，如果是就返回遍历，否则抛出异常，终止遍历。</p><p>解决办法：<br>1、在遍历过程中，所有涉及到改变modCount值的地方都加上synchronized；<br>2、使用CopyOnWriteArrayList来代替ArrayList</p><h1 id="Collection-1"><a href="#Collection-1" class="headerlink" title="Collection"></a>Collection</h1><h2 id="如何边遍历边移除Collection中的元素"><a href="#如何边遍历边移除Collection中的元素" class="headerlink" title="如何边遍历边移除Collection中的元素"></a>如何边遍历边移除Collection中的元素</h2><p>正确写法：</p><div class="hljs"><pre><code class="hljs java">Iterator&lt;Integer&gt; it = list.iterator();<span class="hljs-keyword">while</span>(it.hasNext())&#123;   *<span class="hljs-comment">// do something*</span>   it.remove();&#125;</code></pre></div><p>错误写法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(Integer i : list)&#123;   list.remove(i)&#125;</code></pre></div><p>原因：当使用foreach语句时，会自动生成一个iterator来遍历该list，但同时该list正在被Iterator.remove()修改，<strong>Java一般不允许一个线程在遍历Collection时另一个线程修改它。</strong></p><h2 id="如何实现数组与List之间的转换"><a href="#如何实现数组与List之间的转换" class="headerlink" title="如何实现数组与List之间的转换"></a>如何实现数组与List之间的转换</h2><ul><li>数组转List：使用Arrays.asList(array)进行转换；</li><li>List转数组：使用List自带的toArray方法。</li></ul><h2 id="ArrayLsit和Vector的区别是什么"><a href="#ArrayLsit和Vector的区别是什么" class="headerlink" title="ArrayLsit和Vector的区别是什么"></a>ArrayLsit和Vector的区别是什么</h2><ul><li>线程安全：Vector使用了Synchronized来实现线程同步，而ArrayList是非线程安全的；</li><li>性能：ArrayList在性能方面优于Vector；</li><li>扩容：ArrayList初始大小为10，每次进行1.5倍扩容，Vector进行2倍扩容。</li></ul><h2 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h2><ol><li>ArrayList是实现了基于动态数组的数据结构，LinkedList是基于链表结构。</li><li>对于随机访问的get和set方法，ArrayList要优于LinkedList，因为LinkedList要移动指针。</li><li>对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。</li></ol><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>CopyOnWriteArrayList是一个写时复制的容器，用读写分离的思想用来保证list的一致性，其实现是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行copy，复制出一个新的容器，然后在新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器；这样做的好处是我们可以对CopyOnWriteArrayList进行并发的读，而不需要加锁，而在其<strong>增删改</strong>的操作中都使用了独占锁ReetrantLock来保证某个时间只有一个线程能对list数组进行修改。</p><p>缺点：</p><ul><li>内存占用：在进行写操作的时候，内存里会同时驻扎两个对象的内存。</li><li>数据一致性问题：不能保证数据的实时一致性，只能保证数据的最终一致性。</li></ul><h2 id="List和Set的区别"><a href="#List和Set的区别" class="headerlink" title="List和Set的区别"></a>List和Set的区别</h2><p>List和Set都是继承自Collection接口</p><p>List特点：有序（元素存入集合的顺序和取出的顺序一致），元素可以重复，可以插入多个null元素；支持for循环，可以通过下标来遍历，查找元素效率高，插入删除元素效率低。</p><p>Set特点：无序，不可以存储重复元素，只允许存入一个null元素；只能通过迭代来获取数据，删除和插入效率高，检索元素效率低。</p><h1 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h1><h2 id="HashSet实现原理"><a href="#HashSet实现原理" class="headerlink" title="HashSet实现原理"></a>HashSet实现原理</h2><p>HashSet是基于HashMap实现的，HashSet的值存放于HashMap的<code>key</code>上，HashMap的value统一为<strong>PRESEENT</strong>，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来实现的。</p><h2 id="HashSet如何检查重复？HashSet如何保证数组不可重复？"><a href="#HashSet如何检查重复？HashSet如何保证数组不可重复？" class="headerlink" title="HashSet如何检查重复？HashSet如何保证数组不可重复？"></a>HashSet如何检查重复？HashSet如何保证数组不可重复？</h2><p>HashSet在添加元素时，通过比较hash值以及结合equals方法来比较，HashSet添加进去的值就是作为HashMap的key，<code>PRESENT</code>作为value是一个始终相等的虚值。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">()</span> </span>&#123;    map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span><span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;&#125;</code></pre></div><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><h2 id="在Queue中poll-和remove-有什么区别？"><a href="#在Queue中poll-和remove-有什么区别？" class="headerlink" title="在Queue中poll()和remove()有什么区别？"></a>在Queue中poll()和remove()有什么区别？</h2><ul><li>相同点：都是返回第一个元素，并在队列中删除返回的对象</li><li>不同点：<strong>如果队列中没有元素，调用poll()返回null，调用remove()则抛出异常</strong></li></ul><h1 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h1><h2 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h2><p>HashMap是基于哈希表的Map接口的非同步实现，允许使用null值和null键，此类不保证映射的顺序，HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p><p>HashMap基于Hash算法实现的：</p><ol><li>当我们往HashMap中put元素时，利用key的HashCode重新hash计算出当前对象的元素在数组中的下标;</li><li>在存储时，如果出现hash值相同的key，此时有两种情况：如果key相同，则覆盖原始值，如果key不同，则将当前的key-value放入链表中;</li><li>获取时，直接找到hash值对应的下标，再进一步判断key是否相同，从而找到对应值;</li><li>JDK1.8以后，当链表中的节点数据超过8个以后，该链表会转为<strong>红黑树</strong>来提高查询效率，从原来的O(n)到O(logn)。</li></ol><h2 id="HashMap的扩容操作是怎么实现的？"><a href="#HashMap的扩容操作是怎么实现的？" class="headerlink" title="HashMap的扩容操作是怎么实现的？"></a>HashMap的扩容操作是怎么实现的？</h2><p>1、在JDK1.8中，resize()方法是在HashMap中的键值对大于阈值时或者初始化时，就调用resize方法进行扩容；<br>2、每次扩容时，都是扩为原来的2倍；<br>3、扩展后的Node对象的位置要么在原位置，要么移动到原始位置+增加的数组大小的位置上。</p><h2 id="HashMap是如何有效解决Hash冲突的？"><a href="#HashMap是如何有效解决Hash冲突的？" class="headerlink" title="HashMap是如何有效解决Hash冲突的？"></a>HashMap是如何有效解决Hash冲突的？</h2><p>1、使用<strong>链地址法</strong>(拉链法)来连接拥有相同hash值的数据；<br>2、使用<strong>2次扰动函数</strong>（hash函数）来降低哈希冲突的概率，使得数据分布更平均；<br>3、引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</p><h2 id="HashMap的长度为什么是2的幂次方"><a href="#HashMap的长度为什么是2的幂次方" class="headerlink" title="HashMap的长度为什么是2的幂次方"></a>HashMap的长度为什么是2的幂次方</h2><p>为了能让HashMap存取高效，尽量减少碰撞，也就是尽量把数据分配均匀，另外在取余操作中如果除数是2的幂次方，则等价于与其除数减一的与（&amp;）操作（也就是说<strong>hash%length==hash&amp;(length-1)</strong>的前提是length是2的n次方），采用二进制位运算能够<strong>提高运算效率</strong>。</p><h2 id="HashMap和HashTable有什么区别"><a href="#HashMap和HashTable有什么区别" class="headerlink" title="HashMap和HashTable有什么区别"></a>HashMap和HashTable有什么区别</h2><ol><li>线程安全：HashMap非线程安全，HashTable线程安全，不过不建议使用，一般用ConcurrentHashMap；</li><li>效率：HashMap效率高于HashTable</li><li>对null key 和null value的支持：HashMap允许null作为键，但是只能有一个，可以有多个键所对应的值为null；HashTable中键值对都不允许为null</li><li>初始容量大小和每次扩容量大小：创建时如果不指定容量初始值，HashTable默认的初始值大小为11，之后每次扩容容量变为原来的2n+1，HashMap的初始容量为16，之后每次扩容为原来的2倍。</li></ol><h2 id="HashMap在JDK1-8做了什么优化"><a href="#HashMap在JDK1-8做了什么优化" class="headerlink" title="HashMap在JDK1.8做了什么优化"></a>HashMap在JDK1.8做了什么优化</h2><ul><li>JDK1.8增加了<strong>红黑树</strong>来进行优化，当链表长度超过8时，链表就转为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能；</li><li>在JDK1.7中<strong>，插入链表节点使用头插法</strong>，JDK1.8中变为了尾插法，这是因为头插法在并发下调用transfer()方法，可能会导致链表死循环，以及数据的丢失。</li><li>hash()方法，<strong>将hash值高位（前16位）参与到取模的运算中</strong>，使得计算结果的不确定性增强，降低发生哈希碰撞的概率。</li></ul><h2 id="ConcurrentHashMap在JDK1-8做了哪些优化？"><a href="#ConcurrentHashMap在JDK1-8做了哪些优化？" class="headerlink" title="ConcurrentHashMap在JDK1.8做了哪些优化？"></a>ConcurrentHashMap在JDK1.8做了哪些优化？</h2><p>ConcurrentHashMap在Java 8 里抛弃了Segment的概念，直接用<strong>Node数组+链表+红黑树</strong>的数据结构来实现，Node是ConcurrentHashMap存储结构的基本单元，继承于HashMap中的Entry，用于存储数据，<strong>并发控制使用Synchronized和CAS来操作。</strong></p><h2 id="HashMap-LinkedHashMap-TreeMap的区别？"><a href="#HashMap-LinkedHashMap-TreeMap的区别？" class="headerlink" title="HashMap,LinkedHashMap,TreeMap的区别？"></a>HashMap,LinkedHashMap,TreeMap的区别？</h2><p>区别：</p><ul><li>LinkedHashMap是继承于HashMap，是基于HashMap和<strong>双向链表</strong>来实现的。</li><li>HashMap无序；LinkedHashMap有序，可分为插入顺序和访问顺序两种。如果是访问顺序，那put和get操作已存在的Entry时，都会把Entry移动到双向链表的表尾(其实是先删除再插入)。</li><li>LinkedHashMap存取数据，还是跟HashMap一样使用的Entry[]的方式，双向链表只是为了保证顺序。</li><li>LinkedHashMap是线程不安全的。</li></ul><p>LinkedHashMap应用场景：</p><p>当我们希望有顺序地去存储key-value时，就需要使用LinkedHashMap。</p><p>TreeMap的用法（主要是<strong>排序</strong>）</p><p>TreeMap中默认的排序是升序，如果要改变其排序可以自己写一个Comparator，重写其compare()方法。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Compare</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        TreeMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;String, Integer&gt;(<span class="hljs-keyword">new</span> xbComparator());        map.put(<span class="hljs-string">"192.168.1.11"</span>, <span class="hljs-number">1</span>);        map.put(<span class="hljs-string">"193.168.2.11"</span>, <span class="hljs-number">1</span>);        map.put(<span class="hljs-string">"192.128.1.11"</span>, <span class="hljs-number">1</span>);        map.put(<span class="hljs-string">"192.168.1.12"</span>, <span class="hljs-number">1</span>);        map.put(<span class="hljs-string">"192.168.1.31"</span>, <span class="hljs-number">1</span>);        Set&lt;String&gt; keys = map.keySet();        Iterator&lt;String&gt; iterator = keys.iterator();        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;            String next = iterator.next();            System.out.println(<span class="hljs-string">" "</span> + next + <span class="hljs-string">":"</span> + map.get(next));        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">xbComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;        String s1 = (String) o1;        String s2 = (String) o2;        <span class="hljs-keyword">return</span> s2.compareTo(s1);    &#125;&#125;</code></pre></div><h1 id="辅助工具类"><a href="#辅助工具类" class="headerlink" title="辅助工具类"></a>辅助工具类</h1><h2 id="comparable"><a href="#comparable" class="headerlink" title="comparable"></a>comparable</h2><p>Comparable是<strong>排序接口</strong>，若一个类实现了Comparable接口，就意味着“该类支持排序”，也就是说实现了Comparable接口的类的对象的列表或数组可以通过<code>Collections.sort()</code>或<code>Arrays.sort()</code>进行排序。</p><p>Comparable接口仅仅只包含一个函数，它的定义如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<span class="hljs-keyword">import</span> java.util.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(T o)</span></span>;&#125;</code></pre></div><p>假设我们通过x.compareTo(y)来比较x和y的大小，若返回负数，意味着x比y小，返回0，说明相等，返回正数，说明x比y大。</p><p>现在我们假设一个Person类，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><span class="hljs-class"></span>&#123;    String name;    <span class="hljs-keyword">int</span> age;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span></span>&#123;        <span class="hljs-keyword">super</span>();        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;&#125;</code></pre></div><p>现在有两个Person类的对象，我们如何来比较二者的大小呢？我们可以通过让Person实现Comparable接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Person</span>&gt;</span><span class="hljs-class"></span>&#123;    String name;    <span class="hljs-keyword">int</span> age;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">super</span>();        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Person p)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age-p.getAge();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Person[] people=<span class="hljs-keyword">new</span> Person[]&#123;            <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"xujian"</span>, <span class="hljs-number">20</span>),<span class="hljs-keyword">new</span> Person(<span class="hljs-string">"xiewei"</span>, <span class="hljs-number">10</span>)        &#125;;        System.out.println(<span class="hljs-string">"排序前"</span>);        <span class="hljs-keyword">for</span> (Person person : people) &#123;            System.out.print(person.getName()+<span class="hljs-string">":"</span>+person.getAge());        &#125;        Arrays.sort(people);        System.out.println(<span class="hljs-string">"\n排序后"</span>);        <span class="hljs-keyword">for</span> (Person person : people) &#123;            System.out.print(person.getName()+<span class="hljs-string">":"</span> + person.getAge());        &#125;    &#125;&#125;</code></pre></div><h2 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h2><p>Comparator是<strong>比较器接口</strong>，我们若需要控制某个类的次序，而<strong>该类本身不支持排序</strong>（即没有实现Comparable接口），那么，我们可以建立一个该类的比较器来进行排序，这个比较器只需要实现Comparator接口即可。也就是说，我们可以通过实现Comparator类来新建一个比较器，然后通过该比较器对类进行排序。</p><p>Comparator接口仅仅包含两个函数，它的定义如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(T o1, T o2)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span>;&#125;</code></pre></div><p>说明：</p><ul><li><p>如果一个类要实现Comparator接口，它一定要实现Compare(T o1,T o2)函数，但可以不实现equals(Object obj)函数。</p></li><li><p>int compare(T o1, T o2) 是“比较o1和o2的大小”。返回“负数”，意味着“o1比o2小”；返回“零”，意味着“o1等于o2”；返回“正数”，意味着“o1大于o2”。</p></li></ul><p>现在假如上面的Person类没有实现Comparable接口，该如何比较大小呢？我们可以新建一个类，让其实现Comparator接口，从而构造一个“比较器”。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonCompartor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Person</span>&gt;</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person o1, Person o2)</span> </span>&#123;        <span class="hljs-keyword">return</span> o1.getAge()-o2.getAge();    &#125;&#125;</code></pre></div><p>现在我们就可以利用这个比较器来对其进行排序：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;    String name;    <span class="hljs-keyword">int</span> age;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">super</span>();        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Person[] people=<span class="hljs-keyword">new</span> Person[]&#123;<span class="hljs-keyword">new</span> Person(<span class="hljs-string">"xujian"</span>, <span class="hljs-number">20</span>),<span class="hljs-keyword">new</span> Person(<span class="hljs-string">"xiewei"</span>, <span class="hljs-number">10</span>)&#125;;        System.out.println(<span class="hljs-string">"排序前"</span>);        <span class="hljs-keyword">for</span> (Person person : people) &#123;            System.out.print(person.getName()+<span class="hljs-string">":"</span>+person.getAge());        &#125;        Arrays.sort(people,<span class="hljs-keyword">new</span> PersonCompartor());        System.out.println(<span class="hljs-string">"\n排序后"</span>);        <span class="hljs-keyword">for</span> (Person person : people) &#123;            System.out.print(person.getName()+<span class="hljs-string">":"</span>+person.getAge());        &#125;    &#125;&#125;</code></pre></div><h3 id="Comparable和Comparator区别比较"><a href="#Comparable和Comparator区别比较" class="headerlink" title="Comparable和Comparator区别比较"></a>Comparable和Comparator区别比较</h3><ul><li><p>Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。</p></li><li><p>而Comparator是比较器接口，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</p></li><li><p>Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。</p></li><li><p>两种方法各有优劣， 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。 用Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了， 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>语言相关</category>
      
      <category>Java进阶</category>
      
      <category>Java集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2020/06/28/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/06/28/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h1><h2 id="1-JVM、JRE和JDK的关系"><a href="#1-JVM、JRE和JDK的关系" class="headerlink" title="1. JVM、JRE和JDK的关系"></a>1. JVM、JRE和JDK的关系</h2><p><strong>JVM</strong><br><code>Java Virtual Machine</code>，是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。<br><strong>JRE</strong><br><code>Java Runtime Environment</code>，包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是<code>java.lang</code>包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包；<br>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。<br><strong>JDK</strong><br><code>Java Development Kit</code>，是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等<br><img src="https://img-blog.csdnimg.cn/20200626145717665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="2-Java与C-的区别与联系"><a href="#2-Java与C-的区别与联系" class="headerlink" title="2. Java与C#的区别与联系"></a>2. Java与C#的区别与联系</h2><h3 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h3><p>都是面向对象编程的语言，都能够实现面向对象的思想（封装，继承，多态）；都具有垃圾自动回收机制；Java站在C++的肩膀上，而C#站在了Java的肩膀上。</p><h3 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h3><ul><li>语法特性：  Java抛弃了指针，使用了包（package）的概念，导入包使用import语句；C#没有完全抛弃指针（在unsafe状态下还可以操作指针），对于类的管理采用了名称空间（namespace）的概念，并且还使用了out、ref等关键字，便于从一个方法返回多个结果。</li><li>功能方面：C#有一些由编译器提供的特性，如：委托、属性、真正的泛型等，在Java中实现起来有点麻烦，同样Java中也有C#不具备的功能，如匿名内部类，动态代理等，另外Java实现了真正的跨平台性，而C#的跨平台性是建立在跨windows平台的基础上的。</li></ul><h2 id="3-Java与C-C-的异同"><a href="#3-Java与C-C-的异同" class="headerlink" title="3. Java与C/C++的异同"></a>3. Java与C/C++的异同</h2><ol><li>Java是<strong>解释型语言</strong>，C/C++为<strong>编译型</strong>语言，源代码经过<strong>编译</strong>和<strong>链接</strong>后生成可执行的二进制代码，Java执行速度比C/C++慢，但Java能够跨平台执行；</li><li>Java为纯面向对象语言，不存在全局变量或全局函数；</li><li>Java没有指针的概念；</li><li>Java不支持多重继承</li><li>Java提供了垃圾回收器来实现垃圾的自动回收，C++通常会把需要释放资源的代码放到析构函数中；</li><li>Java具有平台无关性，即对每种数据类型都分配固定长度。</li></ol><h2 id="4-Oracle-JDK和OpenJDK的对比"><a href="#4-Oracle-JDK和OpenJDK的对比" class="headerlink" title="4. Oracle JDK和OpenJDK的对比"></a>4. Oracle JDK和OpenJDK的对比</h2><p>OpenJDk版本每三个月发布一次，而OracleJDK每三年发布一次；<br>OpenJDK是一个参考模型并且完全开源，而OracleJDK是OpenJDK的一个实现，并不是完全开源的；<br>OracleJDK比OpenJDK更稳定，性能更好</p><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="1、-switch能否作用在byte上，是否能作用在long上，是否能作用在String上？"><a href="#1、-switch能否作用在byte上，是否能作用在long上，是否能作用在String上？" class="headerlink" title="1、 switch能否作用在byte上，是否能作用在long上，是否能作用在String上？"></a>1、 switch能否作用在byte上，是否能作用在long上，是否能作用在String上？</h2><p>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</p><p>原因是switch在编译时被编译成对应的两个实现方式的指令，而这两个指令只支持int类型。</p><h2 id="2、Java语言采用何种编码方式，有什么特点？"><a href="#2、Java语言采用何种编码方式，有什么特点？" class="headerlink" title="2、Java语言采用何种编码方式，有什么特点？"></a>2、Java语言采用何种编码方式，有什么特点？</h2><p>Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p><p>Unicode 编码共有三种具体实现，分别为utf-8,utf-16,utf-32，其中utf-8占用一到四个字节，utf-16占用二或四个字节，utf-32占用四个字节</p><h2 id="3、super关键字的用法"><a href="#3、super关键字的用法" class="headerlink" title="3、super关键字的用法"></a>3、super关键字的用法</h2><p>super可以理解为是指向自己超（父）类对象的一个指针。<br>A：可以利用super关键字代表父类对象访问父类的属性和方法；<br>    super.属性 —-&gt; 访问父类的属性<br>    super.方法名()—- &gt; 调用父类的方法<br>B：可以使用super关键字调用父类的构造函数，必须出现在构造函数的第一行；<br>C：super不能和static混用，因为super指的是对象，而static代表的是类。</p><h2 id="4、static关键字的意义"><a href="#4、static关键字的意义" class="headerlink" title="4、static关键字的意义"></a>4、static关键字的意义</h2><p>主要意义是在于创建独立于具体对象的域变量或者方法，以至于即使没有创建对象，也能使用属性和调用方法！<br>另外还可以用来形成静态代码块用来优化程序性能，因为static块在类加载的时候仅会执行一次，所以可以将一些只需要进行一次的初始化操作都放在static代码块中进行;</p><p>利用static实现单例模式：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;&#125;&#125;</code></pre></div><h2 id="5、final关键字"><a href="#5、final关键字" class="headerlink" title="5、final关键字"></a>5、final关键字</h2><p>在Java中，final关键字可以用来修饰类，方法和变量（包括成员变量和局部变量）</p><p><strong>1、修饰类</strong></p><p>　 当用final修饰一个类时，<strong>表明这个类不能被继承</strong>。也就是说，如果一个类你永远不会让它被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意<strong>final类中的所有成员方法都会被隐式地指定为final方法</strong>。</p><p><strong>2、修饰方法</strong></p><p> final修饰的方法表示此方法已经是“<strong>最后的、最终的</strong>”含义，亦即<strong>此方法不能被重写</strong>（可以重载多个final修饰的方法）。如果父类中final修饰的方法同时访问控制权限为private，将会导致子类中不能直接继承到此方法，此时可以在子类中定义相同的方法名和参数，不会产生重写与final的矛盾，而是在子类中重新定义了新的方法。（注：类的private方法会隐式地被指定为final方法。）</p><p><strong>3、修饰变量</strong></p><p><strong>final成员变量表示常量，只能被赋值一次，赋值后值不再改变。</strong></p><p>　　当final修饰一个<strong>基本数据类型</strong>时，表示该基本数据类型的值一旦在<strong>初始化后便不能发生变化</strong>；如果final修饰一个<strong>引用类型</strong>时，则在对其初始化之后便<strong>不能再让其指向其他对象</strong>了，但该<strong>引用所指向的对象的内容是可以发生变化的</strong>。本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。</p><p>　　<strong>final修饰一个成员变量（属性），必须要显式初始化。</strong>这里有两种初始化方式<strong>，一种是在变量声明的时候初始化；第二种方法是在声明变量的时候不赋初值，</strong>但是要在这个变量所在的类的构造函数中对这个变量赋初值。</p><p>如果不在定义的时候或者构造函数中对final变量进行赋值的话，则生成的对象中final变量的值是未知的（编译器会直接报错），因此必须初始化。</p><p>如果用static final同时修饰变量的话，则变量必须在定义的时候进行初始化，因为static变量属于类，在调用构造函数之前就已经被系统赋予默认值了。</p><p>如果定义了static final还可以用静态代码块进行初始化，只定义了final还可以用代码块进行初始化（不能用静态代码块）。</p><h2 id="6、创建String的两种方式："><a href="#6、创建String的两种方式：" class="headerlink" title="6、创建String的两种方式："></a>6、创建String的两种方式：</h2><ul><li>通过字面量来创建：String s = “abc”;</li><li>通过new（构造方法）来创建：String s = new String(“abc”);</li></ul><p>通过字面量来创建，首先会去字符串缓冲池寻找相同内容的字符串，如果存在就直接拿出来应用，如果不存在则创建一个新的字符串放在缓冲池中；</p><p>通过构造方法来创建字符串对象时，每次都会创建一个新的对象。</p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="1、面向对象和面向过程的区别"><a href="#1、面向对象和面向过程的区别" class="headerlink" title="1、面向对象和面向过程的区别"></a>1、面向对象和面向过程的区别</h2><p>面向过程注重的是<strong>性能</strong>，因为面向对象万物皆对象，而类调用时需要实例化，开销比较大，比较消耗资源；<br>面向对象易维护，易复用，易扩展，主要是得益于面向对象的封装，继承，多态特性，可以设计出<strong>低耦合</strong>的系统；</p><h2 id="2、什么是多态机制？Java中是如何实现多态的？"><a href="#2、什么是多态机制？Java中是如何实现多态的？" class="headerlink" title="2、什么是多态机制？Java中是如何实现多态的？"></a>2、什么是多态机制？Java中是如何实现多态的？</h2><p>对于面向对象而言，多态分为<strong>编译时多态</strong>和<strong>运行时多态</strong>，其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，而运行时多态是动态的，通过动态绑定来实现，多态性就是相同的消息使得不同的类做出不同的响应。<br>多态性体现在父类中定义的属性和方法被子类继承后，可以具有不同的属性或表现方式，多态性允许一个接口被多个同类使用，弥补了单继承的不足。</p><p>Java的多态是通过继承、重写、重载来实现的。</p><h2 id="3、面向对象的五大基本原则？"><a href="#3、面向对象的五大基本原则？" class="headerlink" title="3、面向对象的五大基本原则？"></a>3、面向对象的五大基本原则？</h2><p><strong>单一职责</strong>原则：类的功能要单一<br><strong>开放封闭</strong>原则：对扩展开放，对修改关闭<br><strong>里氏替换</strong>原则：任何父类可以出现的地方，子类一定可以出现。</p><ul><li>子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法；</li><li>子类中可以增加自己特有的方法；</li><li>当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更加宽松；</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更加严格。</li></ul><p><strong>依赖倒置</strong>原则：高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象<br><strong>接口分离</strong>原则：设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好</p><h2 id="4、对象实例和对象引用有什么不同？"><a href="#4、对象实例和对象引用有什么不同？" class="headerlink" title="4、对象实例和对象引用有什么不同？"></a>4、对象实例和对象引用有什么不同？</h2><p>对象实例存储在堆上，对象引用存储在栈中，要访问对象实例可以通过对象引用来访问。</p><h2 id="5、成员变量和局部变量的区别有哪些？"><a href="#5、成员变量和局部变量的区别有哪些？" class="headerlink" title="5、成员变量和局部变量的区别有哪些？"></a>5、成员变量和局部变量的区别有哪些？</h2><p><strong>作用域</strong><br>成员变量：针对整个类有效<br>局部变量：只在某个范围内有效<br><strong>存储位置</strong><br>成员变量：存储在堆中<br>局部变量：存储在栈内存中<br><strong>生命周期</strong><br>成员变量：随着对象的创建而存在，随着对象的消失而消失<br>局部变量：当方法调用完，或者语句结束后，就自动释放<br><strong>初始值</strong><br>成员变量：有默认初始值<br>局部变量：没有默认初始值，使用前必须赋值</p><h2 id="6、在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#6、在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="6、在Java中定义一个不做事且没有参数的构造方法的作用"></a>6、在Java中定义一个不做事且没有参数的构造方法的作用</h2><p>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”，因此，如果父类中只定义了有参数的构造方法，而在子类中的构造方法中又没有用super()来调用父类中特定的构造方法，则会在编译时发生错误。</p><h2 id="7、在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是什么"><a href="#7、在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是什么" class="headerlink" title="7、在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是什么"></a>7、在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是什么</h2><p>帮助子类做初始化工作，因为<strong>子类拥有父类的成员变量和成员方法</strong>，如果不调用，则从父类继承而来的成员变量和成员方法得不到正确的初始化。</p><h2 id="8、构造方法有哪些特性？"><a href="#8、构造方法有哪些特性？" class="headerlink" title="8、构造方法有哪些特性？"></a>8、构造方法有哪些特性？</h2><ul><li>方法名和类名相同</li><li>没有返回值，但不能用void声明构造函数</li><li>生成类的对象时自动执行，无需调用</li></ul><h2 id="9、静态变量、实例变量的区别"><a href="#9、静态变量、实例变量的区别" class="headerlink" title="9、静态变量、实例变量的区别"></a>9、静态变量、实例变量的区别</h2><p>静态变量：静态变量不属于任何实例对象，而属于类，所以在内存中只会存在一份，在类的加载过程中，JVM只为静态变量分配一次内存空间；<br>实例变量：每次创建对象，都会为每个对象分配成员变量内存空间，实例变量属于实例对象，在内存中创建几次对象，就会有几份成员变量。</p><h2 id="10、内部类的优点？有哪些应用场景"><a href="#10、内部类的优点？有哪些应用场景" class="headerlink" title="10、内部类的优点？有哪些应用场景"></a>10、内部类的优点？有哪些应用场景</h2><p><strong>优点</strong>：</p><ul><li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据；</li><li>内部类不为同一包的其他类所见，具有很好的封装性；</li><li>内部类有效实现了“多重继承”，优化Java单继承的缺陷；</li><li>匿名内部类可以很方便的实现回调。</li></ul><p><strong>应用场景</strong>：</p><ul><li>一些多算法场合；</li><li>解决一些非面向对象的语句块；</li><li>适当使用内部类，使得代码更加灵活和富有扩展性；</li><li>当某个类除了它的外部类，不再被其他的类使用时；</li></ul><h2 id="11、匿名内部类"><a href="#11、匿名内部类" class="headerlink" title="11、匿名内部类"></a>11、匿名内部类</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-keyword">new</span> Service() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;                    System.out.println(<span class="hljs-string">"匿名内部类"</span> );                &#125;            &#125;        &#125;.method();    &#125; &#125; <span class="hljs-comment">//匿名内部类必须继承一个抽象类或实现一个已有的接口 </span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Service</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p><strong>特点</strong>：</p><ul><li>匿名内部类必须继承一个抽象类或者实现一个接口</li><li>匿名内部类不能定义任何静态成员和静态方法</li><li>当所在的方法的形参需要被匿名内部类使用时，必须声明为final</li><li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现接口的所有方法</li></ul><h2 id="11、局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加final"><a href="#11、局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加final" class="headerlink" title="11、局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加final"></a>11、局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加final</h2><p>用final修饰实际上是为了<strong>保护数据的一致性</strong>，因为如果局部变量发生变化后，匿名内部类或局部内部类是不知道的（因为它只是拷贝了局部变量的值，并不是直接使用的局部变量），如果过了一段时间后局部变量的值指向另外一个对象，或是值发生了改变，那么程序运行的结果和预期的会不一致。<br><img src="https://img-blog.csdnimg.cn/20200627000517571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>JDK1.8中虽然局部变量不需要用final修饰符修饰，但是我们在试图改变这个局部变量的时候会提示编译出错。</p><h2 id="12、重载的方法能否根据返回类型进行区分"><a href="#12、重载的方法能否根据返回类型进行区分" class="headerlink" title="12、重载的方法能否根据返回类型进行区分"></a>12、重载的方法能否根据返回类型进行区分</h2><p>重载发生在同一个类中，方法名相同但参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关。</p><h2 id="13、hashcode和equals"><a href="#13、hashcode和equals" class="headerlink" title="13、hashcode和equals"></a>13、hashcode和equals</h2><p>这个问题应该是有个前提，就是你需要用到 HashMap、HashSet 等 Java 集合，用不到哈希表的话，其实仅仅重写 equals() 方法也可以。而工作中的场景是常常用到 Java 集合，所以 Java 官方建议重写 equals() 就一定要重写 hashCode() 方法。<br>对于对象集合的判重，如果一个集合含有 10000 个对象实例，仅仅使用 equals() 方法的话，那么对于一个对象判重就需要比较 10000 次，随着集合规模的增大，时间开销是很大的。但是同时使用哈希表的话，就能快速定位到对象的大概存储位置，并且在定位到大概存储位置后，后续比较过程中，如果两个对象的 hashCode 不相同，也不再需要调用 equals() 方法，从而<strong>大大减少了 equals() 比较次数</strong>。 </p><p>hashCode()与equals()的相关规定：<br>1、如果两个对象相等，则 hashCode 一定也是相同的；<br>2、两个对象相等，对两个对象分别调用 equals 方法都返回 true；<br>3、两个对象有相同的 hashCode 值，它们也不一定是相等的；<br>4、因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖；<br>5、hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</p><h2 id="14、当一个对象被当作参数传递到一个方法后，此方法可改变整个对象的属性，并返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#14、当一个对象被当作参数传递到一个方法后，此方法可改变整个对象的属性，并返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="14、当一个对象被当作参数传递到一个方法后，此方法可改变整个对象的属性，并返回变化后的结果，那么这里到底是值传递还是引用传递"></a>14、当一个对象被当作参数传递到一个方法后，此方法可改变整个对象的属性，并返回变化后的结果，那么这里到底是值传递还是引用传递</h2><p>是值传递。Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的，也就是说这个引用还是会指向之前的对象，而不会指向其他对象。<strong>之所以能修改引用数据是因为它们同时指向了一个对象。</strong></p><h2 id="15、值传递和引用传递的区别"><a href="#15、值传递和引用传递的区别" class="headerlink" title="15、值传递和引用传递的区别"></a>15、值传递和引用传递的区别</h2><p>所谓的按值调用表示方法接收的是调用者提供的值，而按引用调用则表示方法接收的是<strong>调用者提供的变量地址</strong>，一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</p><h2 id="16、import-java和javax有什么区别"><a href="#16、import-java和javax有什么区别" class="headerlink" title="16、import java和javax有什么区别"></a>16、import java和javax有什么区别</h2><p>实际上java和javax没有区别。这都是一个名字。</p><h2 id="17、Stream"><a href="#17、Stream" class="headerlink" title="17、Stream"></a>17、Stream</h2><p>Stream 就好像一个<strong>高级的迭代器</strong>，但只能遍历一次，在流的过程中，对流中的元素执行一些操作，比如“过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等。</p><p>要想操作流，首先需要有一个数据源，可以是数组或者集合，每次操作都会返回一个新的流对象，方便进行链式操作，但原有的流对象会保持不变。</p><p>如果数据源是数组，可以使用<code>Arrays.stream()</code>或者<code>Stream.of()</code>创建流；</p><p>如果是集合，直接使用<code>stream()</code>方法即可。</p><p>流的操作分为两种类型：</p><ul><li>中间操作：可以有多个，每次返回一个新的流，可以进行链式操作；</li><li>终端操作：只能有一个，每次执行完，这个流也就用完了，无法执行下一个操作，因此只能放在最后。</li></ul><div class="hljs"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();list.add(<span class="hljs-string">"江南飞鹏"</span>);list.add(<span class="hljs-string">"江南"</span>);list.add(<span class="hljs-string">"飞鹏"</span>);list.add(<span class="hljs-string">"江南飞鹏"</span>);<span class="hljs-keyword">long</span> count = list.stream().distinct().count();System.out.println(count);</code></pre></div><p>distinct() 方法是一个中间操作（去重），它会返回一个新的流（没有共同元素）。<br>count() 方法是一个终端操作，返回流中的元素个数。</p><p>中间操作不会立即执行，只有等到终端操作的时候，流才开始真正地遍历，用于映射、过滤等。通俗点说，就是一次遍历执行多个操作，性能就大大提高了。</p><p>可以通过操作流来实现过滤、映射、匹配、组合等功能。</p><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="1-同步、异步、阻塞、非阻塞的区别"><a href="#1-同步、异步、阻塞、非阻塞的区别" class="headerlink" title="1.同步、异步、阻塞、非阻塞的区别"></a>1.同步、异步、阻塞、非阻塞的区别</h2><p><strong>同步和异步</strong>：<br>同步：同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。<br>异步：异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但此时结果并没有返回，此时调用者可以处理其他的请求，被调用者通常依靠事件、回调等机制来通知调用者其返回结果。<br><strong>同步和异步最大区别在于异步的话不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果</strong></p><p><strong>阻塞和非阻塞</strong>：<br>阻塞：阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是<strong>当前线程会被挂起</strong>，无法从事其他任务，只有当条件就绪才能继续<br>非阻塞：非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。</p><p><strong>同步和异步关注的是消息通信机制</strong>：<br>所谓同步，就是在发出一个<strong>调用</strong>时，在没有得到结果之前，该<strong>调用</strong>就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由<strong>调用者</strong>主动等待这个<strong>调用</strong>的结果。而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来告诉调用者，或通过回调函数处理这个调用。</p><p>比如说：<br>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p><p><strong>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态</strong>：<br>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><p>还是上面的例子，你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。</p><h2 id="2-BIO、NIO、AIO有什么区别"><a href="#2-BIO、NIO、AIO有什么区别" class="headerlink" title="2.BIO、NIO、AIO有什么区别"></a>2.BIO、NIO、AIO有什么区别</h2><h3 id="BIO：同步阻塞I-O模型，数据的读取写入必须阻塞在一个线程内等待其完成"><a href="#BIO：同步阻塞I-O模型，数据的读取写入必须阻塞在一个线程内等待其完成" class="headerlink" title="BIO：同步阻塞I/O模型，数据的读取写入必须阻塞在一个线程内等待其完成"></a>BIO：同步阻塞I/O模型，数据的读取写入必须阻塞在一个线程内等待其完成</h3><p>采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，我们一般通过在while(true)循环中服务端会调用accept()方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就建立通信套接字来进行读写操作，如果要让BIO通信模型能够同时处理多个客户端的请求，就必须使用多线程，也就是说它在接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理。为了减少线程创建和销毁带来的开销，可以采用线程池的方式来管理线程。</p><h3 id="NIO：同步非阻塞的I-O模型"><a href="#NIO：同步非阻塞的I-O模型" class="headerlink" title="NIO：同步非阻塞的I/O模型"></a>NIO：同步非阻塞的I/O模型</h3><p>Java NIO使我们可以进行非阻塞IO操作，比如单线程从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程在继续处理数据，写数据同样如此。<br>NIO类库中加入了<strong>Buffer</strong>对象，在NIO库中，所有数据都是用缓冲区处理的，每种Java基本类型（除了Boolean）都对应一种缓冲区。<br><strong>Channel（通道）</strong>：NIO通过Channel进行读写，通道是双向的，可读也可写，而IO中的流是单向的，Channel只能和Buffer交互，因为Buffer，通道可以异步地读写。<br><strong>Selector（选择器）</strong>：选择器用于使用单个线程处理多个通道。<br><img src="https://img-blog.csdnimg.cn/20200627012154414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="AIO：异步IO"><a href="#AIO：异步IO" class="headerlink" title="AIO：异步IO"></a>AIO：异步IO</h3><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><h2 id="3-Files常用方法有哪些"><a href="#3-Files常用方法有哪些" class="headerlink" title="3.Files常用方法有哪些"></a>3.Files常用方法有哪些</h2><p>Files. exists()：检测文件路径是否存在。<br>Files. createFile()：创建文件。<br>Files. createDirectory()：创建文件夹。<br>Files. delete()：删除一个文件或目录。<br>Files. copy()：复制文件。<br>Files. move()：移动文件。<br>Files. size()：查看文件个数。<br>Files. read()：读取文件。<br>Files. write()：写入文件。</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="什么是反射机制"><a href="#什么是反射机制" class="headerlink" title="什么是反射机制"></a>什么是反射机制</h2><p>JAVA反射机制是在<strong>运行状态</strong>中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><h2 id="反射机制的优缺点"><a href="#反射机制的优缺点" class="headerlink" title="反射机制的优缺点"></a>反射机制的优缺点</h2><p>优点：可以动态执行，在运行期间根据业务功能动态执行方法、访问属性，最大限度发挥了java的灵活性。<br>缺点：对性能有影响，这类操作总是慢于直接执行java代码；使内部暴露，破坏封装；反射技术要求程序必须在一个没有安全限制的环境中运行。</p><h2 id="反射机制的应用场景"><a href="#反射机制的应用场景" class="headerlink" title="反射机制的应用场景"></a>反射机制的应用场景</h2><ul><li>在使用JDBC连接数据库时使用Class.forName()，通过反射加载数据库的驱动程序；</li><li>Spring框架也用到很多反射机制，最经典的就是xml的配置模式；</li><li>Web服务器中利用反射调用了Sevlet的服务方法。</li><li>IDEA等开发工具利用反射动态剖析对象的类型与结构，动态提示对象的属性和方法。</li></ul><h2 id="Java获取反射的三种方法"><a href="#Java获取反射的三种方法" class="headerlink" title="Java获取反射的三种方法"></a>Java获取反射的三种方法</h2><p>1.通过<strong>new</strong>对象实现反射</p><p>2.通过<strong>路径</strong>实现反射机制 </p><p>3.通过<strong>类名</strong>实现反射机制</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Get</span> </span>&#123;    <span class="hljs-comment">//获取反射机制三种方式</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;        <span class="hljs-comment">//方式一(通过建立对象)</span>        Student stu = <span class="hljs-keyword">new</span> Student();        Class classobj1 = stu.getClass();        System.out.println(classobj1.getName());        <span class="hljs-comment">//方式二（通过路径-相对路径）</span>        Class classobj2 = Class.forName(<span class="hljs-string">"fanshe.Student"</span>);        System.out.println(classobj2.getName());        <span class="hljs-comment">//方式三（通过类名）</span>        Class classobj3 = Student<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;        System.out.println(classobj3.getName());    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    String name;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> sex;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> score;&#125;</code></pre></div><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Target</span>(value = &#123;ElementType.TYPE&#125;)<span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SecondAnnotation &#123;<span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><ul><li>@Target注解，是专门用来限定某个自定义注解能够被应用在哪些Java元素上面的。</li><li>@Retention注解，用来修饰自定义注解的生命力。<br>注解的生命周期有三个阶段：1、Java源文件阶段；2、编译到class文件阶段；3、运行期阶段。</li><li>@Documented注解，是被用来指定自定义注解是否能随着被定义的java文件生成到JavaDoc文档当中。</li><li>@Inherited注解，是指定某个自定义注解如果写在了父类的声明部分，那么子类的声明部分也能自动拥有该注解。@Inherited注解只对那些@Target被定义为ElementType.TYPE的自定义注解起作用。</li></ul><p><strong>自定义注解类编写的一些规则：</strong></p><ol><li><code>Annotation</code>型定义为<code>@interface</code> 所有的<code>Annotation</code>会自动继承<code>java.lang.Annotation</code>这一接口，并且不能再去继承别的类或是接口；</li><li>参数成员只能用<code>public</code>或默认<code>(default)</code>这两个访问权修饰；</li><li>参数成员只能用基本类型<code>byte,short,char,int,long,float,double,boolean</code>八种基本数据类型和<code>String、Enum、Class、annotations</code>等数据类型，以及这一些类型的数组；</li><li>如果只有一个成员，成员名称最好用<code>value</code>，因为默认就是它；</li><li>一般定义参数成员后，都会给一个默认值，注意<code>String</code>一般不用<code>null</code>做默认值，可以用字符串或空串（”“）；</li><li>要获取类方法和字段的注解信息，必须通过<code>Java</code>的反射技术来获取 <code>Annotation</code>对象,因为你除此之外没有别的获取注解对象的方法；</li><li>注解也可以没有定义成员，不过这样注解就没啥用了</li></ol><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="什么是序列化和反序列化？"><a href="#什么是序列化和反序列化？" class="headerlink" title="什么是序列化和反序列化？"></a>什么是序列化和反序列化？</h2><ul><li>Java序列化是指把Java对象转换为字节序列的过程，而Java反序列化是把字节序列恢复为Java对象的过程；</li><li>序列化：最主要的用处是在传递和保存对象的时候，保证对象的完整性和可传递性，序列化是把对象转换成有序字节流，以便在网络中传输或者保存在本地文件中，序列化后的字节流保存了Java对象的状态以及相关的描述信息，<strong>序列化机制的核心作用就是对象状态的保存和重建。</strong></li><li>反序列化：客户端从文件或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</li><li>从本质上讲，序列化就是把实体对象状态按照一定的格式写入到有序字节流，反序列化就是从有序字节流重建对象，恢复对象状态。</li></ul><h2 id="为什么需要序列化和反序列化？"><a href="#为什么需要序列化和反序列化？" class="headerlink" title="为什么需要序列化和反序列化？"></a>为什么需要序列化和反序列化？</h2><p>Java序列化的好处：</p><ul><li>实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘；</li><li>实现远程通信，即在网络上传输对象的字节序列。</li></ul><h2 id="Java是如何实现序列化和反序列化的？"><a href="#Java是如何实现序列化和反序列化的？" class="headerlink" title="Java是如何实现序列化和反序列化的？"></a>Java是如何实现序列化和反序列化的？</h2><h3 id="1-JDK类库中序列化和反序列化API"><a href="#1-JDK类库中序列化和反序列化API" class="headerlink" title="1. JDK类库中序列化和反序列化API"></a>1. JDK类库中序列化和反序列化API</h3><p><code>java.io.ObjectOutputStream</code>：表示对象输出流，它的writeObject(Object obj)方法可以对参数指令的obj对象进行序列化，把得到的字节序列写到一个目标输出流中；</p><p><code>java.io.ObjectInputStream</code>：表示对象输入流，它的readObject()方法从输入流中读取字节序列，再把它们反序列化成为一个对象，并将其返回；</p><h3 id="2-实现序列化的要求"><a href="#2-实现序列化的要求" class="headerlink" title="2. 实现序列化的要求"></a>2. 实现序列化的要求</h3><p>实现<code>Serializable</code>或<code>Externalizable</code>接口的类的对象才能被序列化，否则抛出异常。</p><h3 id="3-JDK类库中序列化的步骤"><a href="#3-JDK类库中序列化的步骤" class="headerlink" title="3. JDK类库中序列化的步骤"></a>3. JDK类库中序列化的步骤</h3><ol><li><p>创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流：</p><div class="hljs"><pre><code class="hljs java">ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"D:\\object.out"</span>));</code></pre></div></li><li><p>通过对象输出流的writeObject()方法写对象：</p><div class="hljs"><pre><code class="hljs java">oos.writeObject(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"yyj"</span>,<span class="hljs-string">"123"</span>,<span class="hljs-string">"male"</span>));</code></pre></div></li></ol><h3 id="4-JDK类库中反序列化的步骤"><a href="#4-JDK类库中反序列化的步骤" class="headerlink" title="4. JDK类库中反序列化的步骤"></a>4. JDK类库中反序列化的步骤</h3><ol><li><p>创建一个对象输入流，它可以包装一个其他类型输入流，如文件输入流：</p><div class="hljs"><pre><code class="hljs java">ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"D:\\object.out"</span>));</code></pre></div></li><li><p>通过对象输入流的readObject()方法读取对象：</p><div class="hljs"><pre><code class="hljs java">User user = (User)ois.readObject();</code></pre></div></li></ol><p>说明：为了正确读取数据，完成反序列化，必须保证向对象输出流写对象的顺序与从对象输入流中读对象的顺序一致。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>序列化时，只对对象的状态进行保存，而不管对象的方法；</li><li>当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；</li><li>当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；</li><li>并非所有对象都可以进行序列化，如声明为<code>static</code>和<code>transient</code>类型的成员数据不能被序列化；</li><li>序列化运行时使用一个称为serialVersionUID的版本号与每个可序列化类相关联；</li></ul>]]></content>
    
    
    <categories>
      
      <category>语言相关</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Security官方文档总结</title>
    <link href="/2020/06/23/Spring-Security%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%80%BB%E7%BB%93/"/>
    <url>/2020/06/23/Spring-Security%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-引导"><a href="#1-引导" class="headerlink" title="1. 引导"></a>1. 引导</h1><h2 id="跨站脚本攻击（XSS）"><a href="#跨站脚本攻击（XSS）" class="headerlink" title="跨站脚本攻击（XSS）"></a>跨站脚本攻击（XSS）</h2><p>XSS攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。</p><h3 id="如何防护？"><a href="#如何防护？" class="headerlink" title="如何防护？"></a>如何防护？</h3><p>现在主流的浏览器内置了防范XSS的措施，对于开发者来说，有如下方式来防止XSS攻击。</p><h4 id="HTTPOnly防止截取Cookie"><a href="#HTTPOnly防止截取Cookie" class="headerlink" title="HTTPOnly防止截取Cookie"></a>HTTPOnly防止截取Cookie</h4><p>作为一个标准，浏览器将禁止页面的JavaScript访问带有HTTPOnly属性的Cookie，严格来说，HttpOnly并非阻止XSS攻击，而是能阻止XSS攻击后的Cookie劫持攻击。</p><h4 id="输入检查"><a href="#输入检查" class="headerlink" title="输入检查"></a>输入检查</h4><p>对于用户的任何输入要进行检查、过滤和转义，建立可信任的字符和HTML标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。</p><h4 id="输出检查"><a href="#输出检查" class="headerlink" title="输出检查"></a>输出检查</h4><p>一般来说，除富文本的输出外，在变量输出到HTML页面时，可以使用编码或转义的方式来防御XSS攻击。例如利用sanitize-html对输出内容进行有规则的过滤之后再输出到页面中。</p><h2 id="跨站请求伪造（CSRF）"><a href="#跨站请求伪造（CSRF）" class="headerlink" title="跨站请求伪造（CSRF）"></a>跨站请求伪造（CSRF）</h2><h3 id="什么是跨站请求伪造？"><a href="#什么是跨站请求伪造？" class="headerlink" title="什么是跨站请求伪造？"></a><strong>什么是跨站请求伪造？</strong></h3><p>简单来说，就是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站，并运行一些操作（如发邮件，发消息，转账等），由于浏览器曾经认证过该网站，所以被访问的网站会认为是真正的用户操作而去运行，这利用了web中用户身份验证的一个漏洞：<strong>简单的身份验证只能保证请求来自某个用户的浏览器，而不能保证请求本身是用户资源发出的。</strong></p><h3 id="产生的原因："><a href="#产生的原因：" class="headerlink" title="产生的原因："></a><strong>产生的原因：</strong></h3><p>CSRF攻击的可能原因是受害者网站的HTTP请求与攻击者网站的请求完全相同。这意味着没有办法拒绝来自邪恶网站的请求并允许来自银行网站的请求。</p><h3 id="如何防御？"><a href="#如何防御？" class="headerlink" title="如何防御？"></a><strong>如何防御？</strong></h3><p>为了防御CSRF攻击，我们需要确保恶意站点无法提供请求中的某些内容，因此我们可以区分这两个请求。<br>Spring提供了两种机制来防御CSRF攻击：</p><ul><li>同步器令牌模式</li><li>在会话Cookie上指定SameSite属性</li></ul><h4 id="同步器令牌模式"><a href="#同步器令牌模式" class="headerlink" title="同步器令牌模式"></a>同步器令牌模式</h4><p>该解决方案是为了确保我们每个Http请求除了我们的会话cookie外，还必须在HTTP请求中包含一个安全的，随机生成的值，称为CSRF令牌。<br>提交HTTP请求时，服务器必须查找预期的CSRF令牌，并将其与HTTP请求中的实际CSRF令牌进行比较。如果值不匹配，则应拒绝HTTP请求。<br>此外，实际的CSRF令牌应该位于浏览器不会自动包含的HTTP请求的一部分中。例如，在HTTP参数或HTTP header中要求实际的CSRF令牌能防止CSRF攻击。在cookie中要求实际CSRF令牌不起作用，因为浏览器会自动将cookie包含在HTTP请求中。<br>同时也不能在HTTP GET中包含随机令牌，因为这有可能导致令牌泄漏。</p><h4 id="SameSite属性"><a href="#SameSite属性" class="headerlink" title="SameSite属性"></a>SameSite属性</h4><p>防止CSRF攻击的一种新兴方法是在cookie上指定SameSite属性。<br>Spring Security不直接控制session和cookie的创建，因此不提供对SameSite属性的支持。<br>这里也不做过多介绍，感兴趣的可以点击<a href="https://www.jianshu.com/p/66f77b8f1759" target="_blank" rel="noopener">这里</a>进行了解。</p><h3 id="什么情况下使用CSRF保护"><a href="#什么情况下使用CSRF保护" class="headerlink" title="什么情况下使用CSRF保护"></a>什么情况下使用CSRF保护</h3><p>官方建议是对普通用户可能由浏览器处理的任何请求使用CSRF保护（即使你的应用程序是无状态的也可能会受到CSRF攻击）。如果仅创建非浏览器客户端使用的服务，则可能需要禁用CSRF保护。</p><h1 id="2-Servlet安全性（全局角度）"><a href="#2-Servlet安全性（全局角度）" class="headerlink" title="2. Servlet安全性（全局角度）"></a>2. Servlet安全性（全局角度）</h1><h2 id="2-1-过滤器链（Filters）"><a href="#2-1-过滤器链（Filters）" class="headerlink" title="2.1 过滤器链（Filters）"></a>2.1 过滤器链（Filters）</h2><blockquote><p>SpringSecurity 采用的是责任链的设计模式，它有一条很长的过滤器链。</p></blockquote><p>下面通过单个HTTP请求的处理程序的典型分层图来说明过滤器链的使用。<br><img src="https://img-blog.csdnimg.cn/20200517025709729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="图1.FilterChain"><br>客户向应用程序发送一个请求，容器创建一个FilterChain，其中包含过滤器和Servlet，根据请求URI的路径处理HttpServletRequest。在Spring MVC应用程序中，Servlet是DispatcherServlet的一个实例。一个Servlet最多只能处理一个HttpServletRequest和HttpServletResponse，但是，可以使用多个过滤器来进行如下操作：</p><ul><li>阻止下游过滤器或Servlet被调用。在这个情况下，过滤器通常会编写HttpServletResponse</li><li>修改下游过滤器和Servlet使用的HttpServletRequest或HttpServletResponse</li></ul><p>FilterChain的用法例子：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> </span>&#123;    <span class="hljs-comment">// do something before the rest of the application</span>    chain.doFilter(request, response); <span class="hljs-comment">// invoke the rest of the application</span>    <span class="hljs-comment">// do something after the rest of the application</span>&#125;</code></pre></div><p>由此可以看出，过滤器仅仅会对下游的过滤器和servlet带来影响，因此在实际代码编写中，尤其要考虑调用的先后顺序。</p><h2 id="2-2-DelegatingFiterProxy（重要）"><a href="#2-2-DelegatingFiterProxy（重要）" class="headerlink" title="2.2 DelegatingFiterProxy（重要）"></a>2.2 DelegatingFiterProxy（重要）</h2><p>Spring提供了一个名为<strong>DelegatingFilterProxy</strong>的过滤器实现，它允许在Servlet容器的生命周期和Spring的ApplicationContext之间架桥。Servlet容器允许使用自己的标准注册过滤器，但它不知道Spring定义的bean。可以通过标准的Servlet容器机制注册DelegatingFilterProxy，但将所有工作委托给实现Filter的Spring Bean。<br><img src="https://img-blog.csdnimg.cn/20200517144639975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="图2. DelegatingFilterProxy"><br>DelegatingFilterProxy 执行的伪代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> </span>&#123;    <span class="hljs-comment">// Lazily get Filter that was registered as a Spring Bean</span>    <span class="hljs-comment">// For the example in DelegatingFilterProxy delegate is an instance of Bean Filter0</span>    Filter delegate = getFilterBean(someBeanName);    <span class="hljs-comment">// delegate work to the Spring Bean</span>    delegate.doFilter(request, response);&#125;</code></pre></div><p>首先思考一个问题，在SpringBoot中是如何注册 DelegatingFilterProxy 呢？</p><div class="hljs"><pre><code class="hljs java">org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration<span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnBean</span>(name = DEFAULT_FILTER_NAME)<span class="hljs-function"><span class="hljs-keyword">public</span> DelegatingFilterProxyRegistrationBean <span class="hljs-title">securityFilterChainRegistration</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">SecurityProperties securityProperties)</span> </span>&#123;DelegatingFilterProxyRegistrationBean registration = <span class="hljs-keyword">new</span> DelegatingFilterProxyRegistrationBean(DEFAULT_FILTER_NAME);registration.setOrder(securityProperties.getFilter().getOrder());registration.setDispatcherTypes(getDispatcherTypes(securityProperties));<span class="hljs-keyword">return</span> registration;&#125;</code></pre></div><p>代码中DelegatingFilterProxyRegistrationBean 的作用便是在 SpringBoot 环境下通过 TomcatStarter 等内嵌容器启动类来注册一个 DelegatingFilterProxy。<br><strong>DelegatingFilterProxy 是 SpringSecurity 的“门面”，而它本身是 Spring Web 包中的类，并不是 SpringSecurity 中的类。这是因为 Spring 考虑到了多种使用场景，自然希望将侵入性降到最低，所以使用了这个委托代理类来代理真正的 SpringSecurityFilterChain。</strong>DelegatingFilterProxy 实现了 javax.servlet.Filter 接口，使得它可以作为一个 java web 的标准过滤器，其职责也很简单，只负责调用真正的 SpringSecurityFilterChain。<br>下面来看看它的源码（有删减）：</p><div class="hljs"><pre><code class="hljs java">org.springframework.web.filter.DelegatingFilterProxy<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelegatingFilterProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span> </span>&#123;   <span class="hljs-keyword">private</span> WebApplicationContext webApplicationContext;   <span class="hljs-comment">// springSecurityFilterChain</span>   <span class="hljs-keyword">private</span> String targetBeanName;   <span class="hljs-comment">// &lt;1&gt; 关键点</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Filter delegate;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object delegateMonitor = <span class="hljs-keyword">new</span> Object();   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DelegatingFilterProxy</span><span class="hljs-params">(String targetBeanName, WebApplicationContext wac)</span> </span>&#123;      Assert.hasText(targetBeanName, <span class="hljs-string">"Target Filter bean name must not be null or empty"</span>);      <span class="hljs-keyword">this</span>.setTargetBeanName(targetBeanName);      <span class="hljs-keyword">this</span>.webApplicationContext = wac;      <span class="hljs-keyword">if</span> (wac != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">this</span>.setEnvironment(wac.getEnvironment());      &#125;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initFilterBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;      <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.delegateMonitor) &#123;         <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.delegate == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.targetBeanName == <span class="hljs-keyword">null</span>) &#123;               <span class="hljs-keyword">this</span>.targetBeanName = getFilterName();            &#125;            <span class="hljs-comment">// 获取Spring根应用程序上下文并尽早初始化委托，如果可能的话。如果根应用程序上下文将在此之后启动过滤器代理，我们将不得不求助于延迟初始化。</span>            WebApplicationContext wac = findWebApplicationContext();            <span class="hljs-keyword">if</span> (wac != <span class="hljs-keyword">null</span>) &#123;               <span class="hljs-keyword">this</span>.delegate = initDelegate(wac);            &#125;         &#125;      &#125;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span><span class="hljs-function">         <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;      <span class="hljs-comment">// 过滤器代理支持懒加载</span>      Filter delegateToUse = <span class="hljs-keyword">this</span>.delegate;      <span class="hljs-keyword">if</span> (delegateToUse == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.delegateMonitor) &#123;            delegateToUse = <span class="hljs-keyword">this</span>.delegate;            <span class="hljs-keyword">if</span> (delegateToUse == <span class="hljs-keyword">null</span>) &#123;               WebApplicationContext wac = findWebApplicationContext();               delegateToUse = initDelegate(wac);            &#125;            <span class="hljs-keyword">this</span>.delegate = delegateToUse;         &#125;      &#125;      <span class="hljs-comment">// 让代理过滤器执行实际的过滤行为</span>      invokeDelegate(delegateToUse, request, response, filterChain);   &#125;   <span class="hljs-comment">// 初始化过滤器代理</span>   <span class="hljs-comment">// &lt;2&gt;</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> Filter <span class="hljs-title">initDelegate</span><span class="hljs-params">(WebApplicationContext wac)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;      Filter delegate = wac.getBean(getTargetBeanName(), Filter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;      <span class="hljs-keyword">if</span> (isTargetFilterLifecycle()) &#123;         delegate.init(getFilterConfig());      &#125;      <span class="hljs-keyword">return</span> delegate;   &#125;   <span class="hljs-comment">// 调用代理过滤器</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeDelegate</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">         Filter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span><span class="hljs-function">         <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;      delegate.doFilter(request, response, filterChain);   &#125;&#125;</code></pre></div><p>通过阅读源码可以发现，整个DelegatingFilterProxy 类都是围绕delegate来处理，在初始化过滤器代理的时候，DelegatingFilterProxy 尝试去容器中获取名为 targetBeanName 的类，而 targetBeanName 的默认值便是 Filter 的名称，也就是 springSecurityFilterChain！说白了，DelegatingFilterProxy 只是名称和 targetBeanName 叫 springSecurityFilterChain，真正容器中的 Bean(name=”springSecurityFilterChain”) 其实并不是它，而是我们接下来将讲到的FilterChainProxy。</p><h2 id="2-3-FilterChainProxy（重要）"><a href="#2-3-FilterChainProxy（重要）" class="headerlink" title="2.3 FilterChainProxy（重要）"></a>2.3 FilterChainProxy（重要）</h2><p>Spring Security的Servlet支持包含在FilterChainProxy中。FilterChainProxy是Spring Security提供的一个特殊的过滤器，它允许通过SecurityFilterChain委托给多个过滤器实例。因为FilterChainProxy是一个Bean，它通常被包装在一个DelegatingFilterProxy中。<br><img src="https://img-blog.csdnimg.cn/20200517145354762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Figure 3. FilterChainProxy"></p><div class="hljs"><pre><code class="hljs java">org.springframework.security.web.FilterChainProxy<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilterChainProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span> </span>&#123;   <span class="hljs-comment">// &lt;1&gt; 包含了多个 SecurityFilterChain</span>   <span class="hljs-keyword">private</span> List&lt;SecurityFilterChain&gt; filterChains;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FilterChainProxy</span><span class="hljs-params">(SecurityFilterChain chain)</span> </span>&#123;      <span class="hljs-keyword">this</span>(Arrays.asList(chain));   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FilterChainProxy</span><span class="hljs-params">(List&lt;SecurityFilterChain&gt; filterChains)</span> </span>&#123;      <span class="hljs-keyword">this</span>.filterChains = filterChains;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> </span>&#123;      filterChainValidator.validate(<span class="hljs-keyword">this</span>);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response,</span></span><span class="hljs-function"><span class="hljs-params">         FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;         doFilterInternal(request, response, chain);   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(ServletRequest request, ServletResponse response,</span></span><span class="hljs-function"><span class="hljs-params">         FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;      FirewalledRequest fwRequest = firewall            .getFirewalledRequest((HttpServletRequest) request);      HttpServletResponse fwResponse = firewall            .getFirewalledResponse((HttpServletResponse) response);  <span class="hljs-comment">// &lt;1&gt;</span>      List&lt;Filter&gt; filters = getFilters(fwRequest);      <span class="hljs-keyword">if</span> (filters == <span class="hljs-keyword">null</span> || filters.size() == <span class="hljs-number">0</span>) &#123;         fwRequest.reset();         chain.doFilter(fwRequest, fwResponse);         <span class="hljs-keyword">return</span>;      &#125;      VirtualFilterChain vfc = <span class="hljs-keyword">new</span> VirtualFilterChain(fwRequest, chain, filters);      vfc.doFilter(fwRequest, fwResponse);   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * &lt;1&gt; 可能会有多个过滤器链，返回第一个和请求 URL 匹配的过滤器链</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Filter&gt; <span class="hljs-title">getFilters</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;      <span class="hljs-keyword">for</span> (SecurityFilterChain chain : filterChains) &#123;         <span class="hljs-keyword">if</span> (chain.matches(request)) &#123;            <span class="hljs-keyword">return</span> chain.getFilters();         &#125;      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;&#125;</code></pre></div><p>看 FilterChainProxy 的名字就可以发现，它依旧不是真正实施过滤的类，它内部维护了一个 SecurityFilterChain，这个过滤器链才是请求真正对应的过滤器链，并且同一个 Spring 环境下，可能同时存在多个安全过滤器链，如 private List filterChains 所示，需要经过 chain.matches(request) 判断到底哪个过滤器链匹配成功，每个 request 最多只会经过一个 SecurityFilterChain。为何要这么设计？因为 Web 环境下可能有多种安全保护策略，每种策略都需要有自己的一条链路，所以实际每次请求，最多只有一个安全过滤器链被返回！<br>所以说，<strong>SecurityFilterChain 才是真正意义上的 SpringSecurityFilterChain</strong>：</p><div class="hljs"><pre><code class="hljs java">org.springframework.security.web.DefaultSecurityFilterChain<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultSecurityFilterChain</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SecurityFilterChain</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RequestMatcher requestMatcher;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Filter&gt; filters;<span class="hljs-comment">//这里的List filters就包含了 UsernamePasswordAuthenticationFilter，SecurityContextPersistenceFilter，FilterSecurityInterceptor 等常用的 Filter。</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Filter&gt; <span class="hljs-title">getFilters</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> filters;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;      <span class="hljs-keyword">return</span> requestMatcher.matches(request);   &#125;&#125;</code></pre></div><h2 id="2-4-SecurityFiterChain（重要）"><a href="#2-4-SecurityFiterChain（重要）" class="headerlink" title="2.4 SecurityFiterChain（重要）"></a>2.4 SecurityFiterChain（重要）</h2><p>SecurityFilterChain由FilterChainProxy使用，以确定应为此请求调用哪个Spring安全过滤器。<br><img src="https://img-blog.csdnimg.cn/20200517145736434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="图4. SecurityFilterChain"><br>SecurityFilterChain中的安全过滤器通常是bean，但是它们是在FilterChainProxy中注册的，而不是委托给FilterProxy。<br>那么SecurityFiterChain是如何注册的？<br>在我们写SecurityConfig配置类的时候，一般都会使用<code>@EnableWebSecurity</code>注解和继承<code>WebSecurityConfigurerAdapter</code>来进行安全配置，来到WebSecurity类中：</p><div class="hljs"><pre><code class="hljs java">org.springframework.security.config.annotation.web.builders.WebSecurity<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurity</span> <span class="hljs-keyword">extends</span></span><span class="hljs-class">      <span class="hljs-title">AbstractConfiguredSecurityBuilder</span>&lt;<span class="hljs-title">Filter</span>, <span class="hljs-title">WebSecurity</span>&gt; <span class="hljs-keyword">implements</span></span><span class="hljs-class">      <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">Filter</span>&gt;, <span class="hljs-title">ApplicationContextAware</span> </span>&#123;        <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> Filter <span class="hljs-title">performBuild</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<span class="hljs-keyword">int</span> chainSize = ignoredRequests.size()+ securityFilterChainBuilders.size();List&lt;SecurityFilterChain&gt; securityFilterChains = <span class="hljs-keyword">new</span> ArrayList&lt;SecurityFilterChain&gt;(chainSize);<span class="hljs-keyword">for</span> (RequestMatcher ignoredRequest : ignoredRequests) &#123;securityFilterChains.add(<span class="hljs-keyword">new</span> DefaultSecurityFilterChain(ignoredRequest));&#125;<span class="hljs-keyword">for</span> (SecurityBuilder&lt;? extends SecurityFilterChain&gt; securityFilterChainBuilder : securityFilterChainBuilders) &#123;securityFilterChains.add(securityFilterChainBuilder.build());&#125;        <span class="hljs-comment">// &lt;1&gt; FilterChainProxy 由 WebSecurity 构建</span>FilterChainProxy filterChainProxy = <span class="hljs-keyword">new</span> FilterChainProxy(securityFilterChains);<span class="hljs-keyword">if</span> (httpFirewall != <span class="hljs-keyword">null</span>) &#123;filterChainProxy.setFirewall(httpFirewall);&#125;filterChainProxy.afterPropertiesSet();Filter result = filterChainProxy;postBuildAction.run();<span class="hljs-keyword">return</span> result;&#125;&#125;</code></pre></div><p>总结起来就是：<strong>一个名称 SpringSecurityFilterChain，借助于 Spring 的 IOC 容器，完成了 DelegatingFilterProxy 到 FilterChainProxy 的连接，并借助于 FilterChainProxy 内部维护的 List 中的某一个 SecurityFilterChain 来完成最终的过滤。</strong></p><h3 id="使用FilterChainProxy的好处"><a href="#使用FilterChainProxy的好处" class="headerlink" title="使用FilterChainProxy的好处"></a>使用FilterChainProxy的好处</h3><p>FilterChainProxy为直接向Servlet容器或 DelegatingFilterProxy注册提供了许多好处。<br>首先，它为Spring Security的所有Servlet支持提供了一个起点。因此，如果您正尝试对Spring Security的Servlet支持进行故障排除，那么在FilterChainProxy中添加一个调试点是一个很好的起点。<br>第二，由于FilterChainProxy是Spring安全使用的核心，它可以执行非可选的任务。例如，它清除SecurityContext以避免内存泄漏。它还可以使用Spring Security的HttpFirewall来保护应用程序免受某些类型的攻击。<br>此外，它在确定何时应该调用SecurityFilterChain方面提供了更大的灵活性。在Servlet容器中，仅根据URL调用过滤器。但是，FilterChainProxy可以通过利用RequestMatcher接口根据HttpServletRequest中的任何内容确定调用。<br>事实上，FilterChainProxy可以用来决定应该使用哪个SecurityFilterChain。这允许在应用程序中为不同的片提供完全独立的配置。<br><img src="https://img-blog.csdnimg.cn/20200517150636845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="图5.多个SecurityFilterChain"><br>在上图中，FilterChainProxy决定应该使用哪个SecurityFilterChain。只有第一个匹配的SecurityFilterChain才会被调用。如果一个URL的/api/messages/被请求，它将首先匹配SecurityFilterChain0的模式/api/<strong>，所以只有SecurityFilterChain0将被调用，即使它也匹配SecurityFilterChain<del>n</del>。如果一个/messages/的URL被请求，它将不匹配SecurityFilterChain0的/api/</strong>模式，所以FilterChainProxy将继续尝试每个SecurityFilterChain。<br>注意SecurityFilterChain<del>0</del>只配置了三个安全过滤器实例。但是，SecurityFilterChain<del>n</del>配置了四个安全过滤器。需要注意的是，每个SecurityFilterChain都可以是唯一的，并在隔离状态下进行配置。事实上，如果应用程序希望Spring security忽略某些请求，SecurityFilterChain可能没有安全过滤器。</p><h2 id="2-5-SecurityFilter"><a href="#2-5-SecurityFilter" class="headerlink" title="2.5 SecurityFilter"></a>2.5 SecurityFilter</h2><p>【<a href="https://www.cnkirito.moe/spring-security-4/" target="_blank" rel="noopener">建议参考这篇博客</a>】<br>所有的过滤器汇总：<br>ChannelProcessingFilter<br>ConcurrentSessionFilter<br>WebAsyncManagerIntegrationFilter<br><strong>SecurityContextPersistenceFilter</strong>：两个主要职责：请求来临时创建 SecurityContext 安全上下文信息，请求结束时清空 SecurityContextHolder。<br>HeaderWriterFilter<br>CorsFilter<br>CsrfFilter：默认开启的一个过滤器，用于防止 csrf 攻击<br>LogoutFilter：处理注销的过滤器<br>OAuth2AuthorizationRequestRedirectFilter<br>Saml2WebSsoAuthenticationRequestFilter<br>X509AuthenticationFilter<br>AbstractPreAuthenticatedProcessingFilter<br>CasAuthenticationFilter<br>OAuth2LoginAuthenticationFilter<br>Saml2WebSsoAuthenticationFilter<br><strong>UsernamePasswordAuthenticationFilter</strong>：表单提交了 username 和 password，被封装成 token 进行一系列的认证，便是主要通过这个过滤器完成的，在表单认证的方法中，这是最最关键的过滤器。<br>ConcurrentSessionFilter<br>OpenIDAuthenticationFilter<br>DefaultLoginPageGeneratingFilter<br>DefaultLogoutPageGeneratingFilter<br>DigestAuthenticationFilter<br>BearerTokenAuthenticationFilter<br>BasicAuthenticationFilter<br>RequestCacheAwareFilter<br>SecurityContextHolderAwareRequestFilter<br>JaasApiIntegrationFilter<br>RememberMeAuthenticationFilter<br><strong>AnonymousAuthenticationFilter</strong>：匿名身份过滤器<br>OAuth2AuthorizationCodeGrantFilter<br><strong>SessionManagementFilter</strong>： 和 session 相关的过滤器，内部维护了一个 SessionAuthenticationStrategy，两者组合使用，常用来防止 session-fixation protection attack，以及限制同一用户开启多个会话的数量<br><strong>ExceptionTranslationFilter</strong>：这个过滤器本身不处理异常，而是将认证过程中出现的异常交给内部维护的一些类去处理<br><strong>FilterSecurityInterceptor</strong>：决定了访问特定路径应该具备的权限，访问的用户的角色，权限是什么？访问的路径需要什么样的角色和权限？这些判断和处理都是由该类进行的。<br>SwitchUserFilter</p><h2 id="2-6-处理安全异常"><a href="#2-6-处理安全异常" class="headerlink" title="2.6 处理安全异常"></a>2.6 处理安全异常</h2><p>ExceptionTranslationFilter允许将AccessDeniedException和AuthenticationException转换为HTTP响应。<br>ExceptionTranslationFilter作为安全过滤器之一插入到FilterChainProxy中。<br><img src="https://img-blog.csdnimg.cn/20200517154307927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="处理安全异常流程"></p><ol><li>首先，ExceptionTranslationFilter调用FilterChain.doFilter(request,response)将调用应用程序的其余部分。<ol start="2"><li>如果用户未通过身份验证或为AuthenticationException，则开始身份验证。</li><li>1 该SecurityContextHolder中被清除出</li><li>2 将HttpServletRequest保存在中RequestCache。用户成功通过身份验证后，将RequestCache用于重播原始请求。</li><li>3 AuthenticationEntryPoint用于从客户机请求凭据。例如，它可能重定向到登录页面或发送WWW-Authenticate头。</li><li>否则，如果是AccessDeniedException，则拒绝访问。调用AccessDeniedHandler处理拒绝的访问。</li></ol></li></ol><p><strong>ExceptionTranslationFilter伪代码</strong></p><div class="hljs"><pre><code class="hljs Markup">try &#123;    filterChain.doFilter(request, response); &#x2F;&#x2F;1&#125; catch (AccessDeniedException | AuthenticationException e) &#123;    if (!authenticated || e instanceof AuthenticationException) &#123;        startAuthentication(); &#x2F;&#x2F;2    &#125; else &#123;        accessDenied(); &#x2F;&#x2F;3    &#125;&#125;</code></pre></div><h1 id="3-认证"><a href="#3-认证" class="headerlink" title="3.认证"></a>3.认证</h1><h2 id="3-1-认证组件"><a href="#3-1-认证组件" class="headerlink" title="3.1 认证组件"></a>3.1 认证组件</h2><p><strong>SecurityContextHolder</strong>  - 用于存储安全上下文（security context）的信息。当前操作的用户是谁，该用户是否已经被认证，他拥有哪些角色权限… 这些都被保存在 SecurityContextHolder 中。SecurityContextHolder 默认使用 ThreadLocal 策略来存储认证信息。在用户登录时自动绑定认证信息到当前线程，在用户退出时，自动清除当前线程的认证信息。</p><p><strong>SecurityContext</strong> -从securitycontextHolder中获取，并包含当前已验证用户的身份验证。</p><p><strong>Authentication</strong>  -直接继承自 Principal 类，而 Principal 是位于 java.security 包中的。可以见得，Authentication 在 spring security 中是<strong>最高级别的身份 / 认证的抽象</strong>。</p><p><strong>GrantedAuthority</strong>-在Authentication（例如角色，范围等）上授予委托人的权限</p><p><strong>AuthenticationManager</strong>-定义Spring Security的Filters如何执行身份验证的API 。<br>AuthenticationManager（接口）是认证相关的核心接口，也是发起认证的出发点，因为在实际需求中，我们可能会允许用户使用用户名 + 密码登录，同时允许用户使用邮箱 + 密码，手机号码 + 密码登录，甚至，可能允许用户使用指纹登录，所以说 AuthenticationManager 一般不直接认证，AuthenticationManager 接口的常用实现类 ProviderManager 内部会维护一个 List<AuthenticationProvider> 列表，存放多种认证方式，实际上这是委托者模式的应用（Delegate）。也就是说，核心的认证入口始终只有一个：AuthenticationManager，不同的认证方式：用户名 + 密码（UsernamePasswordAuthenticationToken），邮箱 + 密码，手机号码 + 密码登录则对应了三个 AuthenticationProvider。</p><p><strong>ProviderManager</strong>-AuthenticationManager的常用实现类。<br>ProviderManager 中的 List，会依照次序去认证，认证成功则立即返回，若认证失败则返回 null，下一个 AuthenticationProvider 会继续尝试认证，如果所有认证器都无法认证成功，则 ProviderManager 会抛出一个 ProviderNotFoundException 异常。</p><p><strong>AuthenticationProvider</strong>-用于ProviderManager执行特定类型的身份验证，最常用的一个实现便是DaoAuthenticationProvider。顾名思义，Dao 正是数据访问层的缩写，也暗示了这个身份认证器的实现思路。<br>用户前台提交了用户名和密码，而数据库中保存了用户名和密码，认证便是负责比对同一个用户名，提交的密码和保存的密码是否相同便是了。在 Spring Security 中。提交的用户名和密码，被封装成了 UsernamePasswordAuthenticationToken，而根据用户名加载用户的任务则是交给了 UserDetailsService，在 DaoAuthenticationProvider 中，对应的方法便是 retrieveUser，虽然有两个参数，但是 retrieveUser 只有第一个参数起主要作用，返回一个 UserDetails。还需要完成 UsernamePasswordAuthenticationToken 和 UserDetails 密码的比对，这便是交给 additionalAuthenticationChecks 方法完成的，如果这个 void 方法没有抛异常，则认为比对成功。</p><p><strong>Request Credentials with AuthenticationEntryPoint</strong> -用于从客户端请求凭证（即，重定向到登录页面，发送WWW-Authenticate响应等）</p><p><strong>AbstractAuthenticationProcessingFilter</strong>-用于认证的基础。这也为高级身份验证流程以及各个部分如何协同工作提供了一个好主意。</p><h2 id="3-2认证机制"><a href="#3-2认证机制" class="headerlink" title="3.2认证机制"></a>3.2认证机制</h2><p><strong>Username and Password</strong> - 使用用户名和密码来进行身份验证</p><p><strong>OAuth 2.0 Login</strong> - 使用OpenID Connect和非标准OAuth 2.0登录（即GitHub）登录的OAuth 2.0</p><p><strong>SAML 2.0 Login</strong> - SAML 2.0 Log In</p><p><strong>Central Authentication Server (CAS)</strong> - 中央身份验证服务器（CAS）支持</p><p><strong>Remember Me</strong> - 将用户信息保存在cookie中，在浏览器关闭后重新打开，用户再去访问hello接口，此时会携带cookie中的remember-me到服务端，服务端拿到值以后，可以方便的计算出用户名和过期时间，再根据用户名查询到用户密码，然后通过MD5散列函数计算出散列值，再将计算出的散列值和浏览器传递来的散列值进行对比，就能确认这个令牌是否有效。</p><p><strong>JAAS Authentication</strong> - 使用JAAS进行认证</p><p><strong>OpenID</strong> - OpenID身份验证（请勿与OpenID Connect混淆）</p><p><strong>Pre-Authentication Scenarios</strong> - 使用诸如SiteMinder或Java EE安全性之类的外部机制进行身份验证，但仍使用Spring Security进行授权和防范常见漏洞。</p><p><strong>X509 Authentication</strong> -X509验证</p><h2 id="3-3-SecurityContextHolder"><a href="#3-3-SecurityContextHolder" class="headerlink" title="3.3 SecurityContextHolder"></a>3.3 SecurityContextHolder</h2><p><img src="https://img-blog.csdnimg.cn/20200517165322654.png" srcset="/img/loading.gif" alt="Security身份验证模型"><br>如何设置SecurityContextHolder</p><div class="hljs"><pre><code class="hljs java">SecurityContext context = SecurityContextHolder.createEmptyContext(); <span class="hljs-comment">//1</span>Authentication authentication =    <span class="hljs-keyword">new</span> TestingAuthenticationToken(<span class="hljs-string">"username"</span>, <span class="hljs-string">"password"</span>, <span class="hljs-string">"ROLE_USER"</span>);<span class="hljs-comment">//2 </span>context.setAuthentication(authentication);SecurityContextHolder.setContext(context);<span class="hljs-comment">//3</span></code></pre></div><p>&lt;1&gt;：我们首先创建一个空的SecurityContext，重要的是创建一个新SecurityContext实例，而不是使用它SecurityContextHolder.getContext().setAuthentication(authentication)来避免跨多个线程的竞争条件。<br>&lt;2&gt;：接下来，我们创建一个新Authentication对象。Spring Security并不关心Authentication在上设置了哪种类型的实现SecurityContext。我们在这里使用TestingAuthenticationToken它是因为它非常简单。更常见的生产方案是UsernamePasswordAuthenticationToken(userDetails, password, authorities)。<br>&lt;3&gt;：最后，我们可以在SecurityContext上设置SecurityContext。</p><p>如果想访问当前认证的用户，可以参考如下代码：</p><div class="hljs"><pre><code class="hljs java">SecurityContext context = SecurityContextHolder.getContext();Authentication authentication = context.getAuthentication();String username = authentication.getName();Object principal = authentication.getPrincipal();Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();</code></pre></div><p>缺省情况下，会SecurityContextHolder使用ThreadLocal来存储这些详细信息，这意味着SecurityContext即使SecurityContext未将显式地传递给这些方法的参数，该方法也始终可用于同一执行线程中的方法。ThreadLocal如果在处理当前委托人的请求之后要清除线程，则以这种方式使用是非常安全的。Spring Security的FilterChainProxy确保SecurityContext is always cleared.</p><h2 id="3-4-SecurityContext"><a href="#3-4-SecurityContext" class="headerlink" title="3.4 SecurityContext"></a>3.4 SecurityContext</h2><p>从SecurityContextHolder中所得。该SecurityContext包含认证对象的所有信息。</p><h2 id="3-5-Authentication"><a href="#3-5-Authentication" class="headerlink" title="3.5 Authentication"></a>3.5 Authentication<img src="https://img-blog.csdnimg.cn/20200517171946822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="继承关系"></h2><p>Authentication在Spring Security中有两个主要目的：</p><ul><li>AuthenticationManager的输入，提供用户提供的用于身份验证的凭据。在此场景中使用时，isAuthenticated()返回false。</li><li>表示当前已验证的用户。当前的身份验证可以从SecurityContext中获得。</li></ul><p>接口源码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.security.core;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Authentication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Principal</span>, <span class="hljs-title">Serializable</span> </span>&#123;    Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); <span class="hljs-comment">//1</span>    <span class="hljs-function">Object <span class="hljs-title">getCredentials</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 2</span>    <span class="hljs-function">Object <span class="hljs-title">getDetails</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 3</span>        <span class="hljs-function">Object <span class="hljs-title">getPrincipal</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 4</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAuthenticated</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAuthenticated</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> var1)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException</span>;&#125;</code></pre></div><p>(1)：权限信息列表，默认是 GrantedAuthority 接口的一些实现类，通常是代表权限信息的一系列字符串。<br>(2)：密码信息，用户输入的密码字符串，在认证过后通常会被移除，用于保障安全。<br>(3)：细节信息，web 应用中的实现接口通常为 WebAuthenticationDetails，它记录了访问者的 ip 地址和 sessionId 的值。<br>(4)：敲黑板！！！最重要的身份信息，大部分情况下返回的是 UserDetails 接口的实现类，也是框架中的常用接口之一。</p><h2 id="3-6-GrantedAuthority"><a href="#3-6-GrantedAuthority" class="headerlink" title="3.6 GrantedAuthority"></a>3.6 GrantedAuthority</h2><p>GrantedAuthoritys是授予用户的高级权限。主要是角色或范围。<br>可以从authentication.getauthoritys()方法获得GrantedAuthoritys。此方法提供授予的权限对象的集合。这些权限通常是“角色”，例如ROLE_ADMINISTRATOR或ROLE_HR_SUPERVISOR。稍后将为web授权、方法授权和域对象授权配置这些角色。</p><h2 id="3-7-AuthenticationManager"><a href="#3-7-AuthenticationManager" class="headerlink" title="3.7 AuthenticationManager"></a>3.7 AuthenticationManager</h2><p>AuthenticationManager（接口）是认证相关的核心接口，也是发起认证的出发点，因为在实际需求中，我们可能会允许用户使用<strong>用户名 + 密码</strong>登录，同时允许用户使用邮箱 + 密码，手机号码 + 密码登录，甚至，可能允许用户使用指纹登录，所以说 AuthenticationManager 一般不直接认证，<strong>AuthenticationManager 接口的实现类去完成认证工作</strong>。</p><h2 id="3-8-ProviderManager"><a href="#3-8-ProviderManager" class="headerlink" title="3.8 ProviderManager"></a>3.8 ProviderManager</h2><p>ProviderManager是AuthenticationManager最常用的实现。ProviderManager委托给AuthenticationProvider列表。每个AuthenticationProvider都有机会指示身份验证应该成功、失败，或者指示它不能做出决定并允许下游的AuthenticationProvider作出决定。在默认策略下，只需要通过一个 AuthenticationProvider 的认证，即可被认为是登录成功。如果所有配置的authenticationprovider都不能进行身份验证，那么身份验证将失败，出现ProviderNotFoundException，这是一个特殊的AuthenticationException，表明ProviderManager不支持Aut类型。<br><img src="https://img-blog.csdnimg.cn/20200517181019629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="ProviderManager"><br>事实上，多个ProviderManager实例可能共享同一个父AuthenticationManager。在有多个SecurityFilterChain实例的场景中经常见到，这些实例有一些共同的身份验证(共享的父AuthenticationManager)，但也有不同的身份验证机制(不同的ProviderManager实例)。<br><img src="https://img-blog.csdnimg.cn/20200517181558524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="multiple ProviderManager"><br>默认情况下，ProviderManager将尝试从成功的身份验证请求返回的Authentication对象中清除任何敏感的凭据信息。这可以防止密码等信息在HttpSession中保留的时间超过必要的时间。<br>例如，当您使用用户对象的缓存来提高无状态应用程序的性能时，这可能会导致问题。如果身份验证包含对缓存中的对象的引用(例如UserDetails实例)，并且该对象的凭据已被删除，则不再能够根据缓存的值进行身份验证。如果使用缓存，则需要考虑这一点。一个明显的解决方案是，首先在缓存实现中或在创建返回的Authentication对象的AuthenticationProvider中复制对象。</p><h2 id="3-9-AuthenticationProvider"><a href="#3-9-AuthenticationProvider" class="headerlink" title="3.9 AuthenticationProvider"></a>3.9 AuthenticationProvider</h2><p>可以将多个AuthenticationProvider注入到ProviderManager中。每个AuthenticationProvider执行特定类型的身份验证。例如，DaoAuthenticationProvider支持基于用户名/密码的身份验证，而JwtAuthenticationProvider支持对JWT令牌进行身份验证。<br>AuthenticationProvider 最最最常用的一个实现便是 <strong>DaoAuthenticationProvider</strong>。顾名思义，Dao 正是数据访问层的缩写，也暗示了这个身份认证器的实现思路。</p><p>接下来分析DaoAuthenticationProvider是如何认证用户的？</p><div class="hljs"><pre><code class="hljs java">org.springframework.security.authentication.dao.DaoAuthenticationProvider<span class="hljs-comment">//1.根据用户名加载用户</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> UserDetails <span class="hljs-title">retrieveUser</span><span class="hljs-params">(String username,</span></span><span class="hljs-function"><span class="hljs-params">UsernamePasswordAuthenticationToken authentication)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;prepareTimingAttackProtection();<span class="hljs-keyword">try</span> &#123;UserDetails loadedUser = <span class="hljs-keyword">this</span>.getUserDetailsService().loadUserByUsername(username);<span class="hljs-keyword">if</span> (loadedUser == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalAuthenticationServiceException(<span class="hljs-string">"UserDetailsService returned null, which is an interface contract violation"</span>);&#125;<span class="hljs-keyword">return</span> loadedUser;&#125;<span class="hljs-keyword">catch</span> (UsernameNotFoundException ex) &#123;<span class="hljs-comment">//各种异常处理</span>&#125;<span class="hljs-comment">//...省略剩下的catch块</span>&#125;<span class="hljs-comment">//2.完成密码的比对工作</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">additionalAuthenticationChecks</span><span class="hljs-params">(UserDetails userDetails,</span></span><span class="hljs-function"><span class="hljs-params">UsernamePasswordAuthenticationToken authentication)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;<span class="hljs-keyword">if</span> (authentication.getCredentials() == <span class="hljs-keyword">null</span>) &#123;logger.debug(<span class="hljs-string">"Authentication failed: no credentials provided"</span>);<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(messages.getMessage(<span class="hljs-string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,<span class="hljs-string">"Bad credentials"</span>));&#125;String presentedPassword = authentication.getCredentials().toString();<span class="hljs-keyword">if</span> (!passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;logger.debug(<span class="hljs-string">"Authentication failed: password does not match stored value"</span>);<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(messages.getMessage(<span class="hljs-string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,<span class="hljs-string">"Bad credentials"</span>));&#125;&#125;</code></pre></div><p>在 Spring Security 中。提交的用户名和密码，被封装成了 UsernamePasswordAuthenticationToken，而根据用户名加载用户的任务则是交给了 UserDetailsService，在 DaoAuthenticationProvider 中，对应的方法便是 retrieveUser，虽然有两个参数，但是 retrieveUser 只有第一个参数起主要作用，返回一个 UserDetails。还需要完成 UsernamePasswordAuthenticationToken 和 UserDetails 密码的比对，这便是交给 additionalAuthenticationChecks 方法完成的，如果这个 void 方法没有抛异常，则认为比对成功。</p><h2 id="3-10-AuthenticationEntryPoint"><a href="#3-10-AuthenticationEntryPoint" class="headerlink" title="3.10  AuthenticationEntryPoint"></a>3.10  AuthenticationEntryPoint</h2><p>AuthenticationEntryPoint 是认证的入口点，用于发送HTTP响应，以从客户端请求凭据。</p><p>有时，客户端会主动包含凭据（例如用户名/密码）以请求资源。在这些情况下，Spring Security无需提供HTTP响应即可从客户端请求凭证，因为它们已包含在内。</p><p>如果ExceptionTranslationFilter检测到 AuthenticationException（认证异常），则将会交给内部的 AuthenticationEntryPoint 去处理，如果检测到 AccessDeniedException（访问异常），需要先判断当前用户是不是匿名用户，如果是匿名访问，则和前面一样运行 AuthenticationEntryPoint，否则会委托给 AccessDeniedHandler 去处理，而 AccessDeniedHandler 的默认实现，是 AccessDeniedHandlerImpl。所以 ExceptionTranslationFilter 内部的 AuthenticationEntryPoint 是至关重要的。</p><p>比如说，客户端将向未经授权访问的资源发出未经身份验证的请求。在这种情况下，AuthenticationEntryPoint的实现用于从客户机请求凭据。AuthenticationEntryPoint实现可能会重定向到登录页面，响应一个WWW-Authenticate头。</p><h2 id="3-11-AbstractAuthenticationProcessingFilter"><a href="#3-11-AbstractAuthenticationProcessingFilter" class="headerlink" title="3.11 AbstractAuthenticationProcessingFilter"></a>3.11 AbstractAuthenticationProcessingFilter</h2><p>AbstractAuthenticationProcessingFilter用作对用户凭证进行身份验证的基础过滤器。在认证凭证之前，Spring Security通常使用AuthenticationEntryPoint请求凭证。<br>接下来，AbstractAuthenticationProcessingFilter可以验证提交给它的任何身份验证请求。<br><img src="https://img-blog.csdnimg.cn/20200517184444256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="工作流程"><br>（1）：当用户提交其凭证时，AbstractAuthenticationProcessingFilter从HttpServletRequest创建一个要进行身份验证的Authentication。创建的Authentication类型取决于AbstractAuthenticationProcessingFilter的子类。例如，UsernamePasswordAuthenticationFilter根据在HttpServletRequest中提交的用户名和密码创建UsernamePasswordAuthenticationToken。<br>（2）：接下来，将Authentication传递到AuthenticationManager中进行身份验证。<br>（3）：如果身份验证失败，则将该Authentication从SecurityContextHolder中被清除出去，RememberMeServices.loginFail被调用（如果开启了记住我功能），AuthenticationFailureHandler 被调用。<br>（4）：如果身份验证成功，则</p><ul><li>SessionAuthenticationStrategy 收到新登录通知；</li><li>该Authentication被设置在SecurityContextHolder中。稍后将SecurityContextPersistenceFilter保存SecurityContext到HttpSession；</li><li>RememberMeServices.loginSuccess被调用（如果开启了记住我功能）；</li><li>ApplicationEventPublisher发布InteractiveAuthenticationSuccessEvent。</li></ul><h2 id="3-12-Username-Password-Authentication"><a href="#3-12-Username-Password-Authentication" class="headerlink" title="3.12 Username/Password Authentication"></a>3.12 Username/Password Authentication</h2><p>验证用户身份的最常见方法之一是验证用户名和密码。这样，Spring Security为使用用户名和密码进行身份验证提供了全面的支持。</p><p><strong>读取用户名和密码</strong><br>Spring Security提供了以下内置机制，用于从中读取用户名和密码HttpServletRequest：</p><ul><li>表单登录</li><li>基本认证</li><li>摘要式身份验证</li></ul><p><strong>储存机制</strong></p><ul><li>用于读取用户名和密码的每种受支持的机制都可以利用任何受支持的存储机制：</li><li>带有内存身份验证的简单存储</li><li>具有JDBC身份验证的关系数据库</li><li>使用UserDetailsService的自定义数据存储</li><li>具有LDAP认证的 LDAP存储</li></ul><h3 id="表单登录"><a href="#表单登录" class="headerlink" title="表单登录"></a>表单登录</h3><p><img src="https://img-blog.csdnimg.cn/20200517185816784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt=".重定向到登录页面"></p><ol><li>首先，用户向未经授权的资源发出未经身份验证的请求/private。</li><li>Spring Security 通过抛出AccessDeniedException来表示FilterSecurityInterceptor拒绝未认证的请求。</li><li>由于用户未进行身份验证，ExceptionTranslationFilter启动启动身份验证，并使用配置的AuthenticationEntryPoint向登录页面发送重定向。在大多数情况下，AuthenticationEntryPoint是LoginUrlAuthenticationEntryPoint的实例。</li><li>然后，浏览器将请求将其重定向到的登录页面。</li><li>应用程序中的某些内容必须呈现登录页面。</li></ol><p>提交用户名和密码等信息后，将对用户名和密码进行UsernamePasswordAuthenticationFilter身份验证。该UsernamePasswordAuthenticationFilter扩展AbstractAuthenticationProcessingFilter，所以这张图看起来应该非常相似。<img src="https://img-blog.csdnimg.cn/20200517190118241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="验证用户名和密码"></p><ol><li><p>当用户提交其用户名和密码时，UsernamePasswordAuthenticationFilter会通过UsernamePasswordAuthenticationToken从中Authentication提取用户名和密码来创建，这是一种HttpServletRequest。</p></li><li><p>接下来，将UsernamePasswordAuthenticationToken传递到AuthenticationManager中进行身份验证。AuthenticationManager外观的细节取决于用户信息的存储方式。</p></li><li><p>如果身份验证失败，则将该Authentication从SecurityContextHolder中被清除出去，RememberMeServices.loginFail被调用（如果开启了记住我功能），AuthenticationFailureHandler 被调用。</p></li><li><p>如果身份验证成功，则</p><ul><li>SessionAuthenticationStrategy 收到新登录通知；</li><li>该Authentication被设置在SecurityContextHolder中。稍后将SecurityContextPersistenceFilter保存SecurityContext到HttpSession；</li><li>RememberMeServices.loginSuccess被调用（如果开启了记住我功能）；</li><li>ApplicationEventPublisher发布InteractiveAuthenticationSuccessEvent。</li></ul></li></ol><h3 id="基本认证"><a href="#基本认证" class="headerlink" title="基本认证"></a>基本认证</h3><p><img src="https://img-blog.csdnimg.cn/20200517190615814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="发送www验证头"></p><ol><li>首先，用户向未经授权的资源发出未经身份验证的请求。</li><li>Spring Security 通过抛出来FilterSecurityInterceptor表示未认证的请求被拒绝AccessDeniedException。</li><li>由于用户没有经过身份验证，ExceptionTranslationFilter启动Authentication进行身份验证。配置的AuthenticationEntryPoint是BasicAuthenticationEntryPoint的一个实例，它发送一个WWW-Authenticate头。RequestCache通常是一个NullRequestCache，它不保存请求。<br>当客户端收到WWW-Authenticate标头时，它知道应该使用用户名和密码重试。以下是正在处理的用户名和密码的流程。<br><img src="https://img-blog.csdnimg.cn/20200517191017240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="验证用户名和密码"><br>基本流程同表单登录<h3 id="内存中身份验证"><a href="#内存中身份验证" class="headerlink" title="内存中身份验证"></a>内存中身份验证</h3>Spring Security的InMemoryUserDetailsManager实现UserDetailsService为在内存中检索的基于用户名/密码的身份验证提供支持。 通过实现接口InMemoryUserDetailsManager提供管理。 </li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> UserDetailsService <span class="hljs-title">users</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// The builder will ensure the passwords are encoded before saving in memory</span>    UserBuilder users = User.withDefaultPasswordEncoder();    UserDetails user = users        .username(<span class="hljs-string">"user"</span>)        .password(<span class="hljs-string">"password"</span>)        .roles(<span class="hljs-string">"USER"</span>)        .build();    UserDetails admin = users        .username(<span class="hljs-string">"admin"</span>)        .password(<span class="hljs-string">"password"</span>)        .roles(<span class="hljs-string">"USER"</span>, <span class="hljs-string">"ADMIN"</span>)        .build();    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InMemoryUserDetailsManager(user, admin);&#125;</code></pre></div><h3 id="JDBC验证"><a href="#JDBC验证" class="headerlink" title="JDBC验证"></a>JDBC验证</h3><p>Spring Security的JdbcDaoImpl实现了UserDetailsService，为使用JDBC检索的基于用户名/密码的身份验证提供支持。JdbcUserDetailsManager扩展了JdbcDaoImpl，通过UserDetailsManager接口提供对用户详细信息的管理。当Spring Security配置为接受用户名/密码进行身份验证时，将使用基于UserDetails的身份验证。<br><img src="https://img-blog.csdnimg.cn/20200517192443191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="继承关系"></p><ol><li><p>准备数据库用于存放用户信息，权限信息，以及用户权限关联表，Spring Security为基于JDBC的身份验证提供默认查询以及与默认查询一起使用的相应默认架构（路径：org/springframework/security/core/userdetails/jdbc/users.ddl）<br>默认的用户模式：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function">create table <span class="hljs-title">users</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">    username varchar_ignorecase(<span class="hljs-number">50</span>)</span> not <span class="hljs-keyword">null</span> primary key,</span><span class="hljs-function">    password <span class="hljs-title">varchar_ignorecase</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span> not <span class="hljs-keyword">null</span>,</span><span class="hljs-function">    enabled <span class="hljs-keyword">boolean</span> not <span class="hljs-keyword">null</span></span><span class="hljs-function">)</span>;<span class="hljs-function">create table <span class="hljs-title">authorities</span> <span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">    username varchar_ignorecase(<span class="hljs-number">50</span>)</span> not <span class="hljs-keyword">null</span>,</span><span class="hljs-function">    authority <span class="hljs-title">varchar_ignorecase</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span> not <span class="hljs-keyword">null</span>,</span><span class="hljs-function">    constraint fk_authorities_users foreign <span class="hljs-title">key</span><span class="hljs-params">(username)</span> references <span class="hljs-title">users</span><span class="hljs-params">(username)</span></span><span class="hljs-function">)</span>;<span class="hljs-function">create unique index ix_auth_username on <span class="hljs-title">authorities</span> <span class="hljs-params">(username,authority)</span></span>;</code></pre></div></li><li><p>设置数据源</p></li><li><p>配置JdbcUserDetailsManager让我们通过JDBC的方式将数据库和Spring Security连接起来。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<span class="hljs-comment">//userService是UserDetailsService的实现类</span>      auth.userDetailsService(userService);  &#125;</code></pre></div></li><li><p>UserDetails</p></li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDetails</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span> </span>&#123;<span class="hljs-comment">//获取用户权限集</span>Collection&lt;? extends GrantedAuthority&gt; getAuthorities();<span class="hljs-comment">//获得用户名</span><span class="hljs-function">String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//账户是否过期</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonExpired</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//账户是否锁定</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonLocked</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//凭证是否过期</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCredentialsNonExpired</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//账户是否可用</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>一般我们都是实现该接口，另外加上自己想要的信息，比如手机号，地址等等。</p><ol start="4"><li>UserDetailsService</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;<span class="hljs-function">UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException</span>;&#125;</code></pre></div><p>里面就一个方法，根据用户名返回用户信息，这里可以根据不同的验证方式来定制我们自己所需的UserDetailsService实现类。UserDetailsService由DaoAuthenticationProvider用于检索用户名、密码和其他属性，用于使用用户名和密码进行身份验证。Spring Security提供了基于内存和JDBC的UserDetailsService的实现类。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    UserDao userDao;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;        User user = userDao.findUserByUsername(username);        <span class="hljs-keyword">if</span>(user==<span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">"用户不存在"</span>);        &#125;        <span class="hljs-keyword">return</span> user;    &#125;&#125;</code></pre></div><ol start="5"><li>密码编码器</li></ol><p>可以根据需要选择PasswordEncoder接口的实现类。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>   <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span></span>&#123;       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();   &#125;</code></pre></div><ol start="6"><li>DaoAuthenticationProvider<br>DaoAuthenticationProvider是AuthenticationProvider的一种实现类，利用UserDetailsService和PasswordEncoder验证用户名和密码。<br><img src="https://img-blog.csdnimg.cn/20200517201812740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="用法"></li></ol><p>1、从读取用户名和密码的Authentication Filter将一个UsernamePasswordAuthenticationToken传递给由ProviderManager实现的AuthenticationManager。</p><p>2、ProviderManager被配置为使用DaoAuthenticationProvider类型的AuthenticationProvider;</p><p>3、 DaoAuthenticationProvider从UserDetailsService中查找用户详细信息。</p><p>4、 然后，DaoAuthenticationProvider使用PasswordEncoder验证上一步返回的用户详细信息上的密码;</p><p>5、当身份验证成功时，返回的身份验证类型为UsernamePasswordAuthenticationToken，其主体是配置的UserDetailsService返回的用户详细信息。最终，返回的UsernamePasswordAuthenticationToken将由Authentication Filter在securitycontextHolder中设置</p><h2 id="3-13-Session-Management（会话管理）"><a href="#3-13-Session-Management（会话管理）" class="headerlink" title="3.13 Session Management（会话管理）"></a>3.13 Session Management（会话管理）</h2><p>HTTP会话相关的功能由SessionManagementFilter和SessionAuthenticationStrategy接口的组合来处理，该接口是过滤器委托给的。典型的用法包括会话固定保护攻击预防、会话超时检测和对已验证用户可以同时打开多少会话的限制。</p><h3 id="超时检测"><a href="#超时检测" class="headerlink" title="超时检测"></a>超时检测</h3><p>配置Spring Security来检测提交的无效会话ID，并将用户重定向到适当的URL。这是通过以下session-management元素实现的：</p><div class="hljs"><pre><code class="hljs markup">&lt;http&gt;...&lt;session-management invalid-session-url&#x3D;&quot;&#x2F;invalidSession.htm&quot; &#x2F;&gt;&lt;&#x2F;http&gt;</code></pre></div><p>请注意，如果使用此机制来检测会话超时，则在用户注销然后重新登录而不关闭浏览器的情况下，它可能会错误地报告错误。这是因为在使会话无效时不会清除会话cookie，即使用户已注销，会话cookie也会重新提交。您可以通过在注销时显式删除JSESSIONID cookie，例如通过在注销处理程序中使用以下语法：</p><div class="hljs"><pre><code class="hljs markup">&lt;http&gt;&lt;logout delete-cookies&#x3D;&quot;JSESSIONID&quot; &#x2F;&gt;&lt;&#x2F;http&gt;</code></pre></div><p>不幸的是，不能保证它可以与每个servlet容器一起使用，因此您需要在您的环境中对其进行测试，这里不展开讨论。</p><h3 id="并发会话控制"><a href="#并发会话控制" class="headerlink" title="并发会话控制"></a>并发会话控制</h3><p>如果您希望限制单个用户登录应用程序的能力，Spring Security会通过以下简单的补充来支持此功能。首先，您需要向文件中添加以下侦听器，web.xml以使Spring Security保持有关会话生命周期事件的最新信息：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span> <span class="hljs-function">HttpSessionEventPublisher <span class="hljs-title">httpSessionEventPublisher</span><span class="hljs-params">()</span></span>&#123;     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HttpSessionEventPublisher(); &#125;</code></pre></div><p>然后将以下行添加到您的应用程序上下文：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http.authorizeRequests().sessionManagement().maximumSessions(<span class="hljs-number">1</span>)</code></pre></div><p>这将防止用户多次登录，第二次登录将使第一次登录无效。如果您希望避免再次登录，在这种情况下，您可以使用</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http.authorizeRequests().sessionManagement().maximumSessions(<span class="hljs-number">1</span>).maxSessionsPreventsLogin(<span class="hljs-keyword">true</span>);</code></pre></div><p>然后，第二次登录将被拒绝。“拒绝”是指如果用户authentication-failure-url正在使用基于表单的登录名，则该用户将被发送到该页面。如果第二次身份验证是通过另一个非交互机制（例如“ remember-me”）进行的，则“未授权”（401）错误将发送给客户端。相反，如果要使用错误页面，则可以将属性添加session-authentication-error-url到session-management元素。</p><h2 id="3-14-Remember-Me-Authentication"><a href="#3-14-Remember-Me-Authentication" class="headerlink" title="3.14 Remember-Me Authentication"></a>3.14 Remember-Me Authentication</h2><p>“记住我”或“持久登录”身份验证是指网站能够记住会话之间的主体身份。通常，这是通过向浏览器发送一个cookie来实现的，该cookie在以后的会话中被检测到并引起自动登录。Spring Security提供了进行这些操作所需的钩子，并具有两个具体的“记住我”实现。一种使用散列来保留基于cookie的令牌的安全性，另一种使用数据库或其他持久性存储机制来存储生成的令牌。<br>请注意，两个实现都需要一个UserDetailsService。如果您正在使用不使用的身份验证提供程序UserDetailsService（例如LDAP提供程序），那么除非您UserDetailsService在应用程序上下文中也有bean，否则它将无法工作。</p><h3 id="简单的基于哈希的令牌方法"><a href="#简单的基于哈希的令牌方法" class="headerlink" title="简单的基于哈希的令牌方法"></a>简单的基于哈希的令牌方法</h3><p>这种方法使用哈希来实现有用的“记住我”策略。本质上，在成功进行交互式身份验证后，会将cookie发送到浏览器，该cookie的组成如下：</p><div class="hljs"><pre><code class="hljs markup">base64(username + &quot;:&quot; + expirationTime + &quot;:&quot; +md5Hex(username + &quot;:&quot; + expirationTime + &quot;:&quot; password + &quot;:&quot; + key))username:          As identifiable to the UserDetailsServicepassword:          That matches the one in the retrieved UserDetailsexpirationTime:    The date and time when the remember-me token expires, expressed in millisecondskey:               A private key to prevent modification of the remember-me token</code></pre></div><p>因此，“记住我”令牌仅在指定的期限内有效，并且前提是用户名，密码和密钥不变。值得注意的是，这存在潜在的安全问题，因为捕获的“记住我”令牌将可从任何用户代理使用，直到令牌到期为止。这与摘要身份验证相同。如果委托人知道已捕获令牌，则他们可以轻松更改密码并立即使所有出现问题的“记住我”令牌失效。如果需要更重要的安全性，则应使用下一节所述的方法。另外，根本不应该使用“记住我”服务。<br>开启“记住我”功能：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;     http.authorizeRequests().rememberMe().key(<span class="hljs-string">"yyj"</span>)</code></pre></div><h3 id="持久令牌方法"><a href="#持久令牌方法" class="headerlink" title="持久令牌方法"></a>持久令牌方法</h3><p>持久化令牌就是在基本的自动登录功能实现的基础上，又增加了新的校验参数，来提高系统的安全性。<br>在持久化令牌中，新增了两个经过MD5散列函数计算的校验参数，一个是series，另一个是token，其中series只有当用户在使用用户名/密码登录的时候才会生成或者更新，而token只要有新的会话就会重新生成，这就避免了一个用户同时在多端登录。<br>持久化令牌的具体处理类在PersistentTokenBasedRememberMeServices中。<br>首先我们需要一张表来记录令牌信息，这张表我们可以完全自定义，也可以使用系统默认提供的JDBC来操作，如果使用默认的JDBC，即JdbcTokenRepositoryImpl。<br>这里提供了一个JdbcTokenRepositoryImpl实例，并为其配置DataSource数据源，最后通过tokenRepository将JdbcTokenRepositoryImpl实例纳入配置中。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>   <span class="hljs-function">JdbcTokenRepositoryImpl <span class="hljs-title">jdbcTokenRepository</span><span class="hljs-params">()</span></span>&#123;       JdbcTokenRepositoryImpl jdbcTokenRepository = <span class="hljs-keyword">new</span> JdbcTokenRepositoryImpl();       jdbcTokenRepository.setDataSource(dataSource);       <span class="hljs-keyword">return</span> jdbcTokenRepository;   &#125;<span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;       http.authorizeRequests().rememberMe().key(<span class="hljs-string">"yyj"</span>).tokenRepository(jdbcTokenRepository())</code></pre></div><h2 id="3-15-Handling-Logouts"><a href="#3-15-Handling-Logouts" class="headerlink" title="3.15 Handling Logouts"></a>3.15 Handling Logouts</h2><h3 id="注销Java配置"><a href="#注销Java配置" class="headerlink" title="注销Java配置"></a>注销Java配置</h3><p>使用时WebSecurityConfigurerAdapter，将自动应用注销功能。默认设置是访问URL /logout，将通过以下方式注销用户：</p><ul><li>使HTTP会话无效</li><li>清理配置的所有RememberMe身份验证</li><li>清除 SecurityContextHolder</li><li>重定向到 /login?logout</li></ul><p>但是，与配置登录功能相似，您还可以使用各种选项来进一步自定义注销要求：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http        .logout(logout -&gt; logout                           <span class="hljs-comment">//1                      </span>            .logoutUrl(<span class="hljs-string">"/my/logout"</span>)                       <span class="hljs-comment">//2                   </span>            .logoutSuccessUrl(<span class="hljs-string">"/my/index"</span>)                 <span class="hljs-comment">//3                </span>            .logoutSuccessHandler(logoutSuccessHandler)    <span class="hljs-comment">//4             </span>            .invalidateHttpSession(<span class="hljs-keyword">true</span>)                   <span class="hljs-comment">//5          </span>            .addLogoutHandler(logoutHandler)               <span class="hljs-comment">//6       </span>            .deleteCookies(cookieNamesToClear)             <span class="hljs-comment">//7     </span>        )        ...&#125;</code></pre></div><ul><li>提供注销支持。使用时会自动应用WebSecurityConfigurerAdapter。</li><li>触发注销的URL(默认为/logout)。如果启用了CSRF保护(默认)，那么请求也必须是POST。</li><li>注销发生后重定向到的URL。默认值为/login?logout。</li><li>让我们指定一个定制的 LogoutSuccessHandler。如果指定，将logoutSuccessUrl()被忽略。</li><li>指定HttpSession在注销时是否使无效。默认情况下是这样。SecurityContextLogoutHandler在幕后进行配置。</li><li>添加一个LogoutHandler。默认情况下SecurityContextLogoutHandler被添加为最后一个LogoutHandler。</li><li>允许指定成功注销后将删除的cookie名称。这是CookieClearingLogoutHandler显式添加快捷方式。</li></ul><p>通常，为了自定义注销功能，可以添加 LogoutHandler 和/或 LogoutSuccessHandler 实现。</p><h3 id="注销成功处理程序"><a href="#注销成功处理程序" class="headerlink" title="注销成功处理程序"></a>注销成功处理程序</h3><p>LogoutSuccessHandler在成功注销后，将调用LogoutFilter，以处理例如重定向或转发到适当的目的地，不过可能会引起异常。<br>有如下两种实现可供选择：</p><ul><li>SimpleUrlLogoutSuccessHandler</li><li>HttpStatusReturningLogoutSuccessHandler</li></ul><p>正如上面提到的，您不需要直接指定SimpleUrlLogoutSuccessHandler。相反，fluent API通过设置logoutSuccessUrl()提供了一个快捷方式。这将在幕后设置SimpleUrlLogoutSuccessHandler。在注销之后，提供的URL将被重定向到。默认是/login?logout<br>在REST API类型的场景中，HttpStatusReturningLogoutSuccessHandler非常有趣。LogoutSuccessHandler允许您提供要返回的纯HTTP状态代码，而不是在成功注销后重定向到URL。如果没有配置状态码200将默认返回。</p><h2 id="3-16Authentication-Events"><a href="#3-16Authentication-Events" class="headerlink" title="3.16Authentication Events"></a>3.16Authentication Events</h2><p>对于成功或失败的每个身份验证，分别触发AuthenticationSuccessEvent或AuthenticationFailureEvent。</p><p>要收听这些事件，您必须首先发布AuthenticationEventPublisher。Spring Security DefaultAuthenticationEventPublisher可能会做得很好：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-keyword">public</span> AuthenticationEventPublisher authenticationEventPublisher        (ApplicationEventPublisher applicationEventPublisher) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultAuthenticationEventPublisher(applicationEventPublisher);&#125;</code></pre></div><p>然后，您可以使用Spring的@EventListener支持：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthenticationEvents</span> </span>&#123;    <span class="hljs-meta">@EventListener</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(AuthenticationSuccessEvent success)</span> </span>&#123;        <span class="hljs-comment">// ...</span>    &#125;    <span class="hljs-meta">@EventListener</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(AuthenticationFailureEvent failures)</span> </span>&#123;        <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre></div><h3 id="添加异常映射"><a href="#添加异常映射" class="headerlink" title="添加异常映射"></a>添加异常映射</h3><p>默认情况下，DefaultAuthenticationEventPublisher将发布以下事件的AuthenticationFailureEvent:<br><img src="https://img-blog.csdnimg.cn/20200517212651484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="异常映射"><br>发布者进行精确Exception匹配，这意味着这些异常的子类也不会产生事件。<br>为此，您可能希望通过以下setAdditionalExceptionMappings方法向发布者提供其他映射：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-keyword">public</span> AuthenticationEventPublisher authenticationEventPublisher        (ApplicationEventPublisher applicationEventPublisher) &#123;    Map&lt;Class&lt;? extends AuthenticationException&gt;,        Class&lt;? extends AuthenticationFailureEvent&gt;&gt; mapping =            Collections.singletonMap(FooException<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">FooEvent</span>.<span class="hljs-title">class</span>)</span>;    AuthenticationEventPublisher authenticationEventPublisher =        <span class="hljs-keyword">new</span> DefaultAuthenticationEventPublisher(applicationEventPublisher);    authenticationEventPublisher.setAdditionalExceptionMappings(mapping);    <span class="hljs-keyword">return</span> authenticationEventPublisher;&#125;</code></pre></div><h1 id="4-授权"><a href="#4-授权" class="headerlink" title="4.授权"></a>4.授权</h1><p>pring Security中的高级授权功能代表了其受欢迎程度的最令人信服的原因之一。无论选择哪种身份验证方式（使用Spring Security提供的机制和提供程序，还是与容器或其他非Spring Security身份验证机构集成），您都会发现可以在应用程序中以一致且简单的方式使用授权服务。</p><h2 id="4-1-授权架构"><a href="#4-1-授权架构" class="headerlink" title="4.1 授权架构"></a>4.1 授权架构</h2><h3 id="Authorities"><a href="#Authorities" class="headerlink" title="Authorities"></a>Authorities</h3><p>之前讲Authentication时就提到了getAuthorities()方法用来返回GrantedAuthority集合。而这些GrantedAuthority集合就代表了已授予委托人的权限。授予权限对象由AuthenticationManager插入到身份验证对象中，然后在进行授权决策时由AccessDecisionManager 读取。<br>GrantedAuthority 是一个只有一个方法的接口:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">getAuthority</span><span class="hljs-params">()</span></span>;</code></pre></div><p>此方法允许AccessDecisionManager获取授予权限的精确字符串表示形式。通过返回一个表示为字符串的形式，大多数AccessDecisionManager都可以轻松地“读取”授予的权限。如果授予的权限不能精确地表示为字符串，则认为授予的权限是“复杂的”，而getAuthority()必须返回null。<br>“复杂”授予权限的一个示例是存储应用于不同客户帐号的操作和权限阈值列表的实现。将这个复杂的授予权限表示为字符串非常困难，因此getAuthority()方法应该返回null。这将向任何AccessDecisionManager表明，它将需要专门支持GrantedAuthority实现，以便理解其内容。<br>Spring安全性包括一个具体的授予权限实现SimpleGrantedAuthority。这允许将任何用户指定的字符串转换为授予的权限。安全体系结构中包含的所有AuthenticationProvider都使用SimpleGrantedAuthority填充Authentication对象。</p><h3 id="调用前处理"><a href="#调用前处理" class="headerlink" title="调用前处理"></a>调用前处理</h3><p>Spring Security提供了拦截器，用于控制对安全对象的访问，例如方法调用或Web请求。由做出关于是否允许进行调用的预调用决定AccessDecisionManager。<br><strong>AccessDecisionManager</strong><br>由AccessDecisionManager调用，AbstractSecurityInterceptor并负责做出最终的访问控制决策。该AccessDecisionManager接口包含三种方法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decide</span><span class="hljs-params">(Authentication authentication, Object secureObject,</span></span><span class="hljs-function"><span class="hljs-params">    Collection&lt;ConfigAttribute&gt; attrs)</span> <span class="hljs-keyword">throws</span> AccessDeniedException</span>;<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(ConfigAttribute attribute)</span></span>;<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class clazz)</span></span>;</code></pre></div><p>AccessDecisionManager的decide()方法被传递所有它需要的相关信息，以便进行授权决策。特别是，传递安全对象允许检查实际安全对象调用中包含的那些参数。例如，让我们假设安全对象是一个MethodInvocation。可以很容易地查询任何客户参数的MethodInvocation，然后在AccessDecisionManager中实现某种安全逻辑，以确保允许主体对该客户进行操作。如果请求被拒绝，则抛出AccessDeedException异常。</p><p>在启动时，supports(ConfigAttribute)由方法调用此方法AbstractSecurityInterceptor，以确定是否AccessDecisionManager可以处理传递的ConfigAttribute。supports(Class)安全拦截器实现调用该方法，以确保配置的AccessDecisionManager支持安全拦截器将呈现的安全对象的类型，一般都默认返回true。</p><h3 id="调用处理后"><a href="#调用处理后" class="headerlink" title="调用处理后"></a>调用处理后</h3><p>尽管在继续进行安全对象调用之前AccessDecisionManager由AbstractSecurityInterceptor调用了，但是某些应用程序需要一种修改安全对象调用实际返回的对象的方法。尽管您可以轻松实现自己的AOP问题来实现这一目标，但Spring Security提供了一个方便的挂钩，该挂钩具有几种与其ACL功能集成的具体实现。<img src="https://img-blog.csdnimg.cn/20200517220854745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="调用处理后"><br>与Spring Security的许多其他部分一样，AfterInvocationManager具有一个具体的实现AfterInvocationProviderManager，它轮询AfterInvocationProviders 的列表。每个AfterInvocationProvider都允许修改返回对象或抛出一个AccessDeniedException。实际上，由于前一个提供程序的结果将传递到列表中的下一个，因此多个提供程序可以修改对象。</p><p>请注意，如果你使用AfterInvocationManager，你仍然需要配置属性，让MethodSecurityInterceptor的AccessDecisionManager允许的操作。如果您使用的是典型的Spring Security包含的AccessDecisionManager实现，则没有为特定的安全方法调用定义配置属性，则将导致每个人AccessDecisionVoter都放弃投票。反之，如果AccessDecisionManager属性“ allowIfAllAbstainDecisions”为false，AccessDeniedException则会抛出一个。您可以通过（i）将“ allowIfAllAbstainDecisions”设置为true（尽管通常不建议这样做）或（ii）只需确保至少有一个配置属性AccessDecisionVoter将被投票授予访问权限来避免此潜在问题。后一种（推荐）方法通常是通过ROLE_USER或ROLE_AUTHENTICATED配置属性。</p><h3 id="层次角色"><a href="#层次角色" class="headerlink" title="层次角色"></a>层次角色</h3><p>通常要求应用程序中的特定角色应自动“包括”其他角色。例如，在具有“管理员”和“用户”角色概念的应用程序中，您可能希望管理员能够执行普通用户可以执行的所有操作。为此，您可以确保还为所有管理员用户分配了“用户”角色。或者，您可以修改每个需要“用户”角色也要包括“管理员”角色的访问约束。<br>使用角色层次结构可以配置哪些角色(或权限)应该包括其他角色。Spring Security的RoleVoter的扩展版本RoleHierarchyVoter配置了一个RoleHierarchy，从这个RoleHierarchy中可以获得分配给用户的所有“可到达的权限”。一个典型的配置可能是这样的:</p><div class="hljs"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">"roleVoter"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"org.springframework.security.access.vote.RoleHierarchyVoter"</span>&gt;    &lt;constructor-arg ref=<span class="hljs-string">"roleHierarchy"</span> /&gt;&lt;/bean&gt;&lt;bean id=<span class="hljs-string">"roleHierarchy"</span>        <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl"</span>&gt;    &lt;property name=<span class="hljs-string">"hierarchy"</span>&gt;        &lt;value&gt;            ROLE_ADMIN &gt; ROLE_STAFF            ROLE_STAFF &gt; ROLE_USER            ROLE_USER &gt; ROLE_GUEST        &lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre></div><p>在这里，我们在层次结构中具有四个角色ROLE_ADMIN ⇒ ROLE_STAFF ⇒ ROLE_USER ⇒ ROLE_GUEST。ROLE_ADMIN当AccessDecisionManager使用上述配置评估安全性约束时，通过身份验证的用户的行为就好像他们具有所有四个角色一样RoleHierarchyVoter。该&gt;符号可以被认为是“包含”的意思。</p><p>角色层次结构为简化应用程序的访问控制配置数据和/或减少需要分配给用户的权限数量提供了一种方便的方法。对于更复杂的要求，您可能希望在应用程序需要的特定访问权限与分配给用户的角色之间定义逻辑映射，并在加载用户信息时在两者之间进行转换。</p><h2 id="4-2-使用FilterSecurityInterceptor授权HttpServletRequest"><a href="#4-2-使用FilterSecurityInterceptor授权HttpServletRequest" class="headerlink" title="4.2 使用FilterSecurityInterceptor授权HttpServletRequest"></a>4.2 使用FilterSecurityInterceptor授权HttpServletRequest</h2><p><img src="https://img-blog.csdnimg.cn/2020051722160634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt=".授权HttpServletRequest"><br>1、首先，FilterSecurityInterceptor从SecurityContextHolder中获得认证。</p><p>2、其次，FilterSecurityInterceptor创建一个FilterInvocation从HttpServletRequest，HttpServletResponse和FilterChain被传入FilterSecurityInterceptor。</p><p>3、其次，它通过FilterInvocation以SecurityMetadataSource获得ConfigAttributes。</p><p>4、最后，它将身份验证、FilterInvocation和ConfigAttributes传递给AccessDecisionManager。</p><p>5、如果授权被拒绝，AccessDeniedException则抛出。在这种情况下，ExceptionTranslationFilter将处理AccessDeniedException。</p><p>6、如果授予访问权限，则FilterSecurityInterceptor继续执行FilterChain，该链接可允许应用程序正常处理。</p><p>默认情况下，Spring Security的授权将要求对所有请求进行身份验证。显式配置如下所示：<br>每个请求都必须被认证：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http        <span class="hljs-comment">// ...</span>        .authorizeRequests(authorize -&gt; authorize            .anyRequest().authenticated()        );&#125;</code></pre></div><p>授权请求：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http        <span class="hljs-comment">// ...</span>        .authorizeRequests(authorize -&gt; authorize    <span class="hljs-comment">//1                              </span>            .mvcMatchers(<span class="hljs-string">"/resources/**"</span>, <span class="hljs-string">"/signup"</span>, <span class="hljs-string">"/about"</span>).permitAll() <span class="hljs-comment">//2        </span>            .mvcMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"ADMIN"</span>)    <span class="hljs-comment">//3                         </span>            .mvcMatchers(<span class="hljs-string">"/db/**"</span>).access(<span class="hljs-string">"hasRole('ADMIN') and hasRole('DBA')"</span>) <span class="hljs-comment">//4  </span>            .anyRequest().denyAll()    <span class="hljs-comment">//5                                            </span>        );&#125;</code></pre></div><p>（1）指定了多个授权规则。每个规则均按其声明顺序进行考虑。<br>（2）我们指定了任何用户都可以访问的多个URL模式。具体来说，如果URL以“ / resources /”开头，等于“ / signup”或等于“ / about”，则任何用户都可以访问请求。<br>（3）任何以“/admin/”开头的URL都将被限制为具有“ROLE_ADMIN”角色的用户。您将注意到，由于我们调用hasRole方法，所以不需要指定“ROLE_”前缀。<br>（4）任何以“ / db /”开头的URL都要求用户同时具有“ ROLE_ADMIN”和“ ROLE_DBA”。您会注意到，由于我们使用的是hasRole表达式，因此无需指定“ ROLE_”前缀。<br>（5）任何尚未匹配的URL都会被拒绝访问。如果您不想意外忘记更新授权规则，这是一个很好的策略。</p><h2 id="4-3-基于表达式的访问控制"><a href="#4-3-基于表达式的访问控制" class="headerlink" title="4.3 基于表达式的访问控制"></a>4.3 基于表达式的访问控制</h2><p>常见的内置表达式：<br><img src="https://img-blog.csdnimg.cn/20200517223030564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="常见的内置表达式"></p><p>注：以上文档主要来自Spring Security的官方文档，自己通过翻译软件翻译了一部分用于学习，其中也参考了一些大佬的博客，在这里推荐一位博主【<a href="https://www.cnkirito.moe/" target="_blank" rel="noopener">https://www.cnkirito.moe/</a>】，看了他的Spring Security系列文章，受益颇多，在此表示感谢。</p>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shiro系列-2.核心</title>
    <link href="/2020/06/23/shiro%E7%B3%BB%E5%88%97-2-%E6%A0%B8%E5%BF%83/"/>
    <url>/2020/06/23/shiro%E7%B3%BB%E5%88%97-2-%E6%A0%B8%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1、认证"><a href="#1、认证" class="headerlink" title="1、认证"></a>1、认证</h1><p>认证（Authentication）：身份验证的过程–也就是证明一个用户的真实身份。为了证明用户的身份，需要提供系统可以理解和相信的身份信息【principals】和证据【credentials】。</p><ul><li>Principals（身份）是Subject的“标识属性”，可以是任何与Subject相关的标识，通常用用户名或者邮件地址来作为标识。</li><li>Credentials（证明）：通常是只有Subject直到的机密内容，用来证明他们真正拥有所需的身份，一般有密码，指纹，X.509证书等。</li></ul><p>最常见的身份/证明是用户名和密码，用户名是所需的身份说明，密码是证明身份的证据，如果一个提交的密码和系统要求的一致，程序才认为该用户身份正确。</p><h2 id="验证Subjects"><a href="#验证Subjects" class="headerlink" title="验证Subjects"></a>验证Subjects</h2><p>Subject验证的过程可以分为下面三步：</p><ol><li>收集Subject提交的身份和证明；</li><li>向Authentication提交身份和证明；</li><li>如果提交的内容正确，允许访问，否则重新尝试验证或阻止访问；</li></ol><h3 id="第一步：收集用户身份和证明"><a href="#第一步：收集用户身份和证明" class="headerlink" title="第一步：收集用户身份和证明"></a>第一步：收集用户身份和证明</h3><div class="hljs"><pre><code class="hljs java">UssernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(username,password);</code></pre></div><p>Shiro并不关心我们从哪里获得username和password，我们可以根据自己的需求来构造和引用AuthenticationToken实例。</p><h3 id="第二步：提交身份和证明"><a href="#第二步：提交身份和证明" class="headerlink" title="第二步：提交身份和证明"></a>第二步：提交身份和证明</h3><p>当身份和证明被收集并实例化为一个AuthenticationToken（认证令牌）后，我们需要向Shiro提交令牌以执行真正的验证尝试：</p><div class="hljs"><pre><code class="hljs java">Subject currentUser = SecurityUtils.getSubject();currentUser.login(token);</code></pre></div><p>在获取当前执行的Subject后，我们执行一个单独的login命令，将之前创建的AuthenticationToken实例传给它。<br>调用login方法就是为了对用户的身份进行校验。</p><h3 id="第三步：处理成功或失败"><a href="#第三步：处理成功或失败" class="headerlink" title="第三步：处理成功或失败"></a>第三步：处理成功或失败</h3><p>当login方法没有返回信息时说明验证通过，程序可以继续运行，此时执行前面代码里的currentUser.isAuthenticated()将返回true。<br>如果校验失败，则Shiro将会捕捉异常，程序员根据异常信息就可以判断为何校验失败。<br>如果原有的异常不能满足我们的需求，可以自定义AuthenticationExceptions来表示特定的失败场景。</p><h2 id="Remembered-vs-Authenticated"><a href="#Remembered-vs-Authenticated" class="headerlink" title="Remembered vs. Authenticated"></a>Remembered vs. Authenticated</h2><p>Shiro支持在登录过程中执行“remember me”，记住，一个已记住的Subject（remembered Subject）和一个正常通过认证的Subject（authenticated Subject）在Shiro中是完全不同的。<br>已记住（Remembered）和已验证（Authenticated）是互斥的，已记住是说它的身份被先前的认证过程记住，并存在与先前的session中，已验证的Subject是成功验证后存在于当前session中。</p><h2 id="Logging-Out-退出登录"><a href="#Logging-Out-退出登录" class="headerlink" title="Logging Out 退出登录"></a>Logging Out 退出登录</h2><p>与验证相对的是释放所有已知的身份信息，当Subject与程序不再交互了，可以调用Subject.logout（）来丢掉所有的身份信息。</p><div class="hljs"><pre><code class="hljs java">currentUser.logout();<span class="hljs-comment">//清除验证信息，使session失效</span></code></pre></div><p>当调用logout，任何现存的session将变得不可用并且所有的身份信息将消失。<br>注意：因为在web程序中记住身份信息往往使用cookies，而cookies只能在Response提交时才能被删除，所以强烈要求在为最终用户调用subject.logout()之后立即将用户引到到一个新页面，确保任何与安全相关的cookies如期删除。</p><h2 id="认证序列"><a href="#认证序列" class="headerlink" title="认证序列"></a>认证序列</h2><p>现在我们看看当一个验证发生时，Shiro内部发生了什么？<br><strong>第1步</strong>：程序代码调用Subject.login方法，向AuthenticationToken（认证令牌）实例的构造函数传递用户的身份和证明；<br><strong>第2步</strong>：Subject实例，通常是一个<strong>DelegatingSubject</strong>（或其子类）通过调用<code>SecurityManager.login(token)</code>将这个令牌转交给程序的SecurityManager。<br><strong>第3步</strong>：SecurityManager，基本的“安全伞”组件，得到令牌并通过调用 authenticator.authenticate(token)简单地将其转交给它内部的 Authenticator 实例，大部分情况下是一个 <strong>ModularRealmAuthenticator</strong> 实例，用来支持在验证过程中协调一个或多个Realm实例。<br><strong>第4步</strong>：如果程序配置了多个Realm，ModularRealmAuthenticator实例将使用其配置的AuthenticationStrategy开始一个或多个Realm身份验证的尝试。在Realm被验证调用的整个过程中，AuthenticationStrategy被调用用来回应每个Realm的结果。<br>注意：如果只有一个Realm被配置，则不需要AuthenticationStrategy。<br><strong>第5步</strong>：每一个配置的Realm都被检验看其是否支持提交的AuthenticationToken，如果支持，则该Realm的<code>getAuthenticationInfo</code>方法随着提交的令牌被调用，getAuthenticationInfo方法为特定的Realm提供一次有效的独立的验证尝试。</p><h3 id="Authenticator"><a href="#Authenticator" class="headerlink" title="Authenticator"></a>Authenticator</h3><p>如果希望用自定义的Authenticator实现配置SecurityManager，可以在shiro.ini中做这件事：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span>...<span class="hljs-attr">authenticator</span> = com.foo.bar.CustomAuthenticator<span class="hljs-attr">securityManager.authenticator</span> = <span class="hljs-variable">$authenticator</span></code></pre></div><p>不过一般在实际操作中，我们还是使用ModularRealmAuthenticator实例。</p><h3 id="AuthenticationStrategy"><a href="#AuthenticationStrategy" class="headerlink" title="AuthenticationStrategy"></a>AuthenticationStrategy</h3><p>当一个程序中定义了两个或多个realm时，ModularRealmAuthenticator使用一个内部的AuthenticationStrategy组件来决定一个验证是否成功。<br>AuthenticationStrategy 还有责任从每一个成功的 Realm 中收集结果并将它们“绑定”到一个单独的 AuthenticationInfo，这个AuthenticationInfo 实例是被 Authenticator 实例返回的，并且 shiro 用它来展现一个 Subject 的最终身份（也就是 Principals ）。</p><p>如果程序中使用大于一个Realm从多个数据源中获取账户数据，程序可看到的是AuthenticationStrategy最终负责Subject身份最终“合并（merged）”的视图。<br>Shiro有3个具体的AuthenticationStrategy实现：<br><img src="https://img-blog.csdnimg.cn/20200622224909382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>ModularRealmAuthenticator 默认使用 AtLeastOneSuccessfulStrategy 实现，这也是最常用的策略，然而你也可以配置你希望的不同的策略。<br>shiro.ini</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span><span class="hljs-attr">authcStrategy</span> = org.apache.shiro.authc.pam.FirstSuccessfulStrategy<span class="hljs-attr">securityManager.authenticator.authenticationStrategy</span> = <span class="hljs-variable">$authcStrategy</span></code></pre></div><p>自定义的 AuthenticationStrategy</p><p>如果你希望创建你自己的 AuthenticationStrategy 实现，你可以使用 <code>org.apache.shiro.authc.pam.AbstractAuthenticationStrategy</code>作为起始点。AbstractAuthenticationStrategy 类自动实现 ‘绑定（bundling）’/聚集（aggregation）行为将来自于每个Realm 的结果收集到一个 AuthenticationInfo 实例中。</p><h2 id="Realm-验证的顺序"><a href="#Realm-验证的顺序" class="headerlink" title="Realm 验证的顺序"></a>Realm 验证的顺序</h2><p>Realm 交互的 ModularRealmAuthenticator 按迭代（iteration）顺序执行。</p><p>ModularRealmAuthenticator 可以访问为 SecurityManager 配置的 Realm 实例，当尝试一次验证时，它将在集合中遍历，支持对提交的 AuthenticationToken 处理的每个 Realm 都将执行 Realm 的 getAuthenticationInfo 方法。</p><p>我们也可以通过shiro.ini配置文件来按照我们自己期望的顺序来配置Realm，Realm将按照他们在INI文件中定义的顺序执行。</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">blahRealm</span> = com.company.blah.Realm...<span class="hljs-attr">fooRealm</span> = com.company.foo.Realm...<span class="hljs-attr">barRealm</span> = com.company.another.Realm</code></pre></div><p>效果等价于：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">securityManager.realms</span> = <span class="hljs-variable">$blahRealm</span>, <span class="hljs-variable">$fooRealm</span>, <span class="hljs-variable">$barRealm</span></code></pre></div><p>如果你希望明确定义 realm 执行的顺序，不管他们如何被定义，你可以设置 SecurityManager 的 realms 属性，例如，使用上面定义的 realm，但你希望 blahRealm 最后执行而不是第一个：</p><div class="hljs"><pre><code class="hljs java">blahRealm = com.company.blah.Realm...fooRealm = com.company.foo.Realm...barRealm = com.company.another.RealmsecurityManager.realms = $fooRealm, $barRealm, $blahRealm</code></pre></div><p>当你明确的配置 securityManager.realms 属性时，只有被引用的 realm 将为 SecurityManager 配置，也就是说你可能在 INI 中定义了5个 realm，但实际上只使用了3个，如果在 realm 属性中只引用了3个，这和隐含的 realm 顺序不同，在那种情况下，所有有效的 realm 都会用到。</p><h1 id="2、授权"><a href="#2、授权" class="headerlink" title="2、授权"></a>2、授权</h1><p>授权（Authorization）：亦为访问控制，是管理资源访问的过程，换言之，也就是控制在一个程序中“谁”有权利访问“什么”。</p><h2 id="授权要素"><a href="#授权要素" class="headerlink" title="授权要素"></a>授权要素</h2><p>授权有三个核心元素，即：权限（permissions）、角色（roles）和用户（users）</p><h3 id="权限（permissions）"><a href="#权限（permissions）" class="headerlink" title="权限（permissions）"></a>权限（permissions）</h3><p>权限是一组关于行为的基本指令，以明确标识在一个程序中可以做什么，一个很好的权限指令定义必须描述资源以及当一个Subject与这些资源交互时什么动作可以执行。</p><p>下面是一些权限指令的例子：</p><ul><li>打开一个文件；</li><li>查看“/user/list”页面；</li><li>打印文档；</li><li>删除“JSmith”用户</li></ul><p>权限只描述行为（和资源相关的动作），并不关心“谁”有能力执行这个动作。</p><p>定义“谁”（用户）被允许做“什么”（权限）需要用一些方法将权限赋予用户，这通常取决于程序的数据模型而且经常在程序中发生改变。</p><p>上面提到的权限示例都是针对资源（门、文件、客户等）指定的动作（打开、读、删除等），在一些场景中，我们也会指定非常细粒度的“实例级别”行为–例如：“删除”（delete）名为“Jsmith”（实例标识）的“用户”（资源类型）。</p><h3 id="角色（roles）"><a href="#角色（roles）" class="headerlink" title="角色（roles）"></a>角色（roles）</h3><p>角色是一个实体名，代表一组行为或职责，这些行为在程序中转化为你可以或不能做的事情。角色通常赋给用户账户，关联后，用户既可以“做”属于不同角色的事情。</p><p>有两种有效的角色指定方式：</p><ul><li>权限隐含于角色中；<br>隐含的角色可能会增加软件的维护成本和管理问题，比如增加或删除一个角色，重新定义角色的行为等，代码改动太大。</li><li>明确为角色指定权限；<br>明确为角色指定权限本质上是一组权限指令的名称集，程序（以及 Shiro）准确知道一个特定的角色是什么意思，因为它确切知道某行为是否可以执行，而不用去猜测特定的角色可以或不可以做什么。</li></ul><h3 id="用户（users）"><a href="#用户（users）" class="headerlink" title="用户（users）"></a>用户（users）</h3><p>一个用户本质上是程序中的“谁”，前面提到的Subject实际上是shiro的“用户”。<br>用户（Subjects）通过与角色或权限关联确定是否被允许执行程序内特定的动作，程序数据模型确切定义了 Subject 是否允许做什么事情。</p><p>例如，在你的数据模型中，你定义了一个普通的用户类并且直接为其设置了权限，或者你只是直接给角色设置了权限，然后将用户与该角色关联，通过这种关联，用户就“有”了角色所具备的权限，或者你也可以通过“组”的概念完成这件事，这取决于你程序的设计。</p><p>数据模型定义了如何进行授权，Shiro 依赖一个 Realm 实现将你的数据模型关联转换成 Shiro 可以理解的内容，我们将稍后讨论 Realms。</p><p>最终，是 Realm 与你的数据源（RDBMS,LDAP等）做交流，Realm 用来告知Shiro 是否角色或权限是否存在，你可以完全控制你的授权模型如何创建和定义。</p><h2 id="授权对象"><a href="#授权对象" class="headerlink" title="授权对象"></a>授权对象</h2><p>在 Shiro 中执行授权可以有三种途径：</p><ul><li>程序代码–你可以在你的 JAVA 代码中执行用类似于 if 和 else 的结构来执行权限检查。</li><li>JDK 注解–你可以在你的 JAVA 方法上附加权限注解</li><li>JSP/GSP 标签–你可以基于角色和权限控制 JSP 或 GSP 页面输出内容。</li></ul><h3 id="在程序中检查授权"><a href="#在程序中检查授权" class="headerlink" title="在程序中检查授权"></a>在程序中检查授权</h3><h4 id="基于角色的授权"><a href="#基于角色的授权" class="headerlink" title="基于角色的授权"></a>基于角色的授权</h4><p>如果你想简单地检查一下当前Subject是否拥有一个角色，你可以在一个实例上调用 hasRole方法。</p><p>例如，查看一个 Subject 是否有特定（单独）的角色，你可以调用subject.hasRole(roleName))方法，做出相应的反馈。</p><div class="hljs"><pre><code class="hljs java">Subject currentUser = SecurityUtils.getSubject();<span class="hljs-keyword">if</span> (currentUser.hasRole(<span class="hljs-string">"administrator"</span>)) &#123;    <span class="hljs-comment">//显示 admin 按钮</span>&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//不显示按钮?  灰色吗？</span>&#125;</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200622232145591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>另外可以检测 Subjet 是否是指定的某个角色，你可以在的代码执行之前简单判断他们是否是所要求的角色，如果 Subject 不是所要求的角色， AuthorizationException 异常将被抛出，如果是所要求的角色，判断将安静地执行并按期望顺序执行下面的逻辑。</p><div class="hljs"><pre><code class="hljs java">Subject currentUser = SecurityUtils.getSubject();<span class="hljs-comment">//保证当前用户是一个银行出纳员</span><span class="hljs-comment">//因此允许开立帐户：</span>currentUser.checkRole(<span class="hljs-string">"bankTeller"</span>);openBankAccount();</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200622232306827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="基于权限的授权"><a href="#基于权限的授权" class="headerlink" title="基于权限的授权"></a>基于权限的授权</h4><p>通过基于权限的授权执行访问控制是更好的方法。基于权限的授权，因为其与程序功能（以及程序核心资源上的行为）紧密联系，基于权限授权的源代码在程序功能改变时才需要改变，而与安全策略无关。这意味着与同样基于角色的授权相比，对代码的影响更少。</p><p><strong>基于对象的权限检查</strong>：</p><div class="hljs"><pre><code class="hljs java">Permission printPermission = <span class="hljs-keyword">new</span> PrinterPermission(<span class="hljs-string">"laserjet4400n"</span>, <span class="hljs-string">"print"</span>);Subject currentUser = SecurityUtils.getSubject();<span class="hljs-keyword">if</span> (currentUser.isPermitted(printPermission)) &#123;    <span class="hljs-comment">//显示 打印 按钮</span>&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//不显示按钮?  灰色吗？</span>&#125;</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200622232542546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>基于字符串的权限检查</strong>：<br>选择用普通的字符串来代表权限：</p><div class="hljs"><pre><code class="hljs java">Subject currentUser = SecurityUtils.getSubject();<span class="hljs-keyword">if</span> (currentUser.isPermitted(<span class="hljs-string">"printer:print:laserjet4400n"</span>)) &#123;    <span class="hljs-comment">//显示 打印 按钮</span>&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//不显示按钮?  灰色吗？</span>&#125;</code></pre></div><p>基于字符串的权限有利的一面在于你不需要实现一个接口而且简单的字符串也非常易读，而不利的一面在于不保证类型安全，而且当你需要定义超出字符串表现能力之外的更复杂的行为时，你仍旧需要利用权限接口实现你自己的权限对象。实际上，大部分 Shiro 的终端用户因为其简单而选择基于字符串的方式，但最终你的程序需求决定了哪一种方法会更好。<br><img src="https://img-blog.csdnimg.cn/20200622232837821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="权限判断"><a href="#权限判断" class="headerlink" title="权限判断"></a>权限判断</h4><p>另一种检查 Subject 是否被允许做某件事的方法是，在逻辑执行之前简单判断他们是否具备所需的权限，如果不允许，AuthorizationException异常被抛出，如果是允许的，判断将安静地执行并按期望顺序执行下面的逻辑。</p><p>例如：</p><div class="hljs"><pre><code class="hljs java">Subject currentUser = SecurityUtils.getSubject();<span class="hljs-comment">//担保允许当前用户</span><span class="hljs-comment">//开一个银行帐户：</span>Permission p = <span class="hljs-keyword">new</span> AccountPermission(<span class="hljs-string">"open"</span>);currentUser.checkPermission(p);openBankAccount();</code></pre></div><p>或者，同样的判断，可以用字符串形式：</p><div class="hljs"><pre><code class="hljs java">Subject currentUser = SecurityUtils.getSubject();<span class="hljs-comment">//担保允许当前用户</span><span class="hljs-comment">//开一个银行帐户：</span>currentUser.checkPermission(<span class="hljs-string">"account:open"</span>);openBankAccount();</code></pre></div><p>与 isPermitted 方法相比较，这种方法的优势是代码更为清晰，如果当前Subject 不符合条件，你不必创建你自己的 AuthorizationExceptions 异常（如果你不想那么做）。<br><img src="https://img-blog.csdnimg.cn/20200622233049193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="基于注解的授权"><a href="#基于注解的授权" class="headerlink" title="基于注解的授权"></a>基于注解的授权</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在你使用 JAVA 的注解之前，你需要在程序中启动 AOP 支持，因为有许多AOP 框架，所以很不幸，在这里并没有标准的在程序中启用 AOP 的方法。</p><h4 id="RequiresAuthentication-注解"><a href="#RequiresAuthentication-注解" class="headerlink" title="RequiresAuthentication 注解"></a>RequiresAuthentication 注解</h4><p>RequiresAuthentication 注解表示在访问或调用被注解的类/实例/方法时，要求 Subject 在当前的 session中已经被验证。</p><p>举例：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequiresAuthentication</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateAccount</span><span class="hljs-params">(Account userAccount)</span> </span>&#123;    <span class="hljs-comment">//这个方法只会被调用在</span>    <span class="hljs-comment">//Subject 保证被认证的情况下</span>    ...&#125;</code></pre></div><p>这基本上与下面的基于对象的逻辑效果相同：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateAccount</span><span class="hljs-params">(Account userAccount)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!SecurityUtils.getSubject().isAuthenticated()) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthorizationException(...);    &#125;    <span class="hljs-comment">//这里 Subject 保证被认证的情况下</span>    ...&#125;</code></pre></div><h4 id="RequiresGuest-注解"><a href="#RequiresGuest-注解" class="headerlink" title="RequiresGuest 注解"></a>RequiresGuest 注解</h4><p>RequiresGuest 注解表示要求当前Subject是一个“guest(访客)”，也就是，在访问或调用被注解的类/实例/方法时，他们没有被认证或者在被前一个Session 记住。</p><p>例如：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequiresGuest</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signUp</span><span class="hljs-params">(User newUser)</span> </span>&#123;    <span class="hljs-comment">//这个方法只会被调用在</span>    <span class="hljs-comment">//Subject 未知/匿名的情况下</span>    ...&#125;</code></pre></div><p>这基本上与下面的基于对象的逻辑效果相同：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signUp</span><span class="hljs-params">(User newUser)</span> </span>&#123;    Subject currentUser = SecurityUtils.getSubject();    PrincipalCollection principals = currentUser.getPrincipals();    <span class="hljs-keyword">if</span> (principals != <span class="hljs-keyword">null</span> &amp;&amp; !principals.isEmpty()) &#123;        <span class="hljs-comment">//已知的身份 - 不是 guest（访客）:</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthorizationException(...);    &#125;    <span class="hljs-comment">//在这里 Subject 确保是一个 'guest（访客）'</span>    ...&#125;</code></pre></div><h4 id="RequiresPermissions-注解"><a href="#RequiresPermissions-注解" class="headerlink" title="RequiresPermissions 注解"></a>RequiresPermissions 注解</h4><p>RequiresPermissions 注解表示要求当前Subject在执行被注解的方法时具备一个或多个对应的权限。</p><p>例如：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequiresPermissions</span>(<span class="hljs-string">"account:create"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createAccount</span><span class="hljs-params">(Account account)</span> </span>&#123;    <span class="hljs-comment">//这个方法只会被调用在</span>    <span class="hljs-comment">//Subject 允许创建一个 account 的情况下</span>    ...&#125;</code></pre></div><p>这基本上与下面的基于对象的逻辑效果相同</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createAccount</span><span class="hljs-params">(Account account)</span> </span>&#123;    Subject currentUser = SecurityUtils.getSubject();    <span class="hljs-keyword">if</span> (!subject.isPermitted(<span class="hljs-string">"account:create"</span>)) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthorizationException(...);    &#125;    <span class="hljs-comment">//在这里 Subject 确保是允许</span>    ...&#125;</code></pre></div><h4 id="RequiresRoles-注解"><a href="#RequiresRoles-注解" class="headerlink" title="RequiresRoles 注解"></a>RequiresRoles 注解</h4><p>RequiresRoles 注解表示要求当前Subject在执行被注解的方法时具备所有的角色，否则将抛出 AuthorizationException 异常。</p><p>例如：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequiresRoles</span>(<span class="hljs-string">"administrator"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteUser</span><span class="hljs-params">(User user)</span> </span>&#123;    <span class="hljs-comment">//这个方法只会被 administrator 调用 </span>    ...&#125;</code></pre></div><p>这基本上与下面的基于对象的逻辑效果相同</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteUser</span><span class="hljs-params">(User user)</span> </span>&#123;    Subject currentUser = SecurityUtils.getSubject();    <span class="hljs-keyword">if</span> (!subject.hasRole(<span class="hljs-string">"administrator"</span>)) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthorizationException(...);    &#125;    <span class="hljs-comment">//Subject 确保是一个 'administrator'</span>...&#125;</code></pre></div><h4 id="RequiresUser-注解"><a href="#RequiresUser-注解" class="headerlink" title="RequiresUser 注解"></a>RequiresUser 注解</h4><p>RequiresUser 注解表示要求在访问或调用被注解的类/实例/方法时，当前 Subject 是一个程序用户，“程序用户”是一个已知身份的 Subject，或者在当前 Session 中被验证过或者在以前的 Session 中被记住过。</p><p>例如：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequiresUser</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateAccount</span><span class="hljs-params">(Account account)</span> </span>&#123;    <span class="hljs-comment">//这个方法只会被 'user' 调用 </span>    <span class="hljs-comment">//i.e. Subject 是一个已知的身份with a known identity</span>    ...&#125;</code></pre></div><p>这基本上与下面的基于对象的逻辑效果相同</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateAccount</span><span class="hljs-params">(Account account)</span> </span>&#123;    Subject currentUser = SecurityUtils.getSubject();    PrincipalCollection principals = currentUser.getPrincipals();    <span class="hljs-keyword">if</span> (principals == <span class="hljs-keyword">null</span> || principals.isEmpty()) &#123;        <span class="hljs-comment">//无身份 - 他们是匿名的，不被允许</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthorizationException(...);    &#125;    <span class="hljs-comment">//Subject 确保是一个已知的身份</span>    ...&#125;</code></pre></div><h3 id="授权序列"><a href="#授权序列" class="headerlink" title="授权序列"></a>授权序列</h3><p>当一个授权命令调用时 Shiro 内部发生了什么事情？<br><strong>第1步</strong>：程序或框架代码调用一个 Subject 的hasRole<em>、checkRole</em>、 isPermitted<em>或者 checkPermission</em>方法，传递所需的权限或角色。</p><p><strong>第2步</strong>：Subject实例，通常是一个 DelegatingSubject（或子类），通过调用securityManager 与各 hasRole<em>、checkRole*、 isPermitted</em> 或 checkPermission* 基本一致的方法将权限或角色传递给程序的 SecurityManager(实现了 org.apache.shiro.authz.Authorizer 接口)</p><p><strong>第3步</strong>：SecurityManager 作为一个基本的“保护伞”组件,接替/代表其内部 org.apache.shiro.authz.Authorizer 实例通过调用 authorizer 的各自的 hasRole<em>, checkRole</em> , isPermitted* ,或 checkPermission* 方法。 authorizer 默认情况下是一个实例 ModularRealmAuthorizer 支持协调一个或多个实例 Realm 在任何授权操作实例。</p><p><strong>第4步</strong>:，检查每一个被配置的 Realm 是否实现相同的 Authorizer接口，如果是，Realm 自己的各 hasRole<em>、checkRole*、 isPermitted</em> 或 checkPermission* 方法被调用。</p><h4 id="ModularRealmAuthorizer"><a href="#ModularRealmAuthorizer" class="headerlink" title="ModularRealmAuthorizer"></a>ModularRealmAuthorizer</h4><p>前面提到过，Shiro SecurityManager 默认使用 ModularRealmAuthorizer 实例，ModularRealmAuthorizer 实例同等支持用一个 Realm 的程序和用多个 Realm 的程序。</p><p>对于任何授权操作，ModularRealmAuthorizer 将在其内部的 Realm 集中迭代（iterator），按迭代（iteration）顺序同每一个 Realm 交互，与每一个 Realm 交互的方法如下：</p><p>1.如果Realm实现了 Authorizer 接口，调用它各自的授权方法（hasRole<em>、 checkRole</em>、isPermitted<em>或 checkPermission</em>）。</p><p>1.1.如果 Realm 函数的结果是一个 exception，该 exception 衍生自一个 Subject 调用者的 AuthorizationException，就切断授权过程，剩余的授权 Realm 将不在执行。</p><p>1.2.如果 Realm 的方法是一个 hasRole* 或 isPermitted*，并且返回真，则真值立即被返回而且剩余的 Realm 被短路，这种做法作为一种性能增强，在一个 Realm 判断允许后，隐含认为这个 Subject 被允许。它支持最安全的安全策略：默认情况下所有都被禁止，明确指定允许的事情。</p><p>2.如果 Realm 没有实现 Authorizer 接口，将被忽略。</p><h4 id="授权顺序"><a href="#授权顺序" class="headerlink" title="授权顺序"></a>授权顺序</h4><p>需要指出非常重要的一点，就如同验证（authentication）一样，ModularRealmAuthorizer 按迭代（iteration）顺序与 Realm 交互。</p><p>ModularRealmAuthorizer 拥有 SecurityManager 配置的 Realm 实例的入口，当执行一个授权操作时，它将在整个集合中进行迭代（iteration），对于每一个实现 Authorizer 接口的 Realm，调用Realm 各自的 Authorizer 方法（如 hasRole、 checkRole、 isPermitted或 checkPermission）。</p><h4 id="配置全局的-PermissionResolver"><a href="#配置全局的-PermissionResolver" class="headerlink" title="配置全局的 PermissionResolver"></a>配置全局的 PermissionResolver</h4><p>当执行一个基于字符串的权限检查时，大部分 Shiro 默认的 Realm 将会在执行权限隐含逻辑之前首先把这个字符串转换成一个常用的权限实例。</p><p>这是因为权限被认为是基于隐含逻辑而不是相等检查（查看Permission章节了解更多隐含与相等的对比）。隐含逻辑用代码表示要比通过字符串对比好，因此，大部分 Realm需要转换一个提交的权限字符串为对应的权限实例。</p><p>为了这个转换目的，Shiro 支持 PermissionResolver，大部分 Shiro Realm 使用 PermissionResolver 来支持它们对Authorizer 接口中基于字符串权限方法的实现：当这些方法在Realm上被调用时，将使用PermissionResolver 将字符串转换为权限实例，并执行检查。</p><p>所有的 Shiro Realm 默认使用内部的 WildcardPermissionResolver，它使用 Shiro 的WildcardPermission字符串格式。</p><p>如果你想创建你自己的 PermissionResolver 实现，比如说你想创建你自己的权限字符串语法，希望所有配置的Realm实例都支持这个语法，你可以把自己的 PermissionResolver 设置成全局，供所有 realm 使用。</p><p>如，在shiro.ini中：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">globalPermissionResolver</span> = com.foo.bar.authz.MyPermissionResolver...<span class="hljs-attr">securityManager.authorizer.permissionResolver</span> = <span class="hljs-variable">$globalPermissionResolver</span>...</code></pre></div><h4 id="PermissionResolverAware"><a href="#PermissionResolverAware" class="headerlink" title="PermissionResolverAware"></a>PermissionResolverAware</h4><p>如果你想配置一个全局的 PermissionResolver，每一个会读取这个PermissionResolver 配置的 Realm 必须实现PermissionResolverAware 接口，这确保被配置 PermissionResolver 的实例可以传递给支持这种配置的每一个 Realm。</p><p>如果你不想使用一个全局的 PermissionResolver 或者你不想被PermissionResolverAware 接口麻烦，你可以明确地为单个的 Realm 配置 PermissionResolver 接口（可看作是JavaBean的setPermissionResolver 方法）：</p><div class="hljs"><pre><code class="hljs java">permissionResolver = com.foo.bar.authz.MyPermissionResolverrealm = com.foo.bar.realm.MyCustomRealmrealm.permissionResolver = $permissionResolver...</code></pre></div><h4 id="配置全局的RolePermissionResolver"><a href="#配置全局的RolePermissionResolver" class="headerlink" title="配置全局的RolePermissionResolver"></a>配置全局的RolePermissionResolver</h4><p>与 PermissionResolver 类似，RolePermissionResolver 有能力表示执行权限检查的 Realm 所需的权限实例。</p><p>最主要的不同在于接收的字符串是一个角色名，而不是一个权限字符串。</p><p>RolePermissionResolver 被 Realm 在需要时用来转换一个角色名到一组明确的权限实例。</p><p>这是非常有用的，它支持那些遗留的或者不灵活的没有权限概念的数据源。</p><p>例如，许多 LDAP 目录存储角色名称（或组名）但不支持角色名和权限的联合，因为它没有权限的概念。一个使用 shiro 的程序可以使用存储于 LDAP 的角色名，但需要实现一个 RolePermissionResolver 来转换 LDAP 名到一组确切的权限中以执行明确的访问控制，权限的联合将被存储于其它的数据存储中，比如说本地数据库。</p><p>因为这种将角色名转换为权限的概念是特定的，Shiro 默认的 Realm 没有使用它们。</p><p>然而，如果你想创建你自己的 RolePermissionResolver 并且希望用它配置多个 Realm 实现，你可以将你的 RolePermissionResolver设置成全局。<br>shiro.ini</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">globalRolePermissionResolver</span> = com.foo.bar.authz.MyPermissionResolver...<span class="hljs-attr">securityManager.authorizer.rolePermissionResolver</span> = <span class="hljs-variable">$globalRolePermissionResolver</span>...</code></pre></div><h4 id="RolePermissionResolverAware"><a href="#RolePermissionResolverAware" class="headerlink" title="RolePermissionResolverAware"></a>RolePermissionResolverAware</h4><p>如果你想配置一个全局的 RolePermissionResolver, 每个 Realm 接收必须实现了 RolePermisionResolverAware 接口的配置了的 RolePermissionResolver 。这保证了配置全局 RolePermissionResolver 实例可以传递到各个支持这样配置的 Realm 。</p><p>如果你不想使用全局的 RolePermissionResolver 或者你不想麻烦实现 RolePermissionResolverAware 接口，你可以单独为一个 Realm 配置 RolePermissionResolver（可以看作 JavaBean 的 setRolePermissionResolver 方法）。</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">rolePermissionResolver</span> = com.foo.bar.authz.MyRolePermissionResolver<span class="hljs-attr">realm</span> = com.foo.bar.realm.MyCustomRealm<span class="hljs-attr">realm.rolePermissionResolver</span> = <span class="hljs-variable">$rolePermissionResolver</span></code></pre></div><h5 id="定制Authorizer"><a href="#定制Authorizer" class="headerlink" title="定制Authorizer"></a>定制Authorizer</h5><p>如果你的程序使用多于一个 Realm 来执行授权而 ModularRealmAuthorizer 默认的简单迭代（iteration）、短路授权的行为不能满足你的需求，你可以创建自己的 Authorizer 并配置给相应的 SecurityManager。</p><p>例如，在shiro.ini中：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span>...<span class="hljs-attr">authorizer</span> = com.foo.bar.authz.CustomAuthorizer<span class="hljs-attr">securityManager.authorizer</span> = <span class="hljs-variable">$authorizer</span></code></pre></div><h1 id="3、Realms"><a href="#3、Realms" class="headerlink" title="3、Realms"></a>3、Realms</h1><p>Realm 是可以访问程序特定的安全数据如用户、角色、权限等的一个组件。Realm 会将这些程序特定的安全数据转换成一种 Shiro 可以理解的形式。</p><p>Realm通常和数据源是一对一的对应关系，如关系数据库，LDAP 目录，文件系统，或其他类似资源。因此，Realm 接口的实现使用数据源特定的API 来展示授权数据（角色，权限等），如JDBC，文件IO，Hibernate 或JPA，或其他数据访问API。</p><p>Realm实质上就是一个特定安全的DAO</p><p>因为这些数据源大多数通常存储身份验证数据（如密码的凭证）以及授权数据（如角色或权限），每个Shiro Realm能够执行身份验证和授权操作。</p><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>如果使用 Shiro 的 ini 配置文件，你可以在[main]区域内像配置其它对象一样定义和引用Realms，但是 Realm 在 secrityManager上的配置有两种方式：明确方式和隐含方式。</p><h3 id="显式配置"><a href="#显式配置" class="headerlink" title="显式配置"></a>显式配置</h3><p>在定义一个或多个Realm后，再将它们在securityManager上进行统一配置。<br><img src="https://img-blog.csdnimg.cn/20200623002743915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="隐式配置（不推荐）"><a href="#隐式配置（不推荐）" class="headerlink" title="隐式配置（不推荐）"></a>隐式配置（不推荐）</h3><p>这种方法可能引发意想不到的行为，如果你改变 realm 定义的顺序的话。建议你避免使用此方法，并使用显式分配，它拥有确定的行为。该功能很可能在未来的 Shiro 版本中被废弃或移除。</p><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>了解在一个授权尝试中当 Authenticator 与 Realm 交互时到底发生了什么是很重要的。</p><h3 id="Supporting-AuthenticationTokens"><a href="#Supporting-AuthenticationTokens" class="headerlink" title="Supporting AuthenticationTokens"></a>Supporting AuthenticationTokens</h3><p>正如在认证流程中提到的，在一个 Realm 执行一个验证尝试之前，它的supports)方法被调用。只有在返回值为 true 的时候它的getAuthenticationInfo(token) 方法才会执行。</p><p>通常情况下，一个 realm 将检查提交的令牌类型（接口或类）确定自己是否可以处理它，例如，一个处理生物特性数据的Realm 可能一点也不理解 UsernamePasswordTokens，在这种情况下它将从支持函数中返回 false。</p><h3 id="Handling-supported-AuthenticationTokens"><a href="#Handling-supported-AuthenticationTokens" class="headerlink" title="Handling supported AuthenticationTokens"></a>Handling supported AuthenticationTokens</h3><p>如果一个Realm支持提交的验证令牌，验证将调用 Realm 的getAuthenticationInfo(token)) 方法，这是Realm 使用后台数据进行验证的一次有效尝试，顺序执行以下动作：</p><p>1.检查主要 principal (身份)令牌（用户身份信息）；</p><p>2.基于主要 principal (信息)，在数据源中查找对应的用户数据；</p><p>3.确定令牌支持的 credentials (凭证数据)和存储的数据相符；</p><p>4.如果凭证相符，返回一个AuthenticationInfo实例，里面封装了 Shiro 可以理解的用户数据。</p><p>5.如果证据不符，抛出 AuthenticationException异常。</p><p>这是所有Realm getAuthenticationInfo 实现的最高级别工作流，Realm 在这个过程中可以自由做自己想做的事情，比如记录日志，修改数据，以及其他，只要对于存储的数据和验证尝试来讲是合理的就行。</p><p>仅有一件事情是必须的，如果 credentials （凭证）和给定的 principal （主要信息）匹配，需要返回一个非空的 AuthenticationInfo 实例，用来表示来自数据源的 Subject 账户信息。</p><p>直接实现 Realm 接口也许需要时间并容易出错，大部分用户选择继承 AuthorizingRealm 虚拟类，这个类实现了常用的认证和授权工作流，这会节省你的时间而且不易出错。</p><h3 id="凭证匹配"><a href="#凭证匹配" class="headerlink" title="凭证匹配"></a>凭证匹配</h3><p>在上述 realm 认证工作流中，一个 Realm 必须较验 Subject 提交的凭证（如密码）是否与存储在数据中的凭证相匹配，如果匹配，验证成功，系统保留已认证的终端用户身份。</p><p>检查提交的凭证是否与后台存储数据相匹配是每一个 Realm 的责任而不是 Authenticator 的责任，每一个 Realm 都具备与凭证形式及存储密切相关的技能，可以执行详细的凭证比对，而 Authenticator 只是一个普通的工作流组件。</p><p>凭证匹配的过程在所有程序中基本上是一样的，通常只是对比数据方式不同。要确保这个过程在必要时是可插拔和可定制的，AuthenticatingRealm 以及它的子类支持用 CredentialsMatcher 来执行一个凭证对比。</p><p>在找到用户数据之后，它和提交的 AuthenticationToken 一起传递给一个 CredentialsMatcher ，后者用来检查提交的数据和存储的数据是否相匹配。</p><p>Shiro某些 CredentialsMatcher 实现可以使你开箱即用，比如 SimpleCredentialsMatcher 和 HashedCredentialsMatcher 实现，但如果你想配置一个自定义的实现来完成特定的对比逻辑，你可以这样做：</p><div class="hljs"><pre><code class="hljs java">Realm myRealm = <span class="hljs-keyword">new</span> com.company.shiro.realm.MyRealm();CredentialsMatcher customMatcher = <span class="hljs-keyword">new</span> com.company.shiro.realm.CustomCredentialsMatcher();myRealm.setCredentialsMatcher(customMatcher);</code></pre></div><p>或者，使用 Shiro 的 INI配置文件</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span>...<span class="hljs-attr">customMatcher</span> = com.company.shiro.realm.CustomCredentialsMatcher<span class="hljs-attr">myRealm</span> = com.company.shiro.realm.MyRealm<span class="hljs-attr">myRealm.credentialsMatcher</span> = <span class="hljs-variable">$customMatcher</span>...</code></pre></div><h1 id="4、Session-Management"><a href="#4、Session-Management" class="headerlink" title="4、Session Management"></a>4、Session Management</h1><p>Apache Shiro 提供安全框架界独一无二的东西：一个完整的企业级Session 解决方案，从最简单的命令行及智能手机应用到最大的集群企业Web 应用程序。</p><h2 id="使用Sessions"><a href="#使用Sessions" class="headerlink" title="使用Sessions"></a>使用Sessions</h2><p>几乎与所有其他在Shiro 中的东西一样，你通过与当前执行的Subject 交互来获取Session：</p><div class="hljs"><pre><code class="hljs java">Subject currentUser = SecurityUtils.getSubject();Session session = currentUser.getSession();session.setAttribute( <span class="hljs-string">"someKey"</span>, someValue);</code></pre></div><p>subject.getSession() 方法是调用 currentUser.getSubject(true)的快捷方式。</p><p>对于那些熟悉 HttpServletRequest API 的，Subject.getSession(boolean create) 方法与 HttpServletRequest.getSession(boolean create) 方法有着异曲同工之效。</p><ul><li>如果该Subject 已经拥有一个Session，则boolean 参数被忽略且Session 被立即返回。</li><li>如果该Subject 还没有一个Session 且create 参数为true，则创建一个新的会话并返回该会话。</li><li>如果该Subject 还没有一个Session 且create 参数为false，则不会创建新的会话且返回null。</li></ul><p>getSession 要求能够在任何应用程序工作，甚至是非 Web 应用程序。</p><p>当开发框架代码来确保一个 Session 没有被创建是没有必要的时候，subject.getSession(false) 可以起到很好的作用。 当你获取了一个 Subject 的 Session 后，你可以用它来做许多事情，像设置或取得 attribute，设置其超时时间，以及 更多。</p><h2 id="SessionManager"><a href="#SessionManager" class="headerlink" title="SessionManager"></a>SessionManager</h2><p>SessionManager，名如其意，在应用程序中为所有的 subject 管理Session —— 创建，删除，inactivity(失效)及验证，等等。如同其他在Shiro 中的核心结构组件一样，SessionManager 也是一个由 SecurityManager 维护的顶级组件。<br>默认的 SecurityManger 实现是默认使用开箱即用的DefaultSessionManager。</p><p>像其他被 SecurityManager 管理的组件一样，SessionManager 可以通过 JavaBean 风格的 getter/setter 方法在所有Shiro 默认 SecurityManager 实现（getSessionManager()/setSessionManager()）上获取或设置值。或者例如，如果在使用 shiro.ini 配置：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span>...<span class="hljs-attr">sessionManager</span> = com.foo.my.SessionManagerImplementation<span class="hljs-attr">securityManager.sessionManager</span> = <span class="hljs-variable">$sessionManager</span></code></pre></div><p>但从头开始创建一个 SessionManager 是一个复杂的任务且是大多数人不想亲自做的事情。Shiro 的开箱即用的SessionManager 实现是高度可定制的和可配置的，并满足大多数的需要。本文档的其余部分假定你将使用 Shiro 的默认 SessionManager 实现，当覆盖配置选项时。但请注意，你基本上可以创建或插入任何你想要的东西。</p><h3 id="Session超时"><a href="#Session超时" class="headerlink" title="Session超时"></a>Session超时</h3><p>Shiro 的 SessionManager 实现默认是 30 分钟会话超时。也就是说，如果任何 Session 创建后闲置（未被使用，它的lastAccessedTime)未被更新）的时间超过了 30 分钟，那么该 Session 就被认为是过期的，且不允许再被使用。</p><p>你可以设置 SessionManager 默认实现的 globalSessionTimeout 属性来为所有的会话定义默认的超时时间。例如，如果你想超时时间是一个小时而不是 30 分钟：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span>...<span class="hljs-comment"># 3,600,000 milliseconds = 1 hour</span><span class="hljs-attr">securityManager.sessionManager.globalSessionTimeout</span> = <span class="hljs-number">3600000</span></code></pre></div><h3 id="Session监听器"><a href="#Session监听器" class="headerlink" title="Session监听器"></a>Session监听器</h3><p>Shiro 支持 SessionListener 概念来允许你对发生的重要会话作出反应。你可以实现 SessionListener 接口（或扩展易用的SessionListenerAdapter ）并与相应的会话操作作出反应。 由于默认的 SessionManager sessionListeners 属性是一个集合，你可以对 SessionManager 配置一个或多个 listener 实 现，就像其他在 shiro.ini 中的集合一样：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span>...<span class="hljs-attr">aSessionListener</span> = com.foo.my.SessionListener<span class="hljs-attr">anotherSessionListener</span> = com.foo.my.OtherSessionListener<span class="hljs-attr">securityManager.sessionManager.sessionListeners</span> = <span class="hljs-variable">$aSessionListener</span>, <span class="hljs-variable">$anotherSessionListener</span>, etc.</code></pre></div><p>当任何会话发生事件时，SessionListeners 都会被通知——不仅仅是对一个特定的会话</p><h3 id="Session存储"><a href="#Session存储" class="headerlink" title="Session存储"></a>Session存储</h3><p>每当一个会话被创建或更新时，它的数据需要持久化到一个存储位置以便它能够被稍后的应用程序访问。同样地，当一个会话失效且不再被使用时，它需要从存储中删除以便会话数据存储空间不会被耗尽。SessionManager 实现委托这些 Create/Read/Update/Delete(CRUD) 操作为内部组件，同时，SessionDAO，反映了数据访问对象（DAO）设计模式。</p><p>SessionDAO 的权力是你能够实现该接口来与你想要的任何数据存储进行通信。这意味着你的会话数据可以驻留在内存中，文件系统，关系数据库或NoSQL 的数据存储，或其他任何你需要的位置。你得控制持久性行为。</p><p>你可以将任何 SessionDAO 实现作为一个属性配置在默认的SessionManager 实例上。例如，在shiro.ini 中：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span>...<span class="hljs-attr">sessionDAO</span> = com.foo.my.SessionDAO<span class="hljs-attr">securityManager.sessionManager.sessionDAO</span> = <span class="hljs-variable">$sessionDAO</span></code></pre></div><p>注意：上述的 securityManager.sessionManager.sessionDAO = $sessionDAO 作业仅在使用一个本地的 Shiro 会话管理器时才 工作。Web 应用程序默认不会使用本地的会话管理器，而是保持不支持SessionDAO 的 Servlet Container 的默认会话 管理器。如果你想基于 Web 应用程序启用 SessionDAO 来自定义会话存储或会话群集，你将不得不首先配置一个本 地的Web 会话管理器。例如：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span>...<span class="hljs-attr">sessionManager</span> = org.apache.shiro.web.session.mgt.DefaultWebSessionManager<span class="hljs-attr">securityManager.sessionManager</span> = <span class="hljs-variable">$sessionManager</span><span class="hljs-comment"># Configure a SessionDAO and then set it:</span><span class="hljs-attr">securityManager.sessionManager.sessionDAO</span> = <span class="hljs-variable">$sessionDAO</span></code></pre></div><p>Shiro 的默认配置本地 SessionManagers 使用仅内存 Session 存储。这是不适合大多数应用程序的。大多数生产应用程序想要配置提供的 EHCache（见下文）支持或提供自己的SessionDAO 实现。</p><h4 id="EHCache-SessionDAO"><a href="#EHCache-SessionDAO" class="headerlink" title="EHCache SessionDAO"></a>EHCache SessionDAO</h4><p>EHCache 默认是没有启用的，但如果你不打算实现你自己的 SessionDAO，那么强烈地建议你为 Shiro 的 SessionManagerment 启用 EHCache 支持。EHCache SessionDAO 将会在内存中保存会话，并支持溢出到磁盘，若内存成为制约。这对生产程序确保你在运行时不会随机地“丢失”会话是非常好的。</p><p>如果你急需独立的容器会话集群，EHCache 会是一个不错的选择。你可以显式地在 EHCache 之后插入TerraCotta，并拥有一个独立于容器集群的会话缓存。不必再担心 Tomcat，JBoss，Jetty，WebSphere 或WebLogic 特定的会话集群！</p><p>为会话启用 EHCache 是非常容易的。首先，确保在你的 classpath 中有shiro-ehcache-.jar 文件;</p><p>当在 classpath 中后，这第一个 shiro.ini 实例向你演示怎样为所有Shiro 的缓存需要（不只是会话支持）使用 EHCache：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span><span class="hljs-attr">sessionDAO</span> = org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO<span class="hljs-attr">securityManager.sessionManager.sessionDAO</span> = <span class="hljs-variable">$sessionDAO</span><span class="hljs-attr">cacheManager</span> = org.apache.shiro.cache.ehcache.EhCacheManager<span class="hljs-attr">securityManager.cacheManager</span> = <span class="hljs-variable">$cacheManager</span></code></pre></div><p>最后一行，securityManager.cacheManager = $cacheManager，为所有 Shiro 的需要配置了一个 CacheManager。该CacheManager 实例会自动地直接传送到 SessionDAO（通过 EnterpriseCacheSessionDAO 实现 CacheManagerAware 接口的性质）。</p><p>然后，当 SessionManager 要求 EnterpriseCacheSessionDAO 去持久化一个 Session 时，它使用一个 EHCache 支持的 Cache 实现去存储Session 数据。</p><p>注意：Web 应用程序默认使用基于容器的 SessionManager，它不支持 SessionDAO。如果你想在 Web 应用程序中使用基于 EHCache 的会话存储，配置一个 如上所述的 Web SessionManager。</p><h4 id="EHCache-Session-Cache-Configuration"><a href="#EHCache-Session-Cache-Configuration" class="headerlink" title="EHCache Session Cache Configuration"></a>EHCache Session Cache Configuration</h4><p>默认地，EhCacheManager 使用一个 Shiro 特定的 ehcache.xml 文件来建立 Session 缓存区以及确保 Sessions 正常存取的必要设置。</p><p>然而，如果你想改变缓存设置，或想配置你自己的 ehcache.xml 或EHCache net.sf.ehcache.CacheManager 实例，你需要配置缓存区来确保Sessions 被正确地处理。</p><p>如果你查看默认的 ehcache.xml 文件，你会看到接下来的 shiro-activeSessionCache 缓存配置：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"shiro-activeSessionCache"</span></span><span class="hljs-tag">       <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">"10000"</span></span><span class="hljs-tag">       <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">"true"</span></span><span class="hljs-tag">       <span class="hljs-attr">eternal</span>=<span class="hljs-string">"true"</span></span><span class="hljs-tag">       <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">"0"</span></span><span class="hljs-tag">       <span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">"0"</span></span><span class="hljs-tag">       <span class="hljs-attr">diskPersistent</span>=<span class="hljs-string">"true"</span></span><span class="hljs-tag">       <span class="hljs-attr">diskExpiryThreadIntervalSeconds</span>=<span class="hljs-string">"600"</span>/&gt;</span></code></pre></div><p>如果你希望使用你自己的 ehcache.xml 文件，那么请确保你已经为 Shiro 所需的定义了一个类似的缓存项。<br>很有可能 你会改变 maxElementsInMemory 的属性值来吻合你的需要。然而，至少下面两个存在于你自己配置中的属性是非常重要的：</p><ul><li>overflowToDisk=”true” - 这确保当你溢出进程内存时，会话不丢失且能够被序列化到磁盘上。</li><li>eternal=”true” - 确保缓存项（ Session 实例）永不过期或被缓存自动清除。这是很有必要的，因为 Shiro 基于计划过程完成自己的验证。如果我们关掉这项，缓存将会在 Shiro 不知道的情况下清扫这些 Sessions，这可能引起麻烦</li></ul><h4 id="EHCache-Session-Cache-Name"><a href="#EHCache-Session-Cache-Name" class="headerlink" title="EHCache Session Cache Name"></a>EHCache Session Cache Name</h4><p>默认地，EnterpriseCacheSessionDAO 向 CacheManager 寻求一个名为”shiro-activeSessionCache”的 Cache。该缓存的 name/region 将在 ehcache.xml 中配置，如上所述。</p><p>如果你想使用一个不同的名字而不是默认的，你可以在EnterpriseCacheSessionDAO 上配置名字，例如：</p><div class="hljs"><pre><code class="hljs java">[main]...sessionDAO = org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAOsessionDAO.activeSessionsCacheName = myname...</code></pre></div><p>只要确保在 ehcahe.xml 中有一项与名字匹配且你已经配置好了如上所述的 overflowToDisk=”true” 和 eternal=”true”。</p><h2 id="会话集群"><a href="#会话集群" class="headerlink" title="会话集群"></a>会话集群</h2><p>Apache Shiro 会话能力一个非常令人兴奋的事情是,你可以原生的集群 Subject 会话,不需要再担心你的容器环境。也就是说,如果您使用 Shiro 的原生会话并配置一个会话集群,可以部署到 Jetty 和 Tomcat 开发环境,JBoss 或 Geronimo 的生产环境,或任何其他环境，不用担心容器/特定于环境的集群安装或配置。 Shiro 会话集群配置一次，无论您的部署环境如何，都能正常运行</p><p>因为 Shiro 的基于 pojo 的 n 层体系结构,使会话集群的集群机制非常简单,使会话持久性的水平。 也就是说,如果您配置集群 SessionDAO ,DAO 可以与集群交互机制, Shiro 的 SessionManager 不需要知道集群的问题。</p><h2 id="Sessions和Subject状态"><a href="#Sessions和Subject状态" class="headerlink" title="Sessions和Subject状态"></a>Sessions和Subject状态</h2><h3 id="有状态"><a href="#有状态" class="headerlink" title="有状态"></a>有状态</h3><p>默认地，Shiro 的SecurityManager 实现使用一个Subject 的Session 作为一种策略来为接下来的引用存储Subject 的身份 ID（PrincipalCollection）和验证状态（subject.isAuthenticated()）。这通常发生在一个Subject 登录后或当一个 Subject 的身份 ID 通过Remember 服务被发现后。</p><p>这个默认的方法有几个好处:</p><ul><li>任何服务于请求，调用或消息的应用程序可以用请求/调用/消息的有效载荷关联会话ID，且这是Shiro 用入站<br>请求关联用户所有所必须的。例如，如果使用Subject.Builder，这是需要获取相关的Subject 所需的一切：</li></ul><div class="hljs"><pre><code class="hljs java">Serializable sessionId = <span class="hljs-comment">//get from the inbound request or remotemethod invocation payload Subject </span>requestSubject = <span class="hljs-keyword">new</span> Subject.Builder().sessionId(sessionId).buildSubject();</code></pre></div><p>这给大多数Web 应用程序及任何编写远程处理或消息框架的人带来了令人难以置信的方便（这事实上是Shiro 的Web 支持在自己的框架代码内关联Subject 和ServletRequest）。</p><ul><li>任何”RememberMe”身份基于一个能够在第一次访问就能持久化到会话的初始请求。这确保了Subject 被记住的身份可以跨请求保存而不需要反序列化及将它解释到每个请求。例如，在一个 Web 应用程序中，没有必要去读取每一个请求的加密RememberMe Cookie，如果该身份在会话中是已知的。这可是一个很好的性能提升。</li></ul><h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>虽然上述的默认策略对于大多数应用程序而言是很好的（通常是可取的），但这对于尝试尽可能无状态的应用程序来说是不合适的。许多无状态的架构规定在请求中不能存在持久状态，这种情况下的 Sessions 不会被允许（一个会话其本质代表了持久状态）。</p><p>但这一要求带来一个便利的代价—— Subject 状态不能跨请求保留。这意味着有这一要求的应用程序必须确保 Subject 状态可以在每一个请求中以其他的方式代表。</p><p>这几乎总是通过验证每个由应用程序处理的请求/调用/消息来完成的。例如，大多数无状态 Web 应用程序通常支持这一点通过执行 HTTP 基本验证，允许浏览器验证每一个代表最终用户的请求。</p><h3 id="一个混合的方法"><a href="#一个混合的方法" class="headerlink" title="一个混合的方法"></a>一个混合的方法</h3><p>如果你想使用混合的方法呢？如果某些对象应该有会话而某些没有？这种混合法方法能够给许多应用程序带来好处。例如：</p><ul><li>也许 human Subject（如 Web 浏览器用户）由于上面提供的好处能够使用Session。</li><li>也许non-human Subject（如 API 客户端或第三方应用程序）不应该创建session 由于它们与软件的交互可能会间歇或不稳定。</li><li>也许所有某种确定类型的 Subject 或从某一确定位置访问系统的应该将状态保持在会话中，但所有其他的不应该。如果你需要这个混合方法，你可以实现一个 SessionStorageEvaluator。</li></ul><h4 id="SessionStorageEvaluator"><a href="#SessionStorageEvaluator" class="headerlink" title="SessionStorageEvaluator"></a>SessionStorageEvaluator</h4><p>在你想究竟控制哪个 Subject 能够在它们的 Session 中保存它们的状态的情况下，你可以实现<code>org.apache.shiro.mgt.SessionStorageEvaluator</code> 接口，并告诉Shiro 哪个 Subject 支持会话存储。</p><p>该接口只有一个方法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SessionStorageEvaluator</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSessionStorageEnabled</span><span class="hljs-params">(Subject subject)</span></span>;&#125;</code></pre></div><p>关于更详细的API 说明，请参见 SessionStorageEvaluator 的JavaDoc。 你可以实现这一接口，并检查 Subject，为了你可能做出这一决定的任何信息</p><h4 id="Subject-Inspection"><a href="#Subject-Inspection" class="headerlink" title="Subject Inspection"></a>Subject Inspection</h4><p>但实现 isSessionStorageEnabled(subject)接口方法时，你可以一直查看 Subject 并访问任何你需要用来作出决定的东西。</p><p>当然所有期望的 Subject 方法都是可用的（gePrincipals()等），但特定环境的 Subject 实例也是有价值的。</p><p>例如，在 Web 应用程序中，如果该决定必须基于当前 ServletRequest 中的数据，你可以获取该 request 或该 response，因为运行时的Subjce 实例实际上就是一个 WebSubject 实例：</p><div class="hljs"><pre><code class="hljs java">...<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSessionStorageEnabled</span><span class="hljs-params">(Subject subject)</span> </span>&#123;    <span class="hljs-keyword">boolean</span> enabled = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">if</span> (WebUtils.isWeb(Subject)) &#123;        HttpServletRequest request = WebUtils.getHttpRequest(subject);        <span class="hljs-comment">//set 'enabled' based on the current request.</span>    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//not a web request - maybe a RMI or daemon invocation?</span>        <span class="hljs-comment">//set 'enabled' another way...</span>    &#125;    <span class="hljs-keyword">return</span> enabled;&#125;</code></pre></div><p>N.B.框架开发人员应该考虑到这种类型的访问，并确保任何请求/调用/消息上下文对象可用是同过特定环境下的 Subject 实现的。联系 Shiro 用户邮件列表，如果你想帮助设置它，为了你的框架/环境。</p><h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><p>在你实现了 SessionStorageEvaluator 接口后，你可以在 shiro.ini 中配置它：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span>...<span class="hljs-attr">sessionStorageEvaluator</span> = com.mycompany.shiro.subject.mgt.MySessionStorageEvaluator<span class="hljs-attr">securityManager.subjectDAO.sessionStorageEvaluator</span> = <span class="hljs-variable">$sessionStorageEvaluator</span>...</code></pre></div><h4 id="Web-Applications"><a href="#Web-Applications" class="headerlink" title="Web Applications"></a>Web Applications</h4><p>通常 Web 应用程序希望在每一个请求的基础上容易地启用或禁用会话的创建，不管是哪个 Subject 正在执行请求。这经常在支持 REST 及Messaging/RMI 构架上使用来产生很好的效果。例如，也许正常的终端用户（使用浏览器的人）被允许创建和使用会话，但远程的 API 客户端使用REST 或 SOAP，不该拥有会话（因为它们在每一个请求上验证， 常见于 REST/SOAP 体系结构）。</p><p>为了支持这种 hybrid/per-request （混合/每次请求）的能力，noSessionCreation 过滤器被添加到 Shiro 的默认“池”g过滤器中，为 Web 应用程序启用的。该过滤器将会阻止在请求期间创建新的会话来保证无状态的体验。在shiro.ini 的[urls]项中，你通常定义该过滤器在所有其它过滤器之前来确保会话永远不会被使用。</p><p>举例：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[urls]</span>.../rest/** = noSessionCreation, authcBasic, ...</code></pre></div><p>这个过滤器允许现有会话的任何会话操作，但不允许在过滤的请求创建新的会话。也就是说，在请求或没有会话存在的Subject 调用下面四个方法中的任何一个时，将会自动地触发一个 DisabledSessionException 异常：</p><ul><li>httpServletRequest.getSession()</li><li>httpServletRequest.getSession(true)</li><li>subject.getSession()</li><li>subject.getSession(true)</li></ul><p>如果一个 Subject 在访问 noSessionCreation-protected-URL（无会话创建保护的 URL） 之前已经有一个会话，则上述的四种调用仍然会如预期工作。</p><p>最后，在所有情况下，下面的调用将始终被允许：</p><ul><li>httpServletRequest.getSession(false)</li><li>subject.getSession(false)</li></ul>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
      <category>安全框架</category>
      
      <category>Shiro</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shiro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shiro系列-1.总览</title>
    <link href="/2020/06/21/shiro%E7%B3%BB%E5%88%97-1-%E6%80%BB%E8%A7%88/"/>
    <url>/2020/06/21/shiro%E7%B3%BB%E5%88%97-1-%E6%80%BB%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><h2 id="什么是shiro？"><a href="#什么是shiro？" class="headerlink" title="什么是shiro？"></a>什么是shiro？</h2><p>Apache Shiro是一个功能强大、灵活的，开源的安全框架。它可以干净利落地处理<strong>身份验证</strong>、<strong>授权</strong>、<strong>企业会话管理</strong>和<strong>加密</strong>。<br>shiro能做什么？</p><ul><li>验证身份</li><li>用户访问权限控制，比如：<ul><li>判断用户是否分配了一定的安全角色；</li><li>判断用户是否被授予完成某个操作的权限；</li></ul></li><li>在非 web 或 EJB 容器的环境下可以任意使用Session API</li><li>可以响应认证、访问控制、或者Session生命周期中发生的事件</li><li>可以将一个或以上的用户安全数据源数据整合成一个复合的用户“view”（视图）</li><li>支持单点登录（SSO）功能</li><li>支持提供“Remember Me”服务，获取用户关联信息而无需登录</li><li>…<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><img src="https://img-blog.csdnimg.cn/20200619155347749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Authentication（认证）, Authorization（授权）, Session Management（会话管理）, Cryptography（加密）被 Shiro 框架的开发团队称之为应用安全的四大基石。</li><li><strong>Authentication（认证）</strong>：用户身份识别，通常被称为用户“登录”；</li><li><strong>Authorization（授权）</strong>：访问控制，比如某个用户是否具有每个操作的使用权限；</li><li><strong>Session Management（会话管理）</strong>：特定于用户的会话管理，甚至在非web或EJB应用程序；</li><li><strong>Cryptography（加密）</strong>：在对数据源使用加密算法加密的同时，保证易于使用；<br>还提供以下支持：</li><li>web支持：shiro提供的web支持api，可以很轻松的保护web应用程序的安全；</li><li>缓存：缓存是Apache shiro保证安全操作快速、高效的重要手段；</li><li>并发：支持多线程应用程序的并发特性；</li><li>测试：支持单元测试和集成测试，确保代码和预想的一样安全；</li><li>Run As：这个功能允许用户采用其他用户的身份（在许可的前提下），有时在管理方案中很有用；</li><li>Remember Me：跨session记录用户的身份，只有在强制需要时用户才需要登录；</li></ul><h1 id="2-教程"><a href="#2-教程" class="headerlink" title="2 教程"></a>2 教程</h1><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><ul><li>Java1.5及以上</li><li>Maven2.2.1及以上<h2 id="创建shiro-tutorial工程"><a href="#创建shiro-tutorial工程" class="headerlink" title="创建shiro-tutorial工程"></a>创建shiro-tutorial工程</h2>建议先去github上创建一个项目，然后在该项目下创建shiro-tutorial模块。<h3 id="引入pom-xml依赖"><a href="#引入pom-xml依赖" class="headerlink" title="引入pom.xml依赖"></a>引入pom.xml依赖</h3></li></ul><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.gavin.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-tutorial<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.6<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.6<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>$&#123;project.build.sourceEncoding&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-comment">&lt;!-- This plugin is only to test run our little application.  It is not</span><span class="hljs-comment">                 needed in most Shiro-enabled applications: --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.mojo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>exec-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>                        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">classpathScope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">classpathScope</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>Tutorial<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- Shiro uses SLF4J for logging.  We'll use the 'simple' binding</span><span class="hljs-comment">             in this example app.  See http://www.slf4j.org for more info. --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><h3 id="创建Tutorial-java文件"><a href="#创建Tutorial-java文件" class="headerlink" title="创建Tutorial.java文件"></a>创建Tutorial.java文件</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tutorial</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> Logger log = LoggerFactory.getLogger(Tutorial<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        log.info(<span class="hljs-string">"我的第一个shiro应用"</span>);        System.exit(<span class="hljs-number">0</span>);    &#125;&#125;</code></pre></div><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p>在项目根目录下执行<code>mvn compile exec:java</code>，出现下面的打印输出就说明程序运行成功。<br><img src="https://img-blog.csdnimg.cn/20200619195549311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="使用shiro"><a href="#使用shiro" class="headerlink" title="使用shiro"></a>使用shiro</h2><p>在使用shiro之前要理解一件事情就是：shiro几乎所有事情都和一个中心组件SecurityManager有关（这里的SecurityManager跟java.lang.SecurityManager是两码事）。后面会详细说明shiro的设计，这里只是让读者有个概念，每个程序都必定会存在一个SecurityManager。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>通过配置文件的方式来实现对SecurityManager的配置，Shiro默认提供了一个基本的INI配置文件的方案，当然也可以使用XML,YAML,JSON,Groovy Builder markup等多种形式来配置。</p><h4 id="shiro-ini"><a href="#shiro-ini" class="headerlink" title="shiro.ini"></a>shiro.ini</h4><p>在pom.xml同目录中创建一个src/main/resources子目录，在该子目录下创建一个shiro.ini文件，内容如下：</p><div class="hljs"><pre><code class="hljs text"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;# Tutorial INI configuration## Usernames&#x2F;passwords are based on the classic Mel Brooks&#39; film &quot;Spaceballs&quot; :)# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;# -----------------------------------------------------------------------------# Users and their (optional) assigned roles# username &#x3D; password, role1, role2, ..., roleN# -----------------------------------------------------------------------------[users]root &#x3D; secret, adminguest &#x3D; guest, guestpresidentskroob &#x3D; 12345, presidentdarkhelmet &#x3D; ludicrousspeed, darklord, schwartzlonestarr &#x3D; vespa, goodguy, schwartz# -----------------------------------------------------------------------------# Roles with assigned permissions# roleName &#x3D; perm1, perm2, ..., permN# -----------------------------------------------------------------------------[roles]admin &#x3D; *schwartz &#x3D; lightsaber:*goodguy &#x3D; winnebago:drive:eagle5</code></pre></div><p>可以看到，在该配置文件中仅仅配置了几个静态的账户，后面会使用更复杂的用户数据，比如：数据库、LDAP【轻型目录访问协议】和活动目录等。</p><h3 id="引用配置"><a href="#引用配置" class="headerlink" title="引用配置"></a>引用配置</h3><p>接下来创建SecurityManager实例，用来引用INI文件，这里只需在main函数中进行处理即可。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tutorial</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> Logger log = LoggerFactory.getLogger(Tutorial<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        log.info(<span class="hljs-string">"我的第一个shiro应用"</span>);        <span class="hljs-comment">/** 1.从指定路径加载配置文件 */</span>        IniSecurityManagerFactory factory = <span class="hljs-keyword">new</span> IniSecurityManagerFactory(<span class="hljs-string">"classpath:shiro.ini"</span>);        <span class="hljs-comment">/** 2. 分析INI文件，并根据配置文件返回一个SecurityManager实例 */</span>        SecurityManager securityManager = factory.getInstance();        <span class="hljs-comment">/** 3. 将 SecurityManager 设置成了static (memory) singleton，可以通过 JVM 访问 */</span>        SecurityUtils.setSecurityManager(securityManager);        System.exit(<span class="hljs-number">0</span>);    &#125;&#125;</code></pre></div><p>这就是我们要做的–仅仅使用三行代码就把Shiro加进了我们的程序，就是这么简单。</p><p>执行mvn compile exec:java 可以看到程序成功的运行（由于 Shiro 默认在 debug 或更底层才记录日志，所以你不会看到任何 Shiro 的日志输出–只要运行时没有错误提示，你就可以知道已经成功了）。</p><p>上面所加入的代码做了下面的事情：</p><p>使用 Shiro 的 IniSecurityManagerFactory 加载了我们的shiro.ini 文件，该文件存在于 classpath 根目录里。这个执行动作反映出 shiro 支持 Factory Method Design Pattern（工厂模式）。classpath：资源的指示前缀，告诉 shiro 从哪里加载 ini 文件（其它前缀，如 url:和 file: 也被支持）。<br>2.factory.getInstance() 方法被调用，该方法分析 INI 文件并根据配置文件返回一个 SecurityManager 实例。</p><p>3.在这个简单示例中，我们将 SecurityManager 设置成了static (memory) singleton，可以通过 JVM 访问，注意如果你在一个 JVM 中加载多个使用 shiro 的程序时不要这样做，在这个简单示例中，这是可以的，但在其它成熟的应用环境中，通常会将 SecurityManager 放在程序指定的存储中（如在 web 中的 ServletContext 或者 Spring、Guice、 JBoss DI 容器实例）中。</p><h3 id="执行安全操作"><a href="#执行安全操作" class="headerlink" title="执行安全操作"></a>执行安全操作</h3><p>准备好SecurityManager后，可以开始进行我们真正关心的事情了–执行安全操作。<br>其实也就是两个问题：“谁是当前的用户？”，“当前用户是否允许做某件事？”，Shiro的API给当前用户定义了一个新的名词，即“<strong>Subject</strong>”。<br>在几乎所有的环境中，都可以通过如下语句得到当前用户的信息：</p><div class="hljs"><pre><code class="hljs java">Subject currentUser = SecurityUtils.getSubject();</code></pre></div><p>Subject是一个安全术语，意思是“当前运行用户的指定安全视图”，不仅仅局限于一个人，也可以是第三方进程、时钟守护任务、守护进程账户或者其他，可以简单理解为“当前和软件进行交互的事件”。</p><p>在一个独立的程序中调用 getSubject() 会在程序指定位置返回一个基于用户数据的 Subject，在服务器环境（如 web 程序）中，它将获取一个和当前线程或请求相关的基于用户数据的 Subject。</p><p>在取得了Subject后，我们可以利用它做点什么呢？</p><p>如果你想在应用程序的会话期内给用户提供一些信息，那么我们可以获得他们的session。</p><div class="hljs"><pre><code class="hljs java">Session session = currentUser.getSession();session.setAttribute( <span class="hljs-string">"someKey"</span>, <span class="hljs-string">"aValue"</span> );</code></pre></div><p>Session是shiro指定的一个实例，提供几乎所有的HttpSession功能，但是同时它又不需要HTTP环境，这句话的意思是在非web程序中，我们也能使用上面这段代码，不必考虑发布环境！从此任何需要 session 的程序不再需要强制使用 HttpSession 或者 EJB Stateful Session,并且，终端可以共享 session 数据。</p><p>现在我们获取了一个Subject和它们的Session，可以来搞事情了，比如：检测其是否被允许做某些事情？检查其角色和权限？等等。</p><p>我们只能对已知用户进行检查，上面的Subject实例代表当前用户，但是当前用户是谁？如果是匿名用户，那我们就让他们至少登录一次。下面的代码就是完成这个任务：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ( !currentUser.isAuthenticated() ) &#123;    <span class="hljs-comment">//收集用户的主要信息和凭据，来自GUI中的特定的方式</span>    <span class="hljs-comment">//如包含用户名/密码的HTML表格，X509证书，OpenID，等。</span>    <span class="hljs-comment">//我们将使用用户名/密码的例子因为它是最常见的。</span>    UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(<span class="hljs-string">"lonestarr"</span>, <span class="hljs-string">"vespa"</span>);    <span class="hljs-comment">//支持'remember me' (无需配置，自带的!):</span>    token.setRememberMe(<span class="hljs-keyword">true</span>);    currentUser.login(token);&#125;</code></pre></div><p>如果登录失败呢？那我么就可以捕获所有异常，然后按照自己的方式进行处理：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;    currentUser.login( token );    <span class="hljs-comment">//无异常，说明就是我们想要的!</span>&#125; <span class="hljs-keyword">catch</span> ( UnknownAccountException uae ) &#123;    <span class="hljs-comment">//username 不存在，给个错误提示?</span>&#125; <span class="hljs-keyword">catch</span> ( IncorrectCredentialsException ice ) &#123;    <span class="hljs-comment">//password 不匹配，再输入?</span>&#125; <span class="hljs-keyword">catch</span> ( LockedAccountException lae ) &#123;    <span class="hljs-comment">//账号锁住了，不能登入。给个提示?</span>&#125;     ... 更多类型异常 ...&#125; <span class="hljs-keyword">catch</span> ( AuthenticationException ae ) &#123;    <span class="hljs-comment">//未考虑到的问题 - 错误?</span>&#125;</code></pre></div><p>最简单的方式是将异常信息通过人类可以理解的语言返回给用户，不建议直接输出异常原始信息。</p><p>除此之外，我们还可以做些什么呢？<br>显示当前“用户”的信息</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//打印主要信息 (本例子是 username):</span>log.info( <span class="hljs-string">"User ["</span> + currentUser.getPrincipal() + <span class="hljs-string">"] logged in successfully."</span> );</code></pre></div><p>也可以判断它们是否拥有某个角色；</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ( currentUser.hasRole( <span class="hljs-string">"schwartz"</span> ) ) &#123;    log.info(<span class="hljs-string">"May the Schwartz be with you!"</span> );&#125; <span class="hljs-keyword">else</span> &#123;    log.info( <span class="hljs-string">"Hello, mere mortal."</span> );&#125;</code></pre></div><p>还可以判断它们是否拥有某个特定动作或入口的权限；</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ( currentUser.isPermitted( <span class="hljs-string">"lightsaber:weild"</span> ) ) &#123;    log.info(<span class="hljs-string">"You may use a lightsaber ring.  Use it wisely."</span>);&#125; <span class="hljs-keyword">else</span> &#123;    log.info(<span class="hljs-string">"Sorry, lightsaber rings are for schwartz masters only."</span>);&#125;</code></pre></div><p>同样，我们还可以执行非常强大的instance-level（实例级别）的权限检测，检测用户是否具备访问某个类型特定实例的权限：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ( currentUser.isPermitted( <span class="hljs-string">"winnebago:drive:eagle5"</span> ) ) &#123;    log.info(<span class="hljs-string">"You are permitted to 'drive' the 'winnebago' with license plate (id) 'eagle5'.  "</span> +                <span class="hljs-string">"Here are the keys - have fun!"</span>);&#125; <span class="hljs-keyword">else</span> &#123;    log.info(<span class="hljs-string">"Sorry, you aren't allowed to drive the 'eagle5' winnebago!"</span>);&#125;</code></pre></div><p>最后，当用记不再使用系统，可以退出登录：</p><div class="hljs"><pre><code class="hljs java">currentUser.logout(); <span class="hljs-comment">//清除识别信息，设置 session 失效.</span></code></pre></div><h3 id="最终的class"><a href="#最终的class" class="headerlink" title="最终的class"></a>最终的class</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.shiro.SecurityUtils;<span class="hljs-keyword">import</span> org.apache.shiro.authc.*;<span class="hljs-keyword">import</span> org.apache.shiro.config.IniSecurityManagerFactory;<span class="hljs-keyword">import</span> org.apache.shiro.mgt.SecurityManager;<span class="hljs-keyword">import</span> org.apache.shiro.session.Session;<span class="hljs-keyword">import</span> org.apache.shiro.subject.Subject;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: gavin</span><span class="hljs-comment"> * <span class="hljs-doctag">@GitHub</span>: https://github.com/gavin-yyj</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: Created in 19:48 2020/6/19</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tutorial</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> Logger log = LoggerFactory.getLogger(Tutorial<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        log.info(<span class="hljs-string">"我的第一个shiro应用"</span>);        <span class="hljs-comment">//1.从指定路径加载配置文件</span>        IniSecurityManagerFactory factory = <span class="hljs-keyword">new</span> IniSecurityManagerFactory(<span class="hljs-string">"classpath:shiro.ini"</span>);        <span class="hljs-comment">// 2. 分析INI文件，并根据配置文件返回一个SecurityManager实例</span>        SecurityManager securityManager = factory.getInstance();        <span class="hljs-comment">// 3. 将 SecurityManager 设置成了static (memory) singleton，可以通过 JVM 访问</span>        SecurityUtils.setSecurityManager(securityManager);        <span class="hljs-comment">//获取当前执行的用户</span>        Subject currentUser = SecurityUtils.getSubject();        <span class="hljs-comment">//做点跟Session相关的事</span>        Session session = currentUser.getSession();        session.setAttribute(<span class="hljs-string">"someKey"</span>,<span class="hljs-string">"aValue"</span>);        String value = (String) session.getAttribute(<span class="hljs-string">"someKey"</span>);        <span class="hljs-keyword">if</span>(value.equals(<span class="hljs-string">"aValue"</span>))&#123;            log.info(<span class="hljs-string">"检索出正确的值："</span>+ value);        &#125;        <span class="hljs-comment">//登录当前用户检验角色和权限</span>        <span class="hljs-keyword">if</span>(!currentUser.isAuthenticated())&#123;            <span class="hljs-comment">//将用户名和密码包装成token</span>            UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(<span class="hljs-string">"lonestarr"</span>, <span class="hljs-string">"vespa"</span>);            token.setRememberMe(<span class="hljs-keyword">true</span>);            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//尝试登录</span>                currentUser.login(token);            &#125;<span class="hljs-keyword">catch</span> (UnknownAccountException uae)&#123;                log.info(<span class="hljs-string">"用户名不正确"</span>);            &#125;<span class="hljs-keyword">catch</span> (IncorrectCredentialsException ice)&#123;                log.info(<span class="hljs-string">"密码不正确"</span>);            &#125;<span class="hljs-keyword">catch</span> (LockedAccountException lae)&#123;                log.info(<span class="hljs-string">"账号被锁定"</span>);            &#125;            <span class="hljs-comment">// ...其他已知异常</span>            <span class="hljs-keyword">catch</span> (AuthenticationException e)&#123;                log.info(<span class="hljs-string">"其他未知错误，请联系管理员"</span>);            &#125;        &#125;        <span class="hljs-comment">//说出他们是谁：</span>        <span class="hljs-comment">//打印主要识别信息</span>        log.info(<span class="hljs-string">"User["</span>+currentUser.getPrincipal()+<span class="hljs-string">"] logged in successfully."</span>);        <span class="hljs-comment">//测试角色：</span>        <span class="hljs-keyword">if</span>(currentUser.hasRole(<span class="hljs-string">"schwartz"</span>))&#123;            log.info(<span class="hljs-string">"你好！schwartz"</span>);        &#125;<span class="hljs-keyword">else</span>&#123;            log.info(<span class="hljs-string">"你好！普通人"</span>);        &#125;        <span class="hljs-comment">//测试一个权限（非（instance-level)实例级别）</span>        <span class="hljs-keyword">if</span>(currentUser.isPermitted(<span class="hljs-string">"lightsaber:weild"</span>))&#123;            log.info(<span class="hljs-string">"你可以使用这个光剑戒指，试试吧"</span>);        &#125;<span class="hljs-keyword">else</span>&#123;            log.info(<span class="hljs-string">"对不起，光剑戒指仅适用于schwartz大师"</span>);        &#125;        <span class="hljs-comment">//一个非常强大的实例级别的权限：</span>        <span class="hljs-keyword">if</span>(currentUser.isPermitted(<span class="hljs-string">"winnebago:drive:eagle5"</span>))&#123;            log.info(<span class="hljs-string">"您可以使用车牌号为eagle5的winnebago，这是钥匙，玩得开心！"</span>);        &#125;<span class="hljs-keyword">else</span>&#123;            log.info(<span class="hljs-string">"对不起，您money不够，玩不起"</span>);        &#125;        <span class="hljs-comment">//完成，退出</span>        currentUser.logout();        System.exit(<span class="hljs-number">0</span>);    &#125;&#125;</code></pre></div><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200619214928565.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这节我们通过一个示例介绍了如何在基础程序中加入Shiro，并理解Shiro的设计理念，Subject 和 SecurityManager。<br>接下来我们将更加深入的理解Shiro的架构及其配置机制。</p><h1 id="3-架构"><a href="#3-架构" class="headerlink" title="3 架构"></a>3 架构</h1><p>Apache Shiro 设计理念是使程序的安全变得简单直观而易于实现，Shiro的核心设计参照大多数用户对安全的思考模式–如何对某人（或某事）在与程序交互的环境中的进行安全控制。<br>比如：我们设计一个按钮，如果我的应用程序的交互对象是已经登录认证过的用户，那么我们展示的这个按钮可以用来查看他们的账户信息；如果该用户没有登录，那么这个按钮将作为一个注册按钮。</p><h2 id="高级概述"><a href="#高级概述" class="headerlink" title="高级概述"></a>高级概述</h2><p>Shio架构包含三个重要的理念：Subject、SecurityManager和Realm，下图展示了这些组件是如何相互作用的，我们将在下面依次对其进行描述：<br><img src="https://img-blog.csdnimg.cn/20200619220838962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li><strong>Subject</strong>：Subject本质上是当时运行用户特定的View（视图），而单词“User”经常暗指一个人，Subject可以是一个人，也可以是第三方服务、守护进程账户、时钟守护任务或者其他和当前软件交互的任何事件。<strong>Subject实例都和一个SecurityManager绑定</strong>，当你和一个Subject进行交互，这些交互动作被转换成SecurityManager下Subject特定的交互动作，比如前面提到的按钮操作。</li><li><strong>SecurityManager</strong>：SecurityManager是Shiro架构的核心，配合内部安全组件共同组成安全伞。然而，一旦一个程序配置好了SecurityManager和它的内部对象，程序开发人员几乎花费所有的时间在Subject API上，但是我们要清楚，任何Subject的安全操作中SecurityManager才是幕后真正的举重者。</li><li><strong>Realms</strong>：Realms是Shiro和你的程序安全数据之间的“桥”或者“连接”，当真正需要和安全性相关的数据（例如用户账户）进行交互以执行身份验证（登录）和授权（访问控制）时，Shiro会从一个或多个程序配置的Realm中查找这些东西。<br>Realm本质上是一个特定的安全DAO，它封装与数据源连接的细节，得到Shiro所需的相关数据，在配置Shiro的时候，必须指定至少一个Realm来实现认证（Authentication）和/或授权（Authorization）。SecurityManager可以配置多个复杂的Realm，但是至少保证有一个。<br>Shiro提供开箱即用的Realms来连接安全数据源（或叫地址）如：LDAP、JDBC、文件配置如INI和属性文件等，如果已有的Realm不能满足你的需求，你也可以开发自己的Realm实现，和其他内部组件一样，Shiro SecurityManager管理如何使用Realms获取Subject实例所代表的安全和身份信息。</li></ul><h2 id="详细架构"><a href="#详细架构" class="headerlink" title="详细架构"></a>详细架构</h2><p><img src="https://img-blog.csdnimg.cn/20200619225243989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li><p><strong>Subject</strong>：正在与软件交互的一个特定的实体“view”（用户、第三方服务、时钟守护任务等）</p></li><li><p><strong>SecurityManager</strong>：shiro的核心，用来协调它管理的组件使之平稳地一起工作，同时它也管理着Shiro中每一个程序用户的视图，所以它知道每个用户如何执行安全操作。</p></li><li><p><strong>Authenticator</strong>：Authenticator是负责执行用户的身份验证（登录）并对其作出反应的组件。 当用户尝试登录时，该逻辑由身份验证器执行。 身份验证器知道如何与一个或多个存储相关用户/帐户信息的领域进行协调。 从这些领域获得的数据用于验证用户的身份，以确保用户确实是他们所说的真实身份。</p></li><li><p><strong>Authentication Strategy</strong>：如果配置了多个Realm，AuthenticationStrategy将会协调Realm，以确定在一个身份验证成功或失败的条件。（比如：如果在一个方面验证成功了，但是其他方面有验证失败了，那么这次尝试是否成功，由Authentication Strategy说了算）</p></li><li><p><strong>Authorizer</strong>：Authorizer是负责程序中用户访问控制的组件，它是最终判断一个用户是否允许做某件事的途径，像Authenticator一样，Authorizer也知道如何通过协调多种后台数据源来访问角色和权限信息，Authorizer利用这些信息来准确判断一个用户是否可以执行给定的动作。</p></li><li><p><strong>SessionManager</strong>：SessionManager知道如何创建并管理用户Session生命周期，从而在所有环境中为用户提供一个强有力的Session体验。Shiro 将使用现有的session（如Servlet Container），但如果环境中没有，比如在一个独立的程序或非 web 环境中，它将使用它自己建立的 session 提供相同的作用，sessionDAO 用来使用任何数据源使 session 持久化。</p></li><li><p><strong>SessionDAO</strong>：SessionDAO用于将session持久化到数据库，实现对其增删改查。</p></li><li><p><strong>CacheManager</strong>：CacheManager为Shiro的其他组件提供创建缓存实例和管理缓存生命周期的功能，利用缓存来提高访问效率，目前主流开源或企业级缓存框架都可以集成到Shiro中。</p></li><li><p><strong>Cryptography</strong>：Shiro的crypto包包含了易用且易懂的加密方式，Hashes(即digests)和不同的编码实现。</p></li><li><p><strong>Realms</strong>：Realm 是 shiro 和你的应用程序安全数据之间的“桥”或“连接”，当实际要与安全相关的数据进行交互如用户执行身份认证（登录）和授权验证（访问控制）时，shiro 从程序配置的一个或多个Realm 中查找这些数据，你需要配置多少个 Realm 便可配置多少个 Realm（通常一个数据源一个），shiro 将会在认证和授权中协调它们。</p><h2 id="SecurityManager"><a href="#SecurityManager" class="headerlink" title="SecurityManager"></a>SecurityManager</h2><p>因为 Shiro API 鼓励以 Subject 为中心的开发方式，大部分开发人员将很少会和 SecurityManager 直接交互（尽管框架开发人员也许发现它非常有用），尽管如此，知道 SecurityManager 如何工作，特别是当在一个程序中进行配置的时候，是非常重要的。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>程序中SecurityManager执行操作并且管理所有程序用户的状态，在Shiro基础的SecurityManager实现中，包含以下内容：</p></li><li><p>认证（Authentication）</p></li><li><p>授权（Authorization）</p></li><li><p>会话管理（Session Management）</p></li><li><p>缓存管理（Cache Management）</p></li><li><p>Realm协调（Realm coordination）</p></li><li><p>事件传导（Event propagation ）</p></li><li><p>“RememberMe” 服务（”Remember Me” Services）</p></li><li><p>建立Subject(Subject creation)</p></li><li><p>退出登录（Logout）</p></li><li><p>…</p></li></ul><p>   以上这些功能都放在一个单独的组件中进行管理，为了实现配置的简单、灵活、机动性，Shiro的实现在设计上都是高度模块化的，SecurityManager类及其实现类主要充当轻量级的“容器”组件功能，几乎将所有的行为委托给嵌套/包装的组件，这里可以参考上面的架构图。</p><p>   当组件执行逻辑的时候，SecurityManager知道如何以及何时去协调组件做出正确的动作。<br>   SecurityManager 和 JavaBean 兼容，这允许你（或者配置途径）通过标准的JavaBean 访问/设置方法（get/set）很容易地定制插件，这意味着 Shiro 模块可以根据用户行为转化成简易的配置。</p><h1 id="4-配置"><a href="#4-配置" class="headerlink" title="4 配置"></a>4 配置</h1><p>Shiro 的 SecurityManager 的实现和其所依赖的组件都是 JavaBean，所以可以用多种形式对 Shiro 进行配置，比如XML（Spring, JBoss, Guice, 等等），YAML, JSON, Groovy Builder markup等，INI 只是 Shiro 一种最基本的配置方式，使得其可以在任何环境中进行配置。</p><h2 id="在程序中配置"><a href="#在程序中配置" class="headerlink" title="在程序中配置"></a>在程序中配置</h2><p>伪代码如下：</p><div class="hljs"><pre><code class="hljs java">Realm realm = <span class="hljs-comment">//实例化或获得一个Realm的实例。我们将稍后讨论Realm。</span>SecurityManager securityManager = <span class="hljs-keyword">new</span> DefaultSecurityManager(realm);<span class="hljs-comment">//使SecurityManager实例通过静态存储器对整个应用程序可见：</span>SecurityUtils.setSecurityManager(securityManager);</code></pre></div><p>如同我们在架构（Architecture ）中讨论过的，Shiro SecurityMangger 本质上是一个由一套安全组件组成的对象模块视图（graph），因为与 JavaBean兼容，所以可以对所有这些组件调用的 getter 和 setter 方法来配置SecurityManager 和它的内部对象视图。</p><p>例如，你想用一个自定义的 SessionDAO 来定制 Session Management从而配置一个 SecurityManager 实例，你就可以使用 SessionManager 的 setSessionDAO 方法直接 set 这个 SessionDAO。</p><div class="hljs"><pre><code class="hljs java">DefaultSecurityManager securityManager = <span class="hljs-keyword">new</span> DefaultSecurityManager(realm);SessionDAO sessionDAO = <span class="hljs-keyword">new</span> CustomSessionDAO();((DefaultSessionManager)securityManager.getSessionManager()).setSessionDAO(sessionDAO);</code></pre></div><p>使用这些函数，你可以配置 SecurityManager 视图（graph）中的任何一部分。</p><p>虽然在程序中配置很简单，但它并不是我们现实中配置的完美解决方案。在几种情况下这种方法可能并不适合你的程序：</p><ul><li><p>它需要你确切知道并实例化一个直接实现（direct implementation），然而更好的做法是你并不需要知道这些实现也不需要知道从哪里找到它们。</p></li><li><p>因为JAVA类型安全的特性，你必须对通过 get* 获取的对象进行强制类型转换，这么多强制转换非常的丑陋、累赘并且会和你的类紧耦合。</p></li><li><p>SecurityUtils.setSecurityManager 方法会将 SecurityManager实例化为虚拟机的单独静态实例，在大多数程序中没有问题，但如果有多个使用 Shiro 的程序在同一个 JVM 中运行时，各程序有自己独立的实例会更好些，而不是共同引用一块静态内存。 </p></li><li><p>改变配置就需要重新编译你的程序。</p></li></ul><p>然而，尽管有这些不足，在程序中定制的这种方法在限制内存（memory-constrained ）的环境中还是很有价值的，像智能电话程序。如果你的程序不是运行在一个限制内存的环境中，你会发现基于文本的配置会更易读易用。</p><h2 id="INI-配置"><a href="#INI-配置" class="headerlink" title="INI 配置"></a>INI 配置</h2><p>大多数程序已经改为使用基于文本的配置，不需要依靠代码就可进行修改；<br>为了确保具有共性的基于文本配置的途径适用于任何环境而且减少对第三方的依赖，Shiro 支持使用 INI 创建 SecurityManager 对象视图（graph）以及它支持的组件，INI 易读易配置，很容易创建并且对大多数程序都很适合。</p><h3 id="通过INI资源创建-SecurityManager"><a href="#通过INI资源创建-SecurityManager" class="headerlink" title="通过INI资源创建 SecurityManager"></a>通过INI资源创建 SecurityManager</h3><p>这里举两个通过INI配置创建SecurityManager的例子。</p><h4 id="从INI资源创建SecurityManager"><a href="#从INI资源创建SecurityManager" class="headerlink" title="从INI资源创建SecurityManager"></a>从INI资源创建SecurityManager</h4><div class="hljs"><pre><code class="hljs java">Factory&lt;SecurityManager&gt; factory = <span class="hljs-keyword">new</span> IniSecurityManagerFactory(<span class="hljs-string">"classpath:shiro.ini"</span>);SecurityManager securityManager = factory.getInstance();SecurityUtils.setSecurityManager(securityManager);</code></pre></div><h4 id="通过INI实例创建SecurityManager"><a href="#通过INI实例创建SecurityManager" class="headerlink" title="通过INI实例创建SecurityManager"></a>通过INI实例创建SecurityManager</h4><p>INI 配置可以通过<code>org.apache.shiro.config.Ini</code>类用程序方式创建，这个 INI 类类似于 JDK 的<code>java.util.Properties</code>类，但支持通过section 名分割。如：</p><div class="hljs"><pre><code class="hljs java">Ini ini = <span class="hljs-keyword">new</span> Ini();<span class="hljs-comment">//populate the Ini instance as necessary</span>...Factory&lt;SecurityManager&gt; factory = <span class="hljs-keyword">new</span> IniSecurityManagerFactory(ini);SecurityManager securityManager = factory.getInstance();SecurityUtils.setSecurityManager(securityManager);</code></pre></div><p>接下来解决如何定义一个Shiro INI配置文件的问题</p><h3 id="INI-Sections"><a href="#INI-Sections" class="headerlink" title="INI Sections"></a>INI Sections</h3><p>INI　基于文本配置，在独立命名的区域内通过成对的键名/键值组成。键名在每个区域内必须唯一，但是在整个配置文件中并不要求唯一，每个区域（session）可以看作是一个独立的Properties定义。<br>注释行可以用“#”或“;”标识，下面是一个关于shiro的示例。</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-comment"># =======================</span><span class="hljs-comment"># Shiro INI configuration</span><span class="hljs-comment"># =======================</span><span class="hljs-section">[main]</span><span class="hljs-comment"># Objects and their properties are defined here, </span><span class="hljs-comment"># Such as the securityManager, Realms and anything</span><span class="hljs-comment"># else needed to build the SecurityManager</span><span class="hljs-section">[users]</span><span class="hljs-comment"># The 'users' section is for simple deployments</span><span class="hljs-comment"># when you only need a small number of statically-defined </span><span class="hljs-comment"># set of User accounts.</span><span class="hljs-section">[roles]</span><span class="hljs-comment"># The 'roles' section is for simple deployments</span><span class="hljs-comment"># when you only need a small number of statically-defined</span><span class="hljs-comment"># roles.</span><span class="hljs-section">[urls]</span><span class="hljs-comment"># The 'urls' section is used for url-based security</span><span class="hljs-comment"># in web applications.  We'll discuss this section in the</span><span class="hljs-comment"># Web documentation</span></code></pre></div><h4 id="main"><a href="#main" class="headerlink" title="[main]"></a>[main]</h4><p>[main]区域是配置程序 SecurityManager 实例及其支撑组件的地方，如 Realm。</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-section">[main]</span><span class="hljs-attr">sha256Matcher</span> = org.apache.shiro.authc.credential.Sha256CredentialsMatcher<span class="hljs-comment"># 定义一个对象</span><span class="hljs-attr">myRealm</span> = com.company.security.shiro.DatabaseRealm<span class="hljs-comment"># 设置对象属性</span><span class="hljs-attr">myRealm.connectionTimeout</span> = <span class="hljs-number">30000</span><span class="hljs-attr">myRealm.username</span> = jsmith<span class="hljs-attr">myRealm.password</span> = secret<span class="hljs-comment"># 引用值</span><span class="hljs-attr">myRealm.credentialsMatcher</span> = <span class="hljs-variable">$sha256Matcher</span><span class="hljs-comment"># 嵌套属性</span><span class="hljs-attr">securityManager.sessionManager.globalSessionTimeout</span> = <span class="hljs-number">1800000</span></code></pre></div><p><strong>1、定义一个对象</strong><br>这一行实例化了一个类型为 <code>com.company.shiro.realm.MyRealm</code>的对象实例并且使对象使用 myRealm 作为名称以便于将来引用和配置。</p><p>如果对象实例化时实现了 <code>org.apache.shiro.util.Nameable</code>接口，Nameable.setName方法将被以该名（在此例中为myRealm）命名的对象调用。</p><p><strong>2、设置对象属性</strong><br>上面代码等价于</p><div class="hljs"><pre><code class="hljs ini">myRealm.setConnectionTimeout(30000);myRealm.setUsername("jsmith");myRealm.setPassword("secret");</code></pre></div><p>这是因为Shiro默认使用Apache通用的BeanUtils来完成这项复杂的工作，BeanUtils知道如何将这些字符串值转换为适合的原始值类型并调用合适的JavaBeans的setter方法。</p><p><strong>3、引用值</strong><br>如果你想设置的值并不是一个原始值，而是另一个对象怎么办呢？你可以使用一个 $ 符来引用一个之前定义的实例。</p><p><strong>4、嵌套属性</strong><br>通过在等号左侧使用点符号，你可以得到你希望设置对象视图最终的对象/属性；<br><code>securityManager.sessionManager.globalSessionTimeout = 1800000</code>等价于<code>securityManager.getSessionManager().setGlobalSessionTimeout(1800000);</code></p><p><strong>5、字节数组值</strong><br>因为原始的字节数组不能直接在文本中定义，我们必须使用字节数组的文本编码。可以使用64位编码（默认）或者16位编码，使用16位编码必须在字符串前面加上0x前缀；<br><code>securityManager.rememberMeManager.cipherKey = 0x3707344A4093822299F31D008</code></p><p><strong>6、集合属性</strong><br>列表（Lists）、集合（Sets）、图（Maps）可以像其它属性一样设置–直接设置或者像嵌套属性一样，对于列表和集合，只需指定一个逗号分割的值集或者对象引用集。</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">sessionListener1</span> = com.company.my.SessionListenerImplementation...<span class="hljs-attr">sessionListener2</span> = com.company.my.other.SessionListenerImplementation...<span class="hljs-attr">securityManager.sessionManager.sessionListeners</span> = <span class="hljs-variable">$sessionListener1</span>, <span class="hljs-variable">$sessionListener2</span></code></pre></div><p>对于图（Maps），你可以指定以逗号分割的键-值对列表，每个键-值之间用冒号分割：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">object1</span> = com.company.some.Class<span class="hljs-attr">object2</span> = com.company.another.Class...<span class="hljs-attr">anObject</span> = some.class.with.a.Map.property<span class="hljs-attr">anObject.mapProperty</span> = key1:<span class="hljs-variable">$object1</span>, key2:<span class="hljs-variable">$object2</span></code></pre></div><p>在上面的例子中，$object1 引用的对象将存于键 key1 之下，也就是map.get(“key1”) 将返回 object1。你也可以使用其它对象作为键值：</p><div class="hljs"><pre><code class="hljs text">anObject.map &#x3D; $objectKey1:$objectValue1, $objectKey2:$objectValue2</code></pre></div><p><strong>注意事项</strong></p><p>1、顺序问题<br>每一个对象实例以及每一个指定的值都将按照其在 [main] 区域中产生的顺序的执行，这些行最终转换为 JavaBeans 的 getter/setter 方法调用，这些方法按同样的顺序调用。<br>2、覆盖实例<br>每个对象都可以被后定义的新实例覆盖：</p><div class="hljs"><pre><code class="hljs text">myRealm &#x3D; com.company.security.MyRealm...myRealm &#x3D; com.company.security.DatabaseRealm</code></pre></div><p>这样的结果是 myRealm 是<code>com.company.security.DatabaseRealm</code> 实例而前面的实例不会被使用（会作为垃圾回收）。<br>3、默认Default SecurityManager<br>securityManager实例是特殊的–它已经为你实例化过了并且准备好了，所以你并不需要知道指定的实例化SecurityManager的实现类。</p><p>当然，如果你确实想指定你自己的实现类，你可以像上面的覆盖实例那样定义你自己的实现：</p><div class="hljs"><pre><code class="hljs text">securityManager &#x3D; com.company.security.shiro.MyCustomSecurityManager</code></pre></div><p>当然，很少需要这样–Shiro 的 SecurityManager 实现可以按需求进行定制，你可能要问一下自己（或者用户群）你是否真的需要这样做。</p><h4 id="users"><a href="#users" class="headerlink" title="[users]"></a>[users]</h4><p>[users]区域允许你定义一组静态的用户帐号，这对于那些只有少数用户帐号并且用户帐号不需要在运行时动态创建的环境来说非常有用。下面是一个例子：</p><div class="hljs"><pre><code class="hljs text">[users]admin &#x3D; secretlonestarr &#x3D; vespa, goodguy, schwartzdarkhelmet &#x3D; ludicrousspeed, badguy, schwartz</code></pre></div><p>定义非空的[users]或[roles]区域将自动创建<code>org.apache.shiro.realm.text.IniRealm</code>     实例,在[main]区域下生成一个可用的 iniRealm ，你可以像上面配置其它对象那样配置它。</p><p><strong>格式：</strong></p><div class="hljs"><pre><code class="hljs text">username &#x3D; password, roleName1, roleName2, ..., roleNameN</code></pre></div><ul><li>等号左边的值是用户名；</li><li>等号右侧第一个值是用户密码，密码是必须的；</li><li>密码之后用逗号分割的值是赋予用户的角色名，角色名是可选的。</li></ul><p><strong>密码加密</strong><br>如果你不希望[users]区域下的密码以明文显示，你可以用你喜欢的哈希算法（MD5, Sha1, Sha256, 等）来加密它们，将加密后的字符串作为密码值，默认的情况下密码用16位编码算法，但也可以用64位编码算法替代（如下）</p><p>指定哈希文本密码值后，您必须告诉Shiro这些密码已加密。 为此，您可以在[main]部分中配置隐式创建的iniRealm，以使用与您指定的哈希算法相对应的适当CredentialsMatcher实现：</p><div class="hljs"><pre><code class="hljs text">[main]...sha256Matcher &#x3D; org.apache.shiro.authc.credential.Sha256CredentialsMatcher...iniRealm.credentialsMatcher &#x3D; $sha256Matcher...[users]# user1 &#x3D; sha256-hashed-hex-encoded password, role1, role2, ...user1 &#x3D; 2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b, role1, role2, ...</code></pre></div><p>如果用64位编码方式进行编码，需要指定：</p><div class="hljs"><pre><code class="hljs text">[main]...# true &#x3D; hex, false &#x3D; base64:sha256Matcher.storedCredentialsHexEncoded &#x3D; false</code></pre></div><h4 id="roles"><a href="#roles" class="headerlink" title="[roles]"></a>[roles]</h4><p>[roles]区域允许你将权限和在[users]定义的角色对应起来，同样的，这对于那些只有少数用户帐号并且用户帐号不需要在运行时动态创建的环境来说非常有用。</p><div class="hljs"><pre><code class="hljs text">[roles]# &#39;admin&#39; role has all permissions, indicated by the wildcard &#39;*&#39;admin &#x3D; *# The &#39;schwartz&#39; role can do anything (*) with any lightsaber:schwartz &#x3D; lightsaber:*# The &#39;goodguy&#39; role is allowed to &#39;drive&#39; (action) the winnebago (type) with# license plate &#39;eagle5&#39; (instance specific id)goodguy &#x3D; winnebago:drive:eagle5</code></pre></div><p><strong>格式</strong><br>[roles]区域下的每一行必须用下面的格式定义角色-权限的键/值对应关系。<br><code>rolename = permissionDefinition1, permissionDefinition2, ..., permissionDefinitionN</code></p><p>注意如果一个特定的权限定义需要用到逗号分隔（如：printer:5thFloor:print,info），你需要将该定义用双引号括起来从而避免出错：”printer:5thFloor:print,info”。</p><p>如果你有不需要权限的角色，不需要将它们列入[roles]区域，仅仅在 [users]区域定义角色名就可以创建它们。</p><h4 id="urls"><a href="#urls" class="headerlink" title="[urls]"></a>[urls]</h4><p>Web章节讨论</p>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
      <category>安全框架</category>
      
      <category>Shiro</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shiro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shiro系列-shiro入门示例</title>
    <link href="/2020/06/19/shiro%E7%B3%BB%E5%88%97-shiro%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B/"/>
    <url>/2020/06/19/shiro%E7%B3%BB%E5%88%97-shiro%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>基本上，在所有的开发的系统中，都必须做认证(authentication)和授权(authorization)，以保证系统的安全性。<br>简单来说：认证解决“你是谁”的问题，授权解决“你能做什么”的问题。<br>在Java生态中，目前两大安全框架是Spring Security和Apache Shiro，可以用来完成认证和授权的功能。</p><blockquote><p>关于Shiro：<br>Apache Shiro 是一个功能强大且易于使用的 Java 安全框架，它可以提供身份验证、授权、加密和会话管理的功能。<br>通过 Shiro 易于理解的 API ，你可以快速、轻松地保护任何应用程序 —— 从最小的移动端应用程序到大型的的 Web 和企业级应用程序。</p></blockquote><h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h1><h2 id="2-1-引入依赖"><a href="#2-1-引入依赖" class="headerlink" title="2.1 引入依赖"></a>2.1 引入依赖</h2><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--实现对Spring MVC的自动化配置--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-comment">&lt;!--实现对shiro的自动化配置--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h2 id="2-2-ShiroConfig"><a href="#2-2-ShiroConfig" class="headerlink" title="2.2 ShiroConfig"></a>2.2 ShiroConfig</h2><p>创建com.gavin.shiro.config.ShiroConfig配置类，用来实现Shiro的自定义配置，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShiroConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Realm <span class="hljs-title">realm</span><span class="hljs-params">()</span></span>&#123;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DefaultWebSecurityManager <span class="hljs-title">securityManager</span><span class="hljs-params">()</span></span>&#123;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ShiroFilterFactoryBean <span class="hljs-title">shiroFilterFactoryBean</span><span class="hljs-params">()</span></span>&#123;    &#125;&#125;</code></pre></div><p>下面重点分析三个Bean的配置。</p><h3 id="2-2-1-Realm"><a href="#2-2-1-Realm" class="headerlink" title="2.2.1 Realm"></a>2.2.1 Realm</h3><p>Realm是可以访问程序特定的安全数据如用户、角色、权限等的一个组件，Realm可以将这些程序特定的安全数据转换成一种Shiro可以理解的形式。简单说：Realm的职责就是进行<strong>身份认证</strong>和<strong>授权</strong>。</p><p>Realm整体的类图如下：<br><img src="https://img-blog.csdnimg.cn/20200618154954140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Realm接口，主要定义了认证的方法，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Realm</span> </span>&#123;    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(AuthenticationToken var1)</span></span>;    <span class="hljs-function">AuthenticationInfo <span class="hljs-title">getAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken var1)</span> <span class="hljs-keyword">throws</span> AuthenticationException</span>;&#125;</code></pre></div><p>AuthorizingRealm抽象类，额外定义了授权方法，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection var1)</span></span>;</code></pre></div><p>同时它又实现了Authorizer接口，提供判断经过认证过的Subject是否具有指定的角色、权限方法。</p><p>从Realm类图结构可以看出，Shiro提供了多种AuthorizingRealm的实现类，提供从不同的数据源获取数据，不过在一般的项目中，我们会自定义实现Authorizing Realm来从自己定义的表结构中读取用户、角色、权限等数据。虽然Shiro提供了JdbcRealm可以访问数据库，但是它的表结构是固定的，所以我们才选择自定义实现AuthorizingRealm。</p><p>在本示例中，在<code>com.gavin.shiro.config.ShiroConfig#realm</code>方法中，我们创建了SimpleAccountRealm对象，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Realm <span class="hljs-title">realm</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//创建SimpleAccountRealm对象</span>    SimpleAccountRealm realm = <span class="hljs-keyword">new</span> SimpleAccountRealm();    <span class="hljs-comment">//添加两个用户，参数分别是username、password、roles</span>    realm.addAccount(<span class="hljs-string">"admin"</span>,<span class="hljs-string">"admin"</span>,<span class="hljs-string">"ADMIN"</span>);    realm.addAccount(<span class="hljs-string">"normal"</span>,<span class="hljs-string">"normal"</span>,<span class="hljs-string">"NORMAL"</span>);    <span class="hljs-keyword">return</span> realm;&#125;</code></pre></div><p>在该方法中，我们添加了两个用户，分别对应ADMIN和NORMAL角色。</p><h3 id="2-2-2-SecurityManager"><a href="#2-2-2-SecurityManager" class="headerlink" title="2.2.2 SecurityManager"></a>2.2.2 SecurityManager</h3><p>SecurityManager是Shiro架构的核心，配合内部安全组件共同组成安全伞。<br>在本示例中，在<code>com.gavin.shiro.config.ShiroConfig#securityManager</code>方法中，我们创建了DefaultWebSecurityManager对象，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span> <span class="hljs-function"><span class="hljs-keyword">public</span> DefaultWebSecurityManager <span class="hljs-title">securityManager</span><span class="hljs-params">()</span></span>&#123;     <span class="hljs-comment">//创建DefaultWebSecurityManager对象</span>     DefaultWebSecurityManager securityManager = <span class="hljs-keyword">new</span> DefaultWebSecurityManager();     <span class="hljs-comment">//设置其使用的Realm</span>     securityManager.setRealm(<span class="hljs-keyword">this</span>.realm());     <span class="hljs-keyword">return</span> securityManager; &#125;</code></pre></div><h3 id="2-2-3-ShiroFilter"><a href="#2-2-3-ShiroFilter" class="headerlink" title="2.2.3 ShiroFilter"></a>2.2.3 ShiroFilter</h3><p>通过AbstractShiroFilter过滤器，实现对请求的拦截，从而实现Shiro的功能，AbstractShiroFilter整体的类图如下：<br><img src="https://img-blog.csdnimg.cn/20200618164026190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在本示例中，在<code>com.gavin.shiro.config.ShiroConfig#shiroFilterFactoryBean</code>方法中，我们创建了ShiroFilterFactoryBean对象，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> ShiroFilterFactoryBean <span class="hljs-title">shiroFilterFactoryBean</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-comment">//&lt;1&gt;创建ShiroFilterFactoryBean对象，用于创建ShiroFilter过滤器</span>      ShiroFilterFactoryBean filterFactoryBean = <span class="hljs-keyword">new</span> ShiroFilterFactoryBean();      <span class="hljs-comment">//&lt;2&gt;设置其SecurityManager属性</span>      filterFactoryBean.setSecurityManager(<span class="hljs-keyword">this</span>.securityManager());      <span class="hljs-comment">//&lt;3&gt;设置URL</span>      <span class="hljs-comment">//登录URL</span>      filterFactoryBean.setLoginUrl(<span class="hljs-string">"/login"</span>);      <span class="hljs-comment">//登录成功URL</span>      filterFactoryBean.setSuccessUrl(<span class="hljs-string">"/login_success"</span>);      <span class="hljs-comment">//无权限URL，在请求校验权限不通过时，会重定向到该URL上</span>      filterFactoryBean.setUnauthorizedUrl(<span class="hljs-string">"/unauthorized"</span>);      <span class="hljs-comment">//&lt;4&gt;设置URL的权限配置</span>      filterFactoryBean.setFilterChainDefinitionMap(<span class="hljs-keyword">this</span>.filterChainDefinitionMap());      <span class="hljs-keyword">return</span> filterFactoryBean;  &#125;</code></pre></div><p>在介绍<code>filterChainDefinitionMap</code>方法的具体URL的权限配置之前，我们先来了解一下Shiro内置的过滤器，在<code>DefaultFilter</code>枚举类中，枚举了这些过滤器，以及其配置名：<br><img src="https://img-blog.csdnimg.cn/20200618175353156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>比较常用的过滤器有：</p><ul><li><p>anon：AnonymousFilter，允许匿名访问，无需登录；</p></li><li><p>authc：FormAuthenticationFilter，需要经过认证的用户才可以访问，如果是匿名用户，则根据URL不同，会有不同的处理：<br> 1、如果拦截的URL是GET loginUrl登录页面，则进行该请求，跳转到登录页面；<br> 2、如果拦截的URL是POST loginUrl登录请求，则基于请求表单的username、password进行认证，认证通过后，默认重定向到GET loginSuccessUrl地址；<br> 3、如果拦截的URL是其他URL时，则记录该URL到Session中，在用户登录成功后，重定向到该URL上。</p></li><li><p>logout：LogoutFilter，拦截的URL，执行退出登录，退出完成后，重定向到GET loginUrl登录页面。</p></li><li><p>roles：RolesAuthorizationFilter，拥有指定角色的用户可访问；</p></li><li><p>perms：PermissionsAuthorizationFilter，拥有指定权限的用户可以访问。</p><p>下面，让我们回过头来看看<code>#filterChainDefinitionMap()</code>方法的具体URL的权限配置，代码如下：</p></li></ul><div class="hljs"><pre><code class="hljs java">  <span class="hljs-comment">/** URL的权限配置*/</span><span class="hljs-function"><span class="hljs-keyword">private</span> Map&lt;String, String&gt; <span class="hljs-title">filterChainDefinitionMap</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//使用有序的LinkedHashMap，用来实现顺序匹配</span>    LinkedHashMap&lt;String,String&gt; filterMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();    <span class="hljs-comment">//允许匿名访问</span>    filterMap.put(<span class="hljs-string">"/test/echo"</span>,<span class="hljs-string">"anon"</span>);    <span class="hljs-comment">//需要ADMIN角色才能访问</span>    filterMap.put(<span class="hljs-string">"/test/admin"</span>,<span class="hljs-string">"roles[ADMIN]"</span>);    <span class="hljs-comment">//需要NORMAL角色才能访问</span>    filterMap.put(<span class="hljs-string">"/test/normal"</span>,<span class="hljs-string">"roles[NORMAL]"</span>);    <span class="hljs-comment">//注销登录</span>    filterMap.put(<span class="hljs-string">"/logout"</span>,<span class="hljs-string">"logout"</span>);    <span class="hljs-comment">//默认剩余的URL，都要经过认证后才能访问</span>    filterMap.put(<span class="hljs-string">"/**"</span>,<span class="hljs-string">"authc"</span>);    <span class="hljs-keyword">return</span> filterMap;&#125;</code></pre></div><p>这里补充一点，请求在ShiroFilter拦截之后，会根据该请求的情况，匹配到配置中内置的所有Shio Filter，逐个进行处理，也就是说Shiro Filter内部有一个由内置的Shiro Filter组成的过滤器链。</p><h2 id="2-3-SecurityController"><a href="#2-3-SecurityController" class="headerlink" title="2.3 SecurityController"></a>2.3 SecurityController</h2><p> 创建一个SecurityController类，用来提供登录，登录成功等接口，代码如下：</p><div class="hljs"><pre><code class="hljs java">com.gavin.shiro.controller.SecurityController<span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityController</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/login"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">loginPage</span><span class="hljs-params">()</span></span>&#123;    &#125;    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/login"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;    &#125;    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/login_success"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">loginSuccess</span><span class="hljs-params">()</span></span>&#123;    &#125;    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/unauthorized"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">unauthorized</span><span class="hljs-params">()</span></span>&#123;    &#125;&#125;</code></pre></div><h3 id="2-3-1-登录页面"><a href="#2-3-1-登录页面" class="headerlink" title="2.3.1 登录页面"></a>2.3.1 登录页面</h3><p>GET /login地址，来到登录页面，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/login"</span>)  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">loginPage</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"login.html"</span>;  &#125;</code></pre></div><p>login.html静态页面代码如下：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>登录页面<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>        用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>        密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"登录"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>POST提交登录请求到/login地址。</p><h3 id="2-3-2-登录请求"><a href="#2-3-2-登录请求" class="headerlink" title="2.3.2 登录请求"></a>2.3.2 登录请求</h3><p>对于登录请求，会被我们配置的<code>FormAuthenticationFilter</code>过滤器进行拦截，进行用户的身份认证，过程如下：</p><ul><li><p>FormAuthenticationFilter解析请求的<code>username</code>、<code>password</code>参数，创建UsernamePasswordToken对象；</p></li><li><p>然后，调用SecurityManager的<code>login(Subject subject, AuthenticationToken authenticationToken)</code>方法，执行登录操作，进行“身份验证”（认证）；</p></li><li><p>在这内部其实是调用Realm的<code>个体Authentication Info（AuthenticationToken token）</code>方法进行认证，此时根据认证是否成功，会有不同的处理方式：<br>1、如果认证通过，则FormAuthenticationFilter会将请求重定向到Get loginSuccess地址上；<br>2、如果认证失败，则会将认证失败的原因设置到请求的attributes中，后续该请求会继续请求到POST login地址上，这样，在POST loginUrl地址上，我们可以从attributes中获取到失败的原因提示给用户。</p><p>所以，POST loginUrl的目的实际上是为了处理认证失败的情况，其实现的代码如下：</p></li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ResponseBody</span>   <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/login"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;       <span class="hljs-comment">// &lt;1&gt; 判断是否已经登录</span>       Subject subject = SecurityUtils.getSubject();       <span class="hljs-keyword">if</span>(subject.getPrincipal() != <span class="hljs-keyword">null</span>)&#123;           <span class="hljs-keyword">return</span> <span class="hljs-string">"你已经登录，无需重复登录"</span>+subject.getPrincipal();       &#125;       <span class="hljs-comment">// &lt;2&gt; 获得登录失败的原因</span>       String shiroLoginFailure = (String) request.getAttribute(FormAuthenticationFilter.DEFAULT_ERROR_KEY_ATTRIBUTE_NAME);       <span class="hljs-comment">// 翻译成人类看得懂的提示</span>       String msg = <span class="hljs-string">""</span>;       <span class="hljs-keyword">if</span>(UnknownAccountException<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>().<span class="hljs-title">equals</span>(<span class="hljs-title">shiroLoginFailure</span>))</span>&#123;           msg = <span class="hljs-string">"账号不存在"</span>;       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(IncorrectCredentialsException<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>().<span class="hljs-title">equals</span>(<span class="hljs-title">shiroLoginFailure</span>))</span>&#123;           msg = <span class="hljs-string">"密码不正确"</span>;       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(LockedAccountException<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>().<span class="hljs-title">equals</span>(<span class="hljs-title">shiroLoginFailure</span>))</span>&#123;           msg = <span class="hljs-string">"账号被锁定"</span>;       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ExpiredCredentialsException<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>().<span class="hljs-title">equals</span>(<span class="hljs-title">shiroLoginFailure</span>))</span>&#123;           msg = <span class="hljs-string">"账号已过期"</span>;       &#125;<span class="hljs-keyword">else</span>&#123;           msg = <span class="hljs-string">"未知错误，请联系管理员"</span>;           logger.error(<span class="hljs-string">"[login][未知错误：&#123;&#125;]"</span>,shiroLoginFailure);       &#125;       <span class="hljs-keyword">return</span> <span class="hljs-string">"登录失败，原因："</span> + msg;   &#125;</code></pre></div><h3 id="2-3-3-登录成功"><a href="#2-3-3-登录成功" class="headerlink" title="2.3.3 登录成功"></a>2.3.3 登录成功</h3><p>GET login_success地址，登录成功后响应，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ResponseBody</span>   <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/login_success"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">loginSuccess</span><span class="hljs-params">()</span></span>&#123;       <span class="hljs-keyword">return</span> <span class="hljs-string">"恭喜你，登录成功！！"</span>;   &#125;</code></pre></div><p>如果是AJAX请求，我们可以返回json数据；<br>如果是非AJAX请求，我们可以重定向到登录成功的页面，比如管理后台的home页面。</p><h3 id="2-3-4-未授权"><a href="#2-3-4-未授权" class="headerlink" title="2.3.4 未授权"></a>2.3.4 未授权</h3><p>GET unauthorized地址，未授权响应，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ResponseBody</span>   <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/unauthorized"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">unauthorized</span><span class="hljs-params">()</span></span>&#123;       <span class="hljs-keyword">return</span> <span class="hljs-string">"对不起，您没有权限进行操作"</span>;   &#125;</code></pre></div><p>如果是AJAX请求，我们可以返回json数据；<br>如果是非AJAX请求，我们可以重定向到登录页面。</p><h2 id="2-4-TestController"><a href="#2-4-TestController" class="headerlink" title="2.4 TestController"></a>2.4 TestController</h2><p>测试API接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/test"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/demo"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">demo</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"示例返回"</span>;    &#125;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/home"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">home</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"首页"</span>;    &#125;        <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/admin"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"我是管理员"</span>;    &#125;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/normal"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">normal</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"我是普通用户"</span>;    &#125;&#125;</code></pre></div><ul><li>对于 /test/demo 接口，直接访问，无需登陆。</li><li>对于 /test/home 接口，无法直接访问，需要进行登陆。</li><li>对于 /test/admin 接口，需要登陆「admin/admin」用户，因为需要 ADMIN 角色。</li><li>对于 /test/normal 接口，需要登陆「user/user」用户，因为需要 USER 角色。</li></ul><h1 id="3-Shiro注解"><a href="#3-Shiro注解" class="headerlink" title="3.Shiro注解"></a>3.Shiro注解</h1><p>在Shiro中，提供了如下5个注解，可以直接添加在SpringMVC的URL对应的方法上，实现权限配置：</p><h2 id="3-1-RequiresGuest"><a href="#3-1-RequiresGuest" class="headerlink" title="3.1 @RequiresGuest"></a>3.1 @RequiresGuest</h2><p>等同于<code>anon</code></p><h2 id="3-2-RequiresAuthentication"><a href="#3-2-RequiresAuthentication" class="headerlink" title="3.2 @RequiresAuthentication"></a>3.2 @RequiresAuthentication</h2><p>等同于<code>authc</code></p><h2 id="3-3-RequiresUser"><a href="#3-3-RequiresUser" class="headerlink" title="3.3 @RequiresUser"></a>3.3 @RequiresUser</h2><p>等同于<code>user</code>，要求必须登录</p><h2 id="3-4-RequiresRoles"><a href="#3-4-RequiresRoles" class="headerlink" title="3.4 @RequiresRoles"></a>3.4 @RequiresRoles</h2><p>和roles等价，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RequiresRoles &#123;    String[] value();<span class="hljs-comment">//当有多个角色时，AND表示要拥有全部角色，OR表示拥有任意角色即可</span>    <span class="hljs-function">Logical <span class="hljs-title">logical</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> Logical.AND</span>; &#125;</code></pre></div><p>示例代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 属于 NORMAL 角色</span><span class="hljs-meta">@RequiresRoles</span>(<span class="hljs-string">"NORMAL"</span>)<span class="hljs-comment">// 要同时拥有 ADMIN 和 NORMAL 角色</span><span class="hljs-meta">@RequiresRoles</span>(&#123;<span class="hljs-string">"ADMIN"</span>, <span class="hljs-string">"NORMAL"</span>&#125;)<span class="hljs-comment">// 拥有 ADMIN 或 NORMAL 任一角色即可（OR）</span><span class="hljs-meta">@RequiresRoles</span>(value = &#123;<span class="hljs-string">"ADMIN"</span>, <span class="hljs-string">"NORMAL"</span>&#125;, logical = Logical.OR)</code></pre></div><p>如果验证角色不通过，就会抛出AuthorizationException异常，此时我们可以基于Spring MVC提供的@RestControllerAdvice+@ExceptionHandler注解，实现全局异常的处理。<br>不了解可以看看《芋道 Spring Boot SpringMVC 入门》的「5. 全局异常处理」小节。</p><h2 id="3-5-RequiresPermissions"><a href="#3-5-RequiresPermissions" class="headerlink" title="3.5 @RequiresPermissions"></a>3.5 @RequiresPermissions</h2><p>等价于perms，示例代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 拥有 user:add 权限</span><span class="hljs-meta">@RequiresPermissions</span>(<span class="hljs-string">"user:add"</span>)<span class="hljs-comment">// 要同时拥有 user:add 和 user:update 权限</span><span class="hljs-meta">@RequiresPermissions</span>(&#123;<span class="hljs-string">"user:add"</span>, <span class="hljs-string">"user:update"</span>&#125;)<span class="hljs-comment">// 拥有 user:add 和 user:update 任一权限即可</span><span class="hljs-meta">@RequiresPermissions</span>(value = &#123;<span class="hljs-string">"user:add"</span>, <span class="hljs-string">"user:update"</span>&#125;, logical = Logical.OR)</code></pre></div><p>同样如果验证权限不通过，则会抛出AuthorizationException异常。</p><h2 id="3-6-使用示例"><a href="#3-6-使用示例" class="headerlink" title="3.6 使用示例"></a>3.6 使用示例</h2><p>新建DemoController类，提供示例API接口，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/demo"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoController</span> </span>&#123;    <span class="hljs-meta">@RequiresGuest</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/echo"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">demo</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"示例返回"</span>;    &#125;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/home"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">home</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"首页"</span>;    &#125;    <span class="hljs-meta">@RequiresRoles</span>(<span class="hljs-string">"ADMIN"</span>)    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/admin"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"我是管理员"</span>;    &#125;    <span class="hljs-meta">@RequiresRoles</span>(<span class="hljs-string">"NORMAL"</span>)    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/normal"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">normal</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"我是普通用户"</span>;    &#125;&#125;</code></pre></div><p>参考文献：<br><a href="https://mp.weixin.qq.com/s/NmwqOM5rSDlmvs-Bi4P2Ag" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/NmwqOM5rSDlmvs-Bi4P2Ag</a><br>github源码地址：<a href="https://github.com/gavin-yyj/shiro/tree/master/worker/shiro%E7%B3%BB%E5%88%97/shiro-test" target="_blank" rel="noopener">点这里</a></p>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
      <category>安全框架</category>
      
      <category>Shiro</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shiro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入分析Java Web技术内幕-5.JVM内存管理</title>
    <link href="/2020/06/12/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-5-JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2020/06/12/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-5-JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-物理内存与虚拟内存"><a href="#1-物理内存与虚拟内存" class="headerlink" title="1 物理内存与虚拟内存"></a>1 物理内存与虚拟内存</h1><ol><li>物理内存就是RAM（随机存储器），还有一个存储单元叫做寄存器，连接处理器和RAM或者寄存器的是地址总线，这个地址总线的宽度影响了物理地址的索引范围，同时也决定了处理器最大可以寻址的地址空间。</li><li>除了硬件程序或者驱动程序需要直接访问存储器外，大部分情况下都是通过操作系统提供的接口来访问内存，在java中甚至不需要写和内存相关的代码。</li><li>我们要运行程序，都要向操作系统先申请内存地址，每个进程拥有一段独立的地址空间，操作系统也会保证每个进程只能访问自己的内存空间。</li><li>虚拟内存的出现使得多个进程在同时运行时可以共享物理内存，虚拟地址不但可以让进程共享物理内存，提高内存利用率，而且还能扩展内存的地址空间。如：一个进程在不活动的情况下，操作系统将这个物理内存中的数据移到一个磁盘文件中，而真正高效的物理内存留给正在活动的程序使用。</li></ol><h1 id="2-内核空间与用户空间"><a href="#2-内核空间与用户空间" class="headerlink" title="2 内核空间与用户空间"></a>2 内核空间与用户空间</h1><p>内核空间主要是操作系统运行时所使用的用于进程调度，虚拟内存的使用或者硬件资源等的程序逻辑。<br>为了保证系统的稳定性和安全性，所以分为两个空间，如访问硬件资源只能由操作系统来完成，用户程序不允许直接访问硬件资源。<br>如果用户需要访问硬件资源，如网络连接等，可以调用操作系统提供的接口来访问。<br>在执行系统调用的时候，需要在两个内存空间进行切换、复制，虽然保证了程序运行的稳定性和安全性，但是也牺牲了一部分效率，Linux系统提供了sendfile文件传输方式来减少复制带来的开销。</p><h1 id="3-在Java中哪些组件需要使用内存"><a href="#3-在Java中哪些组件需要使用内存" class="headerlink" title="3 在Java中哪些组件需要使用内存"></a>3 在Java中哪些组件需要使用内存</h1><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>Java堆是用于存储Java对象的内存区域，堆的大小在JVM启动时就一次向操作系统申请完成，通过-Xmx和-Xms两个选项来控制。-xmx表示堆的最大值，xms表示初始大小，一旦分配完成，堆空间就固定了。不能重新申请。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>JVM运行实际程序的实体是线程，每个线程创建时JVM都会为它创建一个堆栈。<br>如果运行的应用程序的线程数量比可用于处理它们的处理器数量多，效率通常很低，并且可能导致比较差的性能和更高的内存占用率。</p><h2 id="类和类加载器"><a href="#类和类加载器" class="headerlink" title="类和类加载器"></a>类和类加载器</h2><p>JVM是按需加载类的，JVM只会加载那些在你的应用程序中明确要使用的类到内存中，要查看JVM到底加载了哪些类，可以在启动参数上加上<code>-verbose:class</code>。<br>如果使用自定义的类加载器来加载类，可能会出现重复加载的情况，就有可能导致PermGen区内存泄漏。<br>通常一个类能够被卸载，需要满足如下条件：</p><div class="hljs"><pre><code class="hljs markdown">1：在Java堆中没加载有该类的classloader对象的引用。2：java堆上没有加载该类的classloader已加载的类的class对象引用3：java堆上没有加载该类的类加载器加载的任何类的对象由于jvm创建的三个默认类加载器都不可能满足这些条件，所以任何系统类加载器加载的类都不能在运行时被释放。</code></pre></div><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><div class="hljs"><pre><code class="hljs markdown">NIO引入了一种基于通道和缓存区来执行I/O的新方式；NIO使用java.nio.ByteBuffer.allocateDirect()方法分配内存；ByteBuffer.allocateDirect()分配的内存使用的是本机内存而不是Java堆上的内存，每次分配内存时会调用操作系统的os:malloc()函数；ByteBuffer产生的数据如果和网络或者磁盘交互都在操作系统的内核空间中发生，不需要将数据复制到Java内存中，避免了在Java堆与本机堆之间复制数据；很多NIO框架都在代码中显式地调用System.gc()来释放NIO持有的内存，但是这样做回影响应用程序的性能，还有可能导致内存泄漏。</code></pre></div><h2 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h2><p>JNI技术使得java代码可以调用本机代码（比如c语言程序）。这部分用到了native memory，也就是本地内存。</p><h1 id="4-JVM内存结构"><a href="#4-JVM内存结构" class="headerlink" title="4 JVM内存结构"></a>4 JVM内存结构</h1><h2 id="PC寄存器（程序计数器）"><a href="#PC寄存器（程序计数器）" class="headerlink" title="PC寄存器（程序计数器）"></a>PC寄存器（程序计数器）</h2><p>它用于保存当前正常执行的程序的内存地址，当有多个线程交叉执行时，被中断线程的程序当前执行到哪条的内存地址必然要保存下来，以便于它被恢复执行时再按照被中断时的指令地址继续执行下去。</p><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-number">1</span> Java的栈和线程关联在一起。<span class="hljs-number">2</span> 每个线程有一个栈。<span class="hljs-number">3</span> 每运行一个方法就创建一个新栈帧。<span class="hljs-number">4</span> 栈帧包含了内部变量（方法内部的变量，不是方法参数，方法参数用调用者传来），操作数栈，方法返回值等信息。<span class="hljs-number">5</span> 每个方法执行完成时，每个栈帧都会弹出栈帧的元素作为方法的返回值。<span class="hljs-number">6</span> java栈的栈顶就是当前的活动栈，pc寄存器会指向这个地址。<span class="hljs-number">7</span> 线程私有，不用担心数据一致性问题，也不会存在同步锁的问题</code></pre></div><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是存储对象的地方，每一个存储在堆中的对象都是这个对象类的一个副本，它会复制包括继承它的父类的所有非静态属性。<br>注意是非静态属性，静态属性编译时确定，存在类的元数据中，在方法区。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，是线程共享的内存区域。<br>方法区存储的数据比较稳定，不会被频繁回收。</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池时方法区的一部分，用于存放编译期生成的各种字面量和符号引用。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈是为JVM运行本地方法（Native）方法准备的空间，跟Java栈的作用类似。</p><h1 id="5-JVM内存分配策略"><a href="#5-JVM内存分配策略" class="headerlink" title="5 JVM内存分配策略"></a>5 JVM内存分配策略</h1><h2 id="通常的内存分配策略"><a href="#通常的内存分配策略" class="headerlink" title="通常的内存分配策略"></a>通常的内存分配策略</h2><p>在操作系统中内存分配策略分为三种，分别是：</p><ul><li>静态内存分配</li><li>栈内存分配</li><li>堆内存分配<br>静态内存分配是指在程序编译时就能确定每个数据在运行时的存储空间需求，因此在编译时就可以给它们分配固定的内存空间。<br>栈内存分配也可以称为动态存储分配，是由一个类似于堆栈的运行栈来实现的，按照先进后出的原则进行分配。<br>堆内存分配是在程序运行时才执行的，它的运行效率也是比较差的。<h2 id="Java中的内存分配详情"><a href="#Java中的内存分配详情" class="headerlink" title="Java中的内存分配详情"></a>Java中的内存分配详情</h2>Java栈的分配是和线程绑定在一起的，没创建一个线程，虚拟机就为其分配一个Java栈，一个线程的方法的调用和返回对应这个Java栈的压栈和出栈。当线程激活一个Java方法时，JVM就会在线程的Java堆栈里新压入一个帧，这个帧用来保存参数，局部变量，中间计算过程和其他数据。<br>栈中主要存放一些基本类型的数据变量（int、short、long、byte、float、double、boolean、char）和对象句柄（引用）。<br>优点：存取速度快，数据可以共享；<br>缺点：存在栈中 的数据大小与生存期必须确定，缺乏灵活性。</li></ul><p>每个Java应用都唯一对应一个JVM实例，每个实例唯一对应一个堆，应用程序在运行中所创建的所有类实例或数组都放在这个堆中，并由应用程序所有的线程共享。<br>所有对象的存储空间都是在堆中分配，但是这个对象的引用却是在堆栈中分配；<br>堆的优势是可以动态地分配内存大小；<br>缺点是存取速度慢。</p><p>从栈和堆的功能和作用来通俗的比较：堆主要用来存放对象，栈主要用来执行程序。</p><h1 id="6-JVM内存回收策略"><a href="#6-JVM内存回收策略" class="headerlink" title="6 JVM内存回收策略"></a>6 JVM内存回收策略</h1><p>通常显式的内存申请有两种：静态内存分配和动态内存分配</p><h2 id="静态内存分配和回收"><a href="#静态内存分配和回收" class="headerlink" title="静态内存分配和回收"></a>静态内存分配和回收</h2><p>在Java中静态内存分配是指在Java被编译时就已经能够确定需要的内存空间，当程序被加载时系统把内存一次性分配给它。、<br>在Java的类和方法中的局部变量包括原生数据类型和对象的引用都是静态分配内存。<br>静态内存空间是在Java栈上分配的，当着方法运行结束时，对应的栈帧也就撤销，所以分配的静态内存空间也就回收了。</p><h2 id="动态内存分配和回收"><a href="#动态内存分配和回收" class="headerlink" title="动态内存分配和回收"></a>动态内存分配和回收</h2><p>基本数据类型存储在Java栈中，方法执行结束就会消失，而对象类型存储在Java堆中，是可以被共享的，也不一定随着方法执行结束而被消失。<br>动态分配是程序只有在执行时才知道要分配的存储空间大小，而不是在编译时就能够确定的。<br>内存的回收是以对象不再引用为前提的。</p><h2 id="如何检测垃圾"><a href="#如何检测垃圾" class="headerlink" title="如何检测垃圾"></a>如何检测垃圾</h2><p>只要对象不再被其他活动对象引用，那么就可以被回收，这里的活动对象是指能够被一个根对象集合到达的对象，也就是我们通常所说的可达性分析。<br>除了可达性分析外，还有一种方法叫做引用计数法，但是不推荐使用，因为相互引用会导致无法被垃圾收集器回收，从而可能造成内存泄漏。</p><h2 id="基于分代的垃圾收集是算法"><a href="#基于分代的垃圾收集是算法" class="headerlink" title="基于分代的垃圾收集是算法"></a>基于分代的垃圾收集是算法</h2><p>把对象按照寿命长短来分组，分为年轻代和年老代，如果对象经过几次回收后仍然存活，那么再把这个对象划分到年老代。<br>JVM将整个堆划分为Young区、Old区和Perm区，分别存放不同年龄的对象。<br><img src="https://img-blog.csdnimg.cn/20200614231204862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Young区分为"><br>Young区分为Eden区和两个Survivor区，其中所有新建的对象都放在Eden区，当Eden区满后会触发<strong>minor GC</strong>将Eden区仍然存活的对象复制到其中一个Survivor区中，另外一个Survivor区中的存活对象也复制到这个Survivor中，以保证始终有一个Survivor区是空的。<br>Old区存放的是Young区的Survivor满后触发minor GC后仍然存活的对象，当Eden区满后会将对象存放到Survivor区中，如果Survivor区仍然存放不下这些对象，GC收集器会将这些对象直接放到Old区，如果在Survivor区中的对象足够老，也直接放到Old区，如果Old区也满了，将会触发<strong>Full GC</strong>，回收整个堆内存。<br>Perm区存放的主要是类的Class对象，如果一个类被频繁的加载，也可能导致Perm区满，Perm区的垃圾回收也是由Full GC触发的。<br>建议：Young区的大小为整个堆的1/4，而Young区的Survivor区一般设置为整个Young区的1/8。</p>]]></content>
    
    
    <categories>
      
      <category>JVM规范</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入分析Java Web技术内幕-4.深入分析ClassLoader工作机制</title>
    <link href="/2020/06/12/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-4-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90ClassLoader%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/06/12/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-4-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90ClassLoader%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是ClassLoader"><a href="#1-什么是ClassLoader" class="headerlink" title="1 什么是ClassLoader"></a>1 什么是ClassLoader</h1><p>当我们编写的程序在运行的时候，需要调用其他.class文件中的方法，在Java中并不会一次性加载程序的所要用的所有的class文件，而是根据程序的需要，通过Java的类加载机制来动态加载某个.class文件到内存当中，只有class文件被加载到内存中后，才能被其他clss所引用，JVM负责加载.class字节码到内存，而<strong>ClassLoader</strong>就负责将.class字节码加载到JVM中。<br>ClassLoader除了能将Class加载到JVM中之外，还有两个作用：<br>1、审查每个类应该由谁加载；<br>2、Class字节码重新解析成JVM统一要求的对象格式；</p><p>虚拟机设计团队把类加载阶段中的“<strong>通过一个类的全限定名来获取描述此类的二进制字节流</strong>”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p><h1 id="ClassLoader常用方法"><a href="#ClassLoader常用方法" class="headerlink" title="ClassLoader常用方法"></a>ClassLoader常用方法</h1><h2 id="defineClass-byte-int-int"><a href="#defineClass-byte-int-int" class="headerlink" title="defineClass(byte[],int,int)"></a>defineClass(byte[],int,int)</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; defineClass(<span class="hljs-keyword">byte</span>[] b, <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len)        <span class="hljs-keyword">throws</span> ClassFormatError</code></pre></div><p>用来将byte字节流解析成JVM能够识别的Class对象</p><h2 id="findClass-String"><a href="#findClass-String" class="headerlink" title="findClass(String)"></a>findClass(String)</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException(name);&#125;</code></pre></div><p>defineClass通常和findClass方法一起使用，通过直接覆盖ClassLoader父类的findClass方法来实现类的加载规则，从而取得要加载类的字节码。然后调用defineClass方法生成类的Class对象。</p><h2 id="resolveClass-Class-lt-gt"><a href="#resolveClass-Class-lt-gt" class="headerlink" title="resolveClass(Class&lt;?&gt;)"></a>resolveClass(Class&lt;?&gt;)</h2><p>在类被加载到JVM中调用该方法就会被链接（Link）</p><h2 id="loadClass-String-boolean"><a href="#loadClass-String-boolean" class="headerlink" title="loadClass(String , boolean)"></a>loadClass(String , boolean)</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)       <span class="hljs-keyword">throws</span> ClassNotFoundException   &#123;       <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;           <span class="hljs-comment">// 1.检查这个类是否已经被加载了</span>           Class&lt;?&gt; c = findLoadedClass(name);           <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;               <span class="hljs-keyword">long</span> t0 = System.nanoTime();               <span class="hljs-keyword">try</span> &#123;                   <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;                   <span class="hljs-comment">//如果父加载器存在，使用父加载器加载</span>                       c = parent.loadClass(name, <span class="hljs-keyword">false</span>);                   &#125; <span class="hljs-keyword">else</span> &#123;                   <span class="hljs-comment">//使用内置加载器加载</span>                       c = findBootstrapClassOrNull(name);                   &#125;               &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;                   <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span>                   <span class="hljs-comment">// from the non-null parent class loader</span>               &#125;               <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;                   <span class="hljs-comment">// 如果仍未加载，调用findClass方法加载</span>                   <span class="hljs-keyword">long</span> t1 = System.nanoTime();                   c = findClass(name);                   <span class="hljs-comment">// this is the defining class loader; record the stats</span>                   sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                   sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                   sun.misc.PerfCounter.getFindClasses().increment();               &#125;           &#125;           <span class="hljs-comment">//根据第二个参数来决定是否链接（Link）</span>           <span class="hljs-keyword">if</span> (resolve) &#123;               resolveClass(c);           &#125;           <span class="hljs-keyword">return</span> c;       &#125;   &#125;</code></pre></div><h1 id="ClassLoader的等级加载机制"><a href="#ClassLoader的等级加载机制" class="headerlink" title="ClassLoader的等级加载机制"></a>ClassLoader的等级加载机制</h1><h2 id="BootstrapClassLoader"><a href="#BootstrapClassLoader" class="headerlink" title="BootstrapClassLoader"></a>BootstrapClassLoader</h2><p>主要加载JVM自身工作需要的类，完全由JVM自己控制，别人访问不了这个类，它仅仅是一个类的加载工具而已，既没有更高一级的父加载器，也没有子加载器。</p><h2 id="ExtClassLoader"><a href="#ExtClassLoader" class="headerlink" title="ExtClassLoader"></a>ExtClassLoader</h2><p>ExtClassLoader称为<strong>扩展类加载器</strong>，主要负责加载Java的扩展类库,默认加载<code>JAVA_HOME/jre/lib/ext/</code>目录下的所有jar包或者由<code>java.ext.dirs</code>系统属性指定的jar包.放入这个目录下的jar包对AppClassLoader加载器都是可见的(因为ExtClassLoader是AppClassLoader的父加载器,并且Java类加载器采用了委托机制)。</p><h2 id="AppClassLoader"><a href="#AppClassLoader" class="headerlink" title="AppClassLoader"></a>AppClassLoader</h2><p>AppClassLoader<strong>应用类加载器</strong>，又称为<strong>系统类加载器</strong>，负责在JVM启动时,加载来自在命令java中的<code>classpath</code>或者<code>java.class.path</code>系统属性或者<code>CLASSPATH</code>操作系统属性所指定的JAR类包和类路径。<br>我们在实现自己的类加载器的时候，不管是直接实现抽象类ClassLoad还是继承URLClassLoad类，或是其他子类，他的父加载器都是AppClassLoad，因为不管调用哪个父类构造器，创建的对象都必须最终调用<code>getSystemClassLoader()</code>作为父加载器，而<code>getSystemClassLoader()</code>方法返回的正是AppClassLoader。</p><p>JVM加载class文件到内存的两种方式：</p><ul><li><strong>隐式加载</strong>：不通过在代码里调用ClassLoader来加载需要的类，而是通过JVM来自动加载需要的类到内存的方式，例如：当我们在类中继承或者引用某个类时，JVM在解析当前这个类时发现引用的类不在内存中，那么就会自动将这些类加载到内存中。</li><li><strong>显示加载</strong>：在代码中通过调用ClassLoader类来加载一个类的方式，例如：调用<code>this.getClass.getClassLoader().loadClass()</code>或者<code>Class.forName()</code>，或者是调用我们自己实现的ClassLoader的findClass()方法等。</li></ul><h1 id="3-如何加载class文件"><a href="#3-如何加载class文件" class="headerlink" title="3 如何加载class文件"></a>3 如何加载class文件</h1><p>用ClassLoader加载一个class文件到JVM时需要经过的步骤如下：<br><img src="https://img-blog.csdnimg.cn/20200612110825762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>    第一个阶段是找到.class文件并把这个文件包含的字节码<strong>加载</strong>到内存中。<br>    第二个阶段又可以分为三个步骤，分别是字节码<strong>验证</strong>、Class类数据结构及相应的内存分配和最后的符号表的链接。<br>    第三个阶段是类中静态属性和初始化赋值，以及静态块的执行等。</p><h2 id="加载字节码到内存"><a href="#加载字节码到内存" class="headerlink" title="加载字节码到内存"></a>加载字节码到内存</h2><p>查看URLClassLoader部分源码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">URLClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SecureClassLoader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Closeable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> URLClassPath ucp;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AccessControlContext acc;<span class="hljs-comment">//构造方法必须要指定一个URL数据才能够创建URLClassLoader对象，也就是必须要指定这个ClassLoader默认到哪个目录下去查找class文件</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">URLClassLoader</span><span class="hljs-params">(URL[] urls)</span> </span>&#123;        <span class="hljs-keyword">super</span>();        SecurityManager security = System.getSecurityManager();        <span class="hljs-keyword">if</span> (security != <span class="hljs-keyword">null</span>) &#123;            security.checkCreateClassLoader();        &#125;        <span class="hljs-keyword">this</span>.acc = AccessController.getContext();        <span class="hljs-comment">//通过一个URLClassPath类帮助取得要加载的class文件字节流,URLClassPath也就定义了到哪去找这个class文件，如果找到了这个class文件，在读取他的byte字节流，通过调用defineClass()方法来创建类对象。</span>        ucp = <span class="hljs-keyword">new</span> URLClassPath(urls, acc);    &#125;<span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(<span class="hljs-keyword">final</span> String name)        <span class="hljs-keyword">throws</span> ClassNotFoundException    &#123;        <span class="hljs-keyword">final</span> Class&lt;?&gt; result;        <span class="hljs-keyword">try</span> &#123;            result = AccessController.doPrivileged(                <span class="hljs-keyword">new</span> PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;                    <span class="hljs-keyword">public</span> Class&lt;?&gt; run() <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;                        String path = name.replace(<span class="hljs-string">'.'</span>, <span class="hljs-string">'/'</span>).concat(<span class="hljs-string">".class"</span>);                        <span class="hljs-comment">//这里就用到了ucp来取得要加载类的字节码</span>                        Resource res = ucp.getResource(path, <span class="hljs-keyword">false</span>);                        <span class="hljs-keyword">if</span> (res != <span class="hljs-keyword">null</span>) &#123;                            <span class="hljs-keyword">try</span> &#123;                            <span class="hljs-comment">//生成Class对象</span>                                <span class="hljs-keyword">return</span> defineClass(name, res);                            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException(name, e);                            &#125;                        &#125; <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;                        &#125;                    &#125;                &#125;, acc);        &#125; <span class="hljs-keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;            <span class="hljs-keyword">throw</span> (ClassNotFoundException) pae.getException();        &#125;        <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException(name);        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre></div><p>在URLClassLoader中通过一个URLClassPath类帮助取得要加载的class文件字节流，而这个URLClassPath定义了到哪里去找这个class文件，如果找到了这个class文件，再读取它的byte字节流，通过调用<code>defineClass()</code>方法来创建类对象。</p><p>在创建URLClassPath对象时会根据传过来的URL数组中的路径来判断是文件还是jar包，根据路径的不同分别创建FileLoader或者JarLoader，或者使用默认的加载器。当JVM调用findClass时由这几个加载器来将class文件的字节码加载到内存中。</p><h2 id="验证与解析"><a href="#验证与解析" class="headerlink" title="验证与解析"></a>验证与解析</h2><ul><li>字节码验证，类装入器对于类的字节码要做许多检测，以确保格式正确、行为正确。</li><li>类准备，在这个阶段准备代表每个类中定义的字段、方法和实现接口所必须的数据结构。</li><li>解析，在这个阶段类装入器装入类所引用的其他所有类。可以用许多方式引用类，如超类、接口、字段、方法签名、方法中使用的本地变量。<h2 id="初始化Class对象"><a href="#初始化Class对象" class="headerlink" title="初始化Class对象"></a>初始化Class对象</h2>在类中包含的静态初始化器都会被执行，设置为默认值。<h1 id="4-常见加载类错误分析"><a href="#4-常见加载类错误分析" class="headerlink" title="4 常见加载类错误分析"></a>4 常见加载类错误分析</h1><h2 id="ClassNotFoundException"><a href="#ClassNotFoundException" class="headerlink" title="ClassNotFoundException"></a>ClassNotFoundException</h2>这个异常通常发生在显式加载类的时候。<br>显式加载通常有如下方式：</li><li>通过类Class中的forName()方法；</li><li>通过类ClassLoader中的loadclass()方法；</li><li>通过类ClassLoader中的findSystemClass()方法</li></ul><p>出现这类错误也很好理解，就是当JVM要加载指定文件的字节码到内存时，并没由找到这个类对应的字节码，也就是说这个字节码.class文件不存在。解决方法就是检测在当前的classpath目录下有没有指定的文件存在，如果不知道classpath路径，就可以通过如下命令获取：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">this</span>.getClass().getClassLoader().getResource(<span class="hljs-string">""</span>).toString()</code></pre></div><h2 id="NoClassDefFoundError"><a href="#NoClassDefFoundError" class="headerlink" title="NoClassDefFoundError"></a>NoClassDefFoundError</h2><p>这个异常在第一次使用命令执行Java类时很可能会碰到，如下面这种情况</p><div class="hljs"><pre><code class="hljs java">java -cp example.jar Example</code></pre></div><p>假如在这个jar包里面只有一个类，这个类时net.xx.Exmple ，那么原因很可能是你在命令行中没有加类的包名，正确的写法是这样的：</p><div class="hljs"><pre><code class="hljs java">java cp example.jar net.xx.Example</code></pre></div><p>在JVM的规范中描述了出现NoClassDefFoundError可能的情况就是使用new关键字、属性引用某个类、继承了某个接口或者类，以及方法的某个参数中引用了某个类，这个是出发JVM隐式加载这些类时发现这些类不存在的异常。</p><p>解决这个错误的方法就是确保这个类引用的类都在当前的classpath下面</p><h2 id="ClassCastException"><a href="#ClassCastException" class="headerlink" title="ClassCastException"></a>ClassCastException</h2><p>通常在程序中出现强制类型转换时出现这个错误。<br>JVM在做类型转换时会按照如下规则进行检查</p><ul><li>对于普通对象，对象必须时目标类的实例或目标类的子类的实例。如果目标是是接口，那么会把它当作实现了接口的一个子类。</li><li>对于数组类型，目标类必须是数组类型或java.lang.Object、java.lang.Cloneable、java.io.Serializele</li></ul><p>如果不满足上面的规则，JVM就会报这个错误。要避免这个错误有两种方式：</p><ul><li>在容器类型中现实的指明这个容器所包含的对象类型</li><li>先通过instanceof检查是不是目标类型，然后再进行强制类型转换。<h2 id="ExceptionInInitializerError"><a href="#ExceptionInInitializerError" class="headerlink" title="ExceptionInInitializerError"></a>ExceptionInInitializerError</h2>这个错误在JVM规范中是这样定义的：</li><li>如果Java虚拟机试图创建类ExceptionInInitializerError的新实例，但是因为出现Out-Of-Memory-Error而无法创建新实例，那么就抛出OutOfMemoryError对象作为代替。</li><li>如果初始化器抛出一些Excepton，而且Exception类不是Error或者它的某个子类，那么就会创建ExceptioinInInitializerError类的一个新实例，并用Exception作为参数，用这个实例代替Excepiton。<h2 id="UnsatisfiedLinkError"><a href="#UnsatisfiedLinkError" class="headerlink" title="UnsatisfiedLinkError"></a>UnsatisfiedLinkError</h2>这个异常倒不是很常见，但是出错的话，通常是在JVM启动的时候，如果一不小心将在JVM的某个lib删除了，可能就会报这个错误。</li></ul><p>参考文献：<br>1 <a href="https://blog.csdn.net/u013412772/article/details/80837735" target="_blank" rel="noopener">https://blog.csdn.net/u013412772/article/details/80837735</a></p>]]></content>
    
    
    <categories>
      
      <category>JVM规范</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.SpringSecurity整合OAuth2.0-Day03</title>
    <link href="/2020/06/10/4-SpringSecurity%E6%95%B4%E5%90%88OAuth2-0-Day03/"/>
    <url>/2020/06/10/4-SpringSecurity%E6%95%B4%E5%90%88OAuth2-0-Day03/</url>
    
    <content type="html"><![CDATA[<p>上一篇文章中我们介绍了获取 token 的流程，这一篇重点分析一下，携带 token 访问受限资源时，内部的工作流程。</p><h2 id="EnableResourceServer-与-EnableAuthorizationServer"><a href="#EnableResourceServer-与-EnableAuthorizationServer" class="headerlink" title="@EnableResourceServer 与 @EnableAuthorizationServer"></a>@EnableResourceServer 与 @EnableAuthorizationServer</h2><p>之前我们介绍过了 OAuth2 的两个核心概念，资源服务器与身份认证服务器。我们对两个注解进行配置的同时，到底触发了内部的什么相关配置呢？</p><p>上一篇文章重点介绍的其实是与身份认证相关的流程，即如果获取 token，而本节要分析的携带 token 访问受限资源，自然便是与 @EnableResourceServer 相关的资源服务器配置了。</p><p>我们注意到其相关配置类是 ResourceServerConfigurer，内部关联了 ResourceServerSecurityConfigurer 和 HttpSecurity。前者与资源安全配置相关，后者与 http 安全配置相关。（类名比较类似，注意区分，以 Adapter 结尾的是适配器，以 Configurer 结尾的是配置器，以 Builder 结尾的是建造器，他们分别代表不同的设计模式，对设计模式有所了解可以更加方便理解其设计思路）</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceServerConfigurerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ResourceServerConfigurer</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ResourceServerSecurityConfigurer resources &lt;<span class="hljs-number">1</span>&gt;)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;http.authorizeRequests().anyRequest().authenticated();&#125;&#125;</code></pre></div><p>&lt;1&gt; ResourceServerSecurityConfigurer 显然便是我们分析的重点了。</p><h2 id="ResourceServerSecurityConfigurer（了解）"><a href="#ResourceServerSecurityConfigurer（了解）" class="headerlink" title="ResourceServerSecurityConfigurer（了解）"></a>ResourceServerSecurityConfigurer（了解）</h2><p>其核心配置如下所示：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;AuthenticationManager oauthAuthenticationManager = oauthAuthenticationManager(http);resourcesServerFilter = <span class="hljs-keyword">new</span> OAuth2AuthenticationProcessingFilter();<span class="hljs-comment">//&lt;1&gt;</span>resourcesServerFilter.setAuthenticationEntryPoint(authenticationEntryPoint);resourcesServerFilter.setAuthenticationManager(oauthAuthenticationManager);<span class="hljs-comment">//&lt;2&gt;</span><span class="hljs-keyword">if</span> (eventPublisher != <span class="hljs-keyword">null</span>) &#123;resourcesServerFilter.setAuthenticationEventPublisher(eventPublisher);&#125;<span class="hljs-keyword">if</span> (tokenExtractor != <span class="hljs-keyword">null</span>) &#123;resourcesServerFilter.setTokenExtractor(tokenExtractor);<span class="hljs-comment">//&lt;3&gt;</span>&#125;resourcesServerFilter = postProcess(resourcesServerFilter);resourcesServerFilter.setStateless(stateless);<span class="hljs-comment">// @formatter:off</span>http.authorizeRequests().expressionHandler(expressionHandler).and().addFilterBefore(resourcesServerFilter, AbstractPreAuthenticatedProcessingFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">.<span class="hljs-title">exceptionHandling</span>()</span><span class="hljs-class">.<span class="hljs-title">accessDeniedHandler</span>(<span class="hljs-title">accessDeniedHandler</span>)//&lt;4&gt;</span><span class="hljs-class">.<span class="hljs-title">authenticationEntryPoint</span>(<span class="hljs-title">authenticationEntryPoint</span>)</span>;<span class="hljs-comment">// @formatter:on</span>&#125;</code></pre></div><p>这段是整个 oauth2 与 HttpSecurity 相关的核心配置，其中有非常多的注意点，顺带的都强调一下：</p><p>&lt;1&gt; 创建 OAuth2AuthenticationProcessingFilter，即下一节所要介绍的 OAuth2 核心过滤器。</p><p>&lt;2&gt; 为 OAuth2AuthenticationProcessingFilter 提供固定的 AuthenticationManager 即 OAuth2AuthenticationManager，它并没有将 OAuth2AuthenticationManager 添加到 spring 的容器中，不然可能会影响 spring security 的普通认证流程（非 oauth2 请求），只有被 OAuth2AuthenticationProcessingFilter 拦截到的 oauth2 相关请求才被特殊的身份认证器处理。</p><p>&lt;3&gt; 设置了 TokenExtractor 默认的实现 —-BearerTokenExtractor，这个类在下一节介绍。</p><p>&lt;4&gt; 相关的异常处理器，可以重写相关实现，达到自定义异常的目的。</p><p>还记得我们在一开始的配置中配置了资源服务器，是它触发了相关的配置。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableResourceServer</span><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceServerConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResourceServerConfigurerAdapter</span> </span>&#123;&#125;</code></pre></div><h2 id="核心过滤器-OAuth2AuthenticationProcessingFilter（掌握）"><a href="#核心过滤器-OAuth2AuthenticationProcessingFilter（掌握）" class="headerlink" title="核心过滤器 OAuth2AuthenticationProcessingFilter（掌握）"></a>核心过滤器 OAuth2AuthenticationProcessingFilter（掌握）</h2><p>回顾一下我们之前是如何携带 token 访问受限资源的：<br><code>http://localhost:8080/order/1?access_token=950a7cc9-5a8a-42c9-a693-40e817b1a4b0</code><br>唯一的身份凭证，便是这个 access_token，携带它进行访问，会进入 OAuth2AuthenticationProcessingFilter 之中，其核心代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span>&#123;<span class="hljs-keyword">final</span> HttpServletRequest request = (HttpServletRequest) req;<span class="hljs-keyword">final</span> HttpServletResponse response = (HttpServletResponse) res;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// 从请求中取出身份信息，即 access_token</span>Authentication authentication = tokenExtractor.extract(request);<span class="hljs-keyword">if</span> (authentication == <span class="hljs-keyword">null</span>) &#123;...&#125;<span class="hljs-keyword">else</span> &#123;request.setAttribute(OAuth2AuthenticationDetails.ACCESS_TOKEN_VALUE, authentication.getPrincipal());<span class="hljs-keyword">if</span> (authentication <span class="hljs-keyword">instanceof</span> AbstractAuthenticationToken) &#123;AbstractAuthenticationToken needsDetails = (AbstractAuthenticationToken) authentication;needsDetails.setDetails(authenticationDetailsSource.buildDetails(request));&#125;<span class="hljs-comment">// 认证身份</span>Authentication authResult = authenticationManager.authenticate(authentication);...eventPublisher.publishAuthenticationSuccess(authResult);<span class="hljs-comment">// 将身份信息绑定到 SecurityContextHolder 中</span>SecurityContextHolder.getContext().setAuthentication(authResult);&#125;&#125;<span class="hljs-keyword">catch</span> (OAuth2Exception failed) &#123;...<span class="hljs-keyword">return</span>;&#125;chain.doFilter(request, response);&#125;</code></pre></div><p>整个过滤器便是 oauth2 身份鉴定的关键，在源码中，对这个类有一段如下的描述</p><blockquote><p>A pre-authentication filter for OAuth2 protected resources. Extracts an OAuth2 token from the incoming request and uses it to populate the Spring Security context with an {@link OAuth2Authentication} (if used in conjunction with an {@link OAuth2AuthenticationManager}). </p><p>OAuth2 保护资源的预先认证过滤器。如果与 OAuth2AuthenticationManager 结合使用，则会从到来的请求之中提取一个 OAuth2 token，之后使用 OAuth2Authentication 来填充 Spring Security 上下文。</p></blockquote><p>其中涉及到了两个关键的类 TokenExtractor，AuthenticationManager。相信后者这个接口大家已经不陌生，但前面这个类之前还未出现在我们的视野中。</p><h2 id="OAuth2-的身份管理器-–OAuth2AuthenticationManager（掌握）"><a href="#OAuth2-的身份管理器-–OAuth2AuthenticationManager（掌握）" class="headerlink" title="OAuth2 的身份管理器 –OAuth2AuthenticationManager（掌握）"></a>OAuth2 的身份管理器 –OAuth2AuthenticationManager（掌握）</h2><p>在之前的 OAuth2 核心过滤器中出现的 AuthenticationManager 其实在我们意料之中，携带 access_token 必定得经过身份认证，但是在我们 debug 进入其中后，发现了一个出乎意料的事，AuthenticationManager 的实现类并不是我们在前面文章中聊到的常用实现类 ProviderManager，而是 OAuth2AuthenticationManager。</p><p><img src="https://img-blog.csdnimg.cn/20200610104133512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>回顾之前文章的配置，压根没有出现过这个 OAuth2AuthenticationManager，并且它脱离了我们熟悉的认证流程（之前提到的认证管理器 UML 图是一张经典的 spring security 结构类图），它直接重写了容器的顶级身份认证接口，内部维护了一个 ClientDetailService 和 ResourceServerTokenServices，这两个核心类在前一篇文章中有分析过。在 ResourceServerSecurityConfigurer 的小节中我们已经知晓了它是如何被框架自动配置的，这里要强调的是 OAuth2AuthenticationManager 是密切与 token 认证相关的，而不是与获取 token 密切相关的。</p><p>其判别身份的关键代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;...String token = (String) authentication.getPrincipal();<span class="hljs-comment">// 最终还是借助 tokenServices 根据 token 加载身份信息</span>OAuth2Authentication auth = tokenServices.loadAuthentication(token);...checkClientDetails(auth);<span class="hljs-keyword">if</span> (authentication.getDetails() <span class="hljs-keyword">instanceof</span> OAuth2AuthenticationDetails) &#123;OAuth2AuthenticationDetails details = (OAuth2AuthenticationDetails) authentication.getDetails();...&#125;auth.setDetails(authentication.getDetails());auth.setAuthenticated(<span class="hljs-keyword">true</span>);<span class="hljs-keyword">return</span> auth;&#125;</code></pre></div><p>说到 tokenServices 这个密切与 token 相关的接口，这里要强调下，避免产生误解。tokenServices 分为两类，一个是用在 AuthorizationServer 端</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthorizationServerTokenServices</span> </span>&#123;    <span class="hljs-comment">// 创建 token</span>    <span class="hljs-function">OAuth2AccessToken <span class="hljs-title">createAccessToken</span><span class="hljs-params">(OAuth2Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException</span>;    <span class="hljs-comment">// 刷新 token</span>    <span class="hljs-function">OAuth2AccessToken <span class="hljs-title">refreshAccessToken</span><span class="hljs-params">(String refreshToken, TokenRequest tokenRequest)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> AuthenticationException</span>;    <span class="hljs-comment">// 获取 token</span>    <span class="hljs-function">OAuth2AccessToken <span class="hljs-title">getAccessToken</span><span class="hljs-params">(OAuth2Authentication authentication)</span></span>;&#125;</code></pre></div><p>而在 ResourceServer 端有自己的 tokenServices 接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ResourceServerTokenServices</span> </span>&#123;<span class="hljs-comment">// 根据 accessToken 加载客户端信息</span><span class="hljs-function">OAuth2Authentication <span class="hljs-title">loadAuthentication</span><span class="hljs-params">(String accessToken)</span> <span class="hljs-keyword">throws</span> AuthenticationException, InvalidTokenException</span>;<span class="hljs-comment">// 根据 accessToken 获取完整的访问令牌详细信息。</span><span class="hljs-function">OAuth2AccessToken <span class="hljs-title">readAccessToken</span><span class="hljs-params">(String accessToken)</span></span>;&#125;</code></pre></div><p>具体内部如何加载，和 AuthorizationServer 大同小异，只是从 tokenStore 中取出相应身份的流程有点区别，不再详细看实现类了。</p><h2 id="TokenExtractor（了解）"><a href="#TokenExtractor（了解）" class="headerlink" title="TokenExtractor（了解）"></a>TokenExtractor（了解）</h2><p>这个接口只有一个实现类，而且代码非常简单</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BearerTokenExtractor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TokenExtractor</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Log logger = LogFactory.getLog(BearerTokenExtractor<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">extract</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;String tokenValue = extractToken(request);<span class="hljs-keyword">if</span> (tokenValue != <span class="hljs-keyword">null</span>) &#123;PreAuthenticatedAuthenticationToken authentication = <span class="hljs-keyword">new</span> PreAuthenticatedAuthenticationToken(tokenValue, <span class="hljs-string">""</span>);<span class="hljs-keyword">return</span> authentication;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">extractToken</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<span class="hljs-comment">// first check the header...</span>String token = extractHeaderToken(request);<span class="hljs-comment">// bearer type allows a request parameter as well</span><span class="hljs-keyword">if</span> (token == <span class="hljs-keyword">null</span>) &#123;...<span class="hljs-comment">// 从 requestParameter 中获取 token</span>&#125;<span class="hljs-keyword">return</span> token;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Extract the OAuth bearer token from a header.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">extractHeaderToken</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;Enumeration&lt;String&gt; headers = request.getHeaders(<span class="hljs-string">"Authorization"</span>);<span class="hljs-keyword">while</span> (headers.hasMoreElements()) &#123;<span class="hljs-comment">// typically there is only one (most servers enforce that)</span>...<span class="hljs-comment">// 从 Header 中获取 token</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;&#125;</code></pre></div><p>它的作用在于分离出请求中包含的 token。也启示了我们可以使用多种方式携带 token。<br>1 在 Header 中携带</p><div class="hljs"><pre><code class="hljs http"><span class="hljs-attribute">http://localhost:8080/order/1</span><span class="hljs-attribute">Header：</span>Authentication：Bearer f732723d-af7f-41bb-bd06-2636ab2be135</code></pre></div><p>2 拼接在 url 中作为 requestParam</p><div class="hljs"><pre><code class="hljs http">http://localhost:8080/order/1?access_token=f732723d-af7f-41bb-bd06-2636ab2be135</code></pre></div><p>3 在 form 表单中携带</p><div class="hljs"><pre><code class="hljs http"><span class="hljs-attribute">http://localhost:8080/order/1</span>form param：access_token=f732723d-af7f-41bb-bd06-2636ab2be135</code></pre></div><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>OAuth2 在资源服务器端的异常处理不算特别完善，但基本够用，如果想要重写异常机制，可以直接替换掉相关的 Handler，如权限相关的 AccessDeniedHandler。具体的配置应该在 @EnableResourceServer 中被覆盖，这是适配器 + 配置器的好处。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这儿，Spring Security OAuth2 的整个内部流程就算是分析结束了。本系列的文章只能算是揭示一个大概的流程，重点还是介绍相关设计 + 接口，想要了解更多的细节，需要自己去翻看源码，研究各个实现类。在分析源码过程中总结出的一点经验，与君共勉：</p><ol><li>先掌握宏观，如研究 UML 类图，搞清楚关联</li><li>分析顶级接口，设计是面向接口的，不重要的部分，具体实现类甚至都可以忽略</li><li>学会对比，如 ResourceServer 和 AuthorizationServer 是一种对称的设计，整个框架内部的类非常多，但分门别类的记忆，会加深记忆。如 ResourceServerTokenServices ，AuthorizationServerTokenServices就一定是作用相关，但所属领域不同的两个接口</li><li>熟悉设计模式，spring 中涉及了大量的设计模式，在框架的设计中也是遵循着设计模式的规范，如以 Adapter 结尾，便是运用了适配器模式；以 Factory 结尾，便是运用了工厂模式；Template 结尾，便是运用了模板方法模式；Builder 结尾，便是运用了建造者模式…</li><li>一点自己的理解：对源码的理解和灵感，这一切都建立自身的编码经验之上，自己遵循规范便能更好的理解别人同样遵守规范的代码。相对的，阅读好的源码，也能帮助我们自身提升编码规范。</li></ol>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.SpringSecurity整合OAuth2.0-Day02</title>
    <link href="/2020/06/09/3-SpringSecurity%E6%95%B4%E5%90%88OAuth2.0-Day02/"/>
    <url>/2020/06/09/3-SpringSecurity%E6%95%B4%E5%90%88OAuth2.0-Day02/</url>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先开启 debug 信息：</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">logging:</span>  <span class="hljs-attr">level:</span>    <span class="hljs-attr">org.springframework:</span> <span class="hljs-string">DEBUG</span></code></pre></div><p>可以完整的看到内部的运转流程。</p><p>client 模式稍微简单一些，使用 client 模式获取 token</p><div class="hljs"><pre><code class="hljs http">http://localhost:8080/oauth/token?client_id=client_1&amp;client_secret=123456&amp;scope=select&amp;grant_type=client_credentials</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200609192018214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>查看调试窗口，由于 debug 信息太多了，我简单按照顺序列了一下关键的几个类：</p><div class="hljs"><pre><code class="hljs javascript">ClientCredentialsTokenEndpointFilterDaoAuthenticationProviderTokenEndpointTokenGranter</code></pre></div><h2 id="EnableAuthorizationServer"><a href="#EnableAuthorizationServer" class="headerlink" title="@EnableAuthorizationServer"></a>@EnableAuthorizationServer</h2><p>上一篇博客中我们尝试使用了 password 模式和 client 模式，有一个比较关键的 endpoint：/oauth/token。从这个入口开始分析，spring security oauth2 内部是如何生成 token 的？</p><p>在之前的配置中：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableAuthorizationServer</span><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationServerConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;&#125;</code></pre></div><p>出现了 AuthorizationServerConfigurerAdapter 关键类，他关联了三个重要的配置类，分别是：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthorizationServerConfigurer</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerSecurityConfigurer security &lt;<span class="hljs-number">1</span>&gt;)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients &lt;<span class="hljs-number">2</span>&gt;)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints &lt;<span class="hljs-number">3</span>&gt;)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;&#125;&#125;</code></pre></div><p>&lt;1&gt; 配置 AuthorizationServer 安全认证的相关信息，创建 ClientCredentialsTokenEndpointFilter 核心过滤器</p><p>&lt;2&gt; 配置 OAuth2 的客户端相关信息</p><p>&lt;3&gt; 配置 AuthorizationServerEndpointsConfigurer 众多相关类，包括配置身份认证器，配置认证方式，TokenStore，TokenGranter，OAuth2RequestFactory</p><p>我们逐步分析其中关键的类：</p><h2 id="客户端身份认证核心过滤器-ClientCredentialsTokenEndpointFilter（掌握）"><a href="#客户端身份认证核心过滤器-ClientCredentialsTokenEndpointFilter（掌握）" class="headerlink" title="客户端身份认证核心过滤器 ClientCredentialsTokenEndpointFilter（掌握）"></a>客户端身份认证核心过滤器 ClientCredentialsTokenEndpointFilter（掌握）</h2><p>截取关键的代码，可以分析出大概的流程<br>在请求到达 /oauth/token 之前经过了 ClientCredentialsTokenEndpointFilter 这个过滤器，关键方法如下</p><div class="hljs"><pre><code class="hljs java">org.springframework.security.oauth2.provider.client.ClientCredentialsTokenEndpointFilter#attemptAuthentication    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException, IOException, ServletException </span>&#123;...String clientId = request.getParameter(<span class="hljs-string">"client_id"</span>);String clientSecret = request.getParameter(<span class="hljs-string">"client_secret"</span>);...clientId = clientId.trim();UsernamePasswordAuthenticationToken authRequest = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(clientId,clientSecret);<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);&#125;</code></pre></div><h2 id="顶级身份管理者-AuthenticationManager（掌握）"><a href="#顶级身份管理者-AuthenticationManager（掌握）" class="headerlink" title="顶级身份管理者 AuthenticationManager（掌握）"></a>顶级身份管理者 AuthenticationManager（掌握）</h2><p>用来从请求中获取 client_id,client_secret，组装成一个 UsernamePasswordAuthenticationToken 作为身份标识，使用容器中的顶级身份管理器 AuthenticationManager 去进行身份认证（AuthenticationManager 的实现类一般是 ProviderManager。而 ProviderManager 内部维护了一个 List, 真正的身份认证是由一系列 AuthenticationProvider 去完成。而 AuthenticationProvider 的常用实现类则是 DaoAuthenticationProvider，DaoAuthenticationProvider 内部又聚合了一个 UserDetailsService 接口，</p><p><img src="https://img-blog.csdnimg.cn/20200610091710428.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>所以说UserDetailsService 才是获取用户详细信息的最终接口，而我们上一篇文章中在内存中配置用户，就是使用了 UserDetailsService 的一个实现类 InMemoryUserDetailsManager）。UML 类图可以大概理解下这些类的关系，省略了授权部分。<br><img src="https://img-blog.csdnimg.cn/20200610104349713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>可能机智的读者会发现一个问题，我前面一篇文章已经提到了 client 模式是不存在“用户”的概念的，那么这里的身份认证是在认证什么呢？debug 可以发现 UserDetailsService 的实现被适配成了 ClientDetailsUserDetailsService，这个设计是将 client 客户端的信息（client_id,client_secret）适配成用户的信息 (username,password)，这样我们的认证流程就不需要修改了。</p><p>经过 ClientCredentialsTokenEndpointFilter 之后，身份信息已经得到了 AuthenticationManager 的验证。接着便到达了TokenEndpoint。</p><h2 id="Token-处理端点-TokenEndpoint（掌握）"><a href="#Token-处理端点-TokenEndpoint（掌握）" class="headerlink" title="Token 处理端点 TokenEndpoint（掌握）"></a>Token 处理端点 TokenEndpoint（掌握）</h2><p>前面的两个 ClientCredentialsTokenEndpointFilter 和 AuthenticationManager 可以理解为一些前置校验和身份封装，而这个类一看名字就知道和我们的 token 是密切相关的。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@FrameworkEndpoint</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TokenEndpoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractEndpoint</span> </span>&#123;<span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/oauth/token"</span>, method=RequestMethod.POST)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;OAuth2AccessToken&gt; <span class="hljs-title">postAccessToken</span><span class="hljs-params">(Principal principal, @RequestParam</span></span><span class="hljs-function"><span class="hljs-params">Map&lt;String, String&gt; parameters)</span> <span class="hljs-keyword">throws</span> HttpRequestMethodNotSupportedException </span>&#123; ...String clientId = getClientId(principal);ClientDetails authenticatedClient = getClientDetailsService().loadClientByClientId(clientId);<span class="hljs-comment">//&lt;1&gt;</span>...TokenRequest tokenRequest = getOAuth2RequestFactory().createTokenRequest(parameters, authenticatedClient);<span class="hljs-comment">//&lt;2&gt;</span>...OAuth2AccessToken token = getTokenGranter().grant(tokenRequest.getGrantType(), tokenRequest);<span class="hljs-comment">//&lt;3&gt;</span>...<span class="hljs-keyword">return</span> getResponse(token);&#125;<span class="hljs-keyword">private</span> TokenGranter tokenGranter;&#125;</code></pre></div><p>&lt;1&gt; 加载客户端信息</p><p>&lt;2&gt; 结合请求信息，创建 TokenRequest</p><p>&lt;3&gt; 将 TokenRequest 传递给 TokenGranter 颁发 token</p><p>省略了一些校验代码之后，真正的 /oauth/token 端点暴露在了我们眼前，其中方法参数中的 Principal 经过之前的过滤器，已经被填充了相关的信息，而方法的内部则是依赖了一个 TokenGranter 来颁发 token。其中 OAuth2AccessToken 的实现类 DefaultOAuth2AccessToken 就是最终在控制台得到的 token 序列化之前的原始类:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultOAuth2AccessToken</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span>, <span class="hljs-title">OAuth2AccessToken</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">914967629530462926L</span>;  <span class="hljs-keyword">private</span> String value;  <span class="hljs-keyword">private</span> Date expiration;  <span class="hljs-keyword">private</span> String tokenType = BEARER_TYPE.toLowerCase();  <span class="hljs-keyword">private</span> OAuth2RefreshToken refreshToken;  <span class="hljs-keyword">private</span> Set&lt;String&gt; scope;  <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; additionalInformation = Collections.emptyMap();  <span class="hljs-comment">//getter,setter</span>&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@org</span>.codehaus.jackson.map.annotate.JsonSerialize(using = OAuth2AccessTokenJackson1Serializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">org</span>.<span class="hljs-title">codehaus</span>.<span class="hljs-title">jackson</span>.<span class="hljs-title">map</span>.<span class="hljs-title">annotate</span>.<span class="hljs-title">JsonDeserialize</span>(<span class="hljs-title">using</span> </span>= OAuth2AccessTokenJackson1Deserializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">com</span>.<span class="hljs-title">fasterxml</span>.<span class="hljs-title">jackson</span>.<span class="hljs-title">databind</span>.<span class="hljs-title">annotation</span>.<span class="hljs-title">JsonSerialize</span>(<span class="hljs-title">using</span> </span>= OAuth2AccessTokenJackson2Serializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">com</span>.<span class="hljs-title">fasterxml</span>.<span class="hljs-title">jackson</span>.<span class="hljs-title">databind</span>.<span class="hljs-title">annotation</span>.<span class="hljs-title">JsonDeserialize</span>(<span class="hljs-title">using</span> </span>= OAuth2AccessTokenJackson2Deserializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">OAuth2AccessToken</span> </span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String BEARER_TYPE = <span class="hljs-string">"Bearer"</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String OAUTH2_TYPE = <span class="hljs-string">"OAuth2"</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String ACCESS_TOKEN = <span class="hljs-string">"access_token"</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String TOKEN_TYPE = <span class="hljs-string">"token_type"</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String EXPIRES_IN = <span class="hljs-string">"expires_in"</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String REFRESH_TOKEN = <span class="hljs-string">"refresh_token"</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String SCOPE = <span class="hljs-string">"scope"</span>;...&#125;</code></pre></div><p>一个典型的样例 token 响应, 如下所示，就是上述类序列化后的结果：</p><div class="hljs"><pre><code class="hljs json">&#123; <span class="hljs-attr">"access_token"</span>:<span class="hljs-string">"950a7cc9-5a8a-42c9-a693-40e817b1a4b0"</span>, <span class="hljs-attr">"token_type"</span>:<span class="hljs-string">"bearer"</span>, <span class="hljs-attr">"refresh_token"</span>:<span class="hljs-string">"773a0fcd-6023-45f8-8848-e141296cb3cb"</span>, <span class="hljs-attr">"expires_in"</span>:<span class="hljs-number">27036</span>, <span class="hljs-attr">"scope"</span>:<span class="hljs-string">"select"</span> &#125;</code></pre></div><h2 id="TokenGranter（掌握）"><a href="#TokenGranter（掌握）" class="headerlink" title="TokenGranter（掌握）"></a>TokenGranter（掌握）</h2><p>先从 UML 类图对 TokenGranter 接口的设计有一个宏观的认识：</p><p><img src="https://img-blog.csdnimg.cn/20200610104442401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>TokenGranter 的设计思路是使用 CompositeTokenGranter 管理一个 List 列表，每一种 grantType 对应一个具体的真正授权者，在 debug 过程中可以发现 CompositeTokenGranter 内部就是在循环调用五种 TokenGranter 实现类的 grant 方法，而 granter 内部则是通过 grantType 来区分是否是各自的授权类型。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompositeTokenGranter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TokenGranter</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;TokenGranter&gt; tokenGranters;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CompositeTokenGranter</span><span class="hljs-params">(List&lt;TokenGranter&gt; tokenGranters)</span> </span>&#123;        <span class="hljs-keyword">this</span>.tokenGranters = <span class="hljs-keyword">new</span> ArrayList(tokenGranters);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> OAuth2AccessToken <span class="hljs-title">grant</span><span class="hljs-params">(String grantType, TokenRequest tokenRequest)</span> </span>&#123;        Iterator var3 = <span class="hljs-keyword">this</span>.tokenGranters.iterator();        OAuth2AccessToken grant;        <span class="hljs-keyword">do</span> &#123;            <span class="hljs-keyword">if</span> (!var3.hasNext()) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            TokenGranter granter = (TokenGranter)var3.next();            grant = granter.grant(grantType, tokenRequest);        &#125; <span class="hljs-keyword">while</span>(grant == <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">return</span> grant;    &#125;&#125;</code></pre></div><p>五种类型分别是：</p><ul><li>ResourceOwnerPasswordTokenGranter ==&gt; password 密码模式</li><li>AuthorizationCodeTokenGranter ==&gt; authorization_code 授权码模式</li><li>ClientCredentialsTokenGranter ==&gt; client_credentials 客户端模式</li><li>ImplicitTokenGranter ==&gt; implicit 简化模式</li><li>RefreshTokenGranter ==&gt;refresh_token 刷新 token 专用</li></ul><p>以客户端模式为例，思考如何产生 token 的，则需要继续研究 5 种授权者的抽象类：AbstractTokenGranter</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractTokenGranter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TokenGranter</span> </span>&#123;<span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Log logger = LogFactory.getLog(getClass());<span class="hljs-comment">// 与 token 相关的 service，重点</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AuthorizationServerTokenServices tokenServices;<span class="hljs-comment">// 与 clientDetails 相关的 service，重点</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClientDetailsService clientDetailsService;<span class="hljs-comment">// 创建 oauth2Request 的工厂，重点</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> OAuth2RequestFactory requestFactory;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String grantType;...<span class="hljs-function"><span class="hljs-keyword">public</span> OAuth2AccessToken <span class="hljs-title">grant</span><span class="hljs-params">(String grantType, TokenRequest tokenRequest)</span> </span>&#123;...String clientId = tokenRequest.getClientId();ClientDetails client = clientDetailsService.loadClientByClientId(clientId);validateGrantType(grantType, client);logger.debug(<span class="hljs-string">"Getting access token for:"</span> + clientId);<span class="hljs-keyword">return</span> getAccessToken(client, tokenRequest);&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> OAuth2AccessToken <span class="hljs-title">getAccessToken</span><span class="hljs-params">(ClientDetails client, TokenRequest tokenRequest)</span> </span>&#123;<span class="hljs-keyword">return</span> tokenServices.createAccessToken(getOAuth2Authentication(client, tokenRequest));&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> OAuth2Authentication <span class="hljs-title">getOAuth2Authentication</span><span class="hljs-params">(ClientDetails client, TokenRequest tokenRequest)</span> </span>&#123;OAuth2Request storedOAuth2Request = requestFactory.createOAuth2Request(client, tokenRequest);<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OAuth2Authentication(storedOAuth2Request, <span class="hljs-keyword">null</span>);&#125;...&#125;</code></pre></div><p>回过头去看 TokenEndpoint 中，正是调用了这里的三个重要的类变量的相关方法。由于篇幅限制，不能延展太多，不然没完没了，所以重点分析下 AuthorizationServerTokenServices 是何方神圣。</p><h2 id="AuthorizationServerTokenServices（了解）"><a href="#AuthorizationServerTokenServices（了解）" class="headerlink" title="AuthorizationServerTokenServices（了解）"></a>AuthorizationServerTokenServices（了解）</h2><p>AuthorizationServer 端的 token 操作 service，接口设计如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthorizationServerTokenServices</span> </span>&#123;<span class="hljs-comment">// 创建 token</span><span class="hljs-function">OAuth2AccessToken <span class="hljs-title">createAccessToken</span><span class="hljs-params">(OAuth2Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException</span>;<span class="hljs-comment">// 刷新 token</span><span class="hljs-function">OAuth2AccessToken <span class="hljs-title">refreshAccessToken</span><span class="hljs-params">(String refreshToken, TokenRequest tokenRequest)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException</span>;<span class="hljs-comment">// 获取 token</span><span class="hljs-function">OAuth2AccessToken <span class="hljs-title">getAccessToken</span><span class="hljs-params">(OAuth2Authentication authentication)</span></span>;&#125;</code></pre></div><p>在默认的实现类 DefaultTokenServices 中，可以看到 token 是如何产生的，并且了解了框架对 token 进行哪些信息的关联。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><span class="hljs-function"><span class="hljs-keyword">public</span> OAuth2AccessToken <span class="hljs-title">createAccessToken</span><span class="hljs-params">(OAuth2Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;OAuth2AccessToken existingAccessToken = tokenStore.getAccessToken(authentication);OAuth2RefreshToken refreshToken = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span> (existingAccessToken != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (existingAccessToken.isExpired()) &#123;<span class="hljs-keyword">if</span> (existingAccessToken.getRefreshToken() != <span class="hljs-keyword">null</span>) &#123;refreshToken = existingAccessToken.getRefreshToken();tokenStore.removeRefreshToken(refreshToken);&#125;tokenStore.removeAccessToken(existingAccessToken);&#125;<span class="hljs-keyword">else</span> &#123;tokenStore.storeAccessToken(existingAccessToken, authentication);<span class="hljs-keyword">return</span> existingAccessToken;&#125;&#125;<span class="hljs-keyword">if</span> (refreshToken == <span class="hljs-keyword">null</span>) &#123;refreshToken = createRefreshToken(authentication);&#125;<span class="hljs-comment">// But the refresh token itself might need to be re-issued if it has</span><span class="hljs-comment">// expired.</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (refreshToken <span class="hljs-keyword">instanceof</span> ExpiringOAuth2RefreshToken) &#123;ExpiringOAuth2RefreshToken expiring = (ExpiringOAuth2RefreshToken) refreshToken;<span class="hljs-keyword">if</span> (System.currentTimeMillis() &gt; expiring.getExpiration().getTime()) &#123;refreshToken = createRefreshToken(authentication);&#125;&#125;OAuth2AccessToken accessToken = createAccessToken(authentication, refreshToken);tokenStore.storeAccessToken(accessToken, authentication);<span class="hljs-comment">// In case it was modified</span>refreshToken = accessToken.getRefreshToken();<span class="hljs-keyword">if</span> (refreshToken != <span class="hljs-keyword">null</span>) &#123;tokenStore.storeRefreshToken(refreshToken, authentication);&#125;<span class="hljs-keyword">return</span> accessToken;&#125;</code></pre></div><p>简单总结一下 AuthorizationServerTokenServices 的作用，他提供了创建 token，刷新 token，获取 token 的实现。在创建 token 时，他会调用 tokenStore 对产生的 token 和相关信息存储到对应的实现类中，可以是 redis，数据库，内存，jwt。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇总结了使用客户端模式获取 Token 时，spring security oauth2 内部的运作流程，重点是在分析 AuthenticationServer 相关的类。其他模式有一定的不同，但抽象功能是固定的，只是具体的实现类会被相应地替换。阅读 spring 的源码，会发现它的设计中出现了非常多的抽象接口，这对我们理清楚内部工作流程产生了不小的困扰，我的方式是可以借助 UML 类图，先从宏观理清楚作者的设计思路，这会让我们的分析事半功倍。</p><p>下一篇文章重点分析用户携带 token 访问受限资源时，spring security oauth2 内部的工作流程。即 ResourceServer 相关的类。</p>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.SpringSecurity整合OAuth2.0-Day01</title>
    <link href="/2020/06/08/2-SpringSecurity%E6%95%B4%E5%90%88OAuth2-0-Day01/"/>
    <url>/2020/06/08/2-SpringSecurity%E6%95%B4%E5%90%88OAuth2-0-Day01/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>使用 oauth2 保护你的应用，可以分为简易的分为三个步骤：</p><ul><li><p>配置资源服务器</p></li><li><p>配置认证服务器</p></li><li><p>配置 spring security</p><p>本文重点讲解接口对接中常使用的密码模式（以下简称 password 模式）和客户端模式（以下简称 client 模式）。授权码模式使用到了回调地址，是最为复杂的方式，通常网站中经常出现的微博，qq 第三方登录，都会采用这个形式。简化模式不常用。</p><h1 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h1><p>首先引入依赖：</p><div class="hljs"><pre><code class="hljs java">&lt;dependencies&gt;       &lt;!-- 注意是starter,自动配置 --&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;       &lt;/dependency&gt;       &lt;!-- 不是starter,手动配置 --&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt;           &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt;           &lt;version&gt;2.3.2.RELEASE&lt;/version&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;       &lt;/dependency&gt;       &lt;!-- 将token存储在redis中 --&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;       &lt;/dependency&gt;   &lt;/dependencies&gt;</code></pre></div><p>编写controller类，用来验证效果：</p></li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestEndpoints</span> </span>&#123;    <span class="hljs-comment">/** 商品查询接口，后续不做安全限制 **/</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/product/&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getProduct</span><span class="hljs-params">(@PathVariable String id)</span> </span>&#123;        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();        <span class="hljs-keyword">return</span> <span class="hljs-string">"product id : "</span> + id;    &#125;    <span class="hljs-comment">/** 订单查询接口，后续添加访问控制 **/</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/order/&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getOrder</span><span class="hljs-params">(@PathVariable String id)</span> </span>&#123;        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();        <span class="hljs-keyword">return</span> <span class="hljs-string">"order id : "</span> + id;    &#125;&#125;</code></pre></div><h1 id="配置资源服务器和授权服务器"><a href="#配置资源服务器和授权服务器" class="headerlink" title="配置资源服务器和授权服务器"></a>配置资源服务器和授权服务器</h1><p>资源服务器和授权服务器都是OAuth2的核心内容，这里我们在一个配置类中进行配置。<br>为了简化开发，这里将客户端信息放到内存中，实际项目开发中可以配置到数据库中。<br>token的存储一般使用redis，一来性能较好，二是本身就有自动过期的机制，符合token的特性。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OAuth2ServerConfig</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEMO_RESOURCE_ID = <span class="hljs-string">"order"</span>;    <span class="hljs-meta">@Configuration</span>    <span class="hljs-meta">@EnableResourceServer</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceServerConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResourceServerConfigurerAdapter</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ResourceServerSecurityConfigurer resources)</span> </span>&#123;            resources.resourceId(DEMO_RESOURCE_ID).stateless(<span class="hljs-keyword">true</span>);        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            http.authorizeRequests()                 <span class="hljs-comment">//配置order访问控制，必须认证过后才可以访问</span>                .antMatchers(<span class="hljs-string">"/order/**"</span>).authenticated();        &#125;    &#125;    <span class="hljs-meta">@Configuration</span>    <span class="hljs-meta">@EnableAuthorizationServer</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationServerConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;        <span class="hljs-meta">@Autowired</span>        AuthenticationManager authenticationManager;        <span class="hljs-meta">@Autowired</span>        RedisConnectionFactory redisConnectionFactory;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            String finalSecret = <span class="hljs-string">"&#123;bcrypt&#125;"</span>+<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123456"</span>);            <span class="hljs-comment">//配置两个客户端,一个用于password认证一个用于client认证</span>            clients.inMemory().withClient(<span class="hljs-string">"client_1"</span>)                    .resourceIds(DEMO_RESOURCE_ID)                    .authorizedGrantTypes(<span class="hljs-string">"client_credentials"</span>, <span class="hljs-string">"refresh_token"</span>)                    .scopes(<span class="hljs-string">"select"</span>)                    .authorities(<span class="hljs-string">"oauth2"</span>)                    .secret(finalSecret)                    .and().withClient(<span class="hljs-string">"client_2"</span>)                    .resourceIds(DEMO_RESOURCE_ID)                    .authorizedGrantTypes(<span class="hljs-string">"password"</span>, <span class="hljs-string">"refresh_token"</span>)                    .scopes(<span class="hljs-string">"select"</span>)                    .authorities(<span class="hljs-string">"oauth2"</span>)                    .secret(finalSecret);        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> </span>&#123;            endpoints                    .tokenStore(<span class="hljs-keyword">new</span> RedisTokenStore(redisConnectionFactory))                    .authenticationManager(authenticationManager)                    .allowedTokenEndpointRequestMethods(HttpMethod.GET, HttpMethod.POST);        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerSecurityConfigurer oauthServer)</span> </span>&#123;            <span class="hljs-comment">//允许表单认证</span>            oauthServer.allowFormAuthenticationForClients();        &#125;    &#125;&#125;</code></pre></div><p>认证思路：</p><ul><li>client 模式，没有用户的概念，直接与认证服务器交互，用配置中的客户端信息去申请 accessToken，客户端有自己的 client_id,client_secret ，对应于用户的 username,password，而客户端也拥有自己的 authorities，当采取 client 模式认证时，对应的权限也就是客户端自己的 authorities。</li><li>password 模式，自己本身有一套用户体系，在认证时需要带上自己的用户名和密码，以及客户端的 client_id,client_secret。此时，accessToken 所包含的权限是用户本身的权限，而不是客户端的权限。</li></ul><p>如果你的系统已经有了一套用户体系，每个用户也有了一定的权限，可以采用 password 模式；如果仅仅是接口的对接，不考虑用户，则可以使用 client 模式。</p><h1 id="配置-spring-security"><a href="#配置-spring-security" class="headerlink" title="配置 spring security"></a>配置 spring security</h1><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> UserDetailsService <span class="hljs-title">userDetailsService</span><span class="hljs-params">()</span></span>&#123;        BCryptPasswordEncoder bCryptPasswordEncoder = <span class="hljs-keyword">new</span> BCryptPasswordEncoder();        String finalPassword = <span class="hljs-string">"&#123;bcrypt&#125;"</span>+bCryptPasswordEncoder.encode(<span class="hljs-string">"123456"</span>);        InMemoryUserDetailsManager manager = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();        manager.createUser(User.withUsername(<span class="hljs-string">"user_1"</span>).password(finalPassword).authorities(<span class="hljs-string">"USER"</span>).build());        manager.createUser(User.withUsername(<span class="hljs-string">"user_2"</span>).password(finalPassword).authorities(<span class="hljs-string">"USER"</span>).build());        <span class="hljs-keyword">return</span> manager;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> PasswordEncoderFactories.createDelegatingPasswordEncoder();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 这一步的配置是必不可少的，否则SpringBoot会自动配置一个AuthenticationManager,覆盖掉内存中的用户</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationManager <span class="hljs-title">authenticationManagerBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        AuthenticationManager manager = <span class="hljs-keyword">super</span>.authenticationManagerBean();        <span class="hljs-keyword">return</span> manager;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http            .requestMatchers().anyRequest()            .and()            .authorizeRequests()            .antMatchers(<span class="hljs-string">"/oauth/**"</span>).permitAll();    &#125;&#125;</code></pre></div><p>重点就是配置了一个 UserDetailsService，和 ClientDetailsService 一样，为了方便运行，使用内存中的用户，实际项目中，一般使用的是数据库保存用户，具体的实现类可以使用 JdbcDaoImpl 或者 JdbcUserDetailsManager。</p><h1 id="获取token"><a href="#获取token" class="headerlink" title="获取token"></a>获取token</h1><p>配置完成后，启动项目，使用Postman访问密码模式：</p><div class="hljs"><pre><code class="hljs html">http://localhost:8080/oauth/token?username=user_1&amp;password=123456&amp;grant_type=password&amp;scope=select&amp;client_id=client_2&amp;client_secret=123456</code></pre></div><p>响应如下：<br><img src="https://img-blog.csdnimg.cn/20200608230325325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>接下来试试客户端模式：</p><div class="hljs"><pre><code class="hljs html">http://localhost:8080/oauth/token?grant_type=client_credentials&amp;scope=select&amp;client_id=client_1&amp;client_secret=123456</code></pre></div><p>响应如下：<br><img src="https://img-blog.csdnimg.cn/20200608230514656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在配置中我们已经配置了对order资源的保护，测试如下：<br><img src="https://img-blog.csdnimg.cn/2020060823071875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>而对于未受保护的product资源，访问效果如下：<br><img src="https://img-blog.csdnimg.cn/20200608230845622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>接下来带有accessToken参数来访问受保护的order资源：<br><img src="https://img-blog.csdnimg.cn/20200608231140408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>可以看到成功访问到了资源。<br>下面看下调试的情况：<br>密码模式下：<br><img src="https://img-blog.csdnimg.cn/20200608232347515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>客户端模式下 :<br><img src="https://img-blog.csdnimg.cn/20200608232737620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.理解 OAuth 2.0</title>
    <link href="/2020/06/06/1-%E7%90%86%E8%A7%A3-OAuth-2-0/"/>
    <url>/2020/06/06/1-%E7%90%86%E8%A7%A3-OAuth-2-0/</url>
    
    <content type="html"><![CDATA[<p><a href="http://en.wikipedia.org/wiki/OAuth" target="_blank" rel="noopener">OAuth</a>是一个关于授权（authorization）的<strong>开放网络标准</strong>，在全世界得到广泛应用，目前的版本是2.0版。</p><p>本文对OAuth 2.0的设计思路和运行流程，做一个简明通俗的解释，主要参考材料为<a href="http://www.rfcreader.com/#rfc6749" target="_blank" rel="noopener">RFC 6749</a>。</p><h2 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h2><p>为了理解OAuth的适用场合，让我举一个假设的例子。</p><p>有一个”云冲印”的网站，可以将用户储存在Google的照片，冲印出来。用户为了使用该服务，必须让”云冲印”读取自己储存在Google上的照片。</p><p>问题是只有得到用户的授权，Google才会同意”云冲印”读取这些照片。那么，”云冲印”怎样获得用户的授权呢？</p><p>传统方法是，用户将自己的Google用户名和密码，告诉”云冲印”，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点。</p><div class="hljs"><pre><code class="hljs lsl">（<span class="hljs-number">1</span>）<span class="hljs-string">"云冲印"</span>为了后续的服务，会保存用户的密码，这样很不安全。（<span class="hljs-number">2</span>）Google不得不部署密码登录，而我们知道，单纯的密码登录并不安全。（<span class="hljs-number">3</span>）<span class="hljs-string">"云冲印"</span>拥有了获取用户储存在Google所有资料的权力，用户没法限制<span class="hljs-string">"云冲印"</span>获得授权的范围和有效期。（<span class="hljs-number">4</span>）用户只有修改密码，才能收回赋予<span class="hljs-string">"云冲印"</span>的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效。（<span class="hljs-number">5</span>）只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。</code></pre></div><p>OAuth就是为了解决上面这些问题而诞生的。</p><h2 id="二、名词定义"><a href="#二、名词定义" class="headerlink" title="二、名词定义"></a>二、名词定义</h2><p>在详细讲解OAuth 2.0之前，需要了解几个专用名词。它们对读懂后面的讲解，尤其是几张图，至关重要。</p><div class="hljs"><pre><code class="hljs lsl">（<span class="hljs-number">1</span>）Third-party application：第三方应用程序，本文中又称<span class="hljs-string">"客户端"</span>（client），即上一节例子中的<span class="hljs-string">"云冲印"</span>。（<span class="hljs-number">2</span>）HTTP service：HTTP服务提供商，本文中简称<span class="hljs-string">"服务提供商"</span>，即上一节例子中的Google。（<span class="hljs-number">3</span>）Resource Owner：资源所有者，本文中又称<span class="hljs-string">"用户"</span>（user）。（<span class="hljs-number">4</span>）User Agent：用户代理，本文中就是指浏览器。（<span class="hljs-number">5</span>）Authorization server：认证服务器，即服务提供商专门用来处理认证的服务器。（<span class="hljs-number">6</span>）Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</code></pre></div><p>知道了上面这些名词，就不难理解，OAuth的作用就是让”客户端”安全可控地获取”用户”的授权，与”服务商提供商”进行互动。</p><h2 id="三、OAuth的思路"><a href="#三、OAuth的思路" class="headerlink" title="三、OAuth的思路"></a>三、OAuth的思路</h2><p>OAuth在”客户端”与”服务提供商”之间，设置了一个<code>授权层（authorization layer）</code>。<strong>“客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。</strong>“客户端”登录授权层所用的<code>令牌（token）</code>，与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。</p><p>“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</p><h2 id="四、运行流程"><a href="#四、运行流程" class="headerlink" title="四、运行流程"></a>四、运行流程</h2><p>OAuth 2.0的运行流程如下图，摘自RFC 6749。</p><p><img src="https://img-blog.csdnimg.cn/20200606220240314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs armasm">（A）用户打开客户端以后，客户端要求用户给予授权。（<span class="hljs-keyword">B）用户同意给予客户端授权。</span><span class="hljs-keyword"></span><span class="hljs-keyword">（C）客户端使用上一步获得的授权，向认证服务器申请令牌。</span><span class="hljs-keyword"></span><span class="hljs-keyword">（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</span><span class="hljs-keyword"></span><span class="hljs-keyword">（E）客户端使用令牌，向资源服务器申请获取资源。</span><span class="hljs-keyword"></span><span class="hljs-keyword">（F）资源服务器确认令牌无误，同意向客户端开放资源。</span></code></pre></div><p>不难看出来，上面六个步骤之中，B是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。</p><p>下面一一讲解客户端获取授权的四种模式。</p><h2 id="五、客户端的授权模式"><a href="#五、客户端的授权模式" class="headerlink" title="五、客户端的授权模式"></a>五、客户端的授权模式</h2><p>客户端必须得到用户的<code>授权（authorization grant）</code>，才能获得<code>令牌（access token）</code>。OAuth 2.0定义了四种授权方式。</p><ul><li><code>授权码模式</code>（authorization code）</li><li><code>简化模式</code>（implicit）</li><li><code>密码模式</code>（resource owner password credentials）</li><li><code>客户端模式</code>（client credentials）</li></ul><h2 id="六、授权码模式"><a href="#六、授权码模式" class="headerlink" title="六、授权码模式"></a>六、授权码模式</h2><p>授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。</p><p><img src="https://img-blog.csdnimg.cn/20200606220355162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>它的步骤如下：</p><div class="hljs"><pre><code class="hljs livecodeserver">（A）用户访问客户端，后者将前者导向认证服务器。（B）用户选择是否给予客户端授权。（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的<span class="hljs-string">"重定向URI"</span>（redirection URI），同时附上一个授权码。（D）客户端收到授权码，附上早先的<span class="hljs-string">"重定向URI"</span>，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access <span class="hljs-keyword">token</span>）和更新令牌（refresh <span class="hljs-keyword">token</span>）。</code></pre></div><p>下面是上面这些步骤所需要的参数。</p><p>A步骤中，客户端申请认证的URI，包含以下参数：</p><ul><li><code>response_type</code>：<strong>表示授权类型</strong>，必选项，此处的值固定为”<code>code</code>“</li><li><code>client_id</code>：<strong>表示客户端的ID</strong>，必选项</li><li><code>redirect_uri</code>：<strong>表示重定向URI</strong>，可选项</li><li><code>scope</code>：<strong>表示申请的权限范围</strong>，可选项</li><li><code>state</code>：<strong>表示客户端的当前状态</strong>，可以指定任意值，认证服务器会原封不动地返回这个值。</li></ul><p>下面是一个例子。</p><div class="hljs"><pre><code class="hljs html">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1Host: server.example.com</code></pre></div><p>C步骤中，服务器回应客户端的URI，包含以下参数：</p><ul><li><code>code</code>：<strong>表示授权码</strong>，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。<strong>该码与客户端ID和重定向URI，是一一对应关系</strong>。</li><li><code>state</code>：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li></ul><p>下面是一个例子。</p><div class="hljs"><pre><code class="hljs html">HTTP/1.1 302 FoundLocation: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA&amp;state=xyz</code></pre></div><p>D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：</p><ul><li><code>grant_type</code>：<strong>表示使用的授权模式</strong>，必选项，此处的值固定为”authorization_code”。</li><li><code>code</code>：<strong>表示上一步获得的授权码</strong>，必选项。</li><li><code>redirect_uri</code>：<strong>表示重定向URI</strong>，必选项，且必须与A步骤中的该参数值保持一致。</li><li><code>client_id</code>：<strong>表示客户端ID</strong>，必选项。</li></ul><p>下面是一个例子。</p><div class="hljs"><pre><code class="hljs html">POST /token HTTP/1.1Host: server.example.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</code></pre></div><p>E步骤中，认证服务器发送的HTTP回复，包含以下参数：</p><ul><li><code>access_token</code>：<strong>表示访问令牌</strong>，必选项。</li><li><code>token_type</code>：<strong>表示令牌类型</strong>，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li><li><code>expires_in</code>：<strong>表示过期时间</strong>，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li><code>refresh_token</code>：<strong>表示更新令牌</strong>，用来获取下一次的访问令牌，可选项。</li><li><code>scope</code>：<strong>表示权限范围</strong>，如果与客户端申请的范围一致，此项可省略。</li></ul><p>下面是一个例子。</p><div class="hljs"><pre><code class="hljs html">HTTP/1.1 200 OKContent-Type: application/json;charset=UTF-8Cache-Control: no-storePragma: no-cache&#123;  "access_token":"2YotnFZFEjr1zCsicMWpAA",  "token_type":"example",  "expires_in":3600,  "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",  "example_parameter":"example_value"&#125;</code></pre></div><p>从上面代码可以看到，相关参数使用<code>JSON</code>格式发送（Content-Type: application/json）。此外，HTTP头信息中明确指定不得缓存。</p><h2 id="七、简化模式"><a href="#七、简化模式" class="headerlink" title="七、简化模式"></a>七、简化模式</h2><p>简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。</p><p><img src="https://img-blog.csdnimg.cn/20200606220559505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>它的步骤如下：</p><div class="hljs"><pre><code class="hljs mathematica">（A）客户端将用户导向认证服务器。（B）用户决定是否给于客户端授权。（C）假设用户给予授权，认证服务器将用户导向客户端指定的<span class="hljs-string">"重定向URI"</span>，并在URI的<span class="hljs-keyword">Hash</span>部分包含了访问令牌。（D）浏览器向资源服务器发出请求，其中不包括上一步收到的<span class="hljs-keyword">Hash</span>值。（E）资源服务器返回一个网页，其中包含的代码可以获取<span class="hljs-keyword">Hash</span>值中的令牌。（F）浏览器执行上一步获得的脚本，提取出令牌。（G）浏览器将令牌发给客户端。</code></pre></div><p>下面是上面这些步骤所需要的参数。</p><p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p><ul><li><code>response_type</code>：<strong>表示授权类型</strong>，此处的值固定为”<code>token</code>“，必选项。</li><li><code>client_id</code>：<strong>表示客户端的ID</strong>，必选项。</li><li><code>redirect_uri</code>：<strong>表示重定向的URI</strong>，可选项。</li><li><code>scope</code>：<strong>表示权限范围</strong>，可选项。</li><li><code>state</code>：<strong>表示客户端的当前状态</strong>，可以指定任意值，认证服务器会原封不动地返回这个值。</li></ul><p>下面是一个例子。</p><div class="hljs"><pre><code class="hljs html">GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz    &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1Host: server.example.com</code></pre></div><p>C步骤中，认证服务器回应客户端的URI，包含以下参数：</p><ul><li><code>access_token</code>：<strong>表示访问令牌</strong>，必选项。</li><li><code>token_type</code>：<strong>表示令牌类型</strong>，该值大小写不敏感，必选项。</li><li><code>expires_in</code>：<strong>表示过期时间</strong>，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li><code>scope</code>：<strong>表示权限范围</strong>，如果与客户端申请的范围一致，此项可省略。</li><li><code>state</code>：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li></ul><p>下面是一个例子。</p><div class="hljs"><pre><code class="hljs html"> HTTP/1.1 302 FoundLocation: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA          &amp;state=xyz&amp;token_type=example&amp;expires_in=3600</code></pre></div><p>在上面的例子中，认证服务器用HTTP头信息的Location栏，指定浏览器重定向的网址。注意，在这个网址的Hash部分包含了令牌。</p><p>根据上面的D步骤，下一步浏览器会访问Location指定的网址，但是Hash部分不会发送。接下来的E步骤，服务提供商的资源服务器发送过来的代码，会提取出Hash中的令牌。</p><h2 id="八、密码模式"><a href="#八、密码模式" class="headerlink" title="八、密码模式"></a>八、密码模式</h2><p>密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。</p><p>在这种模式中，<strong>用户必须把自己的密码给客户端，但是客户端不得储存密码</strong>。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p><p><img src="https://img-blog.csdnimg.cn/20200606220702610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>它的步骤如下：</p><div class="hljs"><pre><code class="hljs armasm">（A）用户向客户端提供用户名和密码。（<span class="hljs-keyword">B）客户端将用户名和密码发给认证服务器，向后者请求令牌。</span><span class="hljs-keyword"></span><span class="hljs-keyword">（C）认证服务器确认无误后，向客户端提供访问令牌。</span></code></pre></div><p>B步骤中，客户端发出的HTTP请求，包含以下参数：</p><ul><li><code>grant_type</code>：<strong>表示授权类型</strong>，此处的值固定为”<code>password</code>“，必选项。</li><li><code>username</code>：<strong>表示用户名</strong>，必选项。</li><li><code>password</code>：<strong>表示用户的密码</strong>，必选项。</li><li><code>scope</code>：<strong>表示权限范围</strong>，可选项。</li></ul><p>下面是一个例子。</p><div class="hljs"><pre><code class="hljs html">POST /token HTTP/1.1Host: server.example.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=password&amp;username=johndoe&amp;password=A3ddj3w</code></pre></div><p>C步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p><div class="hljs"><pre><code class="hljs html">HTTP/1.1 200 OKContent-Type: application/json;charset=UTF-8Cache-Control: no-storePragma: no-cache&#123;  "access_token":"2YotnFZFEjr1zCsicMWpAA",  "token_type":"example",  "expires_in":3600,  "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",  "example_parameter":"example_value"&#125;</code></pre></div><p>上面代码中，各个参数的含义参见《授权码模式》一节。整个过程中，客户端不得保存用户的密码。</p><h2 id="九、客户端模式"><a href="#九、客户端模式" class="headerlink" title="九、客户端模式"></a>九、客户端模式</h2><p>客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。</p><p><img src="https://img-blog.csdnimg.cn/20200606220806373.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>它的步骤如下：</p><div class="hljs"><pre><code class="hljs dns">（<span class="hljs-keyword">A</span>）客户端向认证服务器进行身份认证，并要求一个访问令牌。（B）认证服务器确认无误后，向客户端提供访问令牌。</code></pre></div><p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p><ul><li><code>granttype</code>：<strong>表示授权类型</strong>，此处的值固定为”<code>clientcredentials</code>“，必选项。</li><li><code>scope</code>：<strong>表示权限范围</strong>，可选项。</li></ul><div class="hljs"><pre><code class="hljs html">POST /token HTTP/1.1Host: server.example.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=client_credentials</code></pre></div><p>认证服务器必须以某种方式，验证客户端身份。</p><p>B步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p><div class="hljs"><pre><code class="hljs html"> HTTP/1.1 200 OKContent-Type: application/json;charset=UTF-8Cache-Control: no-storePragma: no-cache&#123;  "access_token":"2YotnFZFEjr1zCsicMWpAA",  "token_type":"example",  "expires_in":3600,  "example_parameter":"example_value"&#125;</code></pre></div><p>上面代码中，各个参数的含义参见《授权码模式》一节。</p><h2 id="十、更新令牌"><a href="#十、更新令牌" class="headerlink" title="十、更新令牌"></a>十、更新令牌</h2><p>如果用户访问的时候，客户端的”访问令牌”已经过期，则需要使用”更新令牌”申请一个新的访问令牌。</p><p>客户端发出更新令牌的HTTP请求，包含以下参数：</p><ul><li><code>granttype</code>：表示使用的授权模式，此处的值固定为”refreshtoken”，必选项。</li><li><code>refresh_token</code>：表示早前收到的更新令牌，必选项。</li><li><code>scope</code>：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。</li></ul><p>下面是一个例子。</p><div class="hljs"><pre><code class="hljs html">POST /token HTTP/1.1Host: server.example.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11. Redis--一致性Hash算法</title>
    <link href="/2020/06/06/11-Redis-%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95/"/>
    <url>/2020/06/06/11-Redis-%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Redis集群的使用"><a href="#一、Redis集群的使用" class="headerlink" title="一、Redis集群的使用"></a>一、Redis集群的使用</h1><p>我们在使用Redis的时候，为了保证Redis的高可用，提高Redis的读写性能，最简单的方式我们会做主从复制，组成Master-Master或者Master-Slave的形式，或者搭建Redis集群，进行数据的读写分离，类似于数据库的主从复制和读写分离。如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20200606181116231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>同样类似于数据库，当单表数据大于500W的时候需要对其进行分库分表，当数据量很大的时候（标准可能不一样，要看Redis服务器容量）我们同样可以对Redis进行类似的操作，就是分库分表。 </p><p>假设，我们有一个社交网站，需要使用Redis存储图片资源，存储的格式为键值对，key值为图片名称，value为该图片所在文件服务器的路径，我们需要根据文件名查找该文件所在文件服务器上的路径，数据量大概有2000W左右，按照我们约定的规则进行分库，规则就是随机分配，我们可以部署8台缓存服务器，每台服务器大概含有500W条数据，并且进行主从复制，示意图如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606181138961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>由于规则是随机的，所以我们的一条数据都有可能存储在任何一组Redis中，例如上图我们用户查找一张名称为”a.png”的图片，由于规则是随机的，我们不确定具体是在哪一个Redis服务器上，因此我们需要进行1、2、3、4，4次查询才能够查询到（也就是遍历了所有的Redis服务器），这显然不是我们想要的结果，有了解过的小伙伴可能会想到，随机的规则不行，可以使用类似于数据库中的分库分表规则：按照Hash值、取模、按照类别、按照某一个字段值等等常见的规则就可以出来了！好，按照我们的主题，我们就使用Hash的方式。</p><h1 id="二、为Redis集群使用Hash"><a href="#二、为Redis集群使用Hash" class="headerlink" title="二、为Redis集群使用Hash"></a>二、为Redis集群使用Hash</h1><p><img src="https://img-blog.csdnimg.cn/20200606181214521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>上图中，假设我们查找的是”a.png”，由于有4台服务器（排除从库），因此公式为hash(a.png) % 4 = 2 ，可知定位到了第2号服务器，这样的话就不会遍历所有的服务器，大大提升了性能！</p><h1 id="三、使用Hash的问题"><a href="#三、使用Hash的问题" class="headerlink" title="三、使用Hash的问题"></a>三、使用Hash的问题</h1><p>上述的方式虽然提升了性能，我们不再需要对整个Redis服务器进行遍历！但是，使用上述Hash算法进行缓存时，会出现一些缺陷，主要体现在服务器数量变动的时候，所有缓存的位置都要发生改变！</p><p>试想一下，如果4台缓存服务器已经不能满足我们的缓存需求，那么我们应该怎么做呢？很简单，多增加几台缓存服务器不就行了！假设：我们增加了一台缓存服务器，那么缓存服务器的数量就由4台变成了5台。那么原本hash(a.png) % 4 = 2 的公式就变成了hash(a.png) % 5 = ？ ， 可想而知这个结果肯定不是2的，这种情况带来的结果就是当服务器数量变动时，所有缓存的位置都要发生改变！换句话说，<strong>当服务器数量发生改变时，所有缓存在一定时间内是失效的</strong>，当应用无法从缓存中获取数据时，则会向后端数据库请求数据（还记得上一篇的《缓存雪崩》吗？）！</p><p>同样的，假设4台缓存中突然有一台缓存服务器出现了故障，无法进行缓存，那么我们则需要将故障机器移除，但是如果移除了一台缓存服务器，那么缓存服务器数量从4台变为3台，也是会出现上述的问题！</p><p>所以，我们应该想办法不让这种情况发生，但是由于上述Hash算法本身的缘故，使用取模法进行缓存时，这种情况是无法避免的，为了解决这些问题，Hash一致性算法（一致性Hash算法）诞生了！</p><h1 id="四、一致性Hash算法的神秘面纱"><a href="#四、一致性Hash算法的神秘面纱" class="headerlink" title="四、一致性Hash算法的神秘面纱"></a>四、一致性Hash算法的神秘面纱</h1><p>一致性Hash算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而<strong>一致性Hash算法是对2的32次方取模</strong>，什么意思呢？简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2的32次方-1（即哈希值是一个32位无符号整形），整个哈希环如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606181226458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2的32次方-1，也就是说0点左侧的第一个点代表2的32次方-1， 0和2的32次方在零点中方向重合，我们把这个由2的32次方个点组成的圆环称为Hash环。</p><p>下一步将各个服务器使用Hash进行一个哈希，具体可以选择<strong>服务器的IP或主机名</strong>作为<strong>关键字</strong>进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606181241661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！</p><p>例如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606181254463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>根据一致性Hash算法，数据A会被定位到Node A上，B被定位到Node B上，C被定位到Node C上，D被定位到Node D上。</p><h1 id="五、一致性Hash算法的容错性和可扩展性"><a href="#五、一致性Hash算法的容错性和可扩展性" class="headerlink" title="五、一致性Hash算法的容错性和可扩展性"></a>五、一致性Hash算法的容错性和可扩展性</h1><p>现假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。<strong>一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响</strong>，如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20200606181306101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>下面考虑另外一种情况，如果在系统中增加一台服务器Node X，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200606181318529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X ！一般的，在一致性Hash算法中，<strong>如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据</strong>，其它数据也不会受到影响。</p><p>综上所述，一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</p><h1 id="六、Hash环的数据倾斜问题"><a href="#六、Hash环的数据倾斜问题" class="headerlink" title="六、Hash环的数据倾斜问题"></a>六、Hash环的数据倾斜问题</h1><p>一致性Hash算法在服务节点太少时，容易因为节点分布不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器，其环分布如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606181330666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性Hash算法引入了<strong>虚拟节点机制</strong>，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器IP或主机名的后面增加编号来实现。</p><p>例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：</p><p><img src="https://img-blog.csdnimg.cn/20200606181342261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p><h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><p>上文中，我们一步步分析了什么是一致性Hash算法，主要是考虑到分布式系统每个节点都有可能失效，并且新的节点很可能动态的增加进来的情况，如何保证当系统的节点数目发生变化的时候，我们的系统仍然能够对外提供良好的服务，这是值得考虑的！</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0. Redis--引导</title>
    <link href="/2020/06/06/0-Redis-%E5%BC%95%E5%AF%BC/"/>
    <url>/2020/06/06/0-Redis-%E5%BC%95%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Redis简介"><a href="#一、Redis简介" class="headerlink" title="一、Redis简介"></a>一、Redis简介</h1><p>Redis是一个开源的，基于<strong>内存</strong>的数据结构存储系统，它可以用作：<strong>数据库</strong>、<strong>缓存</strong>和<strong>消息中间件</strong>。</p><p>它支持多种类型的数据结构，如字符串（String），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）与范围查询，Bitmaps，Hyperloglogs 和地理空间（Geospatial）索引半径查询。其中常见的数据结构类型有：<strong>String</strong>、<strong>List</strong>、<strong>Set</strong>、<strong>Hash</strong>、<strong>ZSet</strong>这5种。</p><p>Redis 内置了<strong>复制</strong>（Replication），<strong>LUA脚本</strong>（Lua scripting）， <strong>LRU驱动事件</strong>（LRU eviction），<strong>事务</strong>（Transactions） 和不同级别的磁盘<strong>持久化</strong>（Persistence），并通过 Redis<strong>哨兵</strong>（Sentinel）和<strong>自动分区</strong>（Cluster）提供高可用性（High Availability）。</p><p>Redis也提供了<strong>持久化</strong>的选项，这些选项可以让用户将自己的数据保存到磁盘。根据实际情况，可以每隔一定时间将数据集以快照的形式导出到磁盘（RDB），或者追加到命令日志中（AOF只追加文件），它会在执行写命令时，将被执行的写命令复制到硬盘里面。您也可以关闭持久化功能，将Redis作为一个高效的网络的缓存数据功能使用。</p><p>Redis不使用表，它的数据库不会预定义或者强制去要求用户对Redis存储的不同数据进行关联。</p><p>数据库的工作模式按存储方式可分为：硬盘数据库和内存数据库。Redis 将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度极快。</p><h1 id="二、Redis和其他缓存数据库的区别"><a href="#二、Redis和其他缓存数据库的区别" class="headerlink" title="二、Redis和其他缓存数据库的区别"></a>二、Redis和其他缓存数据库的区别</h1><h2 id="1-1-Redis-与其他-key-value-缓存产品相比有以下三个特点："><a href="#1-1-Redis-与其他-key-value-缓存产品相比有以下三个特点：" class="headerlink" title="1.1 Redis 与其他 key - value 缓存产品相比有以下三个特点："></a>1.1 Redis 与其他 key - value 缓存产品相比有以下三个特点：</h2><p>（1）Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</p><p>（2）Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</p><p>（3）Redis支持数据的备份，即master-slave模式的数据备份。</p><h2 id="1-2-Redis和Memcached的区别"><a href="#1-2-Redis和Memcached的区别" class="headerlink" title="1.2 Redis和Memcached的区别"></a>1.2 Redis和Memcached的区别</h2><p>Redis常被拿来和高性能键值缓存服务器Memcached进行对比：这两者都可以用来存储键值对，彼此的性能也相差无几，但是Redis相对支持更多的数据类型，除了支持键值对之外，还支持list，set，zset，hash等数据结构的存储，而<strong>Memcached只能存储普通的字符串键。</strong></p><p>Memcached用户只能通过<strong>APPEND</strong>的方式将数据添加到已有的字符串的末尾，并将这个字符串当做列表来使用。但是在删除这些元素的时候，Memcached采用的是通过黑名单的方式来隐藏列表里的元素，从而避免了对元素的读取、更新、删除等操作。相反的Redis的List和Set允许用户直接添加和删除元素。</p><h2 id="1-3-Redis和其他数据库的区别"><a href="#1-3-Redis和其他数据库的区别" class="headerlink" title="1.3 Redis和其他数据库的区别"></a>1.3 Redis和其他数据库的区别</h2><p><img src="https://img-blog.csdnimg.cn/20200606171008448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="三、Redis为什么这么快"><a href="#三、Redis为什么这么快" class="headerlink" title="三、Redis为什么这么快"></a>三、Redis为什么这么快</h1><p>1、<strong>完全基于内存</strong>，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p><p>2、<strong>数据结构</strong>简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p><p>3、采用<strong>单线程，避免了不必要的上下文切换和竞争条件</strong>，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p><p>4、使用<strong>多路I/O复用模型</strong>，非阻塞IO；</p><p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p><p>以上几点都比较好理解，下边我们针对多路 I/O 复用模型进行简单的探讨：</p><p>多路I/O复用模型是利用 select、poll、epoll 可以同时监测多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p><p><strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong>采用<strong>多路 I/O 复用技术可以让单个线程高效的处理多个连接请求</strong>（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p><h1 id="四、为什么Redis是单线程的"><a href="#四、为什么Redis是单线程的" class="headerlink" title="四、为什么Redis是单线程的"></a>四、为什么Redis是单线程的</h1><p>我们首先要明白，上边的种种分析，都是为了营造一个Redis很快的氛围！官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，<strong>Redis的瓶颈最有可能是机器内存的大小或者网络带宽</strong>。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。</p><p>但是，我们使用单线程的方式是无法发挥多核CPU 性能，不过我们可以通过在单机开多个Redis 实例来完善！</p><p><strong>警告</strong>：这里我们一直在强调的单线程，只是<strong>在处理我们的网络请求的时候只有一个线程来处理</strong>，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！</p><h1 id="五、扩展"><a href="#五、扩展" class="headerlink" title="五、扩展"></a>五、扩展</h1><p>以下也是你应该知道的几种模型：</p><p>1、单进程多线程模型：MySQL、Memcached、Oracle（Windows版本）；</p><p>2、多进程模型：Oracle（Linux版本）；</p><p>3、Nginx有两类进程，一类称为Master进程(相当于管理进程)，另一类称为Worker进程（实际工作进程）。启动方式有两种：</p><p>（1）单进程启动：此时系统中仅有一个进程，该进程既充当Master进程的角色，也充当Worker进程的角色。</p><p>（2）多进程启动：此时系统有且仅有一个Master进程，至少有一个Worker进程工作。</p><p>（3）Master进程主要进行一些全局性的初始化工作和管理Worker的工作；事件处理是在Worker中进行的。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10. Redis--如何优化缓存架构</title>
    <link href="/2020/06/06/10-Redis-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84/"/>
    <url>/2020/06/06/10-Redis-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="一、为什么要用缓存集群"><a href="#一、为什么要用缓存集群" class="headerlink" title="一、为什么要用缓存集群"></a>一、为什么要用缓存集群</h1><p>啥叫热 Key 和大 Value 呢?简单来说，热 Key，就是你的缓存集群中的某个 Key 瞬间被数万甚至十万的并发请求打爆。</p><p>大 Value，就是你的某个 Key 对应的 Value 可能有 GB 级的大小，导致查询 Value 的时候出现网络相关的故障问题。</p><p>先来看看下面的一幅图：</p><p><img src="https://img-blog.csdnimg.cn/20200606162958479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>简单来说，假设你手头有个系统，它本身是集群部署的，然后后面有一套缓存集群，这个集群不管你用 Redis Cluster，还是Memcached，或者是公司自研缓存集群，都可以。</p><p>那么，这套系统用缓存集群干什么呢？很简单，在缓存里放一些平时不怎么变动的数据，然后用户在查询大量的平时不怎么变动的数据的时候，不就可以直接从缓存里走了吗?</p><p>缓存集群的并发能力是很强的，而且读缓存的性能是很高的。举个例子，假设你每秒有 2 万请求，但是其中 90% 都是读请求，那么每秒 1.8 万请求都是在读一些不太变化的数据，而不是写数据。</p><p>那此时你把数据都放在数据库里，然后每秒发送 2 万请求到数据库上读写数据，你觉得合适吗?</p><p>当然不太合适了，如果你要用数据库承载每秒 2 万请求的话，那么不好意思，你很可能就得搞分库分表 + 读写分离。</p><p>比如你得分 3 个主库，承载每秒 2000 的写入请求，然后每个主库挂 3 个从库，一共 9 个从库承载每秒 1.8 万的读请求。</p><p>这样的话，你可能就需要一共是 12 台高配置的数据库服务器，这是很耗费钱的，成本非常高，而且很不合适。</p><p>所以，此时你完全就可以<strong>把平时不太变化的数据放在缓存集群里</strong>，缓存集群可以采用 2 主 2 从，<strong>主节点用来写入缓存</strong>，<strong>从节点用来读缓存。</strong></p><p>以缓存集群的性能，2 个从节点完全可以用来承载每秒 1.8 万的大量读了，然后 3 个数据库主库就是承载每秒 2000 的写请求和少量其他读请求就可以了。</p><p>大家看看下面的图，你耗费的机器瞬间变成了 4 台缓存机器 + 3 台数据库机器 = 7 台机器，是不是比之前的 12 台机器减少了很大的资源开销?</p><p>没错，缓存其实在系统架构里是非常重要的组成部分。很多时候，对于那些很少变化但是大量高并发读的数据，通过<strong>缓存集群</strong>来抗高并发读，是非常合适的。</p><p><img src="https://img-blog.csdnimg.cn/20200606163024316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>这里所有的机器数量、并发请求量都是一个示例，大家主要是体会一下这个意思就好，其目的主要是给一些不太熟悉缓存相关技术的同学一点背景性的阐述，让这些同学能够理解在系统里用缓存集群承载读请求是什么意思。</p><h1 id="二、20-万用户同时访问一个热点缓存的问题"><a href="#二、20-万用户同时访问一个热点缓存的问题" class="headerlink" title="二、20 万用户同时访问一个热点缓存的问题"></a>二、20 万用户同时访问一个热点缓存的问题</h1><p>好了，背景是已经给大家解释清楚了，那么现在就可以给大家说说今天重点要讨论的问题：热点缓存。</p><p>我们来做一个假设，你现在有 10 个缓存节点来扛大量的读请求。正常情况下，读请求应该是均匀的落在 10 个缓存节点上的，这 10 个缓存节点，每秒承载 1 万请求是差不多的。然后我们再做一个假设，你一个节点承载 2 万请求是极限，所以一般你就限制一个节点正常承载 1 万请求就 OK 了，稍微留一点 Buffer 出来。</p><p>好，所谓的热点缓存问题是什么意思呢？很简单，就是突然因为莫名的原因，出现大量的用户访问同一条缓存数据。</p><p>举个例子，某个明星突然宣布跟某某结婚，这个时候是不是会引发可能短时间内每秒都是数十万的用户去查看这个明星跟某某结婚的那条新闻?</p><p>那么假设那条新闻就是一个缓存，然后对应就是一个缓存 Key，就存在一台缓存机器上，此时瞬时假设有 20 万请求奔向那一台机器上的一个 Key。</p><p>此时会如何?我们看看下面的图，来体会一下这种绝望的感受：</p><p><img src="https://img-blog.csdnimg.cn/20200606163209327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>这个时候很明显了，我们刚才假设的是一个缓存 Slave 节点最多每秒就是 2 万的请求，当然实际缓存单机承载 5 万~10 万读请求也是可能的，我们这里就是一个假设。</p><p>结果此时，每秒突然奔过来 20 万请求到这台机器上，会怎么样？很简单，上面图里那台被 20 万请求指向的缓存机器会过度操劳而宕机的。</p><p>那么如果缓存集群开始出现机器的宕机，此时会如何？接着，读请求发现读不到数据，会从数据库里提取原始数据，然后放入剩余的其他缓存机器里去。</p><p>但是接踵而来的每秒 20 万请求，会再次压垮其他的缓存机器。以此类推，最终导致缓存集群全盘崩溃，引发系统整体宕机。</p><p>咱们看看下面的图，再感受一下这个恐怖的现场：</p><p><img src="https://img-blog.csdnimg.cn/20200606163226832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="三、基于流式计算技术的缓存热点自动发现"><a href="#三、基于流式计算技术的缓存热点自动发现" class="headerlink" title="三、基于流式计算技术的缓存热点自动发现"></a>三、基于流式计算技术的缓存热点自动发现</h1><p>其实这里关键的一点，就是对于这种热点缓存，你的系统需要能够在热点缓存突然发生的时候，直接发现它，然后瞬间立马实现毫秒级的<strong>自动负载均衡</strong>。</p><p>那么我们就先来说说，你如何自动发现热点缓存问题?首先你要知道，一般出现缓存热点的时候，你的每秒并发肯定是很高的，可能每秒都几十万甚至上百万的请求量过来，这都是有可能的。</p><p>所以，此时完全可以基于大数据领域的<strong>流式计算技术</strong>来进行实时数据访问次数的统计，比如 Storm、Spark Streaming、Flink，这些技术都是可以的。</p><p>然后一旦在实时数据访问次数统计的过程中，比如发现一秒之内，某条数据突然访问次数超过了 1000，就直接立马把这条数据判定为热点数据，可以将这个发现出来的热点数据写入Zookeeper 中。</p><p>当然，你的系统如何判定热点数据，可以根据自己的业务还有经验来就可以了。</p><p>大家看看下面这张图，看看整个流程是如何进行的：</p><p><img src="https://img-blog.csdnimg.cn/20200606163237932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>当然肯定有人会问，那你的流式计算系统在进行数据访问次数统计的时候，会不会也存在单台机器被请求每秒几十万次的问题呢?</p><p>答案是否，因为流式计算技术，尤其是 Storm 这种系统，它可以做到同一条数据的请求过来，先分散在很多机器里进行本地计算，最后再汇总局部计算结果到一台机器进行全局汇总。</p><p>所以几十万请求可以先分散在比如 100 台机器上，每台机器统计了这条数据的几千次请求。</p><p>然后 100 条局部计算好的结果汇总到一台机器做全局计算即可，所以基于流式计算技术来进行统计是不会有热点问题的。</p><p><img src="https://img-blog.csdnimg.cn/2020060616325139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="四、热点缓存自动加载为-JVM-本地缓存"><a href="#四、热点缓存自动加载为-JVM-本地缓存" class="headerlink" title="四、热点缓存自动加载为 JVM 本地缓存"></a>四、热点缓存自动加载为 JVM 本地缓存</h1><p>我们自己的系统可以对 Zookeeper 指定的热点缓存对应的 Znode 进行监听，如果有变化它立马就可以感知到了。</p><p>此时系统层就可以立马<strong>把相关的缓存数据从数据库加载出来，然后直接放在自己系统内部的本地缓存</strong>里即可。</p><p>这个本地缓存，你可以用 Ehcache、Hashmap，一切都看自己的业务需求，主要说的就是将缓存集群里的集中式缓存，直接变成每个系统自己本地实现缓存即可，每个系统自己本地是无法缓存过多数据的。</p><p>因为一般这种普通系统单实例部署机器可能就一个 4 核 8G 的机器，留给本地缓存的空间是很少的，所以用来放这种热点数据的本地缓存是最合适的，刚刚好。</p><p>假设你的系统层集群部署了 100 台机器，那么好了，此时你 100 台机器瞬间在本地都会有一份热点缓存的副本。</p><p>然后接下来对热点缓存的读操作，直接系统本地缓存读出来就给返回了，不用再走缓存集群了。</p><p>这样的话，也不可能允许每秒 20 万的读请求到达缓存机器的一台机器上读一个热点缓存了，而是变成 100 台机器每台机器承载数千请求，那么那数千请求就直接从机器本地缓存返回数据了，这是没有问题的。</p><p>我们再来画一幅图，一起来看看这个过程：</p><p><img src="https://img-blog.csdnimg.cn/20200606163305719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="五、限流熔断保护"><a href="#五、限流熔断保护" class="headerlink" title="五、限流熔断保护"></a>五、限流熔断保护</h1><p>除此之外，在每个系统内部，还应该专门加一个对热点数据访问的限流熔断保护措施。</p><p>每个系统实例内部，都可以加一个<strong>熔断保护机制</strong>，假设缓存集群最多每秒承载4万读请求，那么你一共有 100 个系统实例。</p><p>你自己就该限制好，每个系统实例每秒最多请求缓存集群读操作不超过 400 次，一超过就可以熔断掉，不让请求缓存集群，直接返回一个空白信息，然后用户稍后会自行再次重新刷新页面之类的。</p><p>通过系统层自己直接加限流熔断保护措施，可以很好的保护后面的缓存集群、数据库集群之类的不要被打死，我们来看看下面的图：</p><p><img src="https://img-blog.csdnimg.cn/20200606163320488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9. Redis--Redis缓存问题</title>
    <link href="/2020/06/06/9-Redis-Redis%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/"/>
    <url>/2020/06/06/9-Redis-Redis%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>Redis 所存在的缓存问题也是大部分缓存所存在的问题，因此本文不单单特指于 Redis。这些问题包括<strong>缓存穿透、缓存雪崩、缓存击穿、缓存预热</strong>等等，相关文章网络上已经数不胜数了，说实话本文和它们没啥不同之处，只是为了记录，所以对于了解过的人基本就是废话了，谨慎阅读哦。</p><h2 id="二、缓存穿透"><a href="#二、缓存穿透" class="headerlink" title="二、缓存穿透"></a>二、缓存穿透</h2><p><strong>问题描述：</strong></p><p><code>缓存穿透</code>是指<strong>查询一个一定不存在的数据</strong>，这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p><p><strong>解决方案：</strong></p><p>有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用<code>布隆过滤器</code>，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</p><blockquote><p>布隆过滤器：一种比较巧妙的概率型数据结构，特点是高效的插入和查询，可以用来告诉你“某样东西一定不存在或者可能存在”。</p></blockquote><p>另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。</p><p><img src="https://img-blog.csdnimg.cn/20200606160601704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="三、缓存雪崩"><a href="#三、缓存雪崩" class="headerlink" title="三、缓存雪崩"></a>三、缓存雪崩</h2><p><strong>问题描述：</strong></p><p><code>缓存雪崩</code>是指在我们<strong>设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效</strong>，请求全部转发到DB，DB瞬时压力过重雪崩。</p><p>缓存正常从Redis中获取，示意图如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606164835761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>缓存失效瞬间示意图如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606164842618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>解决方案：</strong></p><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者<strong>考虑用加锁或者队列的方式保证缓存的单线程（进程）写</strong>，从而避免失效时大量的并发请求落到底层存储系统上。</p><p>还可以将缓存失效时间分散开，比如我们可以<strong>在原有的失效时间基础上增加一个随机值</strong>，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><h2 id="四、缓存击穿"><a href="#四、缓存击穿" class="headerlink" title="四、缓存击穿"></a>四、缓存击穿</h2><p><strong>问题描述：</strong></p><p>对于一些设置了过期时间的 key，如果这些 key 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个<strong>和缓存雪崩的区别在于这里针对某一 key 缓存，而缓存雪崩则是很多 key</strong>。</p><p>缓存在某个时间点过期的时候，恰好在这个时间点对这个 key 有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮。</p><p><strong>解决方案：</strong></p><p>业界比较常用的做法，是使用<strong>互斥锁(mutex)</strong>。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去 load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的 <code>SETNX</code> 或者 Memcached 的 ADD）去 set 一个 mutex key，当操作返回成功时，再进行 load db 的操作并回设缓存；否则就重试这个 get 缓存的方法。</p><h2 id="五、缓存预热"><a href="#五、缓存预热" class="headerlink" title="五、缓存预热"></a>五、缓存预热</h2><p><strong>问题描述：</strong></p><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p><p><strong>解决方案：</strong></p><ol><li>直接写个缓存刷新页面，上线时手工操作下；</li><li>数据量不大，可以在项目启动的时候自动进行加载；</li><li>定时刷新缓存；</li></ol><h2 id="六、缓存更新"><a href="#六、缓存更新" class="headerlink" title="六、缓存更新"></a>六、缓存更新</h2><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有三种：</p><p>（1）<strong>定时过期</strong>：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除，该策略可以立即清除过期的数据，对内存很友好，但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p><p>（2）<strong>惰性过期</strong>：当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</p><p>（3）<strong>定期过期</strong>：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key，该策略是前两者的一个折中方案，通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</p><h2 id="七、缓存降级"><a href="#七、缓存降级" class="headerlink" title="七、缓存降级"></a>七、缓存降级</h2><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p><p><strong>降级的最终目的是保证核心服务可用</strong>，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。 </p><p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p><p>（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p><p>（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p><p>（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</p><p>（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8. Redis--Redis的实际应用</title>
    <link href="/2020/06/06/8-Redis-Redis%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
    <url>/2020/06/06/8-Redis-Redis%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>在<a href="https://www.jitwxs.cn/5108d6b6.html" target="_blank" rel="noopener">《Redis初探（7）——Jedis操纵集群》</a>中，我们已经学会了搭建 Redis 集群，以及使用策略模式，在xml文件中灵活切换单机版和集群版。</p><p>本章将演示在宜立方商城项目中使用 Redis，项目地址：<a href="https://github.com/jitwxs/e3mall" target="_blank" rel="noopener">e3mall</a>。</p><h2 id="一、功能需求"><a href="#一、功能需求" class="headerlink" title="一、功能需求"></a>一、功能需求</h2><p>商城首页访问量巨大，因为首页的大轮播图是从数据库查询获取的，<strong>每次访问都要查询一次数据库</strong>，数据库压力巨大，亟需缓存。</p><p><img src="https://img-blog.csdnimg.cn/20200606160145616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="二、功能实现"><a href="#二、功能实现" class="headerlink" title="二、功能实现"></a>二、功能实现</h2><p>实现之前首先思考 Redis 是要加在 Service 层还是 Web 层。理论上来说都可以，但是加在 Web 层的话，其他 Web 去调用 Service 还是得去查数据库，因此我们加在 Service 层。</p><p>其次思考使用什么数据类型，我们使用<strong>哈希类型</strong>，field 为类别的 id，value 为对应查询的查询内容。</p><h3 id="2-1-配置文件-cfg-properties"><a href="#2-1-配置文件-cfg-properties" class="headerlink" title="2.1 配置文件 cfg.properties"></a>2.1 配置文件 cfg.properties</h3><p>首先在配置文件中加入 Redis 相关的信息，最后一项 <code>redis.CONTENT_KEY</code> 为我们首页轮播图缓存的 key 值：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-comment">#Redis单机</span><span class="hljs-attr">redis.standalone.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.standalone.port</span>=<span class="hljs-number">6379</span><span class="hljs-comment">#Redis集群</span><span class="hljs-attr">redis.cluster.01.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.01.port</span>=<span class="hljs-number">7001</span><span class="hljs-attr">redis.cluster.02.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.02.port</span>=<span class="hljs-number">7002</span><span class="hljs-attr">redis.cluster.03.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.03.port</span>=<span class="hljs-number">7003</span><span class="hljs-attr">redis.cluster.04.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.04.port</span>=<span class="hljs-number">7004</span><span class="hljs-attr">redis.cluster.05.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.05.port</span>=<span class="hljs-number">7005</span><span class="hljs-attr">redis.cluster.06.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.06.port</span>=<span class="hljs-number">7006</span><span class="hljs-comment">#Redis key相关</span><span class="hljs-comment">#用于存放tb_content表的缓存（哈希类型）</span><span class="hljs-attr">redis.CONTENT_KEY</span>=CONTENT_KEY</code></pre></div><h3 id="2-2-Spring-中-Redis-配置"><a href="#2-2-Spring-中-Redis-配置" class="headerlink" title="2.2 Spring 中 Redis 配置"></a>2.2 Spring 中 Redis 配置</h3><p>这里的代码在上一节已经说过了，因为我们是开发环境，使用单机版即可。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context</span></span><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 注意：单机和集群同时只能放开一个 --&gt;</span>    <span class="hljs-comment">&lt;!-- 加载配置文件 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:cfg.properties"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 配置Redis单机 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jedisClientPool"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"jit.wxs.common.jedis.JedisClientPool"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"jedisPool"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"jedisPool"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jedisPool"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.JedisPool"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.standalone.host&#125;"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.standalone.port&#125;"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置Redis集群 --&gt;</span>    <span class="hljs-comment">&lt;!--&lt;bean id="jedisClientCluster" class="jit.wxs.common.jedis.JedisClientCluster"&gt;--&gt;</span>        <span class="hljs-comment">&lt;!--&lt;property name="jedisCluster" ref="jedisCluster"/&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--&lt;bean id="jedisCluster" class="redis.clients.jedis.JedisCluster"&gt;--&gt;</span>        <span class="hljs-comment">&lt;!--&lt;constructor-arg&gt;--&gt;</span>            <span class="hljs-comment">&lt;!--&lt;set&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;bean class="redis.clients.jedis.HostAndPort"&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="host" value="$&#123;redis.cluster.01.host&#125;"/&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="port" value="$&#123;redis.cluster.01.port&#125;"/&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;bean class="redis.clients.jedis.HostAndPort"&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="host" value="$&#123;redis.cluster.02.host&#125;"/&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="port" value="$&#123;redis.cluster.02.port&#125;"/&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;bean class="redis.clients.jedis.HostAndPort"&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="host" value="$&#123;redis.cluster.03.host&#125;"/&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="port" value="$&#123;redis.cluster.03.port&#125;"/&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;bean class="redis.clients.jedis.HostAndPort"&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="host" value="$&#123;redis.cluster.04.host&#125;"/&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="port" value="$&#123;redis.cluster.04.port&#125;"/&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;bean class="redis.clients.jedis.HostAndPort"&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="host" value="$&#123;redis.cluster.05.host&#125;"/&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="port" value="$&#123;redis.cluster.05.port&#125;"/&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;bean class="redis.clients.jedis.HostAndPort"&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="host" value="$&#123;redis.cluster.06.host&#125;"/&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;constructor-arg name="port" value="$&#123;redis.cluster.06.port&#125;"/&gt;--&gt;</span>                <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span>            <span class="hljs-comment">&lt;!--&lt;/set&gt;--&gt;</span>        <span class="hljs-comment">&lt;!--&lt;/constructor-arg&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><h3 id="2-3-Service-层代码"><a href="#2-3-Service-层代码" class="headerlink" title="2.3 Service 层代码"></a>2.3 Service 层代码</h3><p>首先我们注入了 <code>JedisClient</code>，然后从配置文件取到了 key 的名字 <code>CONTENT_KEY</code>。</p><p>在 <code>listByCategoryId()</code> 方法中，我们先查询 Redis 中是否有存在的 field，如果有，直接返回；如果没有，先查询数据库，然后存入缓存。</p><p>为了<strong>保证缓存的同步</strong>，在添加和删除方法中，我直接删除掉了相应 field 的缓存，这样当执行查询方法时，会重新保存缓存。</p><p>需要注意的是，<strong>Redis 的正常/异常与否，不应当影响程序的正常运行</strong>。因为即使没有 Redis 程序也是可以正常运行的，因此我们在 Redis 操作的地方，需要 <code>try-catch</code>，在 catch 中可以打印日志信息等操作，我这里只是简单的输出在控制台。</p><blockquote><p>注：JedisClient 接口和其单机/集群实现类代码省略，需要请看上一节。</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TbContentServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceImpl</span>&lt;<span class="hljs-title">TbContentMapper</span>, <span class="hljs-title">TbContent</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">TbContentService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> TbContentMapper contentMapper;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> JedisClient jedisClient;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;redis.CONTENT_KEY&#125;"</span>)    <span class="hljs-keyword">private</span> String CONTENT_KEY;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除CONTENT_KEY中指定field</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteContentKeyFromRedis</span><span class="hljs-params">(Long cid)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            jedisClient.hdel(CONTENT_KEY, cid + <span class="hljs-string">""</span>);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;TbContent&gt; <span class="hljs-title">listByCategoryId</span><span class="hljs-params">(Long cid)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 如果缓存存在的话，直接从缓存中取</span>            String json = jedisClient.hget(CONTENT_KEY, cid + <span class="hljs-string">""</span>);            <span class="hljs-keyword">if</span>(StringUtils.isNotBlank(json)) &#123;                <span class="hljs-keyword">return</span> JsonUtils.jsonToList(json, TbContent<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        List&lt;TbContent&gt; contents = contentMapper.selectList(<span class="hljs-keyword">new</span> EntityWrapper&lt;TbContent&gt;() .eq(<span class="hljs-string">"category_id"</span>, cid));        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 加入缓存</span>            jedisClient.hset(CONTENT_KEY, cid+<span class="hljs-string">""</span>, JsonUtils.objectToJson(contents));        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> contents;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addContent</span><span class="hljs-params">(TbContent tbContent)</span> </span>&#123;        <span class="hljs-comment">// 更新缓存</span>        deleteContentKeyFromRedis(tbContent.getCategoryId());        tbContent.setCreated(<span class="hljs-keyword">new</span> Date());        tbContent.setUpdated(<span class="hljs-keyword">new</span> Date());                contentMapper.insert(tbContent);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteById</span><span class="hljs-params">(Long id)</span> </span>&#123;        <span class="hljs-keyword">if</span>(id == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 更新缓存</span>        TbContent tbContent = contentMapper.selectById(id);        deleteContentKeyFromRedis(tbContent.getCategoryId());        contentMapper.deleteById(id);    &#125;&#125;</code></pre></div><h3 id="2-4-Web-层代码"><a href="#2-4-Web-层代码" class="headerlink" title="2.4 Web 层代码"></a>2.4 Web 层代码</h3><p>我们设首页轮播图的 id 为 <code>ad1Id</code>，直接调用 <code>tbContentService.listByCategoryId(ad1Id)</code> 即可。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageController</span> </span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;ad1.id&#125;"</span>)    <span class="hljs-keyword">private</span> Long ad1Id;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> TbContentService tbContentService;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/index"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">showIndex</span><span class="hljs-params">(Model model)</span> </span>&#123;        <span class="hljs-comment">// 得到首页大轮播图的List</span>        List&lt;TbContent&gt; ad1List = tbContentService.listByCategoryId(ad1Id);        model.addAttribute(<span class="hljs-string">"ad1List"</span>, ad1List);        <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;    &#125;&#125;</code></pre></div><h2 id="三、验证"><a href="#三、验证" class="headerlink" title="三、验证"></a>三、验证</h2><p>服务器启动单机版 Redis，当我们刷新首页的时候，就会将缓存保存到了 Redis 中。</p><p>Key 为 <code>CONTENT_KEY</code>，field 目前只有一个，即首页轮播图，其值为89，value 为转换为 json 的数据：</p><p><img src="https://img-blog.csdnimg.cn/2020060616020848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>当我在后台为首页添加一个轮播图后，该 Field 被删除掉了（这里之所以连 key 也被删掉了，是因为该 key 中只有一个field，因此唯一的 field 被删掉了，key 也就删掉了）：</p><div class="hljs"><pre><code class="hljs shell">127.0.0.1:6379&gt; keys *(empty list or set)</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200606160231372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>重新刷新首页，正确显示三张：</p><p><img src="https://img-blog.csdnimg.cn/2020060616025755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>再次查看 Redis：</p><p><img src="https://img-blog.csdnimg.cn/20200606160316730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7. Redis--Redis操纵集群</title>
    <link href="/2020/06/06/7-Redis-Redis%E6%93%8D%E7%BA%B5%E9%9B%86%E7%BE%A4/"/>
    <url>/2020/06/06/7-Redis-Redis%E6%93%8D%E7%BA%B5%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<p>在<a href="https://www.jitwxs.cn/baef2507.html" target="_blank" rel="noopener">《Redis 初探（2）——Jedis 的使用》</a>中，我们已经学会了Jedis操纵单机Redis的简单使用，本章将继续深入，介绍Jedis对集群的操纵。</p><h2 id="一、Jedis-连接单机"><a href="#一、Jedis-连接单机" class="headerlink" title="一、Jedis 连接单机"></a>一、Jedis 连接单机</h2><p>在开始介绍 Jedis 连接集群之前，先简单回顾下连接单机的使用。</p><h3 id="1-1-简单使用"><a href="#1-1-简单使用" class="headerlink" title="1.1 简单使用"></a>1.1 简单使用</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJedis</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 1.获得连接对象。参数为redis所在的服务器地址及端口号</span>    Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">6379</span>);    <span class="hljs-comment">// 2.获得数据</span>    String age = jedis.get(<span class="hljs-string">"age"</span>);    System.out.println(age);    jedis.close();&#125;</code></pre></div><h3 id="1-2-使用连接池"><a href="#1-2-使用连接池" class="headerlink" title="1.2 使用连接池"></a>1.2 使用连接池</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJedisPool</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//1. 创建Jedis连接池配置（包含许多配置，这里只配置了3个）</span>    JedisPoolConfig poolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();    <span class="hljs-comment">// 设置最小和最大闲置个数</span>    poolConfig.setMinIdle(<span class="hljs-number">5</span>);    poolConfig.setMaxIdle(<span class="hljs-number">10</span>);    <span class="hljs-comment">// 设置连接池最大个数</span>    poolConfig.setMaxTotal(<span class="hljs-number">30</span>);    <span class="hljs-comment">//2. 创建Jedis连接池</span>    JedisPool pool = <span class="hljs-keyword">new</span> JedisPool(poolConfig,<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">6379</span>);    <span class="hljs-comment">//3. 从连接池中获取Jedis对象</span>    Jedis jedis = pool.getResource();    <span class="hljs-comment">//4.操纵数据</span>    jedis.set(<span class="hljs-string">"sex"</span>, <span class="hljs-string">"male"</span>);    System.out.println(jedis.get(<span class="hljs-string">"sex"</span>));    <span class="hljs-comment">//5.关闭资源</span>    jedis.close();    pool.close();&#125;</code></pre></div><h2 id="二、Jedis-连接集群"><a href="#二、Jedis-连接集群" class="headerlink" title="二、Jedis 连接集群"></a>二、Jedis 连接集群</h2><p>Jedis 连接集群也是十分简单，首先创建一个 <code>HostAndPort</code> 的集合，里面存放着集群中的每一个节点，然后创建 <code>JedisCluster</code> 对象，直接操纵该对象即可。</p><p><code>JedisCluster</code> 在项目中<strong>单例存在</strong>即可。第三步的关闭可省略（因为单例存在，如果关掉了，即整个项目要结束了）。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJedisCluster</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">// 1.创建一个JedisCluster对象。第一个参数nodes是一个set类型，set中包含若干个HostAndPort对象</span>    Set&lt;HostAndPort&gt; nodes = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    nodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">7001</span>));    nodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">7002</span>));    nodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">7003</span>));    nodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">7004</span>));    nodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">7005</span>));    nodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.30.155"</span>, <span class="hljs-number">7006</span>));    JedisCluster cluster = <span class="hljs-keyword">new</span> JedisCluster(nodes);    <span class="hljs-comment">// 2.直接使用JedisCluster对象操作redis，单例存在即可。</span>    cluster.set(<span class="hljs-string">"test"</span>, <span class="hljs-string">"123"</span>);    System.out.println(cluster.get(<span class="hljs-string">"test"</span>));    <span class="hljs-comment">// 3.关闭JedisCluster对象。</span>    cluster.close();&#125;</code></pre></div><h2 id="三、Jedis-的实际应用"><a href="#三、Jedis-的实际应用" class="headerlink" title="三、Jedis 的实际应用"></a>三、Jedis 的实际应用</h2><p>在实际项目中，测试环境一般使用单机版，生产环境使用集群版。为了避免代码的不必要改动，我们使用<code>策略模式</code>，<code>面向接口开发</code>。</p><h3 id="3-1-JedisClient-接口"><a href="#3-1-JedisClient-接口" class="headerlink" title="3.1 JedisClient 接口"></a>3.1 JedisClient 接口</h3><p>定义一个 <code>JedisClient</code> 的接口，里面封装了常用的一些方法，主要是对 <code>String</code> 类型和 <code>Hash</code> 类型的操作，可以根据实际情况进行修改。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">JedisClient</span> </span>&#123;    <span class="hljs-function">String <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span></span>;    <span class="hljs-function">String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span></span>;    <span class="hljs-function">Boolean <span class="hljs-title">exists</span><span class="hljs-params">(String key)</span></span>;    <span class="hljs-function">Long <span class="hljs-title">expire</span><span class="hljs-params">(String key, <span class="hljs-keyword">int</span> seconds)</span></span>;    <span class="hljs-function">Long <span class="hljs-title">ttl</span><span class="hljs-params">(String key)</span></span>;    <span class="hljs-function">Long <span class="hljs-title">incr</span><span class="hljs-params">(String key)</span></span>;    <span class="hljs-function">Long <span class="hljs-title">hset</span><span class="hljs-params">(String key, String field, String value)</span></span>;    <span class="hljs-function">String <span class="hljs-title">hget</span><span class="hljs-params">(String key, String field)</span></span>;    <span class="hljs-function">Long <span class="hljs-title">hdel</span><span class="hljs-params">(String key, String... field)</span></span>;    <span class="hljs-function">Boolean <span class="hljs-title">hexists</span><span class="hljs-params">(String key, String field)</span></span>;    <span class="hljs-function">List&lt;String&gt; <span class="hljs-title">hvals</span><span class="hljs-params">(String key)</span></span>;    <span class="hljs-function">Long <span class="hljs-title">del</span><span class="hljs-params">(String key)</span></span>;&#125;</code></pre></div><h3 id="3-2-单机实现类"><a href="#3-2-单机实现类" class="headerlink" title="3.2 单机实现类"></a>3.2 单机实现类</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<span class="hljs-keyword">import</span> redis.clients.jedis.JedisPool;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisClientPool</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">JedisClient</span> </span>&#123;        <span class="hljs-keyword">private</span> JedisPool jedisPool;    <span class="hljs-function"><span class="hljs-keyword">public</span> JedisPool <span class="hljs-title">getJedisPool</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisPool;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setJedisPool</span><span class="hljs-params">(JedisPool jedisPool)</span> </span>&#123;        <span class="hljs-keyword">this</span>.jedisPool = jedisPool;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        String result = jedis.set(key, value);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        String result = jedis.get(key);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">exists</span><span class="hljs-params">(String key)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Boolean result = jedis.exists(key);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">expire</span><span class="hljs-params">(String key, <span class="hljs-keyword">int</span> seconds)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Long result = jedis.expire(key, seconds);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">ttl</span><span class="hljs-params">(String key)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Long result = jedis.ttl(key);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">incr</span><span class="hljs-params">(String key)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Long result = jedis.incr(key);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">hset</span><span class="hljs-params">(String key, String field, String value)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Long result = jedis.hset(key, field, value);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hget</span><span class="hljs-params">(String key, String field)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        String result = jedis.hget(key, field);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">hdel</span><span class="hljs-params">(String key, String... field)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Long result = jedis.hdel(key, field);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">hexists</span><span class="hljs-params">(String key, String field)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Boolean result = jedis.hexists(key, field);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">hvals</span><span class="hljs-params">(String key)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        List&lt;String&gt; result = jedis.hvals(key);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">del</span><span class="hljs-params">(String key)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        Long result = jedis.del(key);        jedis.close();        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre></div><h3 id="3-3-集群实现类"><a href="#3-3-集群实现类" class="headerlink" title="3.3 集群实现类"></a>3.3 集群实现类</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> redis.clients.jedis.JedisCluster;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisClientCluster</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">JedisClient</span> </span>&#123;        <span class="hljs-keyword">private</span> JedisCluster jedisCluster;        <span class="hljs-function"><span class="hljs-keyword">public</span> JedisCluster <span class="hljs-title">getJedisCluster</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setJedisCluster</span><span class="hljs-params">(JedisCluster jedisCluster)</span> </span>&#123;        <span class="hljs-keyword">this</span>.jedisCluster = jedisCluster;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.set(key, value);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.get(key);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">exists</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.exists(key);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">expire</span><span class="hljs-params">(String key, <span class="hljs-keyword">int</span> seconds)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.expire(key, seconds);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">ttl</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.ttl(key);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">incr</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.incr(key);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">hset</span><span class="hljs-params">(String key, String field, String value)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.hset(key, field, value);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hget</span><span class="hljs-params">(String key, String field)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.hget(key, field);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">hdel</span><span class="hljs-params">(String key, String... field)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.hdel(key, field);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">hexists</span><span class="hljs-params">(String key, String field)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.hexists(key, field);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">hvals</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.hvals(key);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">del</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> jedisCluster.del(key);    &#125;&#125;</code></pre></div><h3 id="3-4-实战演示"><a href="#3-4-实战演示" class="headerlink" title="3.4 实战演示"></a>3.4 实战演示</h3><p>（1）首先准备一个配置文件 <code>cfg.properties</code>，在配置文件中加入关于 redis 的信息：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-comment"># redis单机</span><span class="hljs-attr">redis.standalone.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.standalone.port</span>=<span class="hljs-number">6379</span><span class="hljs-comment">#redis集群</span><span class="hljs-attr">redis.cluster.01.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.01.port</span>=<span class="hljs-number">7001</span><span class="hljs-attr">redis.cluster.02.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.02.port</span>=<span class="hljs-number">7002</span><span class="hljs-attr">redis.cluster.03.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.03.port</span>=<span class="hljs-number">7003</span><span class="hljs-attr">redis.cluster.04.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.04.port</span>=<span class="hljs-number">7004</span><span class="hljs-attr">redis.cluster.05.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.05.port</span>=<span class="hljs-number">7005</span><span class="hljs-attr">redis.cluster.06.host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">30.155</span><span class="hljs-attr">redis.cluster.06.port</span>=<span class="hljs-number">7006</span></code></pre></div><p>（2）准备 Spring 关于 redis 的配置文件 <code>applicationContext-redis.xml</code>：</p><p>需要注意的是，单机和集群同时<strong>只能放开一个，另一个必须注释掉</strong>。因为我们取Bean是取接口，即 <code>JedisClient</code>，这两个都是 <code>JedisClient</code> 的实现类。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="hljs-tag"><span class="hljs-string">    http://www.springframework.org/schema/context</span></span><span class="hljs-tag"><span class="hljs-string">    http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 注意：单机和集群同时只能放开一个 --&gt;</span>    <span class="hljs-comment">&lt;!-- 加载配置文件 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:cfg.properties"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 配置Redis单机 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jedisClientPool"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"jit.wxs.common.jedis.JedisClientPool"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"jedisPool"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"jedisPool"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jedisPool"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.JedisPool"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.standalone.host&#125;"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.standalone.port&#125;"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置Redis集群 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jedisClientCluster"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"jit.wxs.common.jedis.JedisClientCluster"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"jedisCluster"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"jedisCluster"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jedisCluster"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.JedisCluster"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.HostAndPort"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.01.host&#125;"</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.01.port&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.HostAndPort"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.02.host&#125;"</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.02.port&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.HostAndPort"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.03.host&#125;"</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.03.port&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.HostAndPort"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.04.host&#125;"</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.04.port&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.HostAndPort"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.05.host&#125;"</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.05.port&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.HostAndPort"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"host"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.06.host&#125;"</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.cluster.06.port&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>（3）编写测试方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    ApplicationContext ac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:applicationContext-redis.xml"</span>);    JedisClient jedisClient = ac.getBean(JedisClient<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    jedisClient.set(<span class="hljs-string">"author"</span>, <span class="hljs-string">"jitwxs"</span>);    String result = jedisClient.get(<span class="hljs-string">"author"</span>);    System.out.println(result);&#125;</code></pre></div><p>因为我们是面向接口开发，因此当我们切换单机和集群时，这段代码不需要任何修改，只需要修改配置文件即可。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6. Redis--Redis集群</title>
    <link href="/2020/06/06/6-Redis-Redis%E9%9B%86%E7%BE%A4/"/>
    <url>/2020/06/06/6-Redis-Redis%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<p>之前我们所学习的都是 Redis 的单机版，我们知道 Redis 之所以读取速度快是因为它是<strong>存储在内存</strong>中的。内存的容量是有限的，单台 Redis 会碰到性能瓶颈，这就需要使用 <code>Redis集群（Redis-cluster）</code>。</p><h2 id="一、集群原理"><a href="#一、集群原理" class="headerlink" title="一、集群原理"></a>一、集群原理</h2><h3 id="1-1-集群架构"><a href="#1-1-集群架构" class="headerlink" title="1.1 集群架构"></a>1.1 集群架构</h3><p><img src="https://img-blog.csdnimg.cn/20200606125039833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>如上图所示，每一个蓝色圆圈就是一个 Redis 节点，这些节点组成了一个 <code>Redis集群（Redis-cluster）</code>。节点之间使用 <code>Ping——Pong</code> 机制进行互联，其内部用二进制协议优化传输速度和带宽。</p><p>Redis客户端和节点<strong>直接连接</strong>即可，无需中间件，一台客户端连接一个节点即可，Client 访问时直接访问任意一个Redis节点即可。</p><h3 id="1-2-负载均衡"><a href="#1-2-负载均衡" class="headerlink" title="1.2 负载均衡"></a>1.2 负载均衡</h3><p>当我们搭建了集群后，是如何实现负载均衡的呢？</p><p>Redis 集群中内置了 <strong>16384</strong> 个<code>哈希槽（slot）</code>，它会把所有的物理节点都映射到<strong>[0,16383]</strong>的slot上。</p><p>当我们需要在Redis集群中放置一个 key-value 时，Redis 先对 key 使用 <code>crc16</code> 算法得出一个结果，然后将结果<strong>对16384取余</strong>，这样<strong>每一个 key 都会对应一个编号在0 ~16383的 哈希槽</strong>。</p><p>Redis 会根据节点数量大致均等地将哈希槽映射到不同的节点。例如我们有三个节点，其每个节点哈希槽范围为：0 ~ 5000，5001 ~ 10000，10001~ 16383。</p><p><img src="https://img-blog.csdnimg.cn/20200606130442462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>当我们存储一个名为 Hello1 的 key 时，其通过 <code>crc16</code> 算法计算出的结果为1500，Redis 集群就会将这个 key 放在对应1500的<code>哈希槽</code>中，又因为哈希槽0~ 5000被映射到了 Server1，则 Hello1 就被放置在了 Server1。</p><p><img src="https://img-blog.csdnimg.cn/2020060613054833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="1-3-容错机制"><a href="#1-3-容错机制" class="headerlink" title="1.3 容错机制"></a>1.3 容错机制</h3><p>通过上面的负载均衡的原理，知道其实<strong>每一台</strong> Redis 客户端保存的<strong>内容都是不一样</strong>的，那么当Redis集群中<strong>任意一个节点挂掉</strong>（连接失败）时，<strong>整个集群就挂了</strong>。</p><p>为了实现 Redis 的高可用，需要<strong>为每一个节点添加备用机</strong>，即<code>主备机制</code>。</p><p>一般集群都有集群管理工具，但是 Redis 集群没有，它是通过<code>投票机制</code>来实现的。</p><p>以下图为例简单说一下投票机制：</p><ol><li>当黄色节点发现无法 ping 通红色节点，它就觉得红色节点可能挂掉了，于是它会<strong>发起投票</strong>。</li><li>其他节点会尝试去 ping 红色节点，只要有<strong>超过半数</strong>的节点无法 ping 通红色节点，就<strong>判定红色节点挂掉</strong>（即使它实际上可能并没有挂掉）。</li><li>当红色节点被判定挂掉后，会<strong>启动该节点的备用机</strong>。如果该节点不存在备用机，或备用机也挂掉，那么<strong>整个Redis集群就挂掉了</strong>。</li></ol><p><img src="https://www.jitwxs.cn/images/posts/20180408222553762.png" srcset="/img/loading.gif" alt="img"></p><h2 id="二、搭建集群"><a href="#二、搭建集群" class="headerlink" title="二、搭建集群"></a>二、搭建集群</h2><blockquote><p>说明：在实际项目中，搭建集群都是搞运维的负责的，如果是专门的研发人员，其实可以不用知道如何搭建集群。</p></blockquote><p>Redis 集群为了实现容错机制，<strong>最少需要三个节点</strong>（一个出错，另外两个投票），又因为<strong>每个节点至少要有一台备份机</strong>，因此一个<strong>最简单的 Redis 集群需要6个 Redis 客户端</strong>。</p><p>这里只是演示一下，使用<code>伪集群</code>，即6台 Redis 搭建在一台 Linux 上，仅使用端口号进行区分，设端口号范围为7001 ~ 7006。</p><h3 id="2-1-准备原始-Redis"><a href="#2-1-准备原始-Redis" class="headerlink" title="2.1 准备原始 Redis"></a>2.1 准备原始 Redis</h3><blockquote><p>注：<a href="https://www.jitwxs.cn/e331e26a.html" target="_blank" rel="noopener">《Redis 初探（1）——Redis 的安装》</a>这篇文章中源码和安装后的文件是在同一文件夹下，本篇文章不使用这种方法。</p></blockquote><p>准备一个 Redis 安装包，将源码解压到当前文件夹：</p><div class="hljs"><pre><code class="hljs shell">wxs@ubuntu:~$ lsDesktop  redis-4.0.8.tar.gzwxs@ubuntu:~$ tar zxvf redis-4.0.8.tar.gz</code></pre></div><p>进入解压后文件夹，执行 make 编译：</p><div class="hljs"><pre><code class="hljs shell">wxs@ubuntu:~$ cd redis-4.0.8/wxs@ubuntu:~/redis-4.0.8$ make</code></pre></div><blockquote><p>注：所有源码安装需要自行编译的都需要 gcc、g++ 等相关软件支持</p></blockquote><p>将其安装到<code>/usr/local/redis</code>目录下：</p><div class="hljs"><pre><code class="hljs shell">wxs@ubuntu:~/redis-4.0.8$ sudo make install PREFIX=/usr/local/redis</code></pre></div><p>该目录下只有一个 bin 目录，存放 redis 的可执行文件，我们从源码包中拷贝一份 redis 配置文件过来：</p><div class="hljs"><pre><code class="hljs shell">wxs@ubuntu:/usr/local/redis$ lsbinwxs@ubuntu:/usr/local/redis$ sudo cp ~/redis-4.0.8/redis.conf .wxs@ubuntu:/usr/local/redis$ lsbin  redis.conf</code></pre></div><p>编辑该配置文件：</p><p>（1）修改 bind 端口号为 <code>0.0.0.0</code>，使其支持远程访问。</p><p><img src="https://img-blog.csdnimg.cn/20200606135013850.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>（2）开启后端模式。</p><p><img src="https://img-blog.csdnimg.cn/20200606135225299.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>（3）设置日志文件位置</p><p><img src="https://img-blog.csdnimg.cn/20200606135249116.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>（4）开启 AOF 持久化</p><p><img src="https://img-blog.csdnimg.cn/20200606135308180.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="2-2-准备-Redis-集群客户端"><a href="#2-2-准备-Redis-集群客户端" class="headerlink" title="2.2 准备 Redis 集群客户端"></a>2.2 准备 Redis 集群客户端</h3><p><strong>注意：</strong>用来做集群的客户端<strong>必须是干净的客户端</strong>，像备份文件 <code>dump.rdb</code>、<code>appendonly.aof</code> 等应当先删除掉，避免不必要的错误。</p><p>在 <code>/usr/local</code> 中创建 <code>redis-cluster</code> 文件夹，拷贝六份原始 Redis：</p><div class="hljs"><pre><code class="hljs shell">wxs@ubuntu:/usr/local/redis-cluster$ sudo cp -r ../redis redis01wxs@ubuntu:/usr/local/redis-cluster$ sudo cp -r ../redis redis02wxs@ubuntu:/usr/local/redis-cluster$ sudo cp -r ../redis redis03wxs@ubuntu:/usr/local/redis-cluster$ sudo cp -r ../redis redis04wxs@ubuntu:/usr/local/redis-cluster$ sudo cp -r ../redis redis05wxs@ubuntu:/usr/local/redis-cluster$ sudo cp -r ../redis redis06wxs@ubuntu:/usr/local/redis-cluster$ lsredis01  redis02  redis03  redis04  redis05  redis06</code></pre></div><p>以 redis01 为例，编辑其 <code>redis.conf</code> 文件：</p><p>（1）修改端口号为 7001</p><p><img src="https://img-blog.csdnimg.cn/20200606135324484.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>（2）修改 pidfile</p><p><img src="https://img-blog.csdnimg.cn/20200606135353518.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>（3）开启集群开关</p><p><img src="https://img-blog.csdnimg.cn/20200606135404621.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>依次修改其他客户端，端口号范围从7001 ~ 7006。</p><p>编写一个启动这些客户端的批处理 <code>startup.sh</code>：</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> redis01/binsudo ./redis-server ../redis.conf<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis02/binsudo ./redis-server ../redis.conf<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis03/binsudo ./redis-server ../redis.conf<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis04/binsudo ./redis-server ../redis.conf<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis05/binsudo ./redis-server ../redis.conf<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis06/binsudo ./redis-server ../redis.conf<span class="hljs-built_in">cd</span> ../../</code></pre></div><p>执行脚本，启动成功：</p><p><img src="https://img-blog.csdnimg.cn/20200606135422369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>编写一个关闭这些客户端的批处理 <code>shutdown.sh</code>：</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> redis01/binsudo ./redis-cli -p 7001 shutdown<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis02/binsudo ./redis-cli -p 7002 shutdown<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis03/binsudo ./redis-cli -p 7003 shutdown<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis04/binsudo ./redis-cli -p 7004 shutdown<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis05/binsudo ./redis-cli -p 7005 shutdown<span class="hljs-built_in">cd</span> ../../<span class="hljs-built_in">cd</span> redis06/binsudo ./redis-cli -p 7006 shutdown<span class="hljs-built_in">cd</span> ../../</code></pre></div><p>执行脚本，关闭成功：</p><p><img src="https://img-blog.csdnimg.cn/20200606135446595.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>目录结构如下：</p><div class="hljs"><pre><code class="hljs shell">wxs@ubuntu:/usr/local/redis-cluster$ lsredis01  redis02  redis03  redis04  redis05  redis06  shutdown.sh  startup.sh</code></pre></div><h3 id="2-3-搭建集群"><a href="#2-3-搭建集群" class="headerlink" title="2.3 搭建集群"></a>2.3 搭建集群</h3><p>从 redis 源码的 src 目录中拷贝 <code>redis-trib.rb</code> 过来：</p><div class="hljs"><pre><code class="hljs shell">wxs@ubuntu:/usr/local/redis-cluster$ sudo cp ~/redis-4.0.8/src/redis-trib.rb .wxs@ubuntu:/usr/local/redis-cluster$ lsredis01  redis03  redis05  redis-trib.rb  startup.shredis02  redis04  redis06  shutdown.sh</code></pre></div><p>因为这是一个 <code>shell</code> 文件，需要安装 shell 和 shell 包管理器：</p><div class="hljs"><pre><code class="hljs shell">wxs@ubuntu:/usr/local/redis-cluster$ sudo apt-get install shell shellgems</code></pre></div><p>安装 shell 关于 Redis 的库,可以执行 <code>gem install redis</code> 或者<a href="https://shellgems.org/gems/redis/versions/" target="_blank" rel="noopener">前往官网</a>下载安装包后安装。</p><div class="hljs"><pre><code class="hljs shell">wxs@ubuntu:/usr/local/redis-cluster$ sudo gem install redisFetching: redis-4.0.1.gem (100%)Successfully installed redis-4.0.1Parsing documentation for redis-4.0.1Installing ri documentation for redis-4.0.1Done installing documentation for redis after 0 seconds1 gem installed</code></pre></div><p>执行 <code>redis-trib.rb</code> 时需要附带参数，格式如下：</p><p><img src="https://img-blog.csdnimg.cn/20200606135501801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>先启动所有客户端，然后执行脚本：</p><div class="hljs"><pre><code class="hljs shell">wxs@ubuntu:/usr/local/redis-cluster$ ./startup.sh wxs@ubuntu:/usr/local/redis-cluster$ ./redis-trib.rb create --replicas 1 192.168.30.155:7001 192.168.30.155:7002 192.168.30.155:7003 192.168.30.155:7004 192.168.30.155:7005  192.168.30.155:7006</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200606135527930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>创建成功：</p><p><img src="https://img-blog.csdnimg.cn/20200606135550905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>最后说两句：</p><ol><li>如果你不是伪集群，真的在服务器上搭建了集群，即 <code>真集群</code>，那么只需要在任意一台上执行 <code>redis-trib.rb</code> 即可。</li><li>在真集群的情况下，除了在配置文件中要 <code>bind 0.0.0.0</code> 以外，还要注意<strong>关闭防火墙</strong>，不然无法搭建。</li><li>如果关闭所有 redis 客户端后，想要重新开启集群，在客户端都启动后，进入任意客户端执行<code>cluster nodes</code>即可。</li><li>如果想要重新生成集群，需要删除每个 Redis 中生成的持久化文件。</li></ol><h2 id="三、使用-redis-cli-连接集群"><a href="#三、使用-redis-cli-连接集群" class="headerlink" title="三、使用 redis-cli 连接集群"></a>三、使用 redis-cli 连接集群</h2><p>使用任意一个 <code>redis-cli</code>（以redis01的为例），使用 <code>-h</code> 指定ip地址（默认连接127.0.0.1），使用 <code>-p</code> 参数指定端口号（默认连接原始的端口为6379的 redis），使用 <code>-c</code> 参数指定是集群（不加会导致无法将 key 放入对应的客户端中）。</p><div class="hljs"><pre><code class="hljs shell">wxs@ubuntu:/usr/local/redis-cluster$ ./redis01/bin/redis-cli -h 192.168.30.155 -p 7001 -c</code></pre></div><p>当我在7001中添加了一个 <code>name jitwxs</code> 后，它计算出 key 的哈希槽为5798，这个范围在7002中，因此这个 key 被移动到了7002中，并且当前连接重定向到了7002。</p><p><img src="https://img-blog.csdnimg.cn/20200606135606467.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs shell">192.168.30.155:7002&gt; keys *1) "name"192.168.30.155:7001&gt; keys *(empty list or set)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5. Redis--Redis的持久化</title>
    <link href="/2020/06/06/5-Redis-Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/2020/06/06/5-Redis-Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>Redis 的高性能是由其将所有数据都存储在了内存中，需要使用时直接从内存调用即可。为了使 Redis 在重启之后仍然能保证数据不丢失，需要将数据从内存同步到数据库中，这一过程就是<code>持久化</code>。</p><p>Redis 支持两种持久化方式，一种是 <code>RDB方式</code>，一种是 <code>AOF方式</code>。可以单独使用其中一种或将两种结合使用。</p><ul><li>RDB (默认) 在<strong>指定的时间间隔</strong>内将内存中的数据<strong>快照</strong>写入磁盘。</li><li>AOF 以<strong>日志</strong>的形式记录服务器处理的<strong>每一个写操作</strong>，在Redis服务器启动之初会读取该文件来重新构建数据库，以保证启动后数据库中的数据是完整的。</li></ul><h2 id="一、RDB"><a href="#一、RDB" class="headerlink" title="一、RDB"></a>一、RDB</h2><h3 id="1-1-实现步骤"><a href="#1-1-实现步骤" class="headerlink" title="1.1 实现步骤"></a>1.1 实现步骤</h3><ol><li>Redis 执行 <code>fork</code> 命令创建子进程。</li><li>父进程继续处理 client 请求，子进程负责将内存内容写入到临时文件。由于 OS 的<strong>写时复制机制</strong>父子进程会共享相同的物理页面，<strong>当父进程处理写请求时OS会为父进程要修改的页面创建副本</strong>，而不是写共享的页面。所以子进程的地址空间内的数据是 fork 时刻整个数据库的一个<strong>快照</strong>。</li><li>当子进程将快照写入临时文件完毕后，用临时文件替换原来的快照文件，然后子进程退出。</li></ol><p>需要注意的是，每次 RDB 都是将<strong>内存数据完整写入到磁盘一次</strong>，并<strong>不是在原有数据的基础上增加数据</strong>。如果数据量大的话，而且写操作比较多，必然会引起大量的磁盘IO操作，可能会严重影响性能。</p><h3 id="1-2-优势"><a href="#1-2-优势" class="headerlink" title="1.2 优势"></a>1.2 优势</h3><ol><li>一旦采用该方式，那么你的整个 Redis 数据库将<strong>只包含一个文件</strong>，这样非常<strong>方便备份</strong>。</li><li><strong>方便移植</strong>，我们可以很容易的将一个一个 RDB 文件移动到其他的存储介质上。</li><li>RDB 在恢复大数据集时的速度比 AOF 的<strong>恢复速度要快</strong>。</li><li>RDB 可以<strong>最大化 Redis 的性能</strong>（父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 IO 操作）。</li></ol><h3 id="1-3-劣势"><a href="#1-3-劣势" class="headerlink" title="1.3 劣势"></a>1.3 劣势</h3><ol><li>如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么 RDB 将不是一个很好的选择。 因为系统一旦在定时持久化之前发生宕机， 你就可能会<strong>丢失这之间的数据</strong>。</li><li>因为 RDB 是通过 fork 子进程来协助完成持久化工作的，因此当数据集较大时，会<strong>影响服务器性能</strong>。</li></ol><h3 id="1-4-RDB-配置"><a href="#1-4-RDB-配置" class="headerlink" title="1.4 RDB 配置"></a>1.4 RDB 配置</h3><p>在 <code>redis.conf</code> 中可以配置和RDF相关的信息：</p><p>(1) 配置 RDB 文件位置</p><p><img src="https://img-blog.csdnimg.cn/20200606122136837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>(2) 配置 RDB 保存时机</p><p><img src="https://img-blog.csdnimg.cn/20200606122206950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="二、AOF"><a href="#二、AOF" class="headerlink" title="二、AOF"></a>二、AOF</h2><p>采用 AOF 方式，Redis 会将每一个收到的写命令都通过 <code>write</code> 函数写入到 AOF 文件中。当 Redis 重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。</p><p>AOF 的方式也同时带来了另一个问题：<strong>持久化文件会变的越来越大</strong>。例如我们调用 <code>incr num</code> 命令100次，文件中必须保存全部的100条命令，其实有99条都是多余的，因为要恢复数据库的状态其实文件中保存一条 <code>set num 100</code> 就够了。</p><h3 id="2-1-实现步骤"><a href="#2-1-实现步骤" class="headerlink" title="2.1 实现步骤"></a>2.1 实现步骤</h3><ol><li>Redis调用<code>fork</code>命令创建子进程。</li><li>子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令。</li><li>父进程继续处理client请求，除了把写命令写入到原来的AOF文件中，同时缓存新收到的写命令。</li><li>子进程把快照内容写入到临时文件后，子进程发信号通知父进程，然后父进程把缓存的写命令也写入到临时文件。</li><li>父进程使用临时文件替换老的AOF文件，并重命名，后面收到的写命令也开始往新的AOF文件中追加。</li></ol><p>需要注意的是，重写AOF文件的操作并没有读取旧的AOF文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的AOF文件，这点和快照有点类似。</p><h3 id="2-2-优势"><a href="#2-2-优势" class="headerlink" title="2.2 优势"></a>2.2 优势</h3><ol><li>AOF 提供的三种同步策略，使得数据<strong>安全性更高</strong>。</li><li>因为 AOF 对日志文件的写入操作采用的是<code>append 模式</code>，因此在写入过程中即使出现宕机现象，也不会破坏日志文件已经存在的内容。</li><li>如果 AOF 日志文件过大，Redis可以自动启用 <code>rewrite 机制</code>，使 Redis 以 append 模式不断的将修改数据写入到老的磁盘文件中，同时 Redis 还会创建一个新的文件用于记录此期间有哪些命令被执行。因此在进行 rewrite 切换时可以更好的保证数据安全性。</li></ol><h3 id="2-3-劣势"><a href="#2-3-劣势" class="headerlink" title="2.3 劣势"></a>2.3 劣势</h3><ol><li>对于相同数量的数据集而言，AOF 文件通常要大于 RDB 文件。</li><li>根据同步策略的不同，AOF 在运行效率上往往会<strong>慢</strong>于 RDB。</li></ol><h3 id="2-4-AOF-配置"><a href="#2-4-AOF-配置" class="headerlink" title="2.4 AOF 配置"></a>2.4 AOF 配置</h3><p>AOF 默认是关闭的，修改配置文件 <code>redis.conf</code> 来打开 AOF：</p><p><img src="https://img-blog.csdnimg.cn/20200606122949195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>AOF 具有三种同步策略，在配置文件 <code>redis.conf</code> 中进行配置：</p><p><img src="https://img-blog.csdnimg.cn/20200606123020516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>除了满足同步策略来自动同步外，可以手动同步，执行命令 <code>bgrewriteaof</code> 即可。</p><p>下面演示下 AOF 恢复：</p><div class="hljs"><pre><code class="hljs elixir">wxs<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:/usr/local/redis/src</span><span class="hljs-variable">$ </span>./redis-cli <span class="hljs-number">127.0</span>.0.<span class="hljs-number">1:6379</span>&gt; keys *(empty list <span class="hljs-keyword">or</span> set)<span class="hljs-number">127.0</span>.0.<span class="hljs-number">1:6379</span>&gt; set name jitwxs <span class="hljs-comment">#设置一个key</span>OK<span class="hljs-number">127.0</span>.0.<span class="hljs-number">1:6379</span>&gt; flushdb <span class="hljs-comment">#清空数据库</span>OK<span class="hljs-number">127.0</span>.0.<span class="hljs-number">1:6379</span>&gt; exitwxs<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:/usr/local/redis/src</span><span class="hljs-variable">$ </span>ps auxc | grep rediswxs        <span class="hljs-number">5974</span>  0.<span class="hljs-number">1</span>  0.<span class="hljs-number">4</span>  <span class="hljs-number">51828</span>  <span class="hljs-number">8368</span> ?        Ssl  <span class="hljs-number">21:23</span>   0<span class="hljs-symbol">:</span>00 redis-serverwxs<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:/usr/local/redis/src</span><span class="hljs-variable">$ </span>kill <span class="hljs-number">5974</span> <span class="hljs-comment">#停止服务</span>wxs<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:/usr/local/redis/src</span><span class="hljs-variable">$ </span>vim ../redis_dbfile/appendonly.aof <span class="hljs-comment">#修改AOF文件并删除掉最后一行的flushdb命令</span>wxs<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:/usr/local/redis/src</span><span class="hljs-variable">$ </span>./redis-server ../redis.conf <span class="hljs-comment">#重新启动服务，数据被恢复</span>wxs<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:/usr/local/redis/src</span><span class="hljs-variable">$ </span>./redis-cli <span class="hljs-number">127.0</span>.0.<span class="hljs-number">1:6379</span>&gt; keys *<span class="hljs-number">1</span>) <span class="hljs-string">"name"</span></code></pre></div><blockquote><p>注：这里只是说明Redis持久化配置相关的内容，实际配置由于本人使用的是Docker容器生成的Redis，所以有些地方跟上述不一致，所以仅仅作为参考，后续会更新完善。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4. Redis--Redis的特性</title>
    <link href="/2020/06/06/4-Redis-Redis%E7%9A%84%E7%89%B9%E6%80%A7/"/>
    <url>/2020/06/06/4-Redis-Redis%E7%9A%84%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="一、多数据库"><a href="#一、多数据库" class="headerlink" title="一、多数据库"></a>一、多数据库</h2><p>每一个 Redis 实例可以包括多个数据库，客户端可以指定连接某个 Redis 实例的某个数据库。一个Redis实例最多可以提供 <strong>16</strong> 个数据库，下标从 0 到 15，客户端<strong>默认连接第 0 号数据库</strong>。</p><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>选择第 n 号数据库</td><td>select n</td></tr><tr><td>将当前库的 key 转移到第 n 号数据库</td><td>move key n</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/20200606100035439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>这里补充下之前没有提到的 Redis 服务器的一些命令：</p><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>测试连接状态是否可用</td><td>ping</td></tr><tr><td>命令行中打印内容</td><td>echo xxx</td></tr><tr><td>返回当前数据库中 key 的数目</td><td>dbsize</td></tr><tr><td>获取服务器的信息和统计</td><td>info</td></tr><tr><td>删除当前选择数据库中所有key</td><td>flushdb</td></tr><tr><td>删除所有数据库中所有key</td><td>flushall</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-symbol">wxs@</span>ubuntu:/usr/local/redis/src$ ./redis-cli<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; select <span class="hljs-number">1</span> #进入<span class="hljs-number">1</span>号数据库OK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">1</span>]&gt; ping #检查连接状态PONG<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">1</span>]&gt; dbsize #获取当前数据库key数目(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">1</span>]&gt; flushdb #清空当前数据库OK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">1</span>]&gt; keys *(empty list <span class="hljs-keyword">or</span> <span class="hljs-keyword">set</span>)<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">1</span>]&gt; flushall #清空所有数据库OK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">1</span>]&gt; select <span class="hljs-number">0</span>OK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; keys *(empty list <span class="hljs-keyword">or</span> <span class="hljs-keyword">set</span>)</code></pre></div><h2 id="二、消息订阅与发布"><a href="#二、消息订阅与发布" class="headerlink" title="二、消息订阅与发布"></a>二、消息订阅与发布</h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。Redis 客户端可以订阅<strong>任意数量</strong>的频道。</p><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>订阅频道</td><td>subscribe cctv</td></tr><tr><td>批量订阅频道</td><td>psubscribe cctv*</td></tr><tr><td>在指定频道中发送消息</td><td>publish cctv “hello”</td></tr></tbody></table><p>实现消息的订阅和发布至少需要两个终端，我们在终端1中订阅 cctv 这个频道的消息：</p><p><img src="https://img-blog.csdnimg.cn/20200606103425153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>在终端2中向 cctv 这个频道发布消息：从上面的图可以看到，推送的消息已经被订阅者收到。</p><p><img src="https://img-blog.csdnimg.cn/20200606103500275.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>我们也可以以一种正则的形式订阅多个频道，比如 cctv 下面有多个频道，例如 cctv-1、cctv-2 等等，我们只需订阅这个即可：</p><div class="hljs"><pre><code class="hljs nginx"><span class="hljs-attribute">psubscribe</span> cctv*</code></pre></div><h2 id="三、事务"><a href="#三、事务" class="headerlink" title="三、事务"></a>三、事务</h2><p>Redis 和其他数据库一样，也支持事务功能，但是 Redis 的数据库<strong>并不是一种真正的事务</strong>，它其实<strong>更像是一种批处理</strong>。</p><p>传统数据库意义上的事务，是将多条 SQL 语句作为一个整体，如果其中任何一条语句执行失败，那么这些语句都不会被执行。但是Redis的事务，<strong>如果有某一条命令执行失败，其后的命令仍然会执行</strong>。</p><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>开启事务(类似：begin transaction)</td><td>multi</td></tr><tr><td>提交事务（类似：commit）</td><td>exec</td></tr><tr><td>事务回滚（类似：rollback）</td><td>discard</td></tr></tbody></table><div class="hljs"><pre><code class="hljs accesslog">wxs@ubuntu:/usr/local/redis/src$ ./redis-cli <span class="hljs-number">127.0.0.1:6379</span>&gt; set num <span class="hljs-number">1</span>OK<span class="hljs-number">127.0.0.1:6379</span>&gt; set name jitwxsOK<span class="hljs-number">127.0.0.1:6379</span>&gt; multi #开启事务OK<span class="hljs-number">127.0.0.1:6379</span>&gt; incr numQUEUED<span class="hljs-number">127.0.0.1:6379</span>&gt; incr nameQUEUED<span class="hljs-number">127.0.0.1:6379</span>&gt; set age <span class="hljs-number">20</span>QUEUED<span class="hljs-number">127.0.0.1:6379</span>&gt; exec #执行事务<span class="hljs-number">1</span>) (integer) <span class="hljs-number">2</span><span class="hljs-number">2</span>) (error) ERR value is not an integer or out of range #命令报错<span class="hljs-number">3</span>) OK #前面命令出错后这条命令仍然执行了<span class="hljs-number">127.0.0.1:6379</span>&gt; get num<span class="hljs-string">"2"</span><span class="hljs-number">127.0.0.1:6379</span>&gt; get name<span class="hljs-string">"jitwxs"</span><span class="hljs-number">127.0.0.1:6379</span>&gt; get age #该命令的确执行了<span class="hljs-string">"20"</span><span class="hljs-number">127.0.0.1:6379</span>&gt;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. Redis--Redis的数据类型</title>
    <link href="/2020/06/05/3-Redis-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2020/06/05/3-Redis-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>Redis支持以下五种数据结构：</p><ul><li>String类型</li><li>List类型</li><li>Set类型</li><li>SortedSet类型</li><li>Hash类型</li></ul><table><thead><tr><th>存储极限</th><th>大小</th></tr></thead><tbody><tr><td>String类型的value大小</td><td>512M</td></tr><tr><td>Hash类型key的键值对大小</td><td>4294967295</td></tr><tr><td>List类型的key个数</td><td>4294967295</td></tr><tr><td>Set/SortedSet类型的key个数</td><td>4294967295</td></tr></tbody></table><h2 id="一、String（字符串）类型"><a href="#一、String（字符串）类型" class="headerlink" title="一、String（字符串）类型"></a>一、String（字符串）类型</h2><p>在前面两章中，我们存储的都是 String 类型。该类型增加和删除一个键值对十分简单，如下：</p><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>获取值</td><td>get key</td></tr><tr><td>添加一个键值对</td><td>set key value</td></tr><tr><td>获取并重置一个键值对</td><td>getset key value</td></tr><tr><td>删除一个键值对</td><td>del key</td></tr></tbody></table><p><strong>字符串也可以进行数值操作</strong>（Redis内部自动将value转换为数值型），方法如下：</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>incr key</td><td>值加1</td></tr><tr><td>decr key</td><td>值减1</td></tr><tr><td>incrby key n</td><td>值加n</td></tr><tr><td>decrby key n</td><td>值减n</td></tr></tbody></table><p>如果key值不存在，当做0处理，如果value值无法转换为整型时，会返回错误信息：</p><p><img src="https://img-blog.csdnimg.cn/20200605223023304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>介绍一下字符串拼接方法，如下：</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>append key</td><td>拼接字符串</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/2020060522335293.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h2><p>Redis设计了一种<strong>简单动态字符串SDS</strong>作为底层实现，此对象包含三个属性:</p><ul><li>len：buf中已经占用的长度；</li><li>free：buf中未使用的缓冲区长度；</li><li>buf[]：实际保存字符串数据的地方；</li></ul><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><h3 id="１、常数复杂度获取字符串长度"><a href="#１、常数复杂度获取字符串长度" class="headerlink" title="１、常数复杂度获取字符串长度"></a>１、常数复杂度获取字符串长度</h3><p>​    通过<code>strlen key</code>命令获取key的字符串长度，其时间复杂度变为O(1)。</p><h3 id="2、杜绝缓冲区溢出"><a href="#2、杜绝缓冲区溢出" class="headerlink" title="2、杜绝缓冲区溢出"></a>2、杜绝缓冲区溢出</h3><p>对于 SDS 数据类型，在进行字符修改的时候，会首先根据记录的 len 属性检查内存空间是否满足需求，如果不满足，会进行相应的空间扩展，然后再进行修改操作，所以不会出现缓冲区溢出。</p><h3 id="3、减少修改字符串的内存重新分配次数"><a href="#3、减少修改字符串的内存重新分配次数" class="headerlink" title="3、减少修改字符串的内存重新分配次数"></a>3、减少修改字符串的内存重新分配次数</h3><p>通过未使用空间，SDS实现了<code>空间预分配</code>和<code>惰性空间释放</code>两种优化策略。</p><p><strong>空间预分配：</strong></p><p>当len小于IMB（1024<em>1024）时*</em>增加<strong>字符串分配空间大小为原来的</strong>2倍+1<strong>字节，当len大于等于1M时每次分配额外多分配</strong>1M**的空间。好处是SDS将连续增长Ｎ次字符串所需的内存重分配次数从必然Ｎ次降低为最多Ｎ次。</p><p><strong>惰性空间释放：</strong></p><p>用于优化SDS字符串<strong>缩短</strong>操作，当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用<code>free</code>属性来将这些字节的数量记录起来，并等待将来使用。</p><p>通过惰性空间释放策略，SDS避免了缩短字符串时所需的内存重分配操作，并为将来有可能的增长操作提供了优化。</p><h3 id="4、二进制安全"><a href="#4、二进制安全" class="headerlink" title="4、二进制安全"></a>4、二进制安全</h3><p>​    因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。</p><h3 id="5、兼容部分C-字符串函数"><a href="#5、兼容部分C-字符串函数" class="headerlink" title="5、兼容部分C 字符串函数"></a>5、兼容部分C 字符串函数</h3><p>​    因为buf[]中依然采用了C语言的以<code>\0</code>结尾，因此可以直接使用C语言的部分标准C字符串库函数。</p><h2 id="二、Hash（散列）类型"><a href="#二、Hash（散列）类型" class="headerlink" title="二、Hash（散列）类型"></a>二、Hash（散列）类型</h2><p>Redis的字典使用哈希表作为底层实现。</p><p>散列，即 Hash，Redis 中的 Hash 类型可以看成<strong>Map集合</strong>。Hash 类型的<strong>每一个 key 的 value 对应于一个 Map，该Map包含多个键值对的数据</strong>，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200605231035860.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="2-1-赋值"><a href="#2-1-赋值" class="headerlink" title="2.1 赋值"></a>2.1 赋值</h3><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>hset key field value</td><td>为指定key设置一个键值对</td></tr><tr><td>hmset key field value[field2 value2…]</td><td>为指定key设置多个键值对</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/2020060523171942.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="2-2-取值"><a href="#2-2-取值" class="headerlink" title="2.2 取值"></a>2.2 取值</h3><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>hget key field</td><td>返回指定 key 中 field 的值</td></tr><tr><td>hmget key filed[field2…]</td><td>返回指定 key 中多个 field 的值</td></tr><tr><td>hgetall key</td><td>返回指定 key 中所有 field-value</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/2020060523191135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="2-3-删除"><a href="#2-3-删除" class="headerlink" title="2.3 删除"></a>2.3 删除</h3><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>hdel key field[field2…]</td><td>删除指定 key 一个或多个 field</td></tr><tr><td>del key</td><td>清空 Hash</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/20200605232227429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="2-4-扩展命令"><a href="#2-4-扩展命令" class="headerlink" title="2.4 扩展命令"></a>2.4 扩展命令</h3><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>hexists key field</td><td>判断指定 key 中 field 是否存在</td></tr><tr><td>hlen key</td><td>返回指定 key 中 field 的数量</td></tr><tr><td>hkeys key</td><td>获取指定 key 中所有的 field</td></tr><tr><td>hvals key</td><td>获取指定 key 中所有的 value</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hmset myHash name yyj age <span class="hljs-number">20</span> sex maleOK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hexists myHash name(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hexists myHash unknown(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">0</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hlen myHash(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hkeys myHash<span class="hljs-number">1</span>) <span class="hljs-string">"name"</span><span class="hljs-number">2</span>) <span class="hljs-string">"age"</span><span class="hljs-number">3</span>) <span class="hljs-string">"sex"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hvals myHash<span class="hljs-number">1</span>) <span class="hljs-string">"yyj"</span><span class="hljs-number">2</span>) <span class="hljs-string">"20"</span><span class="hljs-number">3</span>) <span class="hljs-string">"male"</span></code></pre></div><p>Hash底层的数据结构实现有两种：</p><ul><li>一种是<code>ziplist</code>，当存储的数据操作配置的阈值时就是转用hashtable的结构，比较消耗性能；</li><li>另一种是<code>hashtable</code>，会消耗比较多的内存空间。</li></ul><p>Redis 的Hash采用<code>链地址法</code>来处理冲突，没有用到红黑树优化，被分配到同一索引上的多个键值对会连接成一个单向链表；</p><p>在对哈希表进行扩展或收缩操作时，程序需要将现有哈希表包含的所有键值对refresh到新的哈希表里面，并且这个rehash过程并不是一次性地完成， 而是渐进式完成的。</p><p>在渐进式rehash执行期间，新添加到字典的键值对一律会被保存到ht[1]里面，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量随着rehash操作的执行而最终减少为0。</p><h2 id="三、List-类型"><a href="#三、List-类型" class="headerlink" title="三、List 类型"></a>三、List 类型</h2><p>C语言内部没有内置链表这种数据结构，所以Redis自己构建了链表的实现，Redis 的 List 类型有点像 Java 中的 LinkedList，内部实现是一个<code>双向链表</code>，双向链表的知识点参考文章：<a href="https://www.jitwxs.cn/abd3f641.html" target="_blank" rel="noopener">《数据结构 第二章 线性表》</a>。</p><h3 id="3-1-添加"><a href="#3-1-添加" class="headerlink" title="3.1 添加"></a>3.1 添加</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>从左端添加多个value</td><td>lpush key value[value2…]</td></tr><tr><td>从右端添加多个value</td><td>rpush key value[value2…]</td></tr></tbody></table><p><strong>注：</strong> 如果 key 不存在会先创建 key，然后添加。</p><p><img src="https://img-blog.csdnimg.cn/20200605233016372.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="3-2-查看"><a href="#3-2-查看" class="headerlink" title="3.2 查看"></a>3.2 查看</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>获取 list 从 start 到 end 的值</td><td>lrange key start end</td></tr><tr><td>获取 list 中元素数量</td><td>llen key</td></tr></tbody></table><p>因为 List 内部是一个双向链表，因此链表<strong>首元素下标为0，尾元素下标为-1</strong>，因此查看所有元素即：<code>lrange key 0 -1</code>。</p><p><img src="https://img-blog.csdnimg.cn/20200605233241255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="3-3-删除"><a href="#3-3-删除" class="headerlink" title="3.3 删除"></a>3.3 删除</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>返回并弹出左端元素</td><td>lpop key</td></tr><tr><td>返回并弹出右端元素</td><td>rpop key</td></tr></tbody></table><p><strong>注：</strong> 如果 key 不存在，返回nil。</p><p><img src="https://img-blog.csdnimg.cn/20200605233444391.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="3-4-扩展命令"><a href="#3-4-扩展命令" class="headerlink" title="3.4 扩展命令"></a>3.4 扩展命令</h3><h4 id="3-4-1-添加前检查-key-的存在性"><a href="#3-4-1-添加前检查-key-的存在性" class="headerlink" title="3.4.1 添加前检查 key 的存在性"></a>3.4.1 添加前检查 key 的存在性</h4><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>从左端添加多个 value</td><td>lpushx key value[value2…]</td></tr><tr><td>从右端添加多个 value</td><td>rpushx key value[value2…]</td></tr></tbody></table><p>这两个方法加了 <code>x</code> 的和之前不加 <code>x</code> 的不同之处是：如果 key 不存在，将<strong>不进行插入</strong>。</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; del myList(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lpushx myList a b c(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">0</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span>(empty list <span class="hljs-keyword">or</span> <span class="hljs-keyword">set</span>)</code></pre></div><h4 id="3-4-2-根据-value-删除"><a href="#3-4-2-根据-value-删除" class="headerlink" title="3.4.2 根据 value 删除"></a>3.4.2 根据 value 删除</h4><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>删除 count 个值为 value 的元素</td><td>lrem key count value</td></tr></tbody></table><p>若 count &gt; 0，则从左到右删除：</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush myList <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">6</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"2"</span><span class="hljs-number">3</span>) <span class="hljs-string">"1"</span><span class="hljs-number">4</span>) <span class="hljs-string">"3"</span><span class="hljs-number">5</span>) <span class="hljs-string">"5"</span><span class="hljs-number">6</span>) <span class="hljs-string">"1"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrem myList <span class="hljs-number">2</span> <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">2</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"2"</span><span class="hljs-number">2</span>) <span class="hljs-string">"3"</span><span class="hljs-number">3</span>) <span class="hljs-string">"5"</span><span class="hljs-number">4</span>) <span class="hljs-string">"1"</span></code></pre></div><p>若 count &lt; 0，则从右向左删除：</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush myList <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">6</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"2"</span><span class="hljs-number">3</span>) <span class="hljs-string">"1"</span><span class="hljs-number">4</span>) <span class="hljs-string">"3"</span><span class="hljs-number">5</span>) <span class="hljs-string">"5"</span><span class="hljs-number">6</span>) <span class="hljs-string">"1"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrem myList <span class="hljs-number">-2</span> <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">2</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"2"</span><span class="hljs-number">3</span>) <span class="hljs-string">"3"</span><span class="hljs-number">4</span>) <span class="hljs-string">"5"</span></code></pre></div><p>若 count = 0，删除所有：</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush myList <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">6</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"2"</span><span class="hljs-number">3</span>) <span class="hljs-string">"1"</span><span class="hljs-number">4</span>) <span class="hljs-string">"3"</span><span class="hljs-number">5</span>) <span class="hljs-string">"5"</span><span class="hljs-number">6</span>) <span class="hljs-string">"1"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrem myList <span class="hljs-number">0</span> <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"2"</span><span class="hljs-number">2</span>) <span class="hljs-string">"3"</span><span class="hljs-number">3</span>) <span class="hljs-string">"5"</span></code></pre></div><h4 id="3-4-3-根据下标设置-value"><a href="#3-4-3-根据下标设置-value" class="headerlink" title="3.4.3 根据下标设置 value"></a>3.4.3 根据下标设置 value</h4><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>设置下标为 index 的元素值。0代表最左边元素，-1代表最右边元素，下标不存在时抛出异常。</td><td>lset key index value</td></tr></tbody></table><div class="hljs"><pre><code class="hljs tcl"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush myList <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>(integer) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">lset</span> myList <span class="hljs-number">1</span> <span class="hljs-number">5</span>OK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">lrange</span> myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"5"</span><span class="hljs-number">3</span>) <span class="hljs-string">"3"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">lset</span> myList <span class="hljs-number">3</span> <span class="hljs-number">5</span>(<span class="hljs-keyword">error</span>) ERR index out of range</code></pre></div><h4 id="3-4-4-相对于某元素插入-value"><a href="#3-4-4-相对于某元素插入-value" class="headerlink" title="3.4.4 相对于某元素插入 value"></a>3.4.4 相对于某元素插入 value</h4><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>在 pivot 元素前插入value</td><td>linsert key before pivot value</td></tr><tr><td>在 pivot 元素后插入value</td><td>linsert key after pivot value</td></tr></tbody></table><p>注：如果 pivot 不存在，不插入。</p><div class="hljs"><pre><code class="hljs tcl"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush myList <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>(integer) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">linsert</span> myList before <span class="hljs-number">2</span> a(integer) <span class="hljs-number">4</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">linsert</span> myList <span class="hljs-keyword">after</span> <span class="hljs-number">2</span> b(integer) <span class="hljs-number">5</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">lrange</span> myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"a"</span><span class="hljs-number">3</span>) <span class="hljs-string">"2"</span><span class="hljs-number">4</span>) <span class="hljs-string">"b"</span><span class="hljs-number">5</span>) <span class="hljs-string">"3"</span></code></pre></div><h4 id="3-4-5-将链表-A-右边元素移出并添加到链表B-左边"><a href="#3-4-5-将链表-A-右边元素移出并添加到链表B-左边" class="headerlink" title="3.4.5 将链表 A 右边元素移出并添加到链表B 左边"></a>3.4.5 将链表 A 右边元素移出并添加到链表B 左边</h4><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>将链表 A 右边元素移出并添加到链表 B 左边</td><td>rpoplpush listA listB</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush myListA <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush myListB a b c(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpoplpush myListA myListB<span class="hljs-string">"3"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myListA <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"2"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myListB <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"3"</span><span class="hljs-number">2</span>) <span class="hljs-string">"a"</span><span class="hljs-number">3</span>) <span class="hljs-string">"b"</span><span class="hljs-number">4</span>) <span class="hljs-string">"c"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpoplpush myListA myListA<span class="hljs-string">"2"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myListA <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"2"</span><span class="hljs-number">2</span>) <span class="hljs-string">"1"</span></code></pre></div><p>链表被广泛用于实现Redis的各种功能，比如 ：列表键，发布于订阅，慢查询，监视器等；Redis的链表实现是双向链表，可以用于保存各种不同类型的值，可以直接获得头尾节点，常数时间复杂度获得链表长度。</p><h3 id="3-5-特点"><a href="#3-5-特点" class="headerlink" title="3.5 特点"></a>3.5 特点</h3><ul><li>双端：具有前置节点和后置节点的引用，获取这两个节点时间复杂度都是O(1)；</li><li><strong>无环</strong>：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问都是以NULL结束；</li><li><strong>带链表长度计数器</strong>：通过len属性获取链表长度的时间复杂度为O(1)；</li><li>多态：可以保存各种不同类型的值。</li></ul><h2 id="四、Set-类型"><a href="#四、Set-类型" class="headerlink" title="四、Set 类型"></a>四、Set 类型</h2><p>Redis 的 Set 类型和 Java 中的 Set 类型一样，它具有两个重要的特点：<code>无序性</code>和<code>唯一性</code>，具体不再赘述。</p><h3 id="4-1-基本操作"><a href="#4-1-基本操作" class="headerlink" title="4.1 基本操作"></a>4.1 基本操作</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>向 set 中添加成员，如果成员已存在，不再添加</td><td>sadd key member[member2…]</td></tr><tr><td>向 set 中删除成员，如果不存在，也不会报错</td><td>srem key member[member2…]</td></tr><tr><td>获取 set 中所有成员</td><td>smembers key</td></tr><tr><td>判断指定成员是否存在于 set 中</td><td>sismember key member</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sadd mySet <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; smembers mySet<span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"2"</span><span class="hljs-number">3</span>) <span class="hljs-string">"3"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; srem mySet <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">2</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; smembers mySet<span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sismember mySet <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sismember mySet <span class="hljs-number">2</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">0</span></code></pre></div><h3 id="4-2-集合操作"><a href="#4-2-集合操作" class="headerlink" title="4.2 集合操作"></a>4.2 集合操作</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>集合的差集</td><td>sdiff key1 key2[key3…]</td></tr><tr><td>集合的交集</td><td>sinter key1 key2[key3…]</td></tr><tr><td>集合的并集</td><td>sunion key1 key2[key3…]</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sadd mySet1 a b c <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">4</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sadd mySet2 <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> b(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">4</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sdiff mySet1 mySet2<span class="hljs-number">1</span>) <span class="hljs-string">"a"</span><span class="hljs-number">2</span>) <span class="hljs-string">"c"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sdiff mySet2 mySet1<span class="hljs-number">1</span>) <span class="hljs-string">"2"</span><span class="hljs-number">2</span>) <span class="hljs-string">"3"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sinter mySet1 mySet2<span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><span class="hljs-number">2</span>) <span class="hljs-string">"b"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sunion mySet1 mySet2<span class="hljs-number">1</span>) <span class="hljs-string">"c"</span><span class="hljs-number">2</span>) <span class="hljs-string">"1"</span><span class="hljs-number">3</span>) <span class="hljs-string">"b"</span><span class="hljs-number">4</span>) <span class="hljs-string">"2"</span><span class="hljs-number">5</span>) <span class="hljs-string">"a"</span><span class="hljs-number">6</span>) <span class="hljs-string">"3"</span></code></pre></div><h3 id="4-3-扩展命令"><a href="#4-3-扩展命令" class="headerlink" title="4.3 扩展命令"></a>4.3 扩展命令</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>求 set 中成员数量</td><td>scard key</td></tr><tr><td>随机返回一个成员</td><td>srandmember key</td></tr><tr><td>将多个集合的差集存储在 desc 中</td><td>sdiffstore desc key1 key2[key3…]</td></tr><tr><td>将多个集合的交集存储在 desc 中</td><td>sinterstore desc key1 key2[key3…]</td></tr><tr><td>将多个集合的并集存储在 desc 中</td><td>sunionstore desc key1 key2[key3…]</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; smembers mySet1<span class="hljs-number">1</span>) <span class="hljs-string">"a"</span><span class="hljs-number">2</span>) <span class="hljs-string">"c"</span><span class="hljs-number">3</span>) <span class="hljs-string">"1"</span><span class="hljs-number">4</span>) <span class="hljs-string">"b"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; smembers mySet2<span class="hljs-number">1</span>) <span class="hljs-string">"3"</span><span class="hljs-number">2</span>) <span class="hljs-string">"b"</span><span class="hljs-number">3</span>) <span class="hljs-string">"2"</span><span class="hljs-number">4</span>) <span class="hljs-string">"1"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; scard mySet1(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">4</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; srandmember mySet1<span class="hljs-string">"c"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sdiffstore mySet3 mySet1 mySet2(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">2</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; smembers mySet3<span class="hljs-number">1</span>) <span class="hljs-string">"a"</span><span class="hljs-number">2</span>) <span class="hljs-string">"c"</span></code></pre></div><h2 id="五、SortedSet-类型"><a href="#五、SortedSet-类型" class="headerlink" title="五、SortedSet 类型"></a>五、SortedSet 类型</h2><p>SortedSet 和 Set 的区别是，SortedSet 中每一个成员都有一个 <code>score（分数）</code>与之关联，Redis 通过 score 来为集合中的元素进行排序（默认为升序）。</p><p>它的存储方式有两种：</p><ul><li>压缩列表（ziplist）结构：member和score顺序存放并按score的顺序排列；</li><li>skiplist和dict的结合：skiplist是一种<strong>跳跃表</strong>结构，用于有序集合中快速查找，dict用来存储元素信息，并且dict的访问时间复杂度为O(1)。</li></ul><p>Redis的跳跃表实现由<code>zskiplist</code>和<code>zskiplistNode</code>两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头结点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点。</p><h3 id="5-1-添加-获取元素"><a href="#5-1-添加-获取元素" class="headerlink" title="5.1 添加/获取元素"></a>5.1 添加/获取元素</h3><table><thead><tr><th align="left">含义</th><th>方法</th></tr></thead><tbody><tr><td align="left">添加成员。如果成员存在，会用新的 score 替代原有的 score，返回值是新加入到集合中的成员个数</td><td>zadd key score member[score2 member2… ]</td></tr><tr><td align="left">获取指定成员的 score</td><td>zscore key member</td></tr><tr><td align="left">获取 key 中成员个数</td><td>scard key</td></tr><tr><td align="left">获取集合中下标从 start 到 end 的成员，[withscores]表明返回的成员包含其 score</td><td>zrange key start end[withscores]</td></tr><tr><td align="left">上面方法的反转</td><td>zrevrange key start end[withscores]</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zadd mySort <span class="hljs-number">82</span> wangnima <span class="hljs-number">100</span> cat <span class="hljs-number">33</span> dog <span class="hljs-number">43</span> jitwxs <span class="hljs-number">80</span> zhouyang <span class="hljs-number">60</span> liuchang(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">6</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zscore mySort jitwxs<span class="hljs-string">"100"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zcard mySort(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">6</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"dog"</span><span class="hljs-number">2</span>) <span class="hljs-string">"liuchang"</span><span class="hljs-number">3</span>) <span class="hljs-string">"zhouyang"</span><span class="hljs-number">4</span>) <span class="hljs-string">"wangnima"</span><span class="hljs-number">5</span>) <span class="hljs-string">"cat"</span><span class="hljs-number">6</span>) <span class="hljs-string">"jitwxs"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span> withscores <span class="hljs-number">1</span>) <span class="hljs-string">"dog"</span> <span class="hljs-number">2</span>) <span class="hljs-string">"33"</span> <span class="hljs-number">3</span>) <span class="hljs-string">"liuchang"</span> <span class="hljs-number">4</span>) <span class="hljs-string">"60"</span> <span class="hljs-number">5</span>) <span class="hljs-string">"zhouyang"</span> <span class="hljs-number">6</span>) <span class="hljs-string">"80"</span> <span class="hljs-number">7</span>) <span class="hljs-string">"wangnima"</span> <span class="hljs-number">8</span>) <span class="hljs-string">"82"</span> <span class="hljs-number">9</span>) <span class="hljs-string">"cat"</span><span class="hljs-number">10</span>) <span class="hljs-string">"100"</span><span class="hljs-number">11</span>) <span class="hljs-string">"jitwxs"</span><span class="hljs-number">12</span>) <span class="hljs-string">"100"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrevrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span> withscores <span class="hljs-number">1</span>) <span class="hljs-string">"jitwxs"</span> <span class="hljs-number">2</span>) <span class="hljs-string">"100"</span> <span class="hljs-number">3</span>) <span class="hljs-string">"cat"</span> <span class="hljs-number">4</span>) <span class="hljs-string">"100"</span> <span class="hljs-number">5</span>) <span class="hljs-string">"wangnima"</span> <span class="hljs-number">6</span>) <span class="hljs-string">"82"</span> <span class="hljs-number">7</span>) <span class="hljs-string">"zhouyang"</span> <span class="hljs-number">8</span>) <span class="hljs-string">"80"</span> <span class="hljs-number">9</span>) <span class="hljs-string">"liuchang"</span><span class="hljs-number">10</span>) <span class="hljs-string">"60"</span><span class="hljs-number">11</span>) <span class="hljs-string">"dog"</span><span class="hljs-number">12</span>) <span class="hljs-string">"33"</span></code></pre></div><h3 id="5-2-删除元素"><a href="#5-2-删除元素" class="headerlink" title="5.2 删除元素"></a>5.2 删除元素</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>删除成员</td><td>zrem key member[member2…]</td></tr><tr><td>按照下标范围删除成员</td><td>zremrangebyrank key start stop</td></tr><tr><td>按照 score 范围删除成员</td><td>zremrangebyscore key min max</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrem mySort wangnima(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zcard mySort(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">5</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"dog"</span><span class="hljs-number">2</span>) <span class="hljs-string">"liuchang"</span><span class="hljs-number">3</span>) <span class="hljs-string">"zhouyang"</span><span class="hljs-number">4</span>) <span class="hljs-string">"cat"</span><span class="hljs-number">5</span>) <span class="hljs-string">"jitwxs"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zremrangebyrank mySort <span class="hljs-number">0</span> <span class="hljs-number">2</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"cat"</span><span class="hljs-number">2</span>) <span class="hljs-string">"jitwxs"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span> withscores <span class="hljs-number">1</span>) <span class="hljs-string">"dog"</span> <span class="hljs-number">2</span>) <span class="hljs-string">"33"</span> <span class="hljs-number">3</span>) <span class="hljs-string">"jitwxs"</span> <span class="hljs-number">4</span>) <span class="hljs-string">"43"</span> <span class="hljs-number">5</span>) <span class="hljs-string">"liuchang"</span> <span class="hljs-number">6</span>) <span class="hljs-string">"60"</span> <span class="hljs-number">7</span>) <span class="hljs-string">"zhouyang"</span> <span class="hljs-number">8</span>) <span class="hljs-string">"80"</span> <span class="hljs-number">9</span>) <span class="hljs-string">"wangnima"</span><span class="hljs-number">10</span>) <span class="hljs-string">"82"</span><span class="hljs-number">11</span>) <span class="hljs-string">"cat"</span><span class="hljs-number">12</span>) <span class="hljs-string">"100"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zremrangebyscore mySort <span class="hljs-number">50</span> <span class="hljs-number">85</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span> withscores<span class="hljs-number">1</span>) <span class="hljs-string">"dog"</span><span class="hljs-number">2</span>) <span class="hljs-string">"33"</span><span class="hljs-number">3</span>) <span class="hljs-string">"jitwxs"</span><span class="hljs-number">4</span>) <span class="hljs-string">"43"</span><span class="hljs-number">5</span>) <span class="hljs-string">"cat"</span><span class="hljs-number">6</span>) <span class="hljs-string">"100"</span></code></pre></div><h3 id="5-3-扩展方法"><a href="#5-3-扩展方法" class="headerlink" title="5.3 扩展方法"></a>5.3 扩展方法</h3><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>返回 score 在[min,max]的成员并按照 score 排序。[withscores]：显示 score；[limit offset count]：从 offst 开始返回 count 个成员</td><td>zrangebyscore key min max[withscores] [limit offset count]</td></tr><tr><td>设置指定成员增加的分数，返回值是修改后的分数</td><td>zincrby key increment member</td></tr><tr><td>获取分数在[min,max]的成员数量</td><td>zcount key min max</td></tr><tr><td>返回成员在集合中的排名（升序）</td><td>zrank key member</td></tr><tr><td>返回成员在集合中的排名（降序）</td><td>zrevrank key member</td></tr></tbody></table><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mySort <span class="hljs-number">0</span> <span class="hljs-number">-1</span> withscores <span class="hljs-number">1</span>) <span class="hljs-string">"dog"</span> <span class="hljs-number">2</span>) <span class="hljs-string">"33"</span> <span class="hljs-number">3</span>) <span class="hljs-string">"jitwxs"</span> <span class="hljs-number">4</span>) <span class="hljs-string">"43"</span> <span class="hljs-number">5</span>) <span class="hljs-string">"liuchang"</span> <span class="hljs-number">6</span>) <span class="hljs-string">"60"</span> <span class="hljs-number">7</span>) <span class="hljs-string">"zhouyang"</span> <span class="hljs-number">8</span>) <span class="hljs-string">"80"</span> <span class="hljs-number">9</span>) <span class="hljs-string">"wangnima"</span><span class="hljs-number">10</span>) <span class="hljs-string">"82"</span><span class="hljs-number">11</span>) <span class="hljs-string">"cat"</span><span class="hljs-number">12</span>) <span class="hljs-string">"100"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrangebyscore mySort <span class="hljs-number">30</span> <span class="hljs-number">86</span> limit <span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-number">1</span>) <span class="hljs-string">"liuchang"</span><span class="hljs-number">2</span>) <span class="hljs-string">"zhouyang"</span><span class="hljs-number">3</span>) <span class="hljs-string">"wangnima"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zcount mySort <span class="hljs-number">0</span> <span class="hljs-number">60</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zincrby mySort <span class="hljs-number">17</span> jitwxs<span class="hljs-string">"60"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrank mySort jitwxs(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrevrank mySort jitwxs(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">4</span></code></pre></div><h3 id="5-4-跳跃表"><a href="#5-4-跳跃表" class="headerlink" title="5.4 跳跃表"></a>5.4 跳跃表</h3><ul><li>搜索：从最高层的链表节点开始，如果比当前节点要大和比当前层的下一个节点要小，那么往下找，也就是和当前层的下一层的节点的下一个节点进行比较，以此类推，直到找到最底层的最后一个节点，如果找到则返回，反之则返回空；</li><li>插入：首先确定插入的层数，有一种方法是假设抛一枚硬币，如果是正面就累加，直到遇见反面为止，最后记录正面的次数作为插入的层数，当确定插入的层数k后，则需要将新元素插入到从底层到k层；</li><li>删除：在各个层中找到包含指定值的节点，然后将节点从链表中删除即可，如果删除以后只剩下首尾两个节点，则删除这一层。</li></ul><h2 id="六、key-的通用命令"><a href="#六、key-的通用命令" class="headerlink" title="六、key 的通用命令"></a>六、key 的通用命令</h2><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>获取所有于 pattern 匹配的 key。*：任意一个或多个字符，？：任意一个字符</td><td><strong>keys pattern</strong></td></tr><tr><td>删除指定 key</td><td>del key[key2…]</td></tr><tr><td><strong>判断 key 是否存在</strong></td><td><strong>exists key</strong></td></tr><tr><td>为 key 重命名</td><td>rename key newKey</td></tr><tr><td>设置过期时间（单位s）</td><td><strong>expire key</strong></td></tr><tr><td>获取key 剩余的过期时间（单位s）。若没有设置过期时间，返回-1；超时不存在返回-2</td><td><strong>ttl key</strong></td></tr><tr><td>获取 key 类型，key 不存在返回none</td><td>type key</td></tr></tbody></table><p>注：如果你设置了一个 key 的过期时间，如果又不想让它过期，可以执行命令 <code>persist key</code>。</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; keys * <span class="hljs-number">1</span>) <span class="hljs-string">"unknown"</span> <span class="hljs-number">2</span>) <span class="hljs-string">"mySet2"</span> <span class="hljs-number">3</span>) <span class="hljs-string">"float_num"</span> <span class="hljs-number">4</span>) <span class="hljs-string">"myListB"</span> <span class="hljs-number">5</span>) <span class="hljs-string">"mySet3"</span> <span class="hljs-number">6</span>) <span class="hljs-string">"userName"</span> <span class="hljs-number">7</span>) <span class="hljs-string">"myListA"</span> <span class="hljs-number">8</span>) <span class="hljs-string">"int_num"</span> <span class="hljs-number">9</span>) <span class="hljs-string">"mySort"</span><span class="hljs-number">10</span>) <span class="hljs-string">"mySet1"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; del unknown(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; type myListAlist<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rename myListA myListOK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; exists myListA(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">0</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; ttl mySort(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">-1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; expire mySort <span class="hljs-number">30</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; ttl mySort(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">-2</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; keys *<span class="hljs-number">1</span>) <span class="hljs-string">"mySet2"</span><span class="hljs-number">2</span>) <span class="hljs-string">"myList"</span><span class="hljs-number">3</span>) <span class="hljs-string">"float_num"</span><span class="hljs-number">4</span>) <span class="hljs-string">"myListB"</span><span class="hljs-number">5</span>) <span class="hljs-string">"mySet3"</span><span class="hljs-number">6</span>) <span class="hljs-string">"userName"</span><span class="hljs-number">7</span>) <span class="hljs-string">"int_num"</span><span class="hljs-number">8</span>) <span class="hljs-string">"mySet1"</span></code></pre></div><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><ul><li><p>大多数情况下，Redis使用简单字符串SDS作为字符串的表示，相对于C语言字符串，SDS具有常数复杂度获取字符串长度，杜绝了缓冲区的溢出，减少了修改字符串长度时所需的内存重分配次数，以及二进制安全，能存储各种类型文件，并且还兼容部分C语言函数。</p></li><li><p>通过链表设置不同类型的特定函数，Redis链表可以保存各种不同类型的值，除了用作列表键，还在发布与订阅，慢查询，监视器等方面发挥作用；</p></li><li><p>Redis的字典底层使用哈希表实现，每个字典通常有两个哈希表，一个平时使用，另一个用于rehash操作，使用<strong>链地址法</strong>解决哈希冲突；</p></li><li><p>跳跃表通常是有序集合的底层实现之一，表中的节点按照分值大小进行排序；</p></li><li><p>整数集合是集合键的底层实现之一，底层由数组构成，升级特性能尽可能减少内存；</p></li><li><p><strong>压缩链表</strong>是Redis为节省内存而开发的顺序型数据结构，通常作为列表键和哈希键的底层实现之一。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. Redis--Jedis的使用</title>
    <link href="/2020/06/05/2-Redis-Jedis%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/06/05/2-Redis-Jedis%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>在Linux中开启redis服务，并传入一个变量username，赋值为yyj：<br><img src="https://img-blog.csdnimg.cn/20200605211103310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="第一个Jedis程序"><a href="#第一个Jedis程序" class="headerlink" title="第一个Jedis程序"></a>第一个Jedis程序</h1><h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-pool<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hamcrest<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hamcrest-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//1.获得连接对象，参数为redis所在的服务器地址及端口号</span>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">"192.168.75.130"</span>, <span class="hljs-number">6379</span>);        <span class="hljs-comment">//2.获得数据</span>        String username = jedis.get(<span class="hljs-string">"username"</span>);        System.out.println(username);        jedis.close();    &#125;&#125;</code></pre></div><p>这里的redis服务器地址查找方式：</p><div class="hljs"><pre><code class="hljs java">yyj<span class="hljs-meta">@yyj</span>-virtual-machine:~$ ifconfig -a</code></pre></div><p>这样我们通过运行Redis的主机IP地址和Redis的端口号，然后就可以直接get到username的值了。</p><h1 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h1><p>Jedis和数据库连接库一样，都有连接池，即JedisPool，通过简单的配置即可直接从连接池中取Jedis对象。<br>测试代码如下：</p><div class="hljs"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//1.创建Jedis连接池配置</span>        JedisPoolConfig jedisPoolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();        <span class="hljs-comment">//设置最小和最大闲置个数</span>        jedisPoolConfig.setMaxIdle(<span class="hljs-number">5</span>);        jedisPoolConfig.setMaxIdle(<span class="hljs-number">10</span>);        <span class="hljs-comment">//设置连接池最大个数</span>        jedisPoolConfig.setMaxTotal(<span class="hljs-number">30</span>);        <span class="hljs-comment">//2. 创建Jedis连接池</span>        JedisPool jedisPool = <span class="hljs-keyword">new</span> JedisPool(jedisPoolConfig, <span class="hljs-string">"192.168.75.130"</span>, <span class="hljs-number">6379</span>);        <span class="hljs-comment">//3.从连接池中获取Jedis对象</span>        Jedis jedis = jedisPool.getResource();        <span class="hljs-comment">//4.操纵数据</span>        jedis.set(<span class="hljs-string">"age"</span>,<span class="hljs-string">"20"</span>);        System.out.println(jedis.get(<span class="hljs-string">"age"</span>));        <span class="hljs-comment">//5.关闭资源</span>        jedis.close();        jedisPool.close();    &#125;&#125;</code></pre></div><h1 id="封装成工具类"><a href="#封装成工具类" class="headerlink" title="封装成工具类"></a>封装成工具类</h1><p>将上面的Redis连接池封装成一个工具类，其他地方的代码直接调用工具类来执行即可。<br>首先在src下的resource目录下新建一个配置文件redis.properties，把一些配置信息存储在配置文件中：</p><div class="hljs"><pre><code class="hljs java">#Redis连接信息redis.ip = <span class="hljs-number">192.168</span><span class="hljs-number">.75</span><span class="hljs-number">.130</span>redis.port = <span class="hljs-number">6379</span>#Redis配置信息redis.minIdle = <span class="hljs-number">5</span>redis.maxIdle = <span class="hljs-number">30</span>redis.maxTotal = <span class="hljs-number">30</span></code></pre></div><p>新建 JedisUtils.java：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisUtils</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool jedisPool = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">/** 获取连接 **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title">getJedis</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(jedisPool == <span class="hljs-keyword">null</span>)&#123;            initJedisPool();        &#125;        <span class="hljs-keyword">return</span> jedisPool.getResource();    &#125;        <span class="hljs-comment">/** 关闭连接 **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeJedis</span><span class="hljs-params">(Jedis jedis)</span> </span>&#123;        jedis.close();    &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initJedisPool</span><span class="hljs-params">()</span> </span>&#123;        InputStream in = JedisUtils.class.getClassLoader().getResourceAsStream("redis.properties");        Properties properties = <span class="hljs-keyword">new</span> Properties();        <span class="hljs-keyword">try</span> &#123;            properties.load(in);            JedisPoolConfig poolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();            poolConfig.setMinIdle(Integer.parseInt(properties.getProperty(<span class="hljs-string">"redis.minIdle"</span>)));            poolConfig.setMaxIdle(Integer.parseInt(properties.getProperty(<span class="hljs-string">"redis.maxIdle"</span>)));            poolConfig.setMaxTotal(Integer.parseInt(properties.getProperty(<span class="hljs-string">"redis.maxTotal"</span>)));            jedisPool = <span class="hljs-keyword">new</span> JedisPool(                    poolConfig,                    properties.getProperty(<span class="hljs-string">"redis.ip"</span>),                    Integer.parseInt(properties.getProperty(<span class="hljs-string">"redis.port"</span>)));        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            System.out.println(<span class="hljs-string">"载入配置文件错误"</span>);            e.printStackTrace();        &#125;    &#125;&#125;</code></pre></div><p>测试代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;    Jedis jedis = JedisUtils.getJedis();    System.out.println(jedis.get(<span class="hljs-string">"age"</span>));    JedisUtils.closeJedis(jedis);&#125;</code></pre></div><p>目录结构如下：<br><img src="https://img-blog.csdnimg.cn/2020060522103795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. Redis--安装Redis</title>
    <link href="/2020/06/05/1-Redis-%E5%AE%89%E8%A3%85Redis/"/>
    <url>/2020/06/05/1-Redis-%E5%AE%89%E8%A3%85Redis/</url>
    
    <content type="html"><![CDATA[<h2 id="1-1-什么是-Redis"><a href="#1-1-什么是-Redis" class="headerlink" title="1.1 什么是 Redis"></a>1.1 什么是 Redis</h2><p>Redis 是使用 C 语言开发的一个开源的<strong>高性能键值对</strong>（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，Redis 支持以下五种数据类型：</p><ul><li>String 类型</li><li>List 类型</li><li>Set 类型</li><li>SortedSet 类型</li><li>Hash类型</li></ul><h2 id="1-2-Redis-应用场景"><a href="#1-2-Redis-应用场景" class="headerlink" title="1.2 Redis 应用场景"></a>1.2 Redis 应用场景</h2><ul><li>缓存</li><li>分布式集群架构中session分离</li><li>任务队列</li><li>…</li></ul><h2 id="1-3-安装-Redis"><a href="#1-3-安装-Redis" class="headerlink" title="1.3 安装 Redis"></a>1.3 安装 Redis</h2><p>这里我是基于Docker安装Redis</p><ol><li><p>先搜索Redis镜像</p><div class="hljs"><pre><code><pre><code class="hljs linux">yyj@yyj-virtual-machine:~$ docker search redis</code></pre></div></code></pre><p><img src="https://img-blog.csdnimg.cn/20200605201628811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li><li><p>拉取镜像</p> <div class="hljs"><pre><code class="hljs java">sudo docker pull redis:tag</code></pre></div><p><code>:tag</code>是可选的，tag表示软件的版本，默认是latest。</p><h2 id="1-4-根据镜像启动redis"><a href="#1-4-根据镜像启动redis" class="headerlink" title="1.4 根据镜像启动redis"></a>1.4 根据镜像启动redis</h2></li></ol><p>其中 Port 表示redis的端口号，PID 表示改进程的 pid 号，下方光标不停的闪动，此时 redis 就已经启动了。<br>新开一个窗口，运行redis-cli<br><img src="https://img-blog.csdnimg.cn/20200605202656380.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>测试效果：<br><img src="https://img-blog.csdnimg.cn/20200605202757404.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>Tips:如果我们要连接远程Redis，可以加参数： <code>-h IP地址</code><br>如果要指定端口，可以加参数：<code>-p 端口号</code></p></blockquote><h2 id="1-5-后端模式"><a href="#1-5-后端模式" class="headerlink" title="1.5 后端模式"></a>1.5 后端模式</h2><p>如果觉得开多个窗口麻烦，可以设置Redis启动模式为后端启动即可，仅仅只需要在运行redis的时候加上<code>-d</code>。<br><img src="https://img-blog.csdnimg.cn/20200605203644657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="1-6-退出Redis"><a href="#1-6-退出Redis" class="headerlink" title="1.6 退出Redis"></a>1.6 退出Redis</h2><p><img src="https://img-blog.csdnimg.cn/20200605203404108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13.Netty--使用UDP广播事件</title>
    <link href="/2020/06/03/13-Netty-%E4%BD%BF%E7%94%A8UDP%E5%B9%BF%E6%92%AD%E4%BA%8B%E4%BB%B6/"/>
    <url>/2020/06/03/13-Netty-%E4%BD%BF%E7%94%A8UDP%E5%B9%BF%E6%92%AD%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>UDP概述</li><li>一个广播应用程序示例</li></ul></blockquote><h1 id="UDP的基础知识"><a href="#UDP的基础知识" class="headerlink" title="UDP的基础知识"></a>UDP的基础知识</h1><p>面向连接的传输（如TCP）管理了两个网络端点之间的连接的建立，在连接的生命周期内的有序和可靠的消息传输，以及最后连接的有序终止。<br>类似于UDP这样的无连接协议中，并没有持久化连接这样的概念，并且每个消息（一个UDP数据报）都是一个单独的传输单元。</p><h1 id="UDP广播"><a href="#UDP广播" class="headerlink" title="UDP广播"></a>UDP广播</h1><p>UDP提供了向多个接收者发送消息的额外传输模式：<br>多播：传播到一个预定义的主机组<br>广播：传输到网络上的所有主机</p><h1 id="UDP示例应用程序"><a href="#UDP示例应用程序" class="headerlink" title="UDP示例应用程序"></a>UDP示例应用程序</h1><p>发布/订阅模式:一个生产者或者服务发布事件，而多个客户端进行订阅以接收它们。<br><img src="https://img-blog.csdnimg.cn/20200603212624678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>所有的在该UDP端口上监听的事件监视器都将会接收到广播消息。</p><h1 id="消息POJO：LogEvent"><a href="#消息POJO：LogEvent" class="headerlink" title="消息POJO：LogEvent"></a>消息POJO：LogEvent</h1><p>在消息处理应用程序中，数据通常由POJO表示，除了实际上的消息内容，其还可以包含配置或处理信息，在这个应用程序中，我们将会把消息作为事件处理，并且由于该数据来自于日志文件，所以我们称它为LogEvent。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogEvent</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> SEPARATOR = (<span class="hljs-keyword">byte</span>) <span class="hljs-string">':'</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> InetSocketAddress source;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String logfile;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String msg;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> received;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LogEvent</span><span class="hljs-params">(String logfile, String msg)</span> </span>&#123; <span class="hljs-comment">// 用于传出消息的构造函数</span>        <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, -<span class="hljs-number">1</span>, logfile, msg);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LogEvent</span><span class="hljs-params">(InetSocketAddress source, <span class="hljs-keyword">long</span> received, String logfile, String msg)</span> </span>&#123; <span class="hljs-comment">// 用于 传入消息的构造函数</span>        <span class="hljs-keyword">this</span>.source = source;        <span class="hljs-keyword">this</span>.logfile = logfile;        <span class="hljs-keyword">this</span>.msg = msg;        <span class="hljs-keyword">this</span>.received = received;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> InetSocketAddress <span class="hljs-title">getSource</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 返回发送LogEvent 的源的InetSocketAddress</span>        <span class="hljs-keyword">return</span> source;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLogfile</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 返回所发送的LogEvent 的日志文件的名称</span>        <span class="hljs-keyword">return</span> logfile;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMsg</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 返回消息内容</span>        <span class="hljs-keyword">return</span> msg;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getReceivedTimestamp</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 返回接收LogEvent的时间</span>        <span class="hljs-keyword">return</span> received;    &#125;&#125;</code></pre></div><p>定义好了消息组件，接下来便可以实现该应用程序的广播逻辑了。</p><h1 id="编写广播者"><a href="#编写广播者" class="headerlink" title="编写广播者"></a>编写广播者</h1><p>Netty提供了大量的类来支持UDP应用程序的编写<br><img src="https://img-blog.csdnimg.cn/20200603213229555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Netty 的DatagramPacket 是一个简单的消息容器，DatagramChannel 实现用它来和远程节点通信。它包含了接收者（和可选的发送者）的地址以及消息的有效负载本身。<br>下图展示了正在广播的3个日志条目，每个都将通过一个专门的DatagramPacket进行广播：<br><img src="https://img-blog.csdnimg.cn/20200603213320917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>下图呈现了该LogEventBroadcaster的ChannelPipeline的一个高级别视图，展示了LogEvent消息是如何流经它的。<br><img src="https://img-blog.csdnimg.cn/20200603213516499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>所有的将要被传输的数据都被封装在了LogEvent消息中，LogEventBroadcaster将把这些写入到Channel中，并通过ChannelPipeline发送它们，在那里他们将会被转换（编码）为DatagramPacket消息，最后，它们都将通过UDP被广播，并由远程节点（监视器）所捕获。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogEventEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageEncoder</span>&lt;<span class="hljs-title">LogEvent</span>&gt;</span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> InetSocketAddress remoteAddress;     <span class="hljs-comment">//LogEventEncoder创建了即将被发送到指定的InetSocketAddress的DatagramPacket消息</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LogEventEncoder</span><span class="hljs-params">(InetSocketAddress remoteAddress)</span></span>&#123;        <span class="hljs-keyword">this</span>.remoteAddress = remoteAddress;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                          LogEvent logEvent, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">byte</span>[] file = logEvent.getLogfile().getBytes(CharsetUtil.UTF_8);        <span class="hljs-keyword">byte</span>[] msg = logEvent.getMsg().getBytes(CharsetUtil.UTF_8);        ByteBuf buf = channelHandlerContext.alloc().buffer(file.length + msg.length + <span class="hljs-number">1</span>);        <span class="hljs-comment">//将文件名写入到ByteBuf中</span>        buf.writeBytes(file);        <span class="hljs-comment">//添加一个SEPARATOR</span>        buf.writeByte(LogEvent.SEPARATOR);        <span class="hljs-comment">//将日志消息写入ByteBuf中</span>        buf.writeBytes(msg);        <span class="hljs-comment">//将一个拥有数据和目的地地址的新DatagramPacket添加到出站的消息列表中</span>        out.add(<span class="hljs-keyword">new</span> io.netty.channel.socket.DatagramPacket(buf,remoteAddress));    &#125;&#125;</code></pre></div><p>在LogEventEncoder被实现之后，我们已经准备好了引导该服务器，其包括设置各种各样的ChannelOption，以及在ChannelPipeline中安装所需要的ChannelHandler。这将通过主类LogEventBroadcaster完成。如下代码所示。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogEventBroadcaster</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventLoopGroup group;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Bootstrap bootstrap;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> File file;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LogEventBroadcaster</span><span class="hljs-params">(InetSocketAddress address, File file)</span></span>&#123;        group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        bootstrap = <span class="hljs-keyword">new</span> Bootstrap();        <span class="hljs-comment">//引导该NioDatagramChannel（无连接）</span>        bootstrap.group(group).channel(NioDatagramChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                //设置<span class="hljs-title">SO_BROADCAST</span>套接字选项</span><span class="hljs-class">                .<span class="hljs-title">option</span>(<span class="hljs-title">ChannelOption</span>.<span class="hljs-title">SO_BROADCAST</span>,<span class="hljs-title">true</span>)</span><span class="hljs-class">                .<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">LogEventEncoder</span>(<span class="hljs-title">address</span>))</span>;        <span class="hljs-keyword">this</span>.file = file;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        <span class="hljs-comment">//绑定Channel</span>        Channel ch = bootstrap.bind(<span class="hljs-number">0</span>).sync().channel();        <span class="hljs-keyword">long</span> pointer = <span class="hljs-number">0</span>;        <span class="hljs-comment">//启动主处理循环</span>        <span class="hljs-keyword">for</span> (;;)&#123;            <span class="hljs-keyword">long</span> len = file.length();            <span class="hljs-keyword">if</span> (len &lt; pointer)&#123;                <span class="hljs-comment">//file was reset</span>                <span class="hljs-comment">//如果有必要，将文件指针设置到该文件的最后一个字符</span>                pointer = len;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len &gt; pointer)&#123;                <span class="hljs-comment">//Content was added</span>                RandomAccessFile raf = <span class="hljs-keyword">new</span> RandomAccessFile(file,<span class="hljs-string">"r"</span>);                <span class="hljs-comment">//设置当前的文件指针，以确保没有任何的旧日志被发送</span>                raf.seek(pointer);                String line;                <span class="hljs-keyword">while</span>((line = raf.readLine()) != <span class="hljs-keyword">null</span>)&#123;                    <span class="hljs-comment">//对于每条日志条目。，写入一个LogEvent到Channel中</span>                    ch.writeAndFlush(<span class="hljs-keyword">new</span> LogEvent(<span class="hljs-keyword">null</span>,-<span class="hljs-number">1</span>,file.getAbsolutePath(),line));                &#125;                <span class="hljs-comment">//存储其在文件中的当前位置</span>                pointer = raf.getFilePointer();                raf.close();            &#125;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//休眠1秒，如果被中断，则退出循环，否则重新处理它</span>                Thread.sleep(<span class="hljs-number">1000</span>);            &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;                Thread.interrupted();                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>&#123;        group.shutdownGracefully();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        <span class="hljs-keyword">if</span> (args.length != <span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();        &#125;        LogEventBroadcaster broadcaster = <span class="hljs-keyword">new</span> LogEventBroadcaster(                <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"255.255.255.255"</span>,Integer.parseInt(args[<span class="hljs-number">0</span>])),<span class="hljs-keyword">new</span> File(args[<span class="hljs-number">1</span>]));        <span class="hljs-keyword">try</span> &#123;            broadcaster.run();        &#125;<span class="hljs-keyword">finally</span> &#123;            broadcaster.stop();        &#125;    &#125;&#125;</code></pre></div><p>6、编写监视器</p><p>目标是将netcat替换为一个更加完整的事件消费者，我们称之为LogEventMonitor。这个程序将：</p><p>（1）接收有LogEventBroadcaster广播的UDP DatagramPacket</p><p>（2）将它们解码为LogEvent消息</p><p>（3）将LogEvent消息写到System.out</p><p>和之前一样，该逻辑由一组自定义的ChannelHandler实现——对于我们的解码器来说，我们将扩展MessageToMessageDecoder。下图描绘LogEventMonitor的ChannelPipeline，并且展示了LogEvnet是如何流经它的。<br><img src="https://img-blog.csdnimg.cn/20200603214313967.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>ChannelPipeline中的第一个解码器LogEventDecoder负责传入的DatagramPacket解码为LogEvent消息（一个用于转换入站数据的任何Netty应用程序的典型设置）</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogEventDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageDecoder</span>&lt;<span class="hljs-title">DatagramPacket</span>&gt;</span>&#123;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                          DatagramPacket datagramPacket, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//获取对DatagramPacket中的数据的引用</span>        ByteBuf data = datagramPacket.content();        <span class="hljs-comment">//获取该SEPARATOR的索引</span>        <span class="hljs-keyword">int</span> idx = data.indexOf(<span class="hljs-number">0</span>,data.readableBytes(),LogEvent.SEPARATOR);        <span class="hljs-comment">//提取文件名</span>        String fileName = data.slice(<span class="hljs-number">0</span>,idx).toString(CharsetUtil.UTF_8);        <span class="hljs-comment">//提取日志消息</span>        String logMsg = data.slice(idx + <span class="hljs-number">1</span>,data.readableBytes()).toString(CharsetUtil.UTF_8);        <span class="hljs-comment">//构建一个新的LogEvent对象，并且将它添加到列表中</span>        LogEvent event = <span class="hljs-keyword">new</span> LogEvent(datagramPacket.sender(),System.currentTimeMillis(),fileName,logMsg);        out.add(event);    &#125;&#125;</code></pre></div><p>第二个ChannelHandler的工作是对第一个ChannelHandler所创建的LogEvent消息执行一些处理。在这个场景下，它只是简单地将它们写到System.out。在真实世界的应用程序中，你可能需要聚合来源于不同日志文件的事件，或者将它们发布到数据库中。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogEventHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">LogEvent</span>&gt;</span>&#123;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//当异常发生时，打印栈跟踪信息，并关闭对应的Channel</span>        cause.printStackTrace();        ctx.close();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                                LogEvent event)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//创建StringBuilder，并且构建输出的字符串</span>        StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();        builder.append(event.getReceived());        builder.append(<span class="hljs-string">" ["</span>);        builder.append(event.getSource().toString());        builder.append(<span class="hljs-string">"] ["</span>);        builder.append(event.getLogfile());        builder.append(<span class="hljs-string">"] : "</span>);        builder.append(event.getMsg());        <span class="hljs-comment">//打印LogEvent的数据</span>        System.out.println(builder.toString());    &#125;&#125;</code></pre></div><p>LogEventHandler将以一种简单易读的格式打印LogEvent消息，现在我们需要将我们的LogEventDecoder和LogEventHandler安装到ChannelPipeline中。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogEventMonitor</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventLoopGroup group;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Bootstrap bootstrap;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LogEventMonitor</span><span class="hljs-params">(InetSocketAddress address)</span></span>&#123;        group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        bootstrap = <span class="hljs-keyword">new</span> Bootstrap();        bootstrap.group(group)                .channel(NioDatagramChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                .<span class="hljs-title">option</span>(<span class="hljs-title">ChannelOption</span>.<span class="hljs-title">SO_BROADCAST</span>,<span class="hljs-title">true</span>)</span><span class="hljs-class">                .<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt;() </span>&#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel channel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        ChannelPipeline pipeline = channel.pipeline();                        pipeline.addLast(<span class="hljs-keyword">new</span> LogEventDecoder());                        pipeline.addLast(<span class="hljs-keyword">new</span> LogEventHandler());                    &#125;                &#125;).localAddress(address);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Channel <span class="hljs-title">bind</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> bootstrap.bind().syncUninterruptibly().channel();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>&#123;        group.shutdownGracefully();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        <span class="hljs-keyword">if</span> (args.length != <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Usage:LoEventMonitor &lt;port&gt;"</span>);        &#125;        LogEventMonitor monitor = <span class="hljs-keyword">new</span> LogEventMonitor(<span class="hljs-keyword">new</span> InetSocketAddress(Integer.parseInt(args[<span class="hljs-number">0</span>])));        <span class="hljs-keyword">try</span> &#123;            Channel channel = monitor.bind();            System.out.println(<span class="hljs-string">"LogEventMonitor running"</span>);            channel.closeFuture().sync();        &#125;<span class="hljs-keyword">finally</span> &#123;            monitor.stop();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>微服务分布式架构</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12.Netty--WebSocket</title>
    <link href="/2020/06/03/12-Netty-WebSocket/"/>
    <url>/2020/06/03/12-Netty-WebSocket/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>实时Web的概念</li><li>WebSocket协议</li><li>使用Netty构建一个基于WebSocket的聊天室服务器</li></ul></blockquote><h1 id="WebSocket简介"><a href="#WebSocket简介" class="headerlink" title="WebSocket简介"></a>WebSocket简介</h1><p>WebSocket协议是完全重新设计的协议，旨在为Web上的双向数据传输问题提供一个切实可行的解决方案，使得客户端与服务器之间可以在任意时刻传输消息。</p><h1 id="我们的WebSocket示例应用程序"><a href="#我们的WebSocket示例应用程序" class="headerlink" title="我们的WebSocket示例应用程序"></a>我们的WebSocket示例应用程序</h1><p><img src="https://img-blog.csdnimg.cn/20200603155650935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="添加WebSocket支持"><a href="#添加WebSocket支持" class="headerlink" title="添加WebSocket支持"></a>添加WebSocket支持</h1><p><img src="https://img-blog.csdnimg.cn/20200603155948230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="处理HTTP请求"><a href="#处理HTTP请求" class="headerlink" title="处理HTTP请求"></a>处理HTTP请求</h2><p>首先我们需要实现处理HTTP请求的组件，这个组件将提供用于访问聊天室并显示由连接的客户端发送的消息的网页。channelRead0()方法的实现是如何转发任何目标URI为/ws的请求的。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpRequestHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">FullHttpRequest</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String wsUri;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> File INDEX;    <span class="hljs-keyword">static</span> &#123;        URL location = HttpRequestHandler<span class="hljs-class">.<span class="hljs-keyword">class</span></span><span class="hljs-class">            .<span class="hljs-title">getProtectionDomain</span>()</span><span class="hljs-class">            .<span class="hljs-title">getCodeSource</span>().<span class="hljs-title">getLocation</span>()</span>;        <span class="hljs-keyword">try</span> &#123;            String path = location.toURI() + <span class="hljs-string">"index.html"</span>;            path = !path.contains(<span class="hljs-string">"file:"</span>) ? path : path.substring(<span class="hljs-number">5</span>);            INDEX = <span class="hljs-keyword">new</span> File(path);        &#125; <span class="hljs-keyword">catch</span> (URISyntaxException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Unable to locate index.html"</span>, e);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpRequestHandler</span><span class="hljs-params">(String wsUri)</span> </span>&#123;        <span class="hljs-keyword">this</span>.wsUri = wsUri;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,FullHttpRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 如果请求了WebSocket协议升级，则增加引用计数（调用retain()方法），并将它传递给下一个 ChannelInboundHandler</span>        <span class="hljs-keyword">if</span> (wsUri.equalsIgnoreCase(request.getUri())) &#123;            ctx.fireChannelRead(request.retain());         &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 处理100 Continue请求以符合HTTP1.1 规范</span>            <span class="hljs-keyword">if</span> (HttpHeaders.is100ContinueExpected(request)) &#123;                 send100Continue(ctx);            &#125;            <span class="hljs-comment">// 读取index.html</span>            RandomAccessFile file = <span class="hljs-keyword">new</span> RandomAccessFile(INDEX, <span class="hljs-string">"r"</span>);             HttpResponse response = <span class="hljs-keyword">new</span> DefaultHttpResponse(            request.getProtocolVersion(), HttpResponseStatus.OK);            response.headers().set(HttpHeaders.Names.CONTENT_TYPE,<span class="hljs-string">"text/plain; charset=UTF-8"</span>);            <span class="hljs-keyword">boolean</span> keepAlive = HttpHeaders.isKeepAlive(request);            <span class="hljs-keyword">if</span> (keepAlive) &#123;                response.headers().set(HttpHeaders.Names.CONTENT_LENGTH, file.length());                response.headers().set( HttpHeaders.Names.CONNECTION,HttpHeaders.Values.KEEP_ALIVE);            &#125;            <span class="hljs-comment">// 将HttpResponse写到客户端</span>            ctx.write(response);             <span class="hljs-keyword">if</span> (ctx.pipeline().get(SslHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>== <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 将index.html写到客户端</span>                ctx.write(<span class="hljs-keyword">new</span> DefaultFileRegion(file.getChannel(), <span class="hljs-number">0</span>, file.length()));             &#125; <span class="hljs-keyword">else</span> &#123;                ctx.write(<span class="hljs-keyword">new</span> ChunkedNioFile(file.getChannel()));            &#125;            <span class="hljs-comment">// 写LastHttpContent并冲刷至客户端</span>            ChannelFuture future = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);             <span class="hljs-comment">// 如果没有请求keep-alive，则在写操作完成后关闭Channel</span>            <span class="hljs-keyword">if</span> (!keepAlive) &#123;                 future.addListener(ChannelFutureListener.CLOSE);            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send100Continue</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;        FullHttpResponse response = <span class="hljs-keyword">new</span> DefaultFullHttpResponse(        HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE);        ctx.writeAndFlush(response);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre></div><p>如果该HTTP请求指向了地址为/ws的URI，那么HttpRequestHandler将调用FullHttpRequest对象上的retain()方法，并通过调用fireChannelRead(msg)方法将它转发给下一个ChannelInboundHandler。之所以需要调用retain()方法，是因为调用channelRead()方法完成之后，它将调用FullHttpRequest对象上的release()方法来释放它的资源。</p><h2 id="处理WebSocket帧"><a href="#处理WebSocket帧" class="headerlink" title="处理WebSocket帧"></a>处理WebSocket帧</h2><p><img src="https://img-blog.csdnimg.cn/20200603203324279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>TextWebSocketFrame是我们唯一真正需要处理的帧类型。Netty提供了WebSocketServerProtocolHandler来处理其他类型的帧。<br>下面代码展示了我们用于处理TextWebSocketFrame的ChannelInboundHandler，其还将在它的ChannelGroup中跟踪所有活动的WebSocket连接。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextWebSocketFrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">TextWebSocketFrame</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelGroup group;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TextWebSocketFrameHandler</span><span class="hljs-params">(ChannelGroup group)</span> </span>&#123;        <span class="hljs-keyword">this</span>.group = group;    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 重写userEventTriggered()方法以处理自定义事件</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 如果该事件表示握手成功，则从该Channelipeline中移除HttpRequestHandler，因为将不会接收到任何HTTP 消息了</span>        <span class="hljs-keyword">if</span> (evt == WebSocketServerProtocolHandler.ServerHandshakeStateEvent.HANDSHAKE_COMPLETE) &#123;            ctx.pipeline().remove(HttpRequestHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            <span class="hljs-comment">// 通知所有已经连接的WebSocket 客户端新的客户端已经连接上了</span>            group.writeAndFlush(<span class="hljs-keyword">new</span> TextWebSocketFrame(<span class="hljs-string">"Client "</span> + ctx.channel() + <span class="hljs-string">" joined"</span>));            <span class="hljs-comment">// 将新的WebSocket Channel添加到ChannelGroup 中，以便它可以接收到所有的消息</span>            group.add(ctx.channel());        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">super</span>.userEventTriggered(ctx, evt);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,TextWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">// 增加消息的引用计数，并将它写到ChannelGroup 中所有已经连接的客户端</span>        group.writeAndFlush(msg.retain());     &#125;&#125;</code></pre></div><p>和之前一样，对于retain()方法的调用是必需的，因为当channelRead0()方法返回时，TextWebSocketFrame 的引用计数将会被减少。由于所有的操作都是异步的，因此，writeAndFlush()方法可能会在channelRead0()方法返回之后完成，而且它绝对不能访问一个已经失效的引用。</p><h2 id="初始化ChannelPipeline"><a href="#初始化ChannelPipeline" class="headerlink" title="初始化ChannelPipeline"></a>初始化ChannelPipeline</h2><p>为了将ChannelHandler安装到ChannelPipeline中，需要扩展ChannelInitializer，并实现initChannel()方法。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatServerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelGroup group;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ChatServerInitializer</span><span class="hljs-params">(ChannelGroup group)</span> </span>&#123;        <span class="hljs-keyword">this</span>.group = group;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//将所有有需要的ChannelHandler添加到ChannelPipeline中</span>        ChannelPipeline pipeline = ch.pipeline();        pipeline.addLast(<span class="hljs-keyword">new</span> HttpServerCodec());        pipeline.addLast(<span class="hljs-keyword">new</span> ChunkedWriteHandler());        pipeline.addLast(<span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">64</span> * <span class="hljs-number">1024</span>));        pipeline.addLast(<span class="hljs-keyword">new</span> HttpRequestHandler(<span class="hljs-string">"/ws"</span>));        pipeline.addLast(<span class="hljs-keyword">new</span> WebSocketServerProtocolHandler(<span class="hljs-string">"/ws"</span>));        pipeline.addLast(<span class="hljs-keyword">new</span> TextWebSocketFrameHandler(group));    &#125;&#125;</code></pre></div><p>下面是基于WebSocket聊天服务器的ChannelHandler及各自的职责：<br><img src="https://img-blog.csdnimg.cn/20200603204803165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Netty的WebSocketServerProtocolHandler处理了所有委托管理的WebSocket帧类型以及升级握手本身，如果握手成功，那么所需的ChannelHandler将会被添加到ChannelPipeline中，而那些不再需要的ChannelHandler则将会被移除。<br>WebSocket 协议升级之前的ChannelPipeline：<br><img src="https://img-blog.csdnimg.cn/20200603205148885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>WebSocket 协议升级完成之后的ChannelPipeline：<br><img src="https://img-blog.csdnimg.cn/20200603205201947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h2><p>由ChatServer类来引导服务器，并安装ChatServerInitializer的代码。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatServer</span> </span>&#123;<span class="hljs-comment">//创建DefaultChannelGroup，其将保存所有已经连接的WebSocketChannel</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelGroup channelGroup =            <span class="hljs-keyword">new</span> DefaultChannelGroup(ImmediateEventExecutor.INSTANCE);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();    <span class="hljs-keyword">private</span> Channel channel;    <span class="hljs-comment">//引导服务器</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">start</span><span class="hljs-params">(InetSocketAddress address)</span> </span>&#123;        ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();        bootstrap.group(group)                .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                .<span class="hljs-title">childHandler</span>(<span class="hljs-title">createInitializer</span>(<span class="hljs-title">channelGroup</span>))</span>;        ChannelFuture future = bootstrap.bind(address);        future.syncUninterruptibly();        channel = future.channel();        <span class="hljs-keyword">return</span> future;    &#125;    <span class="hljs-comment">//创建ChatServerInitializer</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> ChannelInitializer&lt;Channel&gt; <span class="hljs-title">createInitializer</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            ChannelGroup group)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ChatServerInitializer(group);    &#125;    <span class="hljs-comment">//处理服务器关闭，并释放所有的资源</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>) &#123;            channel.close();        &#125;        channelGroup.close();        group.shutdownGracefully();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">if</span> (args.length != <span class="hljs-number">1</span>) &#123;            System.err.println(<span class="hljs-string">"Please give port as argument"</span>);            System.exit(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">int</span> port = Integer.parseInt(args[<span class="hljs-number">0</span>]);        <span class="hljs-keyword">final</span> ChatServer endpoint = <span class="hljs-keyword">new</span> ChatServer();        ChannelFuture future = endpoint.start(                <span class="hljs-keyword">new</span> InetSocketAddress(port));        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                endpoint.destroy();            &#125;        &#125;);        future.channel().closeFuture().syncUninterruptibly();    &#125;&#125;</code></pre></div><h1 id="测试该应用程序"><a href="#测试该应用程序" class="headerlink" title="测试该应用程序"></a>测试该应用程序</h1><p>略</p><h2 id="如何进行加密"><a href="#如何进行加密" class="headerlink" title="如何进行加密"></a>如何进行加密</h2><p>为ChannelPipeline加密：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//扩展ChatServerInitializer来加密</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecureChatServerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChatServerInitializer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SslContext context;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SecureChatServerInitializer</span><span class="hljs-params">(ChannelGroup group, SslContext context)</span> </span>&#123;        <span class="hljs-keyword">super</span>(group);        <span class="hljs-keyword">this</span>.context = context;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">super</span>.initChannel(ch);        <span class="hljs-comment">//调用父类的initChannel()方法</span>        SSLEng.ine engine = context.newEngine(ch.alloc());        engine.setUseClientMode(<span class="hljs-keyword">false</span>);        <span class="hljs-comment">//将SslHandler添加到ChannelPipeline中</span>        ch.pipeline().addFirst(<span class="hljs-keyword">new</span> SslHandler(engine));    &#125;&#125;</code></pre></div><p>最后一步是调整ChatServer以使用SecureChatServerInitializer，以便在ChannelPipeline中安装SslHandler。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecureChatServer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChatServer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SslContext context;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SecureChatServer</span><span class="hljs-params">(SslContext context)</span> </span>&#123;        <span class="hljs-keyword">this</span>.context = context;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> ChannelInitializer&lt;Channel&gt; <span class="hljs-title">createInitializer</span><span class="hljs-params">(ChannelGroup group)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SecureChatServerInitializer(group, context); <span class="hljs-comment">// 返回之前创建的SecureChatServerInitializer 以启用加密</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">if</span> (args.length != <span class="hljs-number">1</span>) &#123;            System.err.println(<span class="hljs-string">"Please give port as argument"</span>);            System.exit(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">int</span> port = Integer.parseInt(args[<span class="hljs-number">0</span>]);        SelfSignedCertificate cert = <span class="hljs-keyword">new</span> SelfSignedCertificate();        SslContext context = SslContext.newServerContext(cert.certificate(), cert.privateKey());        <span class="hljs-keyword">final</span> SecureChatServer endpoint = <span class="hljs-keyword">new</span> SecureChatServer(context);        ChannelFuture future = endpoint.start(<span class="hljs-keyword">new</span> InetSocketAddress(port));        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                endpoint.destroy();            &#125;        &#125;);        future.channel().closeFuture().syncUninterruptibly();    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>微服务分布式架构</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11.Netty--预置的ChannelHandler和编解码器</title>
    <link href="/2020/06/03/11-Netty-%E9%A2%84%E7%BD%AE%E7%9A%84ChannelHandler%E5%92%8C%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/"/>
    <url>/2020/06/03/11-Netty-%E9%A2%84%E7%BD%AE%E7%9A%84ChannelHandler%E5%92%8C%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>通过SSL/TLS保护Netty应用程序；</li><li>构建基于Netty的HTTP/HTTPS应用程序</li><li>处理空闲的连接和超时</li><li>解码基于分隔符的协议和基于长度的协议</li><li>写大型数据</li><li>Netty为许多通用协议提供了编解码器和处理器，几乎可以开箱即用。</li></ul></blockquote><h1 id="通过SSL-TLS保护Netty应用程序"><a href="#通过SSL-TLS保护Netty应用程序" class="headerlink" title="通过SSL/TLS保护Netty应用程序"></a>通过SSL/TLS保护Netty应用程序</h1><p>为了支持SSL/TLS，Java提供了javax.net.ssl包，它的SSLContext和SSLEngine类使得实现解密和加密相当简单直接。Netty通过一个名为SslHandler的ChannelHandler实现利用了这个API，其中SslHandler在内部使用了SSLEngine来完成实际的工作。<br>下图是通过SslHandler进行解密和加密的数据流。<br><img src="https://img-blog.csdnimg.cn/20200603120939780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Netty还提供了使用OpenSSL工具包的SSLEngine实现，该类提供了比JDK提供的SSLEngine具有更好的性能。<br>下面的代码展示了如何使用ChannelInitializer来将SslHandler添加到ChannelPipeline中。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SslChannelInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt;</span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SslContext context; <span class="hljs-comment">// 传入要使用的SslContext</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> startTls; <span class="hljs-comment">// 如果设置为true，第一个写入的消息将不会被加密（客户端应该设置为true）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SslChannelInitializer</span><span class="hljs-params">(SslContext context,<span class="hljs-keyword">boolean</span> startTls)</span> </span>&#123;        <span class="hljs-keyword">this</span>.context = context;        <span class="hljs-keyword">this</span>.startTls = startTls;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 对于每个SslHandler实例，都使用Channel的ByteBufAllocator从SslContext获取一个新的SSLEngine</span>        SSLEngine engine = context.newEngine(ch.alloc());        <span class="hljs-comment">// 将SslHandler 作为第一个ChannelHandler 添加到ChannelPipeline 中</span>        ch.pipeline().addFirst(<span class="hljs-string">"ssl"</span>,<span class="hljs-keyword">new</span> SslHandler(engine, startTls));    &#125;&#125;</code></pre></div><p>在大多数情况下，SslHandler将是ChannelPipeline中的第一个ChannelHandler，这确保了只有在所有其他的ChannelHandler将他们的逻辑应用到数据之后，才会进行加密。<br>SslHandler提供的一些方法：<br><img src="https://img-blog.csdnimg.cn/20200603121820849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="构建基于Netty的HTTP-HTTPS应用程序"><a href="#构建基于Netty的HTTP-HTTPS应用程序" class="headerlink" title="构建基于Netty的HTTP/HTTPS应用程序"></a>构建基于Netty的HTTP/HTTPS应用程序</h1><h2 id="HTTP解码器、编码器和编解码器"><a href="#HTTP解码器、编码器和编解码器" class="headerlink" title="HTTP解码器、编码器和编解码器"></a>HTTP解码器、编码器和编解码器</h2><p>HTTP是基于请求/响应模式的：客户端向服务器发送一个HTTP请求，然后服务器将会返回一个HTTP响应。<br>下图分别展示了生产和消费HTTP请求和HTTP响应的方法：<br>HTTP 请求的组成部分：<br><img src="https://img-blog.csdnimg.cn/20200603122819791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="HTTP 请求的组成部分"><br>HTTP 响应的组成部分：<br><img src="https://img-blog.csdnimg.cn/20200603122907848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>下面的代码展示了将HTTP支持添加到你的应用程序，几乎只需要将正确的ChannelHandler添加到ChannelPipeline中。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpPipelineInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> client;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpPipelineInitializer</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> client)</span> </span>&#123;        <span class="hljs-keyword">this</span>.client = client;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        <span class="hljs-keyword">if</span> (client) &#123;         <span class="hljs-comment">// 如果是客户端，则添加HttpResponseDecoder来处理来自服务器的响应</span>            pipeline.addLast(<span class="hljs-string">"decoder"</span>, <span class="hljs-keyword">new</span> HttpResponseDecoder());            <span class="hljs-comment">//如果是客户端，则添加HttpRequestEncoder来向服务器发送请求</span>            pipeline.addLast(<span class="hljs-string">"encoder"</span>, <span class="hljs-keyword">new</span> HttpRequestEncoder());        &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//如果是服务器，则添加HttpRequestDecoder来接收来自客户端的请求</span>            pipeline.addLast(<span class="hljs-string">"decoder"</span>, <span class="hljs-keyword">new</span> HttpRequestDecoder());            <span class="hljs-comment">//如果是服务器，则添加HttpResponseEncoder以向客户端发送响应</span>            pipeline.addLast(<span class="hljs-string">"encoder"</span>, <span class="hljs-keyword">new</span> HttpResponseEncoder());        &#125;    &#125;&#125;</code></pre></div><h2 id="聚合HTTP消息"><a href="#聚合HTTP消息" class="headerlink" title="聚合HTTP消息"></a>聚合HTTP消息</h2><p>由于HTTP 的请求和响应可能由许多部分组成，因此你需要聚合它们以形成完整的消息。为了消除这项繁琐的任务，Netty 提供了一个聚合器，它可以将多个消息部分合并为FullHttpRequest 或者FullHttpResponse 消息。<br>引入这种自动聚合机制只不过是向ChannelPipeline中添加另外一个ChannelHandler罢了。<br>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 自动聚合HTTP 的消息片段</span><span class="hljs-comment">*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpAggregatorInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isClient;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpAggregatorInitializer</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isClient)</span> </span>&#123;        <span class="hljs-keyword">this</span>.isClient = isClient;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        <span class="hljs-keyword">if</span> (isClient) &#123;            pipeline.addLast(<span class="hljs-string">"codec"</span>, <span class="hljs-keyword">new</span> HttpClientCodec());        &#125; <span class="hljs-keyword">else</span> &#123;            pipeline.addLast(<span class="hljs-string">"codec"</span>, <span class="hljs-keyword">new</span> HttpServerCodec());        &#125;        <span class="hljs-comment">//将最大的消息大小为512KB的HttpObjectAggregator添加到ChannelPipeline</span>        pipeline.addLast(<span class="hljs-string">"aggregator"</span>,<span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">512</span> * <span class="hljs-number">1024</span>));    &#125;&#125;</code></pre></div><h2 id="HTTP压缩"><a href="#HTTP压缩" class="headerlink" title="HTTP压缩"></a>HTTP压缩</h2><p>Netty 为压缩和解压缩提供了ChannelHandler 实现，它们同时支持gzip 和deflate 编码。<br>客户端可以通过提供以下头部信息来指示服务器它所支持的压缩格式：</p><div class="hljs"><pre><code class="hljs markup">GET &#x2F;encrypted-area HTTP&#x2F;1.1Host: www.example.comAccept-Encoding: gzip, deflate</code></pre></div><p>注意：服务器不需要压缩它所发送的数据<br>下面代码展示了自动压缩HTTP消息</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 自动压缩HTTP 消息</span><span class="hljs-comment">*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpCompressionInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isClient;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpCompressionInitializer</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isClient)</span> </span>&#123;        <span class="hljs-keyword">this</span>.isClient = isClient;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        <span class="hljs-keyword">if</span> (isClient) &#123;            pipeline.addLast(<span class="hljs-string">"codec"</span>, <span class="hljs-keyword">new</span> HttpClientCodec());            <span class="hljs-comment">// 如果是客户端，则添加HttpContentDecompressor 以处理来自服务器的压缩内容.</span>            pipeline.addLast(<span class="hljs-string">"decompressor"</span>,<span class="hljs-keyword">new</span> HttpContentDecompressor());        &#125; <span class="hljs-keyword">else</span> &#123;            pipeline.addLast(<span class="hljs-string">"codec"</span>, <span class="hljs-keyword">new</span> HttpServerCodec());            <span class="hljs-comment">// 如果是服务器，则添加HttpContentCompressor来压缩数据（如果客户端支持它）</span>            pipeline.addLast(<span class="hljs-string">"compressor"</span>,<span class="hljs-keyword">new</span> HttpContentCompressor());        &#125;    &#125;&#125;</code></pre></div><h2 id="使用HTTPS"><a href="#使用HTTPS" class="headerlink" title="使用HTTPS"></a>使用HTTPS</h2><p>启用HTTPS只需要将SslHandler添加到ChannelPipeline的ChannelHandler组合中。<br>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpsCodecInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SslContext context;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isClient;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpsCodecInitializer</span><span class="hljs-params">(SslContext context, <span class="hljs-keyword">boolean</span> isClient)</span> </span>&#123;        <span class="hljs-keyword">this</span>.context = context;        <span class="hljs-keyword">this</span>.isClient = isClient;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        SSLEngine engine = context.newEngine(ch.alloc());        <span class="hljs-comment">//将SslHandler添加到ChannelPipeline中以使用HTTPS</span>        pipeline.addFirst(<span class="hljs-string">"ssl"</span>, <span class="hljs-keyword">new</span> SslHandler(engine));        <span class="hljs-comment">//如果是客户端，则添加HttpClientCodec</span>        <span class="hljs-keyword">if</span> (isClient) &#123;            pipeline.addLast(<span class="hljs-string">"codec"</span>, <span class="hljs-keyword">new</span> HttpClientCodec());        <span class="hljs-comment">//如果是服务器，则添加HttpServerCodec</span>        &#125; <span class="hljs-keyword">else</span> &#123;            pipeline.addLast(<span class="hljs-string">"codec"</span>, <span class="hljs-keyword">new</span> HttpServerCodec());        &#125;    &#125;&#125;</code></pre></div><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket为网页和远程服务器之间的双向通信提供了一种替代HTTP轮询的方案。<br>如果想要在应用程序中添加对于WebSocket的支持，只需要将适当的客户端或者服务器WebSocketChannelHandler添加到ChannelPipeline中，这个类将处理由WebSocket定义的称为帧的特殊消息类型。<br>WebSocket协议如下：<br><img src="https://img-blog.csdnimg.cn/2020060313363214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>WebSocketFrame可以被归类于数据帧或者控制帧，主要类型如下：<br><img src="https://img-blog.csdnimg.cn/20200603133805130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在服务器端支持WebSocket的代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketServerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt;</span>&#123;    <span class="hljs-meta">@Override</span>        ch.pipeline().addLast(        <span class="hljs-keyword">new</span> HttpServerCodec(),        <span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">65536</span>), <span class="hljs-comment">// 为握手提供聚合的HttpRequest</span>        <span class="hljs-keyword">new</span> WebSocketServerProtocolHandler(<span class="hljs-string">"/websocket"</span>), <span class="hljs-comment">// 如果被请求的端点是"/websocket"，则处理该升级握手</span>        <span class="hljs-keyword">new</span> TextFrameHandler(), <span class="hljs-comment">// TextFrameHandler 处理TextWebSocketFrame</span>        <span class="hljs-keyword">new</span> BinaryFrameHandler(),        <span class="hljs-keyword">new</span> ContinuationFrameHandler());    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextFrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">TextWebSocketFrame</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,TextWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Handle text frame</span>        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryFrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">BinaryWebSocketFrame</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,BinaryWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Handle binary frame</span>        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContinuationFrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ContinuationWebSocketFrame</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,ContinuationWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Handle continuation frame</span>        &#125;    &#125;&#125;</code></pre></div><p>想要为WebSocket添加安全性，只需要将SslHandler作为第一个ChannelHandler添加到ChannelPipeline中。</p><h1 id="空闲的连接和超时"><a href="#空闲的连接和超时" class="headerlink" title="空闲的连接和超时"></a>空闲的连接和超时</h1><p>检测空闲连接以及超时连接对于及时释放资源来说是至关重要的，Netty特地为它提供了几个ChannelHandler实现。<br><img src="https://img-blog.csdnimg.cn/20200603142124762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>下列代码展示了当我们通常的发送心跳消息到远程节点的方法时，如果在60s内没有接收或者发送任何的数据，我们将如何得到通知；如果没有响应，则连接会被关闭。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdleStateHandlerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        <span class="hljs-comment">// IdleStateHandler 将在被触发时发送一个IdleStateEvent 事件</span>        pipeline.addLast(<span class="hljs-keyword">new</span> IdleStateHandler(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS));        <span class="hljs-comment">//将一个HeartbeatHandler添加到ChannelPipeline中</span>        pipeline.addLast(<span class="hljs-keyword">new</span> HeartbeatHandler());    &#125;    <span class="hljs-comment">//实现userEventTriggered()方法以发送心跳消息</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeartbeatHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-comment">//发送到远程节点的心跳消息</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ByteBuf HEARTBEAT_SEQUENCE =Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(<span class="hljs-string">"HEARTBEAT"</span>, CharsetUtil.ISO_8859_1));        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx,Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-keyword">if</span> (evt <span class="hljs-keyword">instanceof</span> IdleStateEvent) &#123;             <span class="hljs-comment">// 发送心跳消息，并在发送失败时关闭该连接</span>                ctx.writeAndFlush(HEARTBEAT_SEQUENCE.duplicate())                    .addListener(ChannelFutureListener.CLOSE_ON_FAILURE);            &#125; <span class="hljs-keyword">else</span> &#123;             <span class="hljs-comment">// 不是IdleStateEvent事件，所以将它传递给下一个ChannelInboundHandler</span>                <span class="hljs-keyword">super</span>.userEventTriggered(ctx, evt);            &#125;        &#125;    &#125;&#125;</code></pre></div><p>上面这个示例演示了如何使用IdleStateHandler来测试远程节点是否仍然还活着，并且在它失活时通过关闭连接来释放资源。<br>如果连接超过60s没有接收或者发送任何的数据，那么IdleStateHandler将会使用一个IdleStateEvent事件来调用fireUserEventTriggered()方法。HeartbeatHandler实现了userEventTriggered()方法，如果这个方法检测到IdleSstateEvent事件，它将会发送心跳消息，并且添加一个将在发送操作失败时关闭该连接的ChannelFutureListener。</p><h1 id="解码基于分隔符的协议和基于长度的协议"><a href="#解码基于分隔符的协议和基于长度的协议" class="headerlink" title="解码基于分隔符的协议和基于长度的协议"></a>解码基于分隔符的协议和基于长度的协议</h1><h2 id="基于分隔符的协议"><a href="#基于分隔符的协议" class="headerlink" title="基于分隔符的协议"></a>基于分隔符的协议</h2><p>基于分隔符的（delimited）消息协议使用定义的字符来标记的消息或者消息段（通常被称为帧）的开头或者结尾。由RFC文档正式定义的许多协议（如SMTP、POP3、IMAP以及Telnet）都是这样的。<br><img src="https://img-blog.csdnimg.cn/20200603143648459.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>下图展示了当帧由行尾序列\r\n分割时是如何被处理的：<br><img src="https://img-blog.csdnimg.cn/20200603143900748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LineBasedHandlerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        <span class="hljs-comment">//该LineBasedFrameDecoder将提取的帧转发给下一个ChannelInboundHandler</span>        pipeline.addLast(<span class="hljs-keyword">new</span> LineBasedFrameDecoder(<span class="hljs-number">64</span> * <span class="hljs-number">1024</span>));        <span class="hljs-comment">//添加FrameHandler来接收帧</span>        pipeline.addLast(<span class="hljs-keyword">new</span> FrameHandler());    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-comment">//传入了单个帧的内容</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Do something with the data extracted from the frame</span>        &#125;    &#125;&#125;</code></pre></div><p>作为示例，我们将使用下面的协议规范：<br>1.传入数据流是一系列的帧，每个帧都由换行符（\n）分隔；<br>2.每个帧都由一系列的元素组成，每个元素都由单个空格字符分隔；<br>3.一个帧的内容代表一个命令，定义为一个命令名称后跟着数目可变的参数。<br>我们用于这个协议的自定义解码器将定义以下类：<br>1.Cmd—将帧（命令）的内容存储在ByteBuf 中，一个ByteBuf 用于名称，另一个用于参数；<br>2.CmdDecoder—从被重写了的decode()方法中获取一行字符串，并从它的内容构建一个Cmd 的实例；<br>3.CmdHandler —从CmdDecoder 获取解码的Cmd 对象，并对它进行一些处理；<br>4.CmdHandlerInitializer —为了简便起见，我们将会把前面的这些类定义为专门的ChannelInitializer 的嵌套类，其将会把这些ChannelInboundHandler 安装到ChannelPipeline 中。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CmdHandlerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> SPACE = (<span class="hljs-keyword">byte</span>)<span class="hljs-string">' '</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        pipeline.addLast(<span class="hljs-keyword">new</span> CmdDecoder(<span class="hljs-number">64</span> * <span class="hljs-number">1024</span>)); <span class="hljs-comment">// 添加CmdDecoder 以提取Cmd 对象，并将它转发给下一个ChannelInboundHandler</span>        pipeline.addLast(<span class="hljs-keyword">new</span> CmdHandler()); <span class="hljs-comment">// 添加CmdHandler 以接收和处理Cmd 对象</span>    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cmd</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ByteBuf name;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ByteBuf args;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cmd</span><span class="hljs-params">(ByteBuf name, ByteBuf args)</span> </span>&#123;            <span class="hljs-keyword">this</span>.name = name;            <span class="hljs-keyword">this</span>.args = args;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> name;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title">args</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> args;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CmdDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LineBasedFrameDecoder</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CmdDecoder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxLength)</span> </span>&#123;            <span class="hljs-keyword">super</span>(maxLength);        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf buffer)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//从ByteBuf中提取由行尾符序列分割的帧</span>            ByteBuf frame = (ByteBuf) <span class="hljs-keyword">super</span>.decode(ctx, buffer);            <span class="hljs-keyword">if</span> (frame == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            <span class="hljs-comment">// 查找第一个空格字符的索引。前面是命令名称，接着是参数</span>            <span class="hljs-keyword">int</span> index = frame.indexOf(frame.readerIndex(),frame.writerIndex(), SPACE);            <span class="hljs-comment">// 使用包含有命令名称和参数的切片创建新的Cmd 对象</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Cmd(frame.slice(frame.readerIndex(), index),frame.slice(index + <span class="hljs-number">1</span>, frame.writerIndex()));        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CmdHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">Cmd</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, Cmd msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Do something with the command(获取Cmd对象进一步操作)</span>        &#125;    &#125;&#125;</code></pre></div><h2 id="基于长度的协议"><a href="#基于长度的协议" class="headerlink" title="基于长度的协议"></a>基于长度的协议</h2><p><img src="https://img-blog.csdnimg.cn/20200603144720346.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200603144751918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>如果遇到被编码到消息头部的帧大小不是固定值的协议，为了处理这种变长帧，可以使用LengthFieldBasedFrameDecoder，它将从头部字段确定帧长，然后从数据流中提取指定的字节数。<br><img src="https://img-blog.csdnimg.cn/20200603145131132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LengthBasedInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        pipeline.addLast(<span class="hljs-keyword">new</span> LengthFieldBasedFrameDecoder(<span class="hljs-number">64</span> * <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>));        pipeline.addLast(<span class="hljs-keyword">new</span> FrameHandler());    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Do something with the frame</span>        &#125;    &#125;&#125;</code></pre></div><h1 id="写大型数据"><a href="#写大型数据" class="headerlink" title="写大型数据"></a>写大型数据</h1><p>由于写操作是非阻塞的，所在存在内存耗尽的风险，因此在写大型数据时，需要准备好处理到远程节点的连接是慢速连接的情况，这种情况会导致内存释放的延迟。<br>下面代码展示了如何通过从FileInputStream创建一个DefaultRegion，并将其写入Channel，从而利用零拷贝特性来传输一个文件的内容。</p><div class="hljs"><pre><code class="hljs java">FileInputStream in = <span class="hljs-keyword">new</span> FileInputStream(file);<span class="hljs-comment">// 以该文件的完整长度创建一个新的DefaultFileRegion</span>FileRegion region = <span class="hljs-keyword">new</span> DefaultFileRegion(in.getChannel(), <span class="hljs-number">0</span>, file.length());<span class="hljs-comment">// 发送该DefaultFileRegion，并注册一个ChannelFutureListener</span>channel.writeAndFlush(region).addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">if</span> (!future.isSuccess()) &#123;            Throwable cause = future.cause(); <span class="hljs-comment">// 处理失败</span>            <span class="hljs-comment">// Do something</span>        &#125;    &#125;&#125;);</code></pre></div><p>这个示例只适用于文件内容的直接传输，不包括应用程序对数据的任何处理。在需要将数据从文件系统复制到用户内存中时，可以使用ChunkedWriteHandler，它支持异步写大型数据流，而又不会导致大量的内存消耗。<br><img src="https://img-blog.csdnimg.cn/20200603150611949.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>下面代码展示了ChunkedStream的用法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChunkedWriteHandlerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> File file;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SslContext sslCtx;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ChunkedWriteHandlerInitializer</span><span class="hljs-params">(File file, SslContext sslCtx)</span> </span>&#123;        <span class="hljs-keyword">this</span>.file = file;        <span class="hljs-keyword">this</span>.sslCtx = sslCtx;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        <span class="hljs-comment">//将SslHandler添加到ChannelPipeline中</span>        pipeline.addLast(<span class="hljs-keyword">new</span> SslHandler(sslCtx.newEngine(ch.alloc());        <span class="hljs-comment">//添加ChunkedWritHandler以处理作为ChunkedInput传入的数据</span>        pipeline.addLast(<span class="hljs-keyword">new</span> ChunkedWriteHandler());        <span class="hljs-comment">// 一旦连接建立，WriteStreamHandler就开始写文件数据</span>        pipeline.addLast(<span class="hljs-keyword">new</span> WriteStreamHandler());     &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteStreamHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-comment">//当连接建立时，channelActive()方法将使用ChunkedInput写文件数据</span>        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span><span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-keyword">super</span>.channelActive(ctx);            ctx.writeAndFlush(<span class="hljs-keyword">new</span> ChunkedStream(<span class="hljs-keyword">new</span> FileInputStream(file)));        &#125;    &#125;&#125;</code></pre></div><h1 id="序列化数据"><a href="#序列化数据" class="headerlink" title="序列化数据"></a>序列化数据</h1><h2 id="JDK序列化"><a href="#JDK序列化" class="headerlink" title="JDK序列化"></a>JDK序列化</h2><p><img src="https://img-blog.csdnimg.cn/20200603151321484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="JBoss-Marshalling序列化"><a href="#JBoss-Marshalling序列化" class="headerlink" title="JBoss Marshalling序列化"></a>JBoss Marshalling序列化</h2><p><img src="https://img-blog.csdnimg.cn/20200603151359976.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>下面代码展示了如何使用MarshallingDecoder和MarshallingEncoder：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MarshallingInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MarshallerProvider marshallerProvider;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UnmarshallerProvider unmarshallerProvider;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MarshallingInitializer</span><span class="hljs-params">(UnmarshallerProvider unmarshallerProvider,MarshallerProvider marshallerProvider)</span> </span>&#123;        <span class="hljs-keyword">this</span>.marshallerProvider = marshallerProvider;        <span class="hljs-keyword">this</span>.unmarshallerProvider = unmarshallerProvider;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel channel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = channel.pipeline();        <span class="hljs-comment">//添加MarshallingDecoder以将ByteBuf转换为POJO</span>        pipeline.addLast(<span class="hljs-keyword">new</span> MarshallingDecoder(unmarshallerProvider));        <span class="hljs-comment">//添加MarshallingEncoder以将POJO转换为ByteBuf</span>        pipeline.addLast(<span class="hljs-keyword">new</span> MarshallingEncoder(marshallerProvider));        <span class="hljs-comment">// 添加ObjectHandler，以处理普通的实现了Serializable 接口的POJO</span>        pipeline.addLast(<span class="hljs-keyword">new</span> ObjectHandler());     &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">Serializable</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext,Serializable serializable)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Do something</span>        &#125;    &#125;&#125;</code></pre></div><h2 id="Protocol-Buffers序列化"><a href="#Protocol-Buffers序列化" class="headerlink" title="Protocol Buffers序列化"></a>Protocol Buffers序列化</h2><p>Protocol Buffers 以一种紧凑而高效的方式对结构化的数据进行编码以及解码。它具有许多的编程语言绑定，使得它很适合跨语言的项目。(由Google公司开发的、现在已经开源的数据交换格式。)<br><img src="https://img-blog.csdnimg.cn/20200603151801160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProtoBufInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MessageLite lite;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProtoBufInitializer</span><span class="hljs-params">(MessageLite lite)</span> </span>&#123;        <span class="hljs-keyword">this</span>.lite = lite;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline pipeline = ch.pipeline();        pipeline.addLast(<span class="hljs-keyword">new</span> ProtobufVarint32FrameDecoder());        pipeline.addLast(<span class="hljs-keyword">new</span> ProtobufEncoder()); ①        pipeline.addLast(<span class="hljs-keyword">new</span> ProtobufDecoder(lite));        pipeline.addLast(<span class="hljs-keyword">new</span> ObjectHandler());    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">// Do something with the object</span>        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>微服务分布式架构</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10.Netty--编解码器框架</title>
    <link href="/2020/06/02/10-Netty-%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E6%A1%86%E6%9E%B6/"/>
    <url>/2020/06/02/10-Netty-%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>解码器、编码器以及编解码器的概述</li><li>Netty的编解码器类</li></ul></blockquote><h2 id="什么是编解码器"><a href="#什么是编解码器" class="headerlink" title="什么是编解码器"></a>什么是编解码器</h2><ul><li><p>编码器是将消息转换为适合于传输的格式（最有可能的就是字节流）；</p></li><li><p>解码器则是将网络字节流换回应用程序的消息格式；</p></li><li><p>编码器操作出站数据，解码器处理入站数据；</p></li></ul><h2 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h2><ul><li><p>将字节码解码为消息———ByteToMessageDecoder和ReplayingDecoder；</p></li><li><p>将一种消息类型解码为另一种———MessageToMessagedecoder</p></li></ul><p>因为解码器是负责将入站数据从一种格式转换到另一种格式，所以Netty的解码器实现了ChannelInboundHandler。</p><p>每当需要为ChannelPipeline中的下一个ChannelInboundHanler转换入站数据时会用到解码器，可以将多个解码器链接在一起，以实现任意复杂的转换逻辑。</p><h3 id="抽象类ByteToMessageDecoder"><a href="#抽象类ByteToMessageDecoder" class="headerlink" title="抽象类ByteToMessageDecoder"></a>抽象类ByteToMessageDecoder</h3><p>由于你不可能知道远程节点是否会一次性地发送一个完整的消息，所以这个类会对入站数据进行缓冲，直到它准备好处理。</p><p>ByteToMessageDecoder方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>decode(ChannelHandlerContext ctx,ByteBuf in,List<Objext> out)</td><td>decode()方法被调用时将会传入一个包含了传入数据的ByteBuf，以及一个用来添加解码消息的List，对这个方法的调用将会重复进行，直到确定没有新的元素被添加到该List，或者该ByteBuf中没有更多可读取的字节时为止。然后，如果该List不为空，那么它的内容将会被传递给ChannelPipeline中的下一个ChannelInboundHandler。</td></tr><tr><td>decodeLast(ChannelHandlerContext ctx,ByteBuf in,Lists<Object>out)</td><td>默认实现只是简单地调用了decode()方法，当Channel的状态变为非活动时，这个方法将会被调用一次，可以重写该方法来提供特殊的处理，比如用来产生一个LastHttpContent消息</td></tr></tbody></table><p>示例：假设你接收了一个包含简单int的字节流，每个int都需要被单独处理，在这种情况下，你需要从入站ByteBuf中读取每个int，并将它传递给ChannelPipeline中的下一个ChannelInboundHandler。为了解码这个字节流，你要扩展ByteToMessageDecoder类。</p><p><img src="https://img-blog.csdnimg.cn/20200603100430311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToIntegerDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in,</span></span><span class="hljs-function"><span class="hljs-params">        List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//检查是否至少有 4 字节可读（一个 int 的字节长度）</span>        <span class="hljs-keyword">if</span> (in.readableBytes() &gt;= <span class="hljs-number">4</span>) &#123;            <span class="hljs-comment">//从入站 ByteBuf 中读取一个 int，并将其添加到解码消息的 List 中</span>            out.add(in.readInt());        &#125;    &#125;&#125;</code></pre></div><h3 id="抽象类ReplayingDecoder"><a href="#抽象类ReplayingDecoder" class="headerlink" title="抽象类ReplayingDecoder"></a>抽象类ReplayingDecoder</h3><p>ReplayingDecoder扩展了ByteToMessageDecoder类，不必调用readableBytes()方法。它通过使用一个自定义的ByteBuf也就是ReplayingDecoderByteBuf来实现，包装传入的ByteBuf实现了这一点，readableBytes()方法将在内部执行。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToIntegerDecoder2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReplayingDecoder</span>&lt;<span class="hljs-title">Void</span>&gt; </span>&#123; <span class="hljs-comment">// 扩展ReplayingDecoder&lt;Void&gt;以将字节解码为消息</span>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 传入的ByteBuf 是ReplayingDecoderByteBuf</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in,List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;     <span class="hljs-comment">//从入站ByteBuf中读取一个int，并将其添加</span>        out.add(in.readInt());    &#125;&#125;</code></pre></div><p>如果没有足够的字节可用，这个readInt()方法的实现将会抛出一个Error（实际上是Signal），其将在基类中被捕获并处理，当有更多的数据可供读取时，该decode()方法将会被再次调用。<br>这里有一个简单的准则：如果使用ByteToMessageDecoder 不会引入太多的复杂性，那么请使用它；否则，请使用ReplayingDecoder。</p><h2 id="抽象类MessageToMessageDecoder"><a href="#抽象类MessageToMessageDecoder" class="headerlink" title="抽象类MessageToMessageDecoder"></a>抽象类MessageToMessageDecoder</h2><p>这里我们将编写一个IntegerToStringDecoder解码器来扩展MessageToMessageDecoder<Integer>,尖括号里面的参数代表了输入参数的类型。<br><img src="https://img-blog.csdnimg.cn/20200603102908817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerToStringDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageDecoder</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        out.add(String.valueOf(msg));    &#125;&#125;</code></pre></div><h2 id="TooLongFrameException类"><a href="#TooLongFrameException类" class="headerlink" title="TooLongFrameException类"></a>TooLongFrameException类</h2><p>Netty提供了TooLongFrameException类，其将由解码器在帧超出指定的大小限制时抛出。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SafeByteToMessageDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_FRAME_SIZE = <span class="hljs-number">1024</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in,</span></span><span class="hljs-function"><span class="hljs-params">        List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">int</span> readable = in.readableBytes();        <span class="hljs-keyword">if</span> (readable &gt; MAX_FRAME_SIZE) &#123; <span class="hljs-comment">// 检查缓冲区中是否有超过MAX_FRAME_SIZE个字节</span>            in.skipBytes(readable); <span class="hljs-comment">// 跳过所有的可读字节，抛出TooLongFrameException 并通知ChannelHandler</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TooLongFrameException(<span class="hljs-string">"Frame too big!"</span>);        &#125;        <span class="hljs-comment">// do something</span>        ...    &#125;&#125;</code></pre></div><h1 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h1><p>编码器实现了ChannelOutBoundHandler，并将出站数据从一种格式转换为另一种格式。Netty提供了一组类，用于帮助你编写具有以下功能的编码器：<br>将消息编码为字节；<br>将消息编码为另一种格式的消息；</p><h2 id="抽象类MessageToByteEncoder"><a href="#抽象类MessageToByteEncoder" class="headerlink" title="抽象类MessageToByteEncoder"></a>抽象类MessageToByteEncoder</h2><p><img src="https://img-blog.csdnimg.cn/20200603103905581.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>这个类只有一个方法，而解码器有两个，这是因为解码器通常需要在Channel关闭之后产生最后一个消息，因此也就有了decodeLast()方法，但是编码器就没必要在连接被关闭后仍产生消息了。<br>示例：接收一个Short类型的实例作为消息，将它编码为Short的原子类型，并将它写入ByteBuf中，其将随后被转发给ChannelPipeline中的下一个ChannelOutboundHandler，每个传出的Short值都将会被占用ByteBuf中的2字节。<br><img src="https://img-blog.csdnimg.cn/20200603104641304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShortToByteEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">Short</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Short msg, ByteBuf out)</span><span class="hljs-keyword">throws</span> Exception </span>&#123;        out.writeShort(msg);    &#125;&#125;</code></pre></div><h2 id="抽象类MessageToMessageEncoder"><a href="#抽象类MessageToMessageEncoder" class="headerlink" title="抽象类MessageToMessageEncoder"></a>抽象类MessageToMessageEncoder</h2><p>示例：使用IntegerToStringEncoder扩展了MessageToMessageEncoder，设计如图所示：<br><img src="https://img-blog.csdnimg.cn/20200603105140614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerToStringEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageEncoder</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        out.add(String.valueOf(msg));    &#125;&#125;</code></pre></div><h1 id="抽象的编解码器类"><a href="#抽象的编解码器类" class="headerlink" title="抽象的编解码器类"></a>抽象的编解码器类</h1><h2 id="抽象类ByteToMessageCodec"><a href="#抽象类ByteToMessageCodec" class="headerlink" title="抽象类ByteToMessageCodec"></a>抽象类ByteToMessageCodec</h2><p>应用场景：我们需要将字节解码为某种形式的消息，随后再次对它进行编码。<br><img src="https://img-blog.csdnimg.cn/20200603110056715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="抽象类MessageToMessageCodec"><a href="#抽象类MessageToMessageCodec" class="headerlink" title="抽象类MessageToMessageCodec"></a>抽象类MessageToMessageCodec</h2><p><img src="https://img-blog.csdnimg.cn/20200603111222346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>下面代码展示了Web浏览器与服务器之间的双向通信可能的实现方式：我们的WebSocketConvertHandler在参数化MessageToMessageCodec时将使用INBOUN_IN类型的WebSocketFrame，以及OUTBOUND_IN类型的MyWebSocketFrame，后者是WebSocketConvertHandler本身的一个静态嵌套类。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketConvertHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageCodec</span>&lt;<span class="hljs-title">WebSocketFrame</span>, <span class="hljs-title">WebSocketConvertHandler</span>.<span class="hljs-title">MyWebSocketFrame</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 将MyWebSocketFrame 编码为指定的WebSocketFrame 子类型</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, WebSocketConvertHandler.MyWebSocketFrame msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ByteBuf payload = msg.getData().duplicate().retain();        <span class="hljs-keyword">switch</span> (msg.getType()) &#123; <span class="hljs-comment">// 实例化一个指定子类型的WebSocketFrame</span>            <span class="hljs-keyword">case</span> BINARY:                out.add(<span class="hljs-keyword">new</span> BinaryWebSocketFrame(payload));                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> TEXT:                out.add(<span class="hljs-keyword">new</span> TextWebSocketFrame(payload));                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> CLOSE:                out.add(<span class="hljs-keyword">new</span> CloseWebSocketFrame(<span class="hljs-keyword">true</span>, <span class="hljs-number">0</span>, payload));                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> CONTINUATION:                out.add(<span class="hljs-keyword">new</span> ContinuationWebSocketFrame(payload));                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> PONG:                out.add(<span class="hljs-keyword">new</span> PongWebSocketFrame(payload));                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> PING:                out.add(<span class="hljs-keyword">new</span> PingWebSocketFrame(payload));                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(                        <span class="hljs-string">"Unsupported websocket msg "</span> + msg);        &#125;    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 将WebSocketFrame 解码为MyWebSocketFrame，并设置FrameType</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, WebSocketFrame msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ByteBuf payload = msg.content().duplicate().retain();        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> BinaryWebSocketFrame) &#123;            out.add(<span class="hljs-keyword">new</span> MyWebSocketFrame(                    MyWebSocketFrame.FrameType.BINARY, payload));        &#125; <span class="hljs-keyword">else</span>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> CloseWebSocketFrame) &#123;            out.add(<span class="hljs-keyword">new</span> MyWebSocketFrame (                    MyWebSocketFrame.FrameType.CLOSE, payload));        &#125; <span class="hljs-keyword">else</span>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> PingWebSocketFrame) &#123;            out.add(<span class="hljs-keyword">new</span> MyWebSocketFrame (                    MyWebSocketFrame.FrameType.PING, payload));        &#125; <span class="hljs-keyword">else</span>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> PongWebSocketFrame) &#123;            out.add(<span class="hljs-keyword">new</span> MyWebSocketFrame (                    MyWebSocketFrame.FrameType.PONG, payload));        &#125; <span class="hljs-keyword">else</span>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> TextWebSocketFrame) &#123;            out.add(<span class="hljs-keyword">new</span> MyWebSocketFrame (                    MyWebSocketFrame.FrameType.TEXT, payload));        &#125; <span class="hljs-keyword">else</span>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> ContinuationWebSocketFrame) &#123;            out.add(<span class="hljs-keyword">new</span> MyWebSocketFrame (                    MyWebSocketFrame.FrameType.CONTINUATION, payload));        &#125; <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(                    <span class="hljs-string">"Unsupported websocket msg "</span> + msg);        &#125;    &#125;    <span class="hljs-comment">//声明WebSocketConvertHandler所使用的OUTBOUND_IN类型</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebSocketFrame</span> </span>&#123;    <span class="hljs-comment">//定义拥有被包装的有效负载的WebSocketFrame的类型</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> FrameType &#123;            BINARY,            CLOSE,            PING,            PONG,            TEXT,            CONTINUATION        &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> FrameType type;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ByteBuf data;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyWebSocketFrame</span><span class="hljs-params">(FrameType type, ByteBuf data)</span> </span>&#123;            <span class="hljs-keyword">this</span>.type = type;            <span class="hljs-keyword">this</span>.data = data;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> FrameType <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> type;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> data;        &#125;    &#125;&#125;</code></pre></div><h2 id="CombinedChannelDuplexHandler类"><a href="#CombinedChannelDuplexHandler类" class="headerlink" title="CombinedChannelDuplexHandler类"></a>CombinedChannelDuplexHandler类</h2><p>结合一个解码器和编码器可能会对可重用性造成影响。但是，有一种方法既能够避免这种惩罚，又不会牺牲将一个解码器和一个编码器作为一个单独的单元部署所带来的便利性。CombinedChannelDuplexHandler 提供了这个解决方案，其声明为：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CombinedChannelDuplexHandler</span> &lt;<span class="hljs-title">I</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandler</span>,<span class="hljs-title">O</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelOutboundHandler</span>&gt;</span></code></pre></div><p>首先看看ByteToCharDecoder类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteToCharDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in,</span></span><span class="hljs-function"><span class="hljs-params">        List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">while</span> (in.readableBytes() &gt;= <span class="hljs-number">2</span>) &#123;            out.add(in.readChar());        &#125;    &#125;&#125;</code></pre></div><p>这里的decode()方法一次将从ByteBuf中提取2字节，并将它们作为char写入到List中，其将会被自动装箱为Character对象。<br>再来看看CharToByteEncoder类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CharToByteEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">Character</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Character msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        out.writeChar(msg);    &#125;&#125;</code></pre></div><p>既然我们有了编码器和解码器，我们可以将它们结合起来构建一个编解码器：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//通过该编码器和解码器实现参数化CombinnedByteCharCodec</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CombinedByteCharCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CombinedChannelDuplexHandler</span>&lt;<span class="hljs-title">ByteToCharDecoder</span>, <span class="hljs-title">CharToByteEncoder</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CombinedByteCharCodec</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//将委托实例传递给父类</span>        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> ByteToCharDecoder(), <span class="hljs-keyword">new</span> CharToByteEncoder());    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>微服务分布式架构</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.Netty--单元测试</title>
    <link href="/2020/06/02/9-Netty-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <url>/2020/06/02/9-Netty-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>单元测试</li><li>EmbeddedChannel概述</li><li>使用EmbeddedChannel测试ChannelHandler</li></ul></blockquote><p>单元测试的标准：不仅能够证明你的实现是正确的，而且还要能够很容易地隔离那些因修改代码而突然出现的问题。</p><p>因为正在被测试的代码模块或者单元将在它正常的运行环境之外被执行，所以还需要一个框架或者脚手架以便在其中运行它（这里我们选择的是JUnit4）。</p><h2 id="EmbeddedChannel概述"><a href="#EmbeddedChannel概述" class="headerlink" title="EmbeddedChannel概述"></a>EmbeddedChannel概述</h2><p>我们的业务逻辑是通过将ChannelPipeline中的ChannelHandler实现链接在一起来完成的，每个ChannelHandler都将处理一个明确定义的任务或者是步骤。</p><p>Netty提供了EmbeddedChannel，用于测试ChannelHandler，其原理就是将入站数据或者出站数据写入EmbeddedChannel中，然后检查是否有任何东西到达了ChannelPipeline的尾端，以这种方式便可以确定消息是否已经被编译或者被解码过了，以及是否触发了任何的ChannelHandler动作。</p><p>EmbeddedChannel方法：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>writeInbound(Object…msgs)</td><td>将入站消息写入到EmbeddedChannel中，如果可以通过readInbound()方法从EmbeddedChannel中读取数据，则返回true</td></tr><tr><td>readInbound()</td><td>从EmbeddedChannel中读取一个入站消息，任何返回的消息都经过了整个ChannelPipeline，如果没有数据则返回null</td></tr><tr><td>writeOutbound(…)</td><td>将出站消息写入到EmbeddedChannel中，如果可以通过readOutbound()方法从EmbeddedChannel中读取数据，则返回true</td></tr><tr><td>readOutbound(…)</td><td>从EmbeddedChannel中读取一个出站消息，任何返回的消息都经过了整个ChannelPipeline，如果没有数据则返回null</td></tr><tr><td>finish()</td><td>结束EmbeddedChannel，如果里面有任何类型的可读数据都会返回true，它也会调用Channel的close方法</td></tr></tbody></table><p>EmbeededChannel的处理过程如图所示：</p><p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2399198972,3683808923&fm=15&gp=0.jpg" srcset="/img/loading.gif" alt="img"></p><h2 id="使用EmbeededChannel测试ChannelHandler"><a href="#使用EmbeededChannel测试ChannelHandler" class="headerlink" title="使用EmbeededChannel测试ChannelHandler"></a>使用EmbeededChannel测试ChannelHandler</h2><h3 id="JUnit断言"><a href="#JUnit断言" class="headerlink" title="JUnit断言"></a>JUnit断言</h3><p>org.junit.Assert类提供了很多用于测试的静态方法，失败的断言将导致一个异常被抛出，并将终止当前正在执行的测试。</p><h3 id="测试入站消息"><a href="#测试入站消息" class="headerlink" title="测试入站消息"></a>测试入站消息</h3><p>接下来实现一个简单的ByteToMessageDecoder，给定足够的数据，然后这个解码器将产生固定大小的帧，如果没有足够的数据可供的读取，它将等待下一个数据块的到来，并将再次检查是否能够产生一个新的帧。</p><p>我们代码是这个解码器产生固定为3个字节大小的帧，它可能会需要多个事件来提供足够的字节数来产生一个帧，最终每个帧都会被传递给ChannelPipeline中的下一个ChannelHandler。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FixedLengthFrameDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> frameLength;    <span class="hljs-comment">//指定要生成的帧的长度</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FixedLengthFrameDecoder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> frameLength)</span> </span>&#123;        <span class="hljs-keyword">if</span> (frameLength &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(                <span class="hljs-string">"frameLength must be a positive integer: "</span> + frameLength);        &#125;        <span class="hljs-keyword">this</span>.frameLength = frameLength;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in,</span></span><span class="hljs-function"><span class="hljs-params">        List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//检查是否有足够的字节可以被读取，以生成下一个帧</span>        <span class="hljs-keyword">while</span> (in.readableBytes() &gt;= frameLength) &#123;            <span class="hljs-comment">//从 ByteBuf 中读取一个新帧</span>            ByteBuf buf = in.readBytes(frameLength);            <span class="hljs-comment">//将该帧添加到已被解码的消息列表中</span>            out.add(buf);        &#125;    &#125;&#125;</code></pre></div><p>现在创建一个单元测试：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FixedLengthFrameDecoderTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>                           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFramesDecoded</span><span class="hljs-params">()</span></span>&#123;        ByteBuf buffer = Unpooled.buffer();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;            buffer.writeByte(i);        &#125;        ByteBuf duplicate = buffer.duplicate();        <span class="hljs-comment">//创建一个EmbeddedChannel，并添加一个FixedLengthFramesDecoded，将其以3字节的帧长度被测试</span>        EmbeddedChannel embeddedChannel = <span class="hljs-keyword">new</span> EmbeddedChannel(<span class="hljs-keyword">new</span> FixedLengthFrameDecoder(<span class="hljs-number">3</span>));        <span class="hljs-comment">//将数据写入EmbeddedChannel</span>        Assert.assertTrue(embeddedChannel.writeInbound(duplicate.retain()));        <span class="hljs-comment">//标记Channel为已完成的状态</span>        Assert.assertTrue(embeddedChannel.finish());                <span class="hljs-comment">//读取所生成的消息，并且验证是否有3帧，其中每帧都为3字节</span>        ByteBuf read = (ByteBuf) embeddedChannel.readInbound();        Assert.assertEquals(buffer.readSlice(<span class="hljs-number">3</span>),read);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; read.capacity(); i++) &#123;            System.out.println(read.getByte(i));        &#125;        read.release();        read = (ByteBuf)embeddedChannel.readInbound();        Assert.assertEquals(buffer.readSlice(<span class="hljs-number">3</span>),read);        read.release();        read = embeddedChannel.readInbound();        Assert.assertEquals(buffer.readSlice(<span class="hljs-number">3</span>),read);        read.release();        Assert.assertNull(embeddedChannel.readInbound());        buffer.release();    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFramesDecoded2</span><span class="hljs-params">()</span></span>&#123;        ByteBuf buffer = Unpooled.buffer();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;            buffer.writeByte(i);        &#125;        ByteBuf duplicate = buffer.duplicate();        EmbeddedChannel embeddedChannel = <span class="hljs-keyword">new</span> EmbeddedChannel(<span class="hljs-keyword">new</span> FixedLengthFrameDecoder(<span class="hljs-number">3</span>));        <span class="hljs-comment">//返回false，因为没有一个完整的可供读取的帧</span>        Assert.assertFalse(embeddedChannel.writeInbound(buffer.readBytes(<span class="hljs-number">2</span>)));        Assert.assertTrue(embeddedChannel.writeInbound(buffer.readBytes(<span class="hljs-number">7</span>)));        Assert.assertTrue(embeddedChannel.finish());        <span class="hljs-comment">//读取所生成的消息，并且验证是否有3帧，其中每帧都为3字节</span>        ByteBuf read = (ByteBuf) embeddedChannel.readInbound();        Assert.assertEquals(buffer.readSlice(<span class="hljs-number">3</span>),read);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; read.capacity(); i++) &#123;            System.out.println(read.getByte(i));        &#125;        read.release();        read = (ByteBuf)embeddedChannel.readInbound();        Assert.assertEquals(buffer.readSlice(<span class="hljs-number">3</span>),read);        read.release();        read = embeddedChannel.readInbound();        Assert.assertEquals(buffer.readSlice(<span class="hljs-number">3</span>),read);        read.release();        Assert.assertNull(embeddedChannel.readInbound());        buffer.release();    &#125;&#125;</code></pre></div><h3 id="测试出站消息"><a href="#测试出站消息" class="headerlink" title="测试出站消息"></a>测试出站消息</h3><p>利用EmbeddedChannel来测试一个编码器形式的ChannelOutboundHandler，这里我们只是简单的将负数转换为绝对值。</p><p>步骤：</p><ul><li>持有AbsIntegerEncoder的EmbeddedChannel将会以4字节的负整数的形式写出站数据；</li><li>编码器将从传入的ByteBuf中读取每个负整数，并将会调用Math.abs()方法来获取其绝对值；</li><li>编码器将会把每个负整数的绝对值写到ChannelPipeline中</li></ul><p>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbsIntegerEncoder</span> <span class="hljs-keyword">extends</span></span><span class="hljs-class">    <span class="hljs-title">MessageToMessageEncoder</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">        ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//检查是否有足够的字节用来编码</span>        <span class="hljs-keyword">while</span> (in.readableBytes() &gt;= <span class="hljs-number">4</span>) &#123;            <span class="hljs-comment">//从输入的 ByteBuf中读取下一个整数，并且计算其绝对值</span>            <span class="hljs-keyword">int</span> value = Math.abs(in.readInt());            <span class="hljs-comment">//将该整数写入到编码消息的 List 中</span>            out.add(value);        &#125;    &#125;&#125;</code></pre></div><p>使用了EmbeddedChannel来测试代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbsIntegerEncoderTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testEncoded</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//创建一个ByteBuf，并且写入9个负整数</span>        ByteBuf buf = Unpooled.buffer();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            buf.writeInt(i * -<span class="hljs-number">1</span>);        &#125;        <span class="hljs-comment">//创建一个EmbeddedChannel，并安装一个要测试的AbsIntegerEncoder</span>        EmbeddedChannel channel = <span class="hljs-keyword">new</span> EmbeddedChannel(<span class="hljs-keyword">new</span> AbsIntegerEncoder());        <span class="hljs-comment">//写入ByteBuf,并断言调用readOutbound()方法将会产生数据</span>        assertTrue(channel.writeOutbound(buf));        <span class="hljs-comment">//将该Channel标记为已完成状态</span>        assertTrue(channel.finish());        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            assertEquals(i,channel.readOutbound());        &#125;        assertNull(channel.readOutbound());    &#125;&#125;</code></pre></div><h2 id="测试异常处理"><a href="#测试异常处理" class="headerlink" title="测试异常处理"></a>测试异常处理</h2><p>示例：如果所读取的字节数超出了某个特定的限制，我们将会抛出一个TooLongFrameException，这是一种经常用来防范资源被耗尽的方法。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrameChunkDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxFrameSize;    <span class="hljs-comment">//指定将要产生的帧的最大允许大小</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FrameChunkDecoder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxFrameSize)</span> </span>&#123;        <span class="hljs-keyword">this</span>.maxFrameSize = maxFrameSize;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in,</span></span><span class="hljs-function"><span class="hljs-params">        List&lt;Object&gt; out)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">int</span> readableBytes = in.readableBytes();        <span class="hljs-keyword">if</span> (readableBytes &gt; maxFrameSize) &#123;            <span class="hljs-comment">// discard the bytes</span>            <span class="hljs-comment">//如果该帧太大，则丢弃它并抛出一个 TooLongFrameException……</span>            in.clear();            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TooLongFrameException();        &#125;        <span class="hljs-comment">//……否则，从 ByteBuf 中读取一个新的帧</span>        ByteBuf buf = in.readBytes(readableBytes);        <span class="hljs-comment">//将该帧添加到解码 读取一个新的帧消息的 List 中</span>        out.add(buf);    &#125;&#125;</code></pre></div><p>然后使用EmbeddedChannel来测试之前的代码是否正确：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrameChunkDecoderTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFramesDecoded</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//创建一个ByteBuf,并向它写入9字节</span>        ByteBuf buf = Unpooled.buffer();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;            buf.writeByte(i);        &#125;        ByteBuf input = buf.duplicate();        <span class="hljs-comment">//创建一个EmbeddedChannel，并向其安装一个帧大小为3字节的FrameChunkDecoder</span>        EmbeddedChannel channel = <span class="hljs-keyword">new</span> EmbeddedChannel(<span class="hljs-keyword">new</span> FrameChunkDecoder(<span class="hljs-number">3</span>));        <span class="hljs-comment">//向它写入2字节，并断言它们将会产生一个新帧</span>        assertTrue(channel.writeInbound(<span class="hljs-number">2</span>));        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//写入4字节大小的帧，并捕获预期的TooLongFrameException</span>            channel.writeInbound(input.readBytes(<span class="hljs-number">4</span>));            <span class="hljs-comment">//如果上面没有捕获，那么就会到达这个断言，并且测试失败</span>            fail();        &#125;<span class="hljs-keyword">catch</span> (TooLongFrameException e)&#123;            <span class="hljs-comment">//</span>        &#125;        <span class="hljs-comment">//因为之前的异常拦截里面没有做任何处理，所以程序可以继续执行，写入剩余的2字节，并断言将会产生一个有效帧</span>        assertTrue(channel.writeInbound(input.readBytes(<span class="hljs-number">3</span>)));        <span class="hljs-comment">//将该Channel标记为已完成状态</span>        assertTrue(channel.finish());        <span class="hljs-comment">//读取产生的消息，并且验证值</span>        ByteBuf read = (ByteBuf) channel.readInbound();        assertEquals(buf.readSlice(<span class="hljs-number">2</span>),read);        read.release();        read = (ByteBuf)channel.readInbound();        assertEquals(buf.skipBytes(<span class="hljs-number">4</span>).readSlice(<span class="hljs-number">3</span>),read);        read.release();        buf.release();    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>微服务分布式架构</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.Netty--引导</title>
    <link href="/2020/06/02/8-Netty-%E5%BC%95%E5%AF%BC/"/>
    <url>/2020/06/02/8-Netty-%E5%BC%95%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>引导客户端和服务器</li><li>从Channel内引导客户端</li><li>添加ChannelHandler</li><li>使用ChannelOption和属性</li></ul></blockquote><h2 id="Bootstrap类"><a href="#Bootstrap类" class="headerlink" title="Bootstrap类"></a>Bootstrap类</h2><p>引导类的层次结构：</p><p><img src="https://img-blog.csdnimg.cn/20200602152558618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>服务器致力于使用一个父Channel来接收来自客户端的连接，并创建子Channel以用于它们之间的通信；而客户端一般只需要一个单独的、没有父Channel的Channel来用于所有的网络交互。</p><p>首先聊聊为什么引导类是Cloneable的？</p><p>当我们需要创建多个具有类似配置或者完全相同配置的Channel的时候，可以通过在一个已经配置完成的引导类实例上调用clone（）方法来返回另一个可以立即使用的引导类实例。</p><p>这种方式只会创建引导类实例的EventLoopGroup的一个浅拷贝，被浅拷贝的EventLoopGroup将在所有克隆的Channel实例之间共享。</p><h2 id="引导客户端和无连接协议"><a href="#引导客户端和无连接协议" class="headerlink" title="引导客户端和无连接协议"></a>引导客户端和无连接协议</h2><p>Bootstrap类被用于客户端或者使用了无连接协议的应用程序中，主要方法有如下：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>group</td><td>设置 EventLoopGroup 用于处理所有的 Channel 的事件</td></tr><tr><td>channel channelFactory</td><td>channel() 指定 Channel 的实现类。如果类没有提供一个默认的构造函数,你可以调用 channelFactory() 来指定一个工厂类被 bind() 调用。</td></tr><tr><td>localAddress</td><td>指定Channel应该绑定到本地地址 。如果不提供,将由操作系统创建一个随机的。或者,您可以使用 bind() 或 connect()指定localAddress</td></tr><tr><td>option</td><td>设置 ChannelOption，其将被应用到新创建 Channel 的 ChannelConfig。这些选项将被 bind 或 connect 设置在Channel,这取决于哪个被首先调用。这个方法在创建Channel后没有影响。所支持 ChannelOption 取决于使用的Channel类型</td></tr><tr><td>attr</td><td>指定新创建的Channel属性值，这些属性值通过 bind 或 connect 设置在Channel,这取决于哪个被首先调用。这个方法在创建Channel后没有影响。所支持 ChannelOption 取决于使用的Channel类型</td></tr><tr><td>handler</td><td>设置添加到 ChannelPipeline 中的 ChannelHandler 接收事件通知。</td></tr><tr><td>clone</td><td>创建一个当前 Bootstrap的克隆拥有原来相同的设置。</td></tr><tr><td>remoteAddress</td><td>设置远程地址。此外,您可以通过 connect() 指定</td></tr><tr><td>connect</td><td>连接到远端，返回一个 ChannelFuture, 用于通知连接操作完成</td></tr><tr><td>bind</td><td>将通道绑定并返回一个 ChannelFuture,用于通知绑定操作完成后,必须调用 Channel.connect() 来建立连接。</td></tr></tbody></table><h3 id="引导客户端"><a href="#引导客户端" class="headerlink" title="引导客户端"></a>引导客户端</h3><p>引导过程如下图所示：</p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1591084964998&di=f47186a7d9c0c972d4a0146152c6db5d&imgtype=0&src=http%3A%2F%2Fww1.sinaimg.cn%2Flarge%2F66bbf30bly1g35jn06modj20rq0i6gp3.jpg" srcset="/img/loading.gif" alt="img"></p><p>引导一个客户端代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BootstrapClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;        BootstrapClient client = <span class="hljs-keyword">new</span> BootstrapClient();        client.bootstrap();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 代码清单 8-1 引导一个客户端</span><span class="hljs-comment">     * */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bootstrap</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//设置 EventLoopGroup，提供用于处理 Channel 事件的 EventLoop</span>        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-comment">//创建一个Bootstrap类的实例以创建和连接新的客户端Channel</span>        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();        bootstrap.group(group)            <span class="hljs-comment">//指定要使用的Channel 实现</span>            .channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">            //设置用于 <span class="hljs-title">Channel</span> 事件和数据的<span class="hljs-title">ChannelInboundHandler</span></span><span class="hljs-class">            .<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt;() </span>&#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">                    ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                    ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    System.out.println(<span class="hljs-string">"Received data"</span>);                &#125;                &#125;);        <span class="hljs-comment">//连接到远程主机</span>        ChannelFuture future = bootstrap.connect(            <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"www.manning.com"</span>, <span class="hljs-number">80</span>));        future.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span></span><span class="hljs-function">                <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-keyword">if</span> (channelFuture.isSuccess()) &#123;                    System.out.println(<span class="hljs-string">"Connection established"</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    System.err.println(<span class="hljs-string">"Connection attempt failed"</span>);                    channelFuture.cause().printStackTrace();                &#125;            &#125;        &#125;);    &#125;&#125;</code></pre></div><h3 id="Channel和EventLoopGroup的兼容性"><a href="#Channel和EventLoopGroup的兼容性" class="headerlink" title="Channel和EventLoopGroup的兼容性"></a>Channel和EventLoopGroup的兼容性</h3><p>在引导的过程中，在调用bind（）或者connect（）方法之前，必须调用一下方法来设置所需的组件：</p><ul><li>group()</li><li>channel()或者channelFactory()</li><li>handler()</li></ul><p>如果不这样做，则将会导致IllegalStateException，尤其是handler（）方法，因为它需要配置好的ChannelPipeline。</p><h2 id="引导服务器"><a href="#引导服务器" class="headerlink" title="引导服务器"></a>引导服务器</h2><h3 id="ServerBootstrap类"><a href="#ServerBootstrap类" class="headerlink" title="ServerBootstrap类"></a>ServerBootstrap类</h3><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>group</td><td>设置ServerBootstrap要用的EventLoopGroup，这个 EventLoopGroup 提供 ServerChannel 的 I/O 处理并且接收 Channel</td></tr><tr><td>channel channelFactory</td><td>channel() 指定 Channel 的实现类。如果Channel没有提供一个默认的构造函数,你可以提供一个 ChannelFactory。</td></tr><tr><td>localAddress</td><td>指定 ServerChannel 应该绑定到的本地地址。如果不提供,将由操作系统创建一个随机的。或者,您可以使用 bind() 或 connect()指定localAddress</td></tr><tr><td>option</td><td>指定一个 ChannelOption 来用于新创建的 ServerChannel 的 ChannelConfig 。这些选项将被设置在Channel的 bind() 或 connect(),这取决于谁首先被调用。在此调用这些方法之后设置或更改 ChannelOption 是无效的。</td></tr><tr><td>childOption</td><td>当Channel已被接受，指定一个 ChannelOption 应用于 Channel 的 ChannelConfig。</td></tr><tr><td>attr</td><td>指定 ServerChannel 的属性。这些属性可以被子Channel的 bind() 设置。当调用 bind() 之后，修改它们不会生效。</td></tr><tr><td>childAttr</td><td>应用属性到接收到的子Channel上。后续调用没有效果。</td></tr><tr><td>handler</td><td>设置添加到 ServerChannel 的 ChannelPipeline 中的 ChannelHandler。</td></tr><tr><td>childHandler</td><td>设置添加到接收到的 Channel 的 ChannelPipeline 中的 ChannelHandler。handler() 和 childHandler()之间的区别是前者是接收和处理ServerChannel，同时 childHandler() 添加处理器用于处理和接收 Channel。后者代表一个套接字绑定到一个远端。</td></tr><tr><td>clone</td><td>克隆 ServerBootstrap 用于连接到不同的远端，通过设置相同的原始 ServerBoostrap。</td></tr><tr><td>bind</td><td>绑定 ServerChannel 并且返回一个 ChannelFuture,用于通知连接操作完成了（结果可以是成功或者失败）</td></tr></tbody></table><h3 id="引导服务器-1"><a href="#引导服务器-1" class="headerlink" title="引导服务器"></a>引导服务器</h3><p>ServerBootstrap类比Bootstrap类多了一些childXXX()方法，这是因为ServerChannel的实现负责创建子Channel，这些子Channel代表了已被接受的连接，用这些方法来简化将设置应用到已被接受的子Channel的ChannelConfig的任务。</p><p>下图展示了ServerBootstrap在bind（）方法被调用时创建了一个ServerChannel，并且该ServerChannel管理了多个子Channel。</p><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1542357931,1822191383&fm=15&gp=0.jpg" srcset="/img/loading.gif" alt="img"></p><p>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bootstrap</span><span class="hljs-params">()</span> </span>&#123;        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-comment">//创建 Server Bootstrap</span>        ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();        <span class="hljs-comment">//设置 EventLoopGroup，其提供了用于处理 Channel 事件的EventLoop</span>        bootstrap.group(group)            <span class="hljs-comment">//指定要使用的 Channel 实现</span>            .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">            //设置用于处理已被接受的子 <span class="hljs-title">Channel</span> 的<span class="hljs-title">I</span>/<span class="hljs-title">O</span>及数据的 <span class="hljs-title">ChannelInboundHandler</span></span><span class="hljs-class">            .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt;() </span>&#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                    ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    System.out.println(<span class="hljs-string">"Received data"</span>);                &#125;            &#125;);        <span class="hljs-comment">//通过配置好的 ServerBootstrap 的实例绑定该 Channel</span>        ChannelFuture future = bootstrap.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));        future.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span></span><span class="hljs-function">                <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-keyword">if</span> (channelFuture.isSuccess()) &#123;                    System.out.println(<span class="hljs-string">"Server bound"</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    System.err.println(<span class="hljs-string">"Bind attempt failed"</span>);                    channelFuture.cause().printStackTrace();                &#125;            &#125;        &#125;);    &#125;</code></pre></div><h2 id="从Channel引导客户端"><a href="#从Channel引导客户端" class="headerlink" title="从Channel引导客户端"></a>从Channel引导客户端</h2><p>在实际项目开发中有时需要从已经被接受的子Channel中引导一个客户端Channel，我们可以创建一个新的Bootstrap实例，但是这样会产生额外的线程，以及在已被接受的子Channel和客户端Channel之间交换数据时带来的上下文切换。</p><p>一个更好的解决方案是：通过将已被接受的子Channel的EventLoop传递给Bootstrap的group（）方法来共享该EventLoop。</p><p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=2705103063,4189013526&fm=26&gp=0.jpg" srcset="/img/loading.gif" alt="img"></p><p>代码实现如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bootstrap</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//创建 ServerBootstrap 以创建 ServerSocketChannel，并绑定它</span>        ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();        <span class="hljs-comment">//设置 EventLoopGroup，其将提供用以处理 Channel 事件的 EventLoop</span>        bootstrap.group(<span class="hljs-keyword">new</span> NioEventLoopGroup(), <span class="hljs-keyword">new</span> NioEventLoopGroup())            <span class="hljs-comment">//指定要使用的 Channel 实现</span>            .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">            //设置用于处理已被接受的子 <span class="hljs-title">Channel</span> 的 <span class="hljs-title">I</span>/<span class="hljs-title">O</span> 和数据的 <span class="hljs-title">ChannelInboundHandler</span></span><span class="hljs-class">            .<span class="hljs-title">childHandler</span>(</span><span class="hljs-class">                <span class="hljs-title">new</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt;() </span>&#123;                    ChannelFuture connectFuture;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span></span><span class="hljs-function">                        <span class="hljs-keyword">throws</span> Exception </span>&#123;                        <span class="hljs-comment">//创建一个 Bootstrap 类的实例以连接到远程主机</span>                        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();                        <span class="hljs-comment">//指定 Channel 的实现</span>                        bootstrap.channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">handler</span>(</span><span class="hljs-class">                            //为入站 <span class="hljs-title">I</span>/<span class="hljs-title">O</span> 设置 <span class="hljs-title">ChannelInboundHandler</span></span><span class="hljs-class">                            <span class="hljs-title">new</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt;() </span>&#123;                                <span class="hljs-meta">@Override</span>                                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">                                    ChannelHandlerContext ctx, ByteBuf in)</span></span><span class="hljs-function">                                    <span class="hljs-keyword">throws</span> Exception </span>&#123;                                    System.out.println(<span class="hljs-string">"Received data"</span>);                                &#125;                            &#125;);                        <span class="hljs-comment">//使用与分配给已被接受的子Channel相同的EventLoop</span>                        bootstrap.group(ctx.channel().eventLoop());                        connectFuture = bootstrap.connect(                            <span class="hljs-comment">//连接到远程节点</span>                            <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"www.manning.com"</span>, <span class="hljs-number">80</span>));                    &#125;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">                        ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                            ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        <span class="hljs-keyword">if</span> (connectFuture.isDone()) &#123;                            <span class="hljs-comment">//当连接完成时，执行一些数据操作（如代理）</span>                            <span class="hljs-comment">// do something with the data</span>                        &#125;                    &#125;                &#125;);        <span class="hljs-comment">//通过配置好的 ServerBootstrap 绑定该 ServerSocketChannel</span>        ChannelFuture future = bootstrap.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));        future.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span></span><span class="hljs-function">                <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-keyword">if</span> (channelFuture.isSuccess()) &#123;                    System.out.println(<span class="hljs-string">"Server bound"</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    System.err.println(<span class="hljs-string">"Bind attempt failed"</span>);                    channelFuture.cause().printStackTrace();                &#125;            &#125;        &#125;);    &#125;</code></pre></div><p>编写Netty应用程序的一个一般原则：<strong>尽可能地重用EventLoop，以减少线程创建所带来的开销</strong>。</p><h2 id="在引导过程中添加多个ChannelHandler"><a href="#在引导过程中添加多个ChannelHandler" class="headerlink" title="在引导过程中添加多个ChannelHandler"></a>在引导过程中添加多个ChannelHandler</h2><p>之前的代码中，我们调用handler（）或者childHandler（）方法来添加单个的ChannelHandler。Netty提供了一个特殊的ChannelInboundHandlerAdapter（）子类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Channel</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span></span></code></pre></div><p>通过它的<code>protected abstract void initChannel(C ch) throws Exception</code>方法来讲多个ChannelHandler添加到一个ChannelPipeLine中的简便方法。你只需要简单的向Bootstrap或ServerBootstrap的实例提供你的ChannelInitializer实现即可，在该方法返回之后，ChannelInitializer的实例将会从ChannelPipeline中移除它自己。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bootstrap</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">//创建 ServerBootstrap 以创建和绑定新的 Channel</span>        ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();        <span class="hljs-comment">//设置 EventLoopGroup，其将提供用以处理 Channel 事件的 EventLoop</span>        bootstrap.group(<span class="hljs-keyword">new</span> NioEventLoopGroup(), <span class="hljs-keyword">new</span> NioEventLoopGroup())            <span class="hljs-comment">//指定 Channel 的实现</span>            .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">            //注册一个 <span class="hljs-title">ChannelInitializerImpl</span> 的实例来设置 <span class="hljs-title">ChannelPipeline</span></span><span class="hljs-class">            .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializerImpl</span>())</span>;        <span class="hljs-comment">//绑定到地址</span>        ChannelFuture future = bootstrap.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));        future.sync();    &#125;    <span class="hljs-comment">//用以设置 ChannelPipeline 的自定义 ChannelInitializerImpl 实现</span>    <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChannelInitializerImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-comment">//将所需的 ChannelHandler 添加到 ChannelPipeline</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            ChannelPipeline pipeline = ch.pipeline();            pipeline.addLast(<span class="hljs-keyword">new</span> HttpClientCodec());            pipeline.addLast(<span class="hljs-keyword">new</span> HttpObjectAggregator(Integer.MAX_VALUE));        &#125;    &#125;</code></pre></div><p>如果你的应用程序使用了多个ChannelHandler，自己定义一个ChannelInitializer的实现来将它们安装到ChannelPipeline中即可。</p><h2 id="使用Netty的ChannelOption和属性"><a href="#使用Netty的ChannelOption和属性" class="headerlink" title="使用Netty的ChannelOption和属性"></a>使用Netty的ChannelOption和属性</h2><p>在每个Channel创建时都手动配置它很麻烦，这时我们可以通过option()方法来讲ChannelOption应用到引导，我们提供的值将会被自动应用到引导所创建的所有Channel。</p><p>Netty提供了AttributeMap抽象以及AttributeKey等工具来实现任何类型的数据项与客户端和服务器Channel之间安全地关联。</p><p>下面代码展示了如何使用ChannelOption来配置Channel，以及如何使用属性来存储整型值。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bootstrap</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//创建一个 AttributeKey 以标识该属性</span>        <span class="hljs-keyword">final</span> AttributeKey&lt;Integer&gt; id = AttributeKey.newInstance(<span class="hljs-string">"ID"</span>);        <span class="hljs-comment">//创建一个 Bootstrap 类的实例以创建客户端 Channel 并连接它们</span>        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();        <span class="hljs-comment">//设置 EventLoopGroup，其提供了用于处理 Channel 事件的 EventLoop</span>        bootstrap.group(<span class="hljs-keyword">new</span> NioEventLoopGroup())            <span class="hljs-comment">//指定 Channel 的实现</span>            .channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">            .<span class="hljs-title">handler</span>(</span><span class="hljs-class">                //设置用以处理 <span class="hljs-title">Channel</span> 的 <span class="hljs-title">I</span>/<span class="hljs-title">O</span> 以及数据的 <span class="hljs-title">ChannelInboundHandler</span></span><span class="hljs-class">                <span class="hljs-title">new</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt;() </span>&#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRegistered</span><span class="hljs-params">(ChannelHandlerContext ctx)</span></span><span class="hljs-function">                        <span class="hljs-keyword">throws</span> Exception </span>&#123;                        <span class="hljs-comment">//使用 AttributeKey 检索属性以及它的值</span>                        Integer idValue = ctx.channel().attr(id).get();                        <span class="hljs-comment">// do something with the idValue</span>                    &#125;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">                        ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                        ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        System.out.println(<span class="hljs-string">"Received data"</span>);                    &#125;                &#125;            );        <span class="hljs-comment">//设置 ChannelOption，其将在 connect()或者bind()方法被调用时被设置到已经创建的 Channel 上</span>        bootstrap.option(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)            .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">5000</span>);        <span class="hljs-comment">//存储该 id 属性</span>        bootstrap.attr(id, <span class="hljs-number">123456</span>);        <span class="hljs-comment">//使用配置好的 Bootstrap 实例连接到远程主机</span>        ChannelFuture future = bootstrap.connect(            <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"www.manning.com"</span>, <span class="hljs-number">80</span>));        future.syncUninterruptibly();    &#125;</code></pre></div><h2 id="引导DatagramChannel"><a href="#引导DatagramChannel" class="headerlink" title="引导DatagramChannel"></a>引导DatagramChannel</h2><p>前面提到的都是基于TCP协议的SocketChannel，但是Bootstrap类也可以被用于无连接的协议，Netty提供了各种DatagramChannel的实现，唯一区别就是，不再调用connect()方法，而是只调用bind()方法，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bootstrap</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//创建一个 Bootstrap 的实例以创建和绑定新的数据报 Channel</span>        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();        <span class="hljs-comment">//设置 EventLoopGroup，其提供了用以处理 Channel 事件的 EventLoop</span>        bootstrap.group(<span class="hljs-keyword">new</span> OioEventLoopGroup()).channel(            <span class="hljs-comment">//指定 Channel 的实现</span>            OioDatagramChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">handler</span>(</span><span class="hljs-class">            //设置用以处理 <span class="hljs-title">Channel</span> 的 <span class="hljs-title">I</span>/<span class="hljs-title">O</span> 以及数据的 <span class="hljs-title">ChannelInboundHandler</span></span><span class="hljs-class">            <span class="hljs-title">new</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">DatagramPacket</span>&gt;() </span>&#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,</span></span><span class="hljs-function"><span class="hljs-params">                    DatagramPacket msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    <span class="hljs-comment">// Do something with the packet</span>                &#125;            &#125;        );        <span class="hljs-comment">//调用 bind() 方法，因为该协议是无连接的</span>        ChannelFuture future = bootstrap.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">0</span>));        future.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span></span><span class="hljs-function">               <span class="hljs-keyword">throws</span> Exception </span>&#123;               <span class="hljs-keyword">if</span> (channelFuture.isSuccess()) &#123;                   System.out.println(<span class="hljs-string">"Channel bound"</span>);               &#125; <span class="hljs-keyword">else</span> &#123;                   System.err.println(<span class="hljs-string">"Bind attempt failed"</span>);                   channelFuture.cause().printStackTrace();               &#125;            &#125;        &#125;);    &#125;</code></pre></div><h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><p><strong>最重要的是关闭EventLoopGroup</strong>，通过调用EventLoopGroup.shutdownGracefully()方法。这个调用将返回一个 Future 用来通知关闭完成。注意,shutdownGracefully()也是一个异步操作,所以你需要阻塞,直到它完成或注册一个侦听器直到返回的 Future 来通知完成。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bootstrap</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//创建处理 I/O 的EventLoopGroup</span>        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-comment">//创建一个 Bootstrap 类的实例并配置它</span>        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();        bootstrap.group(group)             .channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">        //...</span><span class="hljs-class">             .<span class="hljs-title">handler</span>(</span><span class="hljs-class">                <span class="hljs-title">new</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt;() </span>&#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">                            ChannelHandlerContext channelHandlerContext,</span></span><span class="hljs-function"><span class="hljs-params">                            ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        System.out.println(<span class="hljs-string">"Received data"</span>);                    &#125;                &#125;             );        bootstrap.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"www.manning.com"</span>, <span class="hljs-number">80</span>)).syncUninterruptibly();        <span class="hljs-comment">//,,,</span>        <span class="hljs-comment">//shutdownGracefully()方法将释放所有的资源，并且关闭所有的当前正在使用中的 Channel</span>        Future&lt;?&gt; future = group.shutdownGracefully();        <span class="hljs-comment">// block until the group has shutdown</span>        future.syncUninterruptibly();    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>微服务分布式架构</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.Netty--EventLoop和线程模型</title>
    <link href="/2020/06/01/7-Netty-EventLoop%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/06/01/7-Netty-EventLoop%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>线程模型概述</li><li>事件循环的概念和实现</li><li>任务调度</li><li>实现细节</li></ul></blockquote><h2 id="线程模型概述"><a href="#线程模型概述" class="headerlink" title="线程模型概述"></a>线程模型概述</h2><p>基本的线程池化模式可以描述为：</p><ul><li><p>从池的空闲列表中选择一个Thread，并且指派它去运行一个已提交的任务（一个Runnable的实现）；</p></li><li><p>当任务完成时，将该Thread返回给该列表，使其可被重用。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200602154938594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>（1）要执行的任务；</p><p>（2）任务递交给了线程池；</p><p>（3）从线程池中拉取一个可用的Thread，并执行任务，当任务完成时，将该Thread返回给空闲列表，使其可被重用</p><h2 id="EventLoop接口"><a href="#EventLoop接口" class="headerlink" title="EventLoop接口"></a>EventLoop接口</h2><p>EventLoop是协同设计的一部分，采用了两个基本的API：并发和网络编程。</p><p><img src="https://img-blog.csdnimg.cn/20200602155018734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>一个EventLoop将由一个永远都不会改变的Thread驱动，同时任务（Runnable或者Callable）可以直接提交给EventLoop实现，以立即执行或者调度执行。根据配置和可用核心不同，可能会创建多个EventLoop实例用以优化资源的使用，并且单个EventLoop可能会被指派用于服务多个Channel。</strong></p><h3 id="Netty4中的I-O和事件处理"><a href="#Netty4中的I-O和事件处理" class="headerlink" title="Netty4中的I/O和事件处理"></a>Netty4中的I/O和事件处理</h3><p>所有的I/O操作和事件都由已经被分配给了EventLoop的那个Thread来处理。</p><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>常见的用例是：发送心跳消息到远程节点，以检查连接是否还活着。</p><h3 id="JDK的任务调度API"><a href="#JDK的任务调度API" class="headerlink" title="JDK的任务调度API"></a>JDK的任务调度API</h3><p>java.util.concurrent.Executors类的工厂方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>newScheduledThreadPool(int corePoolSize)<br /><br />newScheduledThreadPool(int corePoolSize,<br />ThreadFactory threadFactory)</td><td>创建一个ScheduledThreadExecutorService，用于调度命令在指定延迟之后运行或者周期性地执行。它使用corePoolSize参数来计算线程数</td></tr><tr><td>newSingleThreadScheduledExecutor（）<br /><br />newSingleThreadScheduledExecutor(ThreadFactory threadFactory)</td><td>创建一个ScheduledThreadExecutorService，用于调度命令在指定延迟之后运行或者周期性地执行。它使用一个线程来执行被调度的任务。</td></tr></tbody></table><p>下面代码展示了如何使用ScheduledExecutorService来在60s的延迟之后执行一个任务：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//创建一个其线程池具有 10 个线程的ScheduledExecutorService</span>        ScheduledExecutorService executor =                Executors.newScheduledThreadPool(<span class="hljs-number">10</span>);        ScheduledFuture&lt;?&gt; future = executor.schedule(            <span class="hljs-comment">//创建一个 Runnable，以供调度稍后执行</span>            <span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-comment">//该任务要打印的消息</span>                System.out.println(<span class="hljs-string">"Now it is 60 seconds later"</span>);            &#125;        <span class="hljs-comment">//调度任务在从现在开始的 60 秒之后执行</span>        &#125;, <span class="hljs-number">60</span>, TimeUnit.SECONDS);        <span class="hljs-comment">//...</span>        <span class="hljs-comment">//一旦调度任务执行完成，就关闭 ScheduledExecutorService 以释放资源</span>        executor.shutdown();    &#125;</code></pre></div><p>高负载下性能上不佳</p><h3 id="使用EventLoop调度任务"><a href="#使用EventLoop调度任务" class="headerlink" title="使用EventLoop调度任务"></a>使用EventLoop调度任务</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleViaEventLoop</span><span class="hljs-params">()</span> </span>&#123;     Channel ch = CHANNEL_FROM_SOMEWHERE; <span class="hljs-comment">// get reference from somewhere</span>     ScheduledFuture&lt;?&gt; future = ch.eventLoop().schedule(         <span class="hljs-comment">//创建一个 Runnable以供调度稍后执行</span>         <span class="hljs-keyword">new</span> Runnable() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;             <span class="hljs-comment">//要执行的代码</span>             System.out.println(<span class="hljs-string">"60 seconds later"</span>);         &#125;         <span class="hljs-comment">//调度任务在从现在开始的 60 秒之后执行</span>     &#125;, <span class="hljs-number">60</span>, TimeUnit.SECONDS); &#125;</code></pre></div><p>如果要调度任务以每隔60s执行一次，则使用ScheduleAtFixedRate()方法。</p><p>要想取消或者检查（被调度任务的）执行状态，可以使用每个异步操作所返回的ScheduledFuture。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancelingTaskUsingScheduledFuture</span><span class="hljs-params">()</span></span>&#123;       Channel ch = CHANNEL_FROM_SOMEWHERE; <span class="hljs-comment">// get reference from somewhere</span>       <span class="hljs-comment">//...</span>       <span class="hljs-comment">//调度任务，并获得所返回的ScheduledFuture</span>       ScheduledFuture&lt;?&gt; future = ch.eventLoop().scheduleAtFixedRate(               <span class="hljs-keyword">new</span> Runnable() &#123;                   <span class="hljs-meta">@Override</span>                   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                       System.out.println(<span class="hljs-string">"Run every 60 seconds"</span>);                   &#125;               &#125;, <span class="hljs-number">60</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS);       <span class="hljs-comment">// Some other code that runs...</span>       <span class="hljs-keyword">boolean</span> mayInterruptIfRunning = <span class="hljs-keyword">false</span>;       <span class="hljs-comment">//取消该任务，防止它再次运行</span>       future.cancel(mayInterruptIfRunning);   &#125;</code></pre></div><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h3><p>Netty线程模型的卓越性能取决于对于当前执行的Thread的身份的确定（通过调用EventLoop的inEventLoop（Thread）方法实现），也就是说，确定它是否是分配给当前Channel以及它的EventLoop的那一个线程。</p><p>如果当前调用线程正是支撑EventLoop的线程，那么所提交的代码块将会被直接执行，否则，EventLoop将调度该任务以便稍后执行，并将它放入到内部队列中，当EventLoop下次处理它的事件时，它会执行队列中的那些任务/事件。</p><p>注意：每个EventLoop都有他自己的任务队列，独立于任何其他的EventLoop。</p><p><img src="https://img-blog.csdnimg.cn/20200602155127463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="EventLoop-线程的分配"><a href="#EventLoop-线程的分配" class="headerlink" title="EventLoop/线程的分配"></a>EventLoop/线程的分配</h3><h4 id="异步传输"><a href="#异步传输" class="headerlink" title="异步传输"></a>异步传输</h4><p>异步传输实现只使用了少量的EventLoop（以及和它们相关联的Thread），而且在当前的线程模型中，它们可能会被多个Channel所共享。这使得可以通过尽可能少的Thread来支撑大量的Channel，而不是每个Channel分配一个Thread。</p><p><img src="https://img-blog.csdnimg.cn/20200602155138107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>EventLoopGroup负责为每个新创建的Channel分配一个EventLoop，并且相同的Event Loop可能会被分配给多个Channel。</p><p>一旦一个Channel被分配给要给EventLoop，它将在它的整个生命周期中都使用整个EventLoop（以及相关联的Thread）。</p><h4 id="阻塞传输"><a href="#阻塞传输" class="headerlink" title="阻塞传输"></a>阻塞传输</h4><p>每个Channel都将会被分配给一个EventLoop（以及它的Thread）</p><p><img src="https://img-blog.csdnimg.cn/2020060215514520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>微服务分布式架构</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.Netty--ChannelHandler和ChannelPipeline</title>
    <link href="/2020/05/31/6-Netty-ChannelHandler%E5%92%8CChannelPipeline/"/>
    <url>/2020/05/31/6-Netty-ChannelHandler%E5%92%8CChannelPipeline/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>ChannelHandler和ChannelPipeline</li><li>检测资源泄漏</li><li>异常处理</li></ul></blockquote><h2 id="ChannelHandler家族"><a href="#ChannelHandler家族" class="headerlink" title="ChannelHandler家族"></a>ChannelHandler家族</h2><h3 id="Channel的生命周期"><a href="#Channel的生命周期" class="headerlink" title="Channel的生命周期"></a>Channel的生命周期</h3><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>ChannelUnregistered</td><td>Channel已经被创建，但还未注册到EventLoop</td></tr><tr><td>ChannelRegistered</td><td>Channel已经被注册到了EventLoop</td></tr><tr><td>ChannelActive</td><td>Channel处于活动状态（已连接到远程节点），可以接收和发送数据了</td></tr><tr><td>ChannelInactive</td><td>Channel没有连接到远程节点</td></tr></tbody></table><p>Channel的正常生命周期如下图所示，当这些状态发生改变时，将会生成对应的事件，这些事件将会被转发给ChannelPipeline中的ChannelHandler，其可以随后对它们做出响应。</p><p><img src="https://img-blog.csdnimg.cn/20200601160759198.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="ChannelHandler的生命周期"><a href="#ChannelHandler的生命周期" class="headerlink" title="ChannelHandler的生命周期"></a>ChannelHandler的生命周期</h3><p>ChannelHandler的生命周期方法主要有下面几种，这些方法都有一个ChannelHandlerContext参数，在ChannelHandler被添加到ChannelPipeline中或者从ChannelPipeline中移除时都会调用这些操作。</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>handlerAdded</td><td>当把ChannelHandler添加到ChannelPipeline中时被调用</td></tr><tr><td>handlerRemoved</td><td>当从ChannelPineline中移除ChannelHandler时被调用</td></tr><tr><td>exceptionCaught</td><td>当处理过程中在ChannelPipeline中有错误产生时被调用</td></tr></tbody></table><p>Netty定义了两个重要的ChannelHandler子接口：</p><ul><li>ChannelInboundHandler：处理入站数据以及各种状态变化；</li><li>ChannelOutboundHandler：处理出站数据并且允许拦截所有的操作；</li></ul><h3 id="ChannelInboundHandler接口"><a href="#ChannelInboundHandler接口" class="headerlink" title="ChannelInboundHandler接口"></a>ChannelInboundHandler接口</h3><p>下面这些是ChannelInboundHandler的生命周期方法，将会在数据被接收时或者与其对应的Channel状态发生改变时被调用。</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>ChannelUnregistered</td><td>当Channel从它的EventLoop注销并且无法处理任何I/O时被调用</td></tr><tr><td>ChannelRegistered</td><td>当Channel已经注册到它的EventLoop，并且能够处理I/O时被调用</td></tr><tr><td>ChannelActive</td><td>当Channel处于活动状态（已连接到远程节点）时被调用</td></tr><tr><td>ChannelInactive</td><td>当Channel离开活动状态并且不再连接它的远程节点时被调用</td></tr><tr><td>ChannelReadComplete</td><td>当Channel上的一个读操作完成时被调用</td></tr><tr><td>ChannelRead</td><td>当从Channel读取数据时被调用</td></tr><tr><td>ChannelWritabilityChanged</td><td>当Channel的可写状态发生改变时被调用</td></tr><tr><td>userEventTriggered</td><td>当调用ChannelInboundHandler.fireUserEventTriggered()方法时被调用</td></tr></tbody></table><p>当某个ChannelInboundHandler的实现重写了channelRead（）方法时，它将负责显式地释放与池化和ByteBuf实例相关的内存。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;        <span class="hljs-comment">//丢弃已接收的消息</span>        ReferenceCountUtil.release(msg);    &#125;&#125;</code></pre></div><p>不过我们一般使用SimpleChannelInboundHandler来自动释放资源。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleDiscardHandler</span></span><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,</span></span><span class="hljs-function"><span class="hljs-params">        Object msg)</span> </span>&#123;        <span class="hljs-comment">//不需要任何显式的资源释放</span>        <span class="hljs-comment">// No need to do anything special</span>    &#125;&#125;</code></pre></div><p>由于使用SimpleChannelInboundHandler会自动释放资源，所以不能存储指向任何消息的引用供将来使用。</p><h3 id="ChannelOutboundHandler接口"><a href="#ChannelOutboundHandler接口" class="headerlink" title="ChannelOutboundHandler接口"></a>ChannelOutboundHandler接口</h3><p>用来处理出站操作，它的方法将被Channel、ChannelPipeline以及ChannelHandlerContext调用。</p><p>ChannelOutboundHandler的一个强大的功能就是可以按需推迟操作或者事件，比如到远程节点的写入被暂停了，你可以推迟冲刷操作并在稍后继续。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ChannelOutboundHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelHandler</span> </span>&#123;<span class="hljs-comment">//当请求将Channel绑定到本地地址时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bind</span><span class="hljs-params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-comment">//当请求将Channel连接到远程节点时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            ChannelHandlerContext ctx, SocketAddress remoteAddress,</span></span><span class="hljs-function"><span class="hljs-params">            SocketAddress localAddress, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-comment">//当请求将Channel从远程节点断开时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">disconnect</span><span class="hljs-params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-comment">//当请求关闭Channel时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-comment">//当请求将Channel从它的EventLoop注销时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deregister</span><span class="hljs-params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-comment">//当请求从Channel读取更多的数据时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-comment">//当请求通过Channel将数据写到远程节点时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-comment">//当请求通过Channel将入队数据冲刷到远程节点时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception</span>;&#125;</code></pre></div><p>ChannelOutboundHandler中的大部分方法都需要一个ChannelPromise参数，以便在操作完成时得到通知。ChannelPromise是ChannelFuture的一个子类，其定义了一些可写的方法，如setSuccess（）和setFailure（），从而使ChannelFuture不可变。</p><h3 id="ChannelHandler适配器"><a href="#ChannelHandler适配器" class="headerlink" title="ChannelHandler适配器"></a>ChannelHandler适配器</h3><p>我们可以使用ChannelInboundHandlerAdapter和ChannelOutboundHandlerAdapter类作为自己的ChannelHandler的起始点。这两个适配器分别提供了ChannelInboundHandler和ChannelOutboundHandler的基本实现，通过扩展抽象类ChannelHandlerAdapter，他们获得了ChannelHandler的方法。生成的类的层次结构如下图</p><p><img src="https://img-blog.csdnimg.cn/20200601160813550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200601160827702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>在ChannelInboundHandlerAdapter和ChannelOutboundHandlerAdapter中所提供的方法体调用了其相关联的ChannelHandlerContext上的等效方法，从而将事件转发到了ChannelPipeline中的下一个ChannelHandler中。</p><h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><p>每当通过调用ChannelInboundHandler.channelRead()或者ChannelOutboundHandler.write()方法来处理数据时，你都需要确保没有任何的资源泄露。</p><p>Netty提供了4种泄漏检测级别，分别如下：</p><ul><li><p>DISABLED——禁用泄露检测</p></li><li><p>SIMPLE——使用1%的默认采样率检测并报告任何发现的泄露</p></li><li><p>ADVANCED——使用默认的采样率，报告所发现的任何的泄露以及对应的消息被访问的位置</p></li><li><p>PARANOID——类似于ADVANCED，但是其将会对每次访问都进行采样，这对性能将会有很大的影响，应该只在调试阶段使用</p></li></ul><p>泄露检测级别可以通过将下面的Java系统属性设置为表中的一个值来定义：</p><div class="hljs"><pre><code class="hljs java">java -Dio.netty.leakDetectionLevel = ADVANCED</code></pre></div><p>消费入站可以通过SimpleChannelInboundHandler类来实现，在消息被channelRead0()方法消费之后自动释放消息。</p><p>如果是出站消息，丢弃并释放资源的代码参考如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardOutboundHandler</span></span><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelOutboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx,</span></span><span class="hljs-function"><span class="hljs-params">        Object msg, ChannelPromise promise)</span> </span>&#123;        <span class="hljs-comment">//通过使用 ReferenceCountUtil.realse(...)方法释放资源</span>        ReferenceCountUtil.release(msg);        <span class="hljs-comment">//通知 ChannelPromise数据已经被处理了</span>        promise.setSuccess();    &#125;&#125;</code></pre></div><p>这里要注意的是，我们不仅要释放资源，同时也要通知ChannelPromise，否则可能会出现ChannelFutureListener收不到某个消息已经被处理的通知。</p><h2 id="ChannelPipeline接口"><a href="#ChannelPipeline接口" class="headerlink" title="ChannelPipeline接口"></a>ChannelPipeline接口</h2><p>每个新建的Channel都会被分配一个新的ChannelPipeline，Channel既不能附加另一个ChannelPipeline，也不能分离当前的。</p><p>根据事件的起源，事件将会被ChannelInboundHandler或者ChannelOutboundHandler处理，随后通过调用ChannelHandlerContext的实现，它将被转发给同一超类型的下一个ChannelHandler。</p><p>ChannelHandlerContext的作用就是使得ChannelHandler能够和它的ChannelPipeline以及其他的ChannelHandler交互。</p><p>Netty总是将ChannelPipeline的入站口作为头部，而将出站口作为尾部，在ChannelPipeline传播事件时，它会测试ChannelPipeline中下一个ChannelHandler的类型是否和事件的运动方向相匹配，如果不匹配就跳过，直到找到和该事件所期望的方向相匹配的为止。</p><h3 id="修改ChannelPipeline"><a href="#修改ChannelPipeline" class="headerlink" title="修改ChannelPipeline"></a>修改ChannelPipeline</h3><p>通过调用ChannelPipeline上的相关方法，ChannelHandler可以添加、删除或者替换其他的ChannelHandler，从而实时地修改ChannelPipeline的布局。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">modifyPipeline</span><span class="hljs-params">()</span> </span>&#123;        ChannelPipeline pipeline = CHANNEL_PIPELINE_FROM_SOMEWHERE; <span class="hljs-comment">// get reference to pipeline;</span>        <span class="hljs-comment">//创建一个 FirstHandler 的实例</span>        FirstHandler firstHandler = <span class="hljs-keyword">new</span> FirstHandler();        <span class="hljs-comment">//将该实例作为"handler1"添加到ChannelPipeline 中</span>        pipeline.addLast(<span class="hljs-string">"handler1"</span>, firstHandler);        <span class="hljs-comment">//将一个 SecondHandler的实例作为"handler2"添加到 ChannelPipeline的第一个槽中。这意味着它将被放置在已有的"handler1"之前</span>        pipeline.addFirst(<span class="hljs-string">"handler2"</span>, <span class="hljs-keyword">new</span> SecondHandler());        <span class="hljs-comment">//将一个 ThirdHandler 的实例作为"handler3"添加到 ChannelPipeline 的最后一个槽中</span>        pipeline.addLast(<span class="hljs-string">"handler3"</span>, <span class="hljs-keyword">new</span> ThirdHandler());        <span class="hljs-comment">//...</span>        <span class="hljs-comment">//通过名称移除"handler3"</span>        pipeline.remove(<span class="hljs-string">"handler3"</span>);        <span class="hljs-comment">//通过引用移除FirstHandler（它是唯一的，所以不需要它的名称）</span>        pipeline.remove(firstHandler);        <span class="hljs-comment">//将 SecondHandler("handler2")替换为 FourthHandler:"handler4"</span>        pipeline.replace(<span class="hljs-string">"handler2"</span>, <span class="hljs-string">"handler4"</span>, <span class="hljs-keyword">new</span> FourthHandler());    &#125;</code></pre></div><p>通常ChannelPipeline中的每个ChannelHandler都是通过它的EventLoop（I/O线程）来处理传递给它的事件的。</p><h3 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h3><ul><li>ChannelPipeline保存了与Channel相关联的ChannelHandler；</li></ul><ul><li>ChannelPipeline可以根据需要、通过添加或者删除ChannelHandler来动态修改；</li></ul><ul><li>ChannelPipeline有着丰富的API用以被调用、以响应入站和出站事件。</li></ul><h2 id="ChannelHandlerContext接口"><a href="#ChannelHandlerContext接口" class="headerlink" title="ChannelHandlerContext接口"></a>ChannelHandlerContext接口</h2><p>前面也提到了，ChannelHandlerContext代表了ChannelHandler和ChannelPipeline之间的关联，<strong>ChannelHandlerContext的主要功能就是管理它所关联的ChannelHandler和在同一个ChannelPipeline中的其他ChannelHandler之间的交互。</strong></p><p>ChannelHandlerContext本身很多方法在Channel和ChannelPipeline中也存在，但是如果调用Channel或者ChannelPipeline上的这些方法，它们将沿着整个ChannelPipeline进行传播，而调用位于ChannelHandlerContext上的这些方法，则将从当前所关联的ChannelHandler开始，并且只会传播给位于该ChannelPipeline中的下一个能够处理该事件的ChannelHandler，因此它会产生更短的事件流，性能会得到提高。</p><p>另外，ChannelHandlerContext和ChannelHandler之间的关联（绑定）是永远不会改变的，所以缓存对它的引用是安全的。</p><h3 id="使用ChannelHandlerContext"><a href="#使用ChannelHandlerContext" class="headerlink" title="使用ChannelHandlerContext"></a>使用ChannelHandlerContext</h3><p>Channel、ChannelPipeline、ChannelHandler以及ChannelHandlerContext之间的关系如下图：</p><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=777592249,3155125613&fm=15&gp=0.jpg" srcset="/img/loading.gif" alt="img"></p><p>为什么想要从channelPipeline中的某个特定点开始传播事件呢？</p><ul><li><p>为了减少将事件经传对它不感兴趣的ChannelHandler所带来的开销；</p></li><li><p>为了避免将事件传经那些可能会对它感兴趣的ChannelHandler。</p></li></ul><p>如果想调用从某个特定的ChannelHandler开始的处理过程，必须获取到在（ChannelPipeline）该ChannelHandler之前的ChannelHandler所关联的ChannelHandlerContext，这个ChannelHandlerContext将调用和它所关联的ChannelHandler之后的ChannelHandler。</p><p>通过ChannelHandlerContext触发的操作的事件流如下图所示：</p><p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=770095752,3504408543&fm=15&gp=0.jpg" srcset="/img/loading.gif" alt="img"></p><h3 id="ChannelHandler和ChannelHandlerContext的高级用法"><a href="#ChannelHandler和ChannelHandlerContext的高级用法" class="headerlink" title="ChannelHandler和ChannelHandlerContext的高级用法"></a>ChannelHandler和ChannelHandlerContext的高级用法</h3><p>通过调用ChannelHandlerContext上的pipeline()方法来获得被封闭的ChannelPipeline的引用，这使得运行时得以操作ChannelPipeline的ChannelHandler。如可以通过将ChannelHandler添加到ChannelPipeline中来实现动态的协议切换；还可以缓存ChannelHandlerContext的引用以供后面使用。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelHandlerAdapter</span> </span>&#123;    <span class="hljs-keyword">private</span> ChannelHandlerContext ctx;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;        <span class="hljs-comment">//存储到 ChannelHandlerContext的引用以供稍后使用</span>        <span class="hljs-keyword">this</span>.ctx = ctx;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(String msg)</span> </span>&#123;        <span class="hljs-comment">//使用之前存储的到 ChannelHandlerContext的引用来发送消息</span>        ctx.writeAndFlush(msg);    &#125;&#125;</code></pre></div><p>因为一个ChannelHandler可以从属于多个ChannelPipeline，所以也可以绑定多个ChannelHandlerContext实例，但是ChannelHandler必须使用@Sharable注解，并且ChannelHandler必须是线程安全的。</p><p>看个错误示例：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Sharable</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsharableHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;        <span class="hljs-comment">//将 count 字段的值加 1</span>        count++;        <span class="hljs-comment">//记录方法调用，并转发给下一个ChannelHandler</span>        System.out.println(<span class="hljs-string">"inboundBufferUpdated(...) called the "</span>                + count + <span class="hljs-string">" time"</span>);        ctx.fireChannelRead(msg);    &#125;&#125;</code></pre></div><p>为什么要共享一个ChannelHandler？</p><p>主要是用于收集跨越多个Channel的统计信息。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="处理入站异常"><a href="#处理入站异常" class="headerlink" title="处理入站异常"></a>处理入站异常</h3><p>要想处理入站异常，需要在自己的ChannelInboundHandler实现中重写exceptionCaught（）方法。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InboundExceptionHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx,</span></span><span class="hljs-function"><span class="hljs-params">        Throwable cause)</span> </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre></div><ul><li>ChannelHandler.exceptionCaught()的默认实现是简单地将当前异常转发给ChannelPipeline中的下一个ChannelHandler；</li><li>如果异常到达了ChannelPipeline的尾端，它将会被记录为未被处理；</li><li>要想自定义处理逻辑，需要重写exceptionCaught（）方法，然后决定是否需要将异常传播出去。</li></ul><h3 id="处理出站异常"><a href="#处理出站异常" class="headerlink" title="处理出站异常"></a>处理出站异常</h3><p>用于处理出站操作中的正常完成以及异常完成的选项，都基于以下的通知机制：</p><ul><li>每个出站操作都将返回一个ChannelFuture。注册到ChannelFuture的ChannelFutureListener将在操作完成时被通知该操作是成功了还是失败了；</li><li>几乎所有的ChannelOutboundHandler上的方法都会传入一个ChannelPromise的实例，作为ChannelFuture的子类，ChannelPromise也可以被分配用于异步通知的监听器。</li></ul><p>添加ChannelFutureListener到ChannelFuture的代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addingChannelFutureListener</span><span class="hljs-params">()</span></span>&#123;    Channel channel = CHANNEL_FROM_SOMEWHERE; <span class="hljs-comment">// get reference to pipeline;</span>    ByteBuf someMessage = SOME_MSG_FROM_SOMEWHERE; <span class="hljs-comment">// get reference to pipeline;</span>    <span class="hljs-comment">//...</span>    io.netty.channel.ChannelFuture future = channel.write(someMessage);    future.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(io.netty.channel.ChannelFuture f)</span> </span>&#123;            <span class="hljs-keyword">if</span> (!f.isSuccess()) &#123;                f.cause().printStackTrace();                f.channel().close();            &#125;        &#125;    &#125;);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>微服务分布式架构</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.Netty--ByteBuf</title>
    <link href="/2020/05/31/5-Netty-ByteBuf/"/>
    <url>/2020/05/31/5-Netty-ByteBuf/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>ByteBuf：Netty的数据容器</li><li>API的详细信息</li><li>用例</li><li>内存分配</li></ul></blockquote><h2 id="ByteBuf的API"><a href="#ByteBuf的API" class="headerlink" title="ByteBuf的API"></a>ByteBuf的API</h2><p>Java NIO虽然提供了ByteBuffer作为字节容器，但是其使用过于复杂和繁琐，因此用ByteBuf来代替ByteBuffer。</p><p>优点：</p><ul><li>可以被用户自定义的缓冲区类型扩展</li><li>通过内置的复合缓冲区类型实现了透明的零拷贝</li><li>容量可以按需增长</li><li>在读和写这两种模式之间切换不需要调用ByteBuffer的flip（）方法；</li><li>读和写使用了不同的索引；</li><li>支持方法的链式调用</li><li>支持引用计数</li><li>支持<a href="https://blog.csdn.net/syviah/article/details/46550161" target="_blank" rel="noopener">池化</a></li></ul><h2 id="ByteBuf类"><a href="#ByteBuf类" class="headerlink" title="ByteBuf类"></a>ByteBuf类</h2><h3 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h3><p>ByteBuf维护了两个不同的索引：一个用于读取，一个用于写入。当你从ByteBuf读取时，它的readIndex将会被递增已经被读取的字节数，同样，当你写入ByteBuf时，它的writerIndex也会被递增。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy84MTk2OTQxLTIyYjg2MzlkMGY0Njg0MDAucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="img"></p><h3 id="ByteBuf的使用模式"><a href="#ByteBuf的使用模式" class="headerlink" title="ByteBuf的使用模式"></a>ByteBuf的使用模式</h3><h4 id="堆缓冲区"><a href="#堆缓冲区" class="headerlink" title="堆缓冲区"></a>堆缓冲区</h4><p>将数据存储在JVM的堆空间中，这种模式被称为支撑数组，它能在没有使用<a href="https://blog.csdn.net/syviah/article/details/46550161" target="_blank" rel="noopener">池化</a>的情况下提供快速的分配和释放。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapBuffer</span><span class="hljs-params">()</span> </span>&#123;        ByteBuf heapBuf = BYTE_BUF_FROM_SOMEWHERE; <span class="hljs-comment">//get reference form somewhere</span>        <span class="hljs-comment">//检查 ByteBuf 是否有一个支撑数组</span>        <span class="hljs-keyword">if</span> (heapBuf.hasArray()) &#123;            <span class="hljs-comment">//如果有，则获取对该数组的引用</span>            <span class="hljs-keyword">byte</span>[] array = heapBuf.array();            <span class="hljs-comment">//计算第一个字节的偏移量</span>            <span class="hljs-keyword">int</span> offset = heapBuf.arrayOffset() + heapBuf.readerIndex();            <span class="hljs-comment">//获得可读字节数</span>            <span class="hljs-keyword">int</span> length = heapBuf.readableBytes();            <span class="hljs-comment">//使用数组、偏移量和长度作为参数调用你的方法</span>            handleArray(array, offset, length);        &#125;    &#125;</code></pre></div><h4 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h4><p>直接缓冲区时另一种ByteBuf模式，它的内容将驻留在常规的会被垃圾回收的堆之外，相对于堆缓冲区，它的分配和释放都较为昂贵，另外因为数据不是在堆上，所以还要进行一次复制。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">directBuffer</span><span class="hljs-params">()</span> </span>&#123;        ByteBuf directBuf = BYTE_BUF_FROM_SOMEWHERE; <span class="hljs-comment">//get reference form somewhere</span>        <span class="hljs-comment">//检查 ByteBuf 是否由数组支撑。如果不是，则这是一个直接缓冲区</span>        <span class="hljs-keyword">if</span> (!directBuf.hasArray()) &#123;            <span class="hljs-comment">//获取可读字节数</span>            <span class="hljs-keyword">int</span> length = directBuf.readableBytes();            <span class="hljs-comment">//分配一个新的数组来保存具有该长度的字节数据</span>            <span class="hljs-keyword">byte</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length];            <span class="hljs-comment">//将字节复制到该数组</span>            directBuf.getBytes(directBuf.readerIndex(), array);            <span class="hljs-comment">//使用数组、偏移量和长度作为参数调用你的方法</span>            handleArray(array, <span class="hljs-number">0</span>, length);        &#125;    &#125;</code></pre></div><h4 id="复合缓冲区"><a href="#复合缓冲区" class="headerlink" title="复合缓冲区"></a>复合缓冲区</h4><p>Netty通过一个ByteBuf子类<strong>CompositeByteBuf来提供一个将多个缓冲区表示为单个合并缓冲区</strong>的虚拟表示。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">byteBufComposite</span><span class="hljs-params">()</span> </span>&#123;        CompositeByteBuf messageBuf = Unpooled.compositeBuffer();        ByteBuf headerBuf = BYTE_BUF_FROM_SOMEWHERE; <span class="hljs-comment">// can be backing or direct</span>        ByteBuf bodyBuf = BYTE_BUF_FROM_SOMEWHERE;   <span class="hljs-comment">// can be backing or direct</span>        <span class="hljs-comment">//将 ByteBuf 实例追加到 CompositeByteBuf</span>        messageBuf.addComponents(headerBuf, bodyBuf);        <span class="hljs-comment">//...</span>        <span class="hljs-comment">//删除位于索引位置为 0（第一个组件）的 ByteBuf</span>        messageBuf.removeComponent(<span class="hljs-number">0</span>); <span class="hljs-comment">// remove the header</span>        <span class="hljs-comment">//循环遍历所有的 ByteBuf 实例</span>        <span class="hljs-keyword">for</span> (ByteBuf buf : messageBuf) &#123;            System.out.println(buf.toString());        &#125;    &#125;</code></pre></div><p>CompositeByteBuf可能不支持访问其支撑数组，因此访问CompositeByteBuf中的数据类似于访问直接缓冲区，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">byteBufCompositeArray</span><span class="hljs-params">()</span> </span>&#123;        CompositeByteBuf compBuf = Unpooled.compositeBuffer();        <span class="hljs-comment">//获得可读字节数</span>        <span class="hljs-keyword">int</span> length = compBuf.readableBytes();        <span class="hljs-comment">//分配一个具有可读字节数长度的新数组</span>        <span class="hljs-keyword">byte</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length];        <span class="hljs-comment">//将字节读到该数组中</span>        compBuf.getBytes(compBuf.readerIndex(), array);        <span class="hljs-comment">//使用偏移量和长度作为参数使用该数组</span>        handleArray(array, <span class="hljs-number">0</span>, array.length);    &#125;</code></pre></div><h2 id="字节级操作"><a href="#字节级操作" class="headerlink" title="字节级操作"></a>字节级操作</h2><h3 id="随机访问索引"><a href="#随机访问索引" class="headerlink" title="随机访问索引"></a>随机访问索引</h3><p>ByteBuf的索引也是从零开始的，访问数据的代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">byteBufRelativeAccess</span><span class="hljs-params">()</span> </span>&#123;        ByteBuf buffer = BYTE_BUF_FROM_SOMEWHERE; <span class="hljs-comment">//get reference form somewhere</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; buffer.capacity(); i++) &#123;            <span class="hljs-keyword">byte</span> b = buffer.getByte(i);            System.out.println((<span class="hljs-keyword">char</span>) b);        &#125;    &#125;</code></pre></div><h3 id="顺序访问索引"><a href="#顺序访问索引" class="headerlink" title="顺序访问索引"></a>顺序访问索引</h3><p>ByteBuf被读索引和写索引划分为了三个区域：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczAuYmRzdGF0aWMuY29tLzcwY0Z1SFNoX1ExWW54R2twb1dLMUhGNmhoeS9pdC91PTI2NDQwMjEyMDgsMzczMDkyNDY5OCZmbT0xNSZncD0wLmpwZw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="img"></p><h3 id="可丢弃字节"><a href="#可丢弃字节" class="headerlink" title="可丢弃字节"></a>可丢弃字节</h3><p>可丢弃字节的分段包含了已经被读过的字节。通过调用discardReadBytes()方法，可以丢弃它们并回收空间，变成可写字节，但是不建议频繁调用discardReadBytes()方法，因为可读字节必须被移动到缓冲区的开始位置。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy84MTk2OTQxLTY2MjFjZGQ2MjQwNzdkODcucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="img"></p><h3 id="可读字节"><a href="#可读字节" class="headerlink" title="可读字节"></a>可读字节</h3><p>存储了实际数据，任何名称以read 或者skip 开头的操作都将检索或者跳过位于当前readerIndex 的数据，并且将它增加已读字节数。</p><h3 id="可写字节"><a href="#可写字节" class="headerlink" title="可写字节"></a>可写字节</h3><p>拥有未定义内容的、写入就绪的内存区域，任何名称以write开头的操作都将从当前的writerIndex处开始写数据，并将它增加已经写入的字节数。</p><h3 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h3><p>通过调用markReaderIndex()、markWriterIndex()、resetWriterIndex()和resetReaderIndex()来标记和重置ByteBuf 的readerIndex 和writerIndex。可以通过调用<code>clear()</code>方法来将readerIndex 和writerIndex 都设置为0，但是这并不会清除内存中的内容。</p><p>clear（）方法调用前：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy84MTk2OTQxLTZlMzMxM2E5NTA4NmRkMDgucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="img"></p><p>clear（）方法调用后：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy84MTk2OTQxLTYxNDdhYmM0M2MwNTYwZTYucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="img"></p><h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><ul><li><p>boolean process(byte value) 检查输入值是否是正在查找的值</p></li><li><p>forEachByte(ByteBufProcessor.FIND_NUL) 和以NULL结尾的内容的Flash套接字集成</p></li></ul><h3 id="派生缓冲区"><a href="#派生缓冲区" class="headerlink" title="派生缓冲区"></a>派生缓冲区</h3><p>1.duplicate()；<br> 2.slice()；<br> 3.slice(int, int)；<br> 4.Unpooled.unmodifiableBuffer(…)；<br> 5.order(ByteOrder)；<br> 6.readSlice(int)。</p><p>以上这些方法都将返回一个新的ByteBuf实例，它具有自己的读索引、写索引和标记索引，其内部存储和JDK的ByteBuffer一样也是共享的，因此如果修改了它的内容，那么同时也就修改了其对应的源实例。</p><p>如果需要一个现有缓冲区的真实副本，使用copy()或者copy(int,int)方法。</p><p>下面代码展示了如何使用slice(int,int)方法来操作ByteBuf的一个分段：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">byteBufSlice</span><span class="hljs-params">()</span> </span>&#123;      Charset utf8 = Charset.forName(<span class="hljs-string">"UTF-8"</span>);      <span class="hljs-comment">//创建一个用于保存给定字符串的字节的 ByteBuf</span>      ByteBuf buf = Unpooled.copiedBuffer(<span class="hljs-string">"Netty in Action rocks!"</span>, utf8);      <span class="hljs-comment">//创建该 ByteBuf 从索引 0 开始到索引 15 结束的一个新切片</span>      ByteBuf sliced = buf.slice(<span class="hljs-number">0</span>, <span class="hljs-number">15</span>);      <span class="hljs-comment">//将打印“Netty in Action”</span>      System.out.println(sliced.toString(utf8));      <span class="hljs-comment">//更新索引 0 处的字节</span>      buf.setByte(<span class="hljs-number">0</span>, (<span class="hljs-keyword">byte</span>)<span class="hljs-string">'J'</span>);      <span class="hljs-comment">//将会成功，因为数据是共享的，对其中一个所做的更改对另外一个也是可见的</span>      <span class="hljs-keyword">assert</span> buf.getByte(<span class="hljs-number">0</span>) == sliced.getByte(<span class="hljs-number">0</span>);  &#125;</code></pre></div><p>如果有可能，建议使用slice()方法来避免复制内存的开销。</p><h3 id="读-写操作"><a href="#读-写操作" class="headerlink" title="读/写操作"></a>读/写操作</h3><p>有两种类别的读/写操作：</p><ul><li><p>get()和set()操作，从给定的索引开始，并且保持索引不变；</p></li><li><p>read()和write()操作，从给定的索引开始，并且会根据已经访问过的字节数对索引进行调整。</p></li></ul><p>测试代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">byteBufSetGet</span><span class="hljs-params">()</span> </span>&#123;        Charset utf8 = Charset.forName(<span class="hljs-string">"UTF-8"</span>);        <span class="hljs-comment">//创建一个新的 ByteBuf以保存给定字符串的字节</span>        ByteBuf buf = Unpooled.copiedBuffer(<span class="hljs-string">"Netty in Action rocks!"</span>, utf8);        <span class="hljs-comment">//打印第一个字符'N'</span>        System.out.println((<span class="hljs-keyword">char</span>)buf.getByte(<span class="hljs-number">0</span>));        <span class="hljs-comment">//存储当前的 readerIndex 和 writerIndex</span>        <span class="hljs-keyword">int</span> readerIndex = buf.readerIndex();        <span class="hljs-keyword">int</span> writerIndex = buf.writerIndex();        <span class="hljs-comment">//将索引 0 处的字 节更新为字符'B'</span>        buf.setByte(<span class="hljs-number">0</span>, (<span class="hljs-keyword">byte</span>)<span class="hljs-string">'B'</span>);        <span class="hljs-comment">//打印第一个字符，现在是'B'</span>        System.out.println((<span class="hljs-keyword">char</span>)buf.getByte(<span class="hljs-number">0</span>));        <span class="hljs-comment">//将会成功，因为这些操作并不会修改相应的索引</span>        <span class="hljs-keyword">assert</span> readerIndex == buf.readerIndex();        <span class="hljs-keyword">assert</span> writerIndex == buf.writerIndex();    &#125;</code></pre></div><h2 id="ByteBufHolder接口"><a href="#ByteBufHolder接口" class="headerlink" title="ByteBufHolder接口"></a>ByteBufHolder接口</h2><p>Netty提供了ByteBufHolder来提供高级特性的支持，如存储各种属性值（HTTP响应中字节的内容，状态码，cookie等），缓冲区池化等。</p><p>ByteBufHolder只有几种用于访问底层数据和引用计数的方法：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>content()</td><td>返回由这个ByteBufHolder所持有的ByteBuf</td></tr><tr><td>copy()</td><td>返回这个ByteBufHolder的一个深拷贝，包括一个其所包含的ByteBuf 的非共享拷贝</td></tr><tr><td>duplicate()</td><td>返回这个ByteBufHolder 的一个浅拷贝，包括一个其所包含的ByteBuf 的共享拷贝</td></tr></tbody></table><h2 id="ByteBuf-分配"><a href="#ByteBuf-分配" class="headerlink" title="ByteBuf 分配"></a>ByteBuf 分配</h2><h3 id="按需分配：ByteBufAllocator-接口"><a href="#按需分配：ByteBufAllocator-接口" class="headerlink" title="按需分配：ByteBufAllocator 接口"></a>按需分配：ByteBufAllocator 接口</h3><p>Netty 通过<code>ByteBufAllocator</code>接口 实现了（ByteBuf 的）<a href="https://blog.csdn.net/syviah/article/details/46550161" target="_blank" rel="noopener">池化</a> ，它可以用来分配我们所描述过的任意类型的ByteBuf实例。</p><p>Netty提供了两种ByteBufAllocator 的实现： <code>PooledByteBufAllocator</code>和<code>UnpooledByteBufAllocator</code>。前者池化了ByteBuf的实例以提高性能并最大限度地减少内存碎片(一种称为jemalloc的已被大量现代操作系统所采用的高效方法来分配内存).后者的实现不池化ByteBuf实例，并且在每次它被调用时都会返回一个新的实例。</p><h3 id="Unpooled缓冲区"><a href="#Unpooled缓冲区" class="headerlink" title="Unpooled缓冲区"></a>Unpooled缓冲区</h3><p>提供静态的辅助方法来创建未池化的ByteBuf实例：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>buffer()<br/>buffer(int initialCapacity)<br/>buffer(int initialCapacity, int maxCapacity)</td><td>返回一个未池化的基于堆内存存储的ByteBuf</td></tr><tr><td>directBuffer()<br/>directBuffer(int initialCapacity)<br/>directBuffer(int initialCapacity, int maxCapacity)</td><td>返回一个未池化的基于直接内存存储的ByteBuf</td></tr><tr><td>wrappedBuffer()</td><td>返回一个包装了给定数据的ByteBuf</td></tr><tr><td>copiedBuffer()</td><td>返回一个复制了给定数据的ByteBuf</td></tr></tbody></table><h3 id="ByteBufUtil-类"><a href="#ByteBufUtil-类" class="headerlink" title="ByteBufUtil 类"></a>ByteBufUtil 类</h3><p>提供了用于操作ByteBuf的静态的辅助方法，有两个非常有用的方法：</p><ul><li>hexdump() 以十六进制的表示形式打印ByteBuf 的内容</li><li>equals(ByteBuf, ByteBuf) 它被用来判断两个ByteBuf实例的相等性</li></ul><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>引用计数是一种通过在某个对象所持有的资源不再被其他对象引用时释放该对象所持有的资源来优化内存使用和性能的技术。</p><p>引用计数对于池化实现（如PooledByteBufAllocator）来说是至关重要的，它降低了内存分配的开销。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">referenceCounting</span><span class="hljs-params">()</span></span>&#123;     Channel channel = CHANNEL_FROM_SOMEWHERE; <span class="hljs-comment">//get reference form somewhere</span>     <span class="hljs-comment">//从 Channel 获取ByteBufAllocator</span>     ByteBufAllocator allocator = channel.alloc();     <span class="hljs-comment">//...</span>     <span class="hljs-comment">//从 ByteBufAllocator分配一个 ByteBuf</span>     ByteBuf buffer = allocator.directBuffer();     <span class="hljs-comment">//检查引用计数是否为预期的 1</span>     <span class="hljs-keyword">assert</span> buffer.refCnt() == <span class="hljs-number">1</span>;     <span class="hljs-comment">//...</span> &#125;</code></pre></div><p>释放引用计数的对象：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseReferenceCountedObject</span><span class="hljs-params">()</span></span>&#123;      ByteBuf buffer = BYTE_BUF_FROM_SOMEWHERE; <span class="hljs-comment">//get reference form somewhere</span>      <span class="hljs-comment">//减少到该对象的活动引用。当减少到 0 时，该对象被释放，并且该方法返回 true</span>      <span class="hljs-keyword">boolean</span> released = buffer.release();      <span class="hljs-comment">//...</span>  &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>微服务分布式架构</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.Netty--传输</title>
    <link href="/2020/05/31/4-Netty-%E4%BC%A0%E8%BE%93/"/>
    <url>/2020/05/31/4-Netty-%E4%BC%A0%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>OIO：阻塞传输</li><li>NIO：异步传输</li><li>Local：JVM内部的异步通信</li><li>Embedded：测试你的ChannelHandler</li></ul></blockquote><h2 id="案例研究：传输迁移"><a href="#案例研究：传输迁移" class="headerlink" title="案例研究：传输迁移"></a>案例研究：传输迁移</h2><h3 id="不通过Netty使用OIO和NIO"><a href="#不通过Netty使用OIO和NIO" class="headerlink" title="不通过Netty使用OIO和NIO"></a>不通过Netty使用OIO和NIO</h3><p>未使用Netty的阻塞网络编程代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlainOioServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//将服务器绑定到指定端口</span>        ServerSocket socket = <span class="hljs-keyword">new</span> ServerSocket(port);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span>(;;)&#123;                <span class="hljs-comment">//接收连接</span>                <span class="hljs-keyword">final</span> Socket clientSocket = socket.accept();                System.out.println(<span class="hljs-string">"Accepted connection from "</span>+ clientSocket);                <span class="hljs-comment">//创建一个新的线程来处理该连接</span>                <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                        OutputStream out;                        <span class="hljs-keyword">try</span> &#123;                            out = clientSocket.getOutputStream();                            out.write(<span class="hljs-string">"Hi!\r\n"</span>.getBytes(CharsetUtil.UTF_8));                            <span class="hljs-comment">//关闭连接</span>                            clientSocket.close();                        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                            e.printStackTrace();                        &#125;                        <span class="hljs-keyword">finally</span> &#123;                            <span class="hljs-keyword">try</span> &#123;                                clientSocket.close();                            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                                                            &#125;                        &#125;                    &#125;                &#125;).start();<span class="hljs-comment">//启动线程</span>            &#125;        &#125;        <span class="hljs-keyword">catch</span> (IOException e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre></div><p>未使用Netty的异步网络编程代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlainNioServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        ServerSocketChannel serverChannel = ServerSocketChannel.open();        serverChannel.configureBlocking(<span class="hljs-keyword">false</span>);        ServerSocket serverSocket = serverChannel.socket();        InetSocketAddress address = <span class="hljs-keyword">new</span> InetSocketAddress(port);        <span class="hljs-comment">//将服务器绑定到选定的端口</span>        serverSocket.bind(address);        <span class="hljs-comment">//打开Selector来处理Channel</span>        Selector selector = Selector.open();        <span class="hljs-comment">//将ServerSocket注册到Selector来接收连接</span>        serverChannel.register(selector, SelectionKey.OP_ACCEPT);        <span class="hljs-keyword">final</span> ByteBuffer msg = ByteBuffer.wrap(<span class="hljs-string">"Hi!\r\n"</span>.getBytes());        <span class="hljs-comment">//等待需要处理的新事件，阻塞将一直持续到下一个传入事件</span>        <span class="hljs-keyword">for</span> (;;)&#123;            <span class="hljs-keyword">try</span> &#123;                selector.select();            &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;                e.printStackTrace();                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-comment">//获取所有接收事件的SelectorKey实例</span>            Set&lt;SelectionKey&gt; readKeys = selector.selectedKeys();            Iterator&lt;SelectionKey&gt; iterator = readKeys.iterator();            <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;                SelectionKey key = iterator.next();                iterator.remove();                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">//检测事件是否是一个新的并且已经就绪可以被接收的连接</span>                    <span class="hljs-keyword">if</span>(key.isAcceptable())&#123;                        ServerSocketChannel server = (ServerSocketChannel) key.channel();                        SocketChannel client = server.accept();                        client.configureBlocking(<span class="hljs-keyword">false</span>);                        <span class="hljs-comment">//接收客户端，并将它注册到选择器</span>                        client.register(selector,SelectionKey.OP_WRITE |                                 SelectionKey.OP_READ,msg.duplicate());                        System.out.println(<span class="hljs-string">"Accepted connection from "</span> + client);                    &#125;                    <span class="hljs-comment">//检查套接字是否已经准备好写数据</span>                    <span class="hljs-keyword">if</span>(key.isWritable())&#123;                        SocketChannel client = (SocketChannel) key.channel();                        ByteBuffer buffer = (ByteBuffer) key.attachment();                        <span class="hljs-keyword">while</span>(buffer.hasRemaining())&#123;                            <span class="hljs-comment">//将数据写到已连接的客户端</span>                            <span class="hljs-keyword">if</span>(client.write(buffer) == <span class="hljs-number">0</span>)&#123;                                <span class="hljs-keyword">break</span>;                            &#125;                        &#125;                        <span class="hljs-comment">//关闭连接</span>                        client.close();                    &#125;                &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;                    key.cancel();                    <span class="hljs-keyword">try</span> &#123;                        key.channel().close();                    &#125;<span class="hljs-keyword">catch</span> (IOException ex)&#123;                                            &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="通过Netty使用OIO和NIO"><a href="#通过Netty使用OIO和NIO" class="headerlink" title="通过Netty使用OIO和NIO"></a>通过Netty使用OIO和NIO</h3><p>使用Netty的阻塞网络处理代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyOioServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">final</span> ByteBuf buf = Unpooled.unreleasableBuffer(                Unpooled.copiedBuffer(<span class="hljs-string">"Hi!\r\n"</span>, CharsetUtil.UTF_8));        OioEventLoopGroup group = <span class="hljs-keyword">new</span> OioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建ServerBootstrap</span>            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();            b.group(group)                    <span class="hljs-comment">//使用OioEventLoopGroup以允许阻塞模式</span>                    .channel(OioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                    .<span class="hljs-title">localAddress</span>(<span class="hljs-title">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-title">port</span>))</span><span class="hljs-class">                    //指定<span class="hljs-title">ChannelInitializer</span>，对于每个已接收的连接都调用它</span><span class="hljs-class">                    .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            <span class="hljs-comment">//添加一个ChannelInboundHandlerAdapter以拦截和处理事件</span>                            socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;                                <span class="hljs-meta">@Override</span>                                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span></span>&#123;                                    <span class="hljs-comment">//将消息写到客户端，并添加ChannelFutureListener，以便消息一被写完就关闭连接</span>                                    ctx.writeAndFlush(buf.duplicate()).addListener(ChannelFutureListener.CLOSE);                                &#125;                            &#125;);                        &#125;                    &#125;);            ChannelFuture f = b.bind().sync();            f.channel().closeFuture().sync();        &#125;<span class="hljs-keyword">finally</span> &#123;            group.shutdownGracefully().sync();        &#125;            &#125;&#125;</code></pre></div><p>非阻塞的Netty版本</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyNioServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">final</span> ByteBuf buf = Unpooled.unreleasableBuffer(                Unpooled.copiedBuffer(<span class="hljs-string">"Hi!\r\n"</span>, CharsetUtil.UTF_8));        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<span class="hljs-comment">//</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建ServerBootstrap</span>            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();            b.group(group)                    <span class="hljs-comment">//使用OioEventLoopGroup以允许阻塞模式</span>                    .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)//</span><span class="hljs-class">                    .<span class="hljs-title">localAddress</span>(<span class="hljs-title">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-title">port</span>))</span><span class="hljs-class">                    //指定<span class="hljs-title">ChannelInitializer</span>，对于每个已接收的连接都调用它</span><span class="hljs-class">                    .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            <span class="hljs-comment">//添加一个ChannelInboundHandlerAdapter以拦截和处理事件</span>                            socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;                                <span class="hljs-meta">@Override</span>                                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span></span>&#123;                                    <span class="hljs-comment">//将消息写到客户端，并添加ChannelFutureListener，以便消息一被写完就关闭连接</span>                                    ctx.writeAndFlush(buf.duplicate()).addListener(ChannelFutureListener.CLOSE);                                &#125;                            &#125;);                        &#125;                    &#125;);            ChannelFuture f = b.bind().sync();            f.channel().closeFuture().sync();        &#125;<span class="hljs-keyword">finally</span> &#123;            group.shutdownGracefully().sync();        &#125;    &#125;&#125;</code></pre></div><p>我们发现使用Netty框架，从阻塞传输切换到非阻塞传输代码要做的更改非常小。</p><h2 id="传输API"><a href="#传输API" class="headerlink" title="传输API"></a>传输API</h2><p>传输API 的核心就是Channel接口，它被用于所有的I/O操作，其层次结构如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200531232951464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>如图所示，每个Channel都将会被分配一个ChannelPipeline和ChannelConfig，ChannelConfig包含了该Channel的所有配置设置，并且支持<strong>热更新</strong>。</p><p>ChannelPipeline持有所有将应用于入站和出站数据以及事件的ChannelHandler实例，这些<strong>ChannelHandler实现了应用程序用于处理状态变化以及数据处理的逻辑</strong>。</p><p>ChannelHandler的典型用途包括：</p><ul><li>将数据从一种格式转换为另一种格式：</li><li>提供异常的通知；</li><li>提供Channel变为活动的或者非活动的通知；</li><li>提供当Channel注册到EventLoop或者从EventLoop注销时的通知；</li><li>提供有关用户自定义事件的通知。</li></ul><p>channel的方法：</p><table><thead><tr><th align="center">方法名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">eventLoop</td><td align="left">返回分配给Channel的EventLoop</td></tr><tr><td align="center">pipeline</td><td align="left">返回分配给Channel的ChannelPipeline</td></tr><tr><td align="center">isActive</td><td align="left">如果Channel是活动的，则返回true</td></tr><tr><td align="center">localAddress</td><td align="left">返回本地的SocketAddress</td></tr><tr><td align="center">remoteAddress</td><td align="left">返回远程的SocketAddress</td></tr><tr><td align="center">write</td><td align="left">将数据写到缓冲区，这个数据将被传递给ChannelPipeline，并且排队直到它被冲刷</td></tr><tr><td align="center">flush</td><td align="left">将缓冲区数据冲刷到底层传输，如一个Socket</td></tr><tr><td align="center">writeAndFlush</td><td align="left">等同于调用write()并接着调用flush()方法</td></tr></tbody></table><p>前面我们也提到过，Netty的Channel实现是线程安全的，因此我们可以存储一个到Channel的引用，并且每当需要向远程节点写数据时，都可以使用它。</p><p>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChannelOperationExamples</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Channel CHANNEL_FROM_SOMEWHERE = <span class="hljs-keyword">new</span> NioSocketChannel();  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writingToChannelFromManyThreads</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 存储一个Channel的引用</span>        <span class="hljs-keyword">final</span> Channel channel = CHANNEL_FROM_SOMEWHERE;         <span class="hljs-comment">//创建持有要写数据的ByteBuf</span>        <span class="hljs-keyword">final</span> ByteBuf buf = Unpooled.copiedBuffer(<span class="hljs-string">"your data"</span>,                CharsetUtil.UTF_8);        <span class="hljs-comment">//创建将数据写到Channel 的 Runnable</span>        Runnable writer = <span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                channel.write(buf.duplicate());            &#125;        &#125;;        <span class="hljs-comment">//获取到线程池Executor 的引用</span>        Executor executor = Executors.newCachedThreadPool();        <span class="hljs-comment">//递交写任务给线程池以便在某个线程中执行</span>        executor.execute(writer);        <span class="hljs-comment">//递交另一个写任务以便在另一个线程中执行</span>        executor.execute(writer);        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><h2 id="内置的传输"><a href="#内置的传输" class="headerlink" title="内置的传输"></a>内置的传输</h2><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>NIO</td><td>基于选择器的方式</td></tr><tr><td>Epoll</td><td>由JNI驱动的epoll()和非阻塞IO，支持只有在Linux上可用的多种特性，如SO_REUSEPORT，比NIO传输更快，完全非阻塞</td></tr><tr><td>OIO</td><td>阻塞IO</td></tr><tr><td>Local</td><td>可以在VM内部通过管道进行通信的本地传输</td></tr><tr><td>Embedded</td><td>允许使用ChannelHandler而又不需要一个真正的基于网络的传输，主要用于测试</td></tr></tbody></table><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>NIO提供了一个所有I/O操作的全异步的实现，利用选择器来获取Channel状态改变时的通知，可能的状态变化有：</p><ul><li>新的Channel已被接收并且就绪；</li><li>Channel连接已经完成；</li><li>Channel有已经就绪的可供读取的数据；</li><li>Channel可用于写数据。</li></ul><p>选择器运行在一个检查状态变化并对其做出响应的线程上，在应用程序对状态的改变作出响应之后，选择器将会被重置，并将重复这个过程。</p><p>选择操作的位模式：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>OP_ACCEPT</td><td>请求在接收新连接并创建Channel时获得通知</td></tr><tr><td>OP_CONNECT</td><td>请求在建立一个连接时获得通知</td></tr><tr><td>OP_READ</td><td>请求当数据已经就绪，可以从Channel中读取时获得通知</td></tr><tr><td>OP_WRITE</td><td>请求当可以向Channel中写入更多的数据时获得通知</td></tr></tbody></table><p>处理流程如下：</p><p><img src="https://img-blog.csdnimg.cn/20200531232937617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>知识点扩展：</p><p>零拷贝：零拷贝时一种目前只有在使用NIO和Epoll传输时才可使用的特性，<strong>可以快速高效地将数据从文件系统移动到网络接口</strong>，而不需要将其从<strong>内核空间</strong>复制到<strong>用户空间</strong>，因此CPU不需要为数据在内存之间的拷贝消耗资源。但是它对于实现了数据加密或者压缩的文件系统是不可用的，只能传输文件的原始内容。</p>]]></content>
    
    
    <categories>
      
      <category>微服务分布式架构</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.Netty--Netty的组件和设计</title>
    <link href="/2020/05/31/3-Netty-Netty%E7%9A%84%E7%BB%84%E4%BB%B6%E5%92%8C%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/05/31/3-Netty-Netty%E7%9A%84%E7%BB%84%E4%BB%B6%E5%92%8C%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li>Netty的技术和体系结构方面的内容</li><li>Channel、EventLoop和ChannelFuture</li><li>ChannelHandler和ChannelPipeline</li><li>引导</li></ul></blockquote><p>学习Netty是因为它是基于Java NIO 的<strong>异步</strong>和<strong>事件驱动</strong>的实现，保证了高负载下应用程序性能的最大化和可伸缩性；同时它包含了一组设计模式，实现了<strong>应用程序逻辑从网络层解耦</strong>，简化了开发过程，最大限度地提高了可测试性、模块化以及代码的可重用性。</p><h2 id="1-Channel、EventLoop和ChannelFuture"><a href="#1-Channel、EventLoop和ChannelFuture" class="headerlink" title="1. Channel、EventLoop和ChannelFuture"></a>1. Channel、EventLoop和ChannelFuture</h2><ul><li><p>Channel：Socket；</p></li><li><p>EventLoop：控制流、多线程处理、并发；</p></li><li><p>ChannelFuture：异步通知</p></li></ul><h3 id="Channel接口"><a href="#Channel接口" class="headerlink" title="Channel接口"></a>Channel接口</h3><p>基本的I/O操作（bind、connect、read、write）都依赖于底层网络传送所提供的原语，也就是Socket，而<strong>Netty中的Channel就是简化Socket编程的复杂性</strong>。</p><h3 id="EventLoop接口"><a href="#EventLoop接口" class="headerlink" title="EventLoop接口"></a>EventLoop接口</h3><p>用于<strong>处理连接的生命周期中所发生的事件</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20200531232619159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>其关系是：</p><ul><li>一个EventLoopGroup包含一个或多个EventLoop；</li><li>一个EventLoop在它的生命周期内只和一个Thread绑定；</li><li>所有由EventLoop处理的I/O事件都将在它专有的Thread上被处理（<strong>消除了对同步的需求</strong>）</li><li>一个Channel在它的生命周期内只注册于一个EventLoop；</li><li>一个EventLoop可能会被分配给一个或多个Channel。</li></ul><h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><p>正因为Netty中所有的I/O操作都是异步的，其执行结果不会立即返回，所以Netty提供了ChannelFuture接口，其addListener()方法注册了一个ChannelFutureListener，以便在某个操作完成时(无论是否成功)都能得到通知。</p><h2 id="2-ChannelHandler和ChannelPipeline"><a href="#2-ChannelHandler和ChannelPipeline" class="headerlink" title="2. ChannelHandler和ChannelPipeline"></a>2. ChannelHandler和ChannelPipeline</h2><p>管理数据流以及执行应用程序处理逻辑的组件</p><h3 id="ChannelHandler接口"><a href="#ChannelHandler接口" class="headerlink" title="ChannelHandler接口"></a>ChannelHandler接口</h3><p>充当了<strong>所有处理入站和出站数据的应用程序逻辑的容器</strong>，因为<code>ChannelHandler</code>的方法是由<strong>网络事件触发</strong>的。</p><h3 id="ChannelPipeline接口"><a href="#ChannelPipeline接口" class="headerlink" title="ChannelPipeline接口"></a>ChannelPipeline接口</h3><p>提供了ChannelHandler链的容器，并定义了用于在该链上传播入站和出站事件流的API，当Channel被创建时，他会被自动的分配到它专属的ChannelPipeline。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//在创建Channel时向ChannelPipeline中添加一个EchoClientHandler实例</span>.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> EchoClientHandler());    &#125;&#125;);</code></pre></div><p><img src="https://img-blog.csdnimg.cn/2020053123263110.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>执行顺序由添加顺序所决定，ChannelHandler处理完后将数据传递给链中的下一个ChannelHandler，该ChanelHandler不一定会去修改数据，如果数据到达ChannelPipeline一端，也就说明处理结束。</p><p>当ChannelHandler被添加到ChannelPipeline时，它将会被分配一个ChannelHandlerContext，其代表了ChannelHandler和ChannelPipeline之间的绑定，主要用于写出站数据。</p><p>在Netty中有两种发送消息的方式，直接写到Channel中，也可以写到ChannelHandlerContext对象中，前一种方式将会导致消息从ChannelPipeline的尾端开始流动，后者将导致消息从ChannelPipeline中的下一个ChannelHandler开始流动。</p><h3 id="编码器和解码器"><a href="#编码器和解码器" class="headerlink" title="编码器和解码器"></a>编码器和解码器</h3><p>因为网络数据总是一系列的字节，而我们写的代码是一些对象</p><p>所有由Netty提供的编码器/解码器适配器类都实现了ChannelInboundHandler接口或者ChannelOutboundHandler接口。</p><h3 id="抽象类SimpleChannelInboundHandler"><a href="#抽象类SimpleChannelInboundHandler" class="headerlink" title="抽象类SimpleChannelInboundHandler"></a>抽象类SimpleChannelInboundHandler</h3><p>当我们利用一个ChannelHandler来接收解码消息，并对该数据应用业务逻辑，基本上只需要扩展基类SimpleChannelInboundHandler<T>，其中T就是我们要处理的Java类型。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;<span class="hljs-comment">//这里的ByteBuf应该是跟服务端代码没有关系的，根据我们自身的业务需求来定的</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">"Client received: "</span>+ byteBuf.toString(CharsetUtil.UTF_8));    &#125;</code></pre></div><h3 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h3><p>Netty的引导类为应用程序的<strong>网络层</strong>配置提供了容器，有两种类型的引导：一种用于客户端，另一种用于服务器，区别如下：</p><table><thead><tr><th align="center">区别</th><th align="center">BootStrap</th><th align="center">ServerBootStrap</th></tr></thead><tbody><tr><td align="center">网络编程中的作用</td><td align="center">连接到远程主机和端口</td><td align="center">绑定到一个本地端口</td></tr><tr><td align="center">EventLoopGroup的数目</td><td align="center">1</td><td align="center">2</td></tr></tbody></table><p>为什么ServerBootStrap需要两个EventLoopGroup呢？</p><p>因为服务器需要两组不同的Channel，第一组将只包含一个ServerChannel，代表服务器自身的已绑定到某个本地端口的正在监听的套接字，而第二组将包含所有已创建的用来<strong>处理传入客户端连接的Channel</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20200531232645361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>微服务分布式架构</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.Netty--你的第一款Netty应用</title>
    <link href="/2020/05/31/2-Netty-%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%BENetty%E5%BA%94%E7%94%A8/"/>
    <url>/2020/05/31/2-Netty-%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%BENetty%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：</p><ul><li><p>设置开发环境</p></li><li><p>编写Echo服务器和客户端</p></li><li><p>构建并测试应用程序</p></li></ul></blockquote><h3 id="1-设置开发环境"><a href="#1-设置开发环境" class="headerlink" title="1.设置开发环境"></a>1.设置开发环境</h3><p>准备好JDK和Maven</p><h3 id="2-Netty客户端-服务器概览"><a href="#2-Netty客户端-服务器概览" class="headerlink" title="2.Netty客户端/服务器概览"></a>2.Netty客户端/服务器概览</h3><p><img src="https://img-blog.csdnimg.cn/20200531232146835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>在客户端建立一个连接之后，它会向服务器发送一个或多个消息，反过来，服务器又会将每个消息回送给客户端。</p><h3 id="3-编写Echo服务器"><a href="#3-编写Echo服务器" class="headerlink" title="3.编写Echo服务器"></a>3.编写Echo服务器</h3><p>首先明确的一点是，所有的Netty服务器都需要以下两部分：</p><ul><li>至少一个ChannelHandler：用户实现服务器对从客户端接收的数据的处理，即<strong>业务逻辑</strong>。</li><li><strong>引导</strong>：配置服务器的启动代码，如将服务器绑定到它需要监听连接请求的端口上。</li></ul><h4 id="3-1ChannelHandler和业务逻辑"><a href="#3-1ChannelHandler和业务逻辑" class="headerlink" title="3.1ChannelHandler和业务逻辑"></a>3.1ChannelHandler和业务逻辑</h4><p>ChannelHandler是一个父接口，它的实现负责<strong>接收并响应事件通知</strong>。</p><p>这里我们的Echo服务器需要响应传入的消息，所以需要实现ChannelInboundHandler接口，用来定义响应入站事件的方法，这里我们继承ChannelInboundHandlerAdapter类。</p><p>主要有如下方法可以调用：</p><ul><li><p>channelRead(): 对于每个传入的消息都要调用</p></li><li><p>channelReadComplete()：表明了本次从 Socket 读了数据，但是否是完整的数据它其实并不知道</p></li><li><p>exceptionCaught()：在读取操作期间 ，有异常抛出时会调用</p></li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/** Sharable标识一个ChannelHandler可以被多个Channel安全地共享 **/</span><span class="hljs-meta">@ChannelHandler</span>.Sharable<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ByteBuf in = (ByteBuf)msg;        System.out.println(<span class="hljs-string">"Server received: "</span> + in.toString(CharsetUtil.UTF_8));        <span class="hljs-comment">//将接收到的消息写给发送者</span>        ctx.write(in);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//将消息冲刷到客户端，并且关闭该Channel</span>        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//打印异常栈跟踪</span>        cause.printStackTrace();        <span class="hljs-comment">//关闭该Channel</span>        ctx.close();    &#125;&#125;</code></pre></div><h4 id="3-2-引导服务器"><a href="#3-2-引导服务器" class="headerlink" title="3.2 引导服务器"></a>3.2 引导服务器</h4><p>主要内容如下：</p><ul><li>绑定服务器将在其上监听并接收传入连接请求的端口；</li><li>配置Channel，以将有关的入站消息通知给EchoServerHandler实例</li></ul><p>编写EchoServer类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EchoServer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;        <span class="hljs-keyword">this</span>.port = port;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">//设置端口值不正确</span>        <span class="hljs-keyword">if</span>(args.length != <span class="hljs-number">1</span>)&#123;            System.err.print("Usage: " + EchoServer.class.getSimpleName() + "&lt;port&gt;");        &#125;        <span class="hljs-keyword">int</span> port = Integer.parseInt(args[<span class="hljs-number">0</span>]);        <span class="hljs-comment">//调用服务器的start()方法</span>        <span class="hljs-keyword">new</span> EchoServer(port).start();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">final</span> EchoServerHandler serverHandler = <span class="hljs-keyword">new</span> EchoServerHandler();        <span class="hljs-comment">//创建EventLoopGroup，因为我们使用的是NIO传输，所以要指定NioEventLoopGroup来接收和处理新的连接</span>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建ServerBootstrap</span>            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();            b.group(group)                    <span class="hljs-comment">//指定所使用的NIO传输Channel</span>                    .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                    //使用指定的端口设置套接字地址，服务器将绑定到这个地址以监听新的连接请求</span><span class="hljs-class">                    .<span class="hljs-title">localAddress</span>(<span class="hljs-title">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-title">port</span>))</span><span class="hljs-class">                    //当一个新的连接被接收时，一个新的子<span class="hljs-title">Channel</span>将会被创建，<span class="hljs-title">ChannelInitializer</span>会把<span class="hljs-title">EchoServerHandler</span>的实例添加到<span class="hljs-title">Channel</span>的<span class="hljs-title">ChannelPipeline</span>中,这个<span class="hljs-title">ChannelHandler</span>会接收入站消息的通知。</span><span class="hljs-class">                    .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            <span class="hljs-comment">//由于EchoServerHandler被标注位@Shareable，所以我们使用的是同一个EchoServerHandler</span>                            socketChannel.pipeline().addLast(serverHandler);                        &#125;                    &#125;);            <span class="hljs-comment">//异步的绑定服务器，调用sync()方法阻塞等待直到绑定完成</span>            ChannelFuture f = b.bind().sync();            <span class="hljs-comment">//获取Channel的CloseFuture，并且阻塞当前线程直到它完成</span>            f.channel().closeFuture().sync();        &#125;<span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//关闭EventLoopGroup，并且释放所有的资源</span>            group.shutdownGracefully().sync();        &#125;    &#125;&#125;</code></pre></div><p>主要步骤：</p><ul><li>EchoServerHandler实现业务逻辑；</li><li>main()方法引导了服务器</li></ul><p>在引导过程中的步骤：</p><ul><li><p>使用一个EchoServerHandler实例来初始化每一个新的Channel</p></li><li><p>创建并分配一个NioEventLoopGroup实例以进行事件的处理，如接收新连接以及读/写数据；</p></li><li><p>创建一个ServerBootstrap的实例以引导和绑定服务器；</p></li><li><p>指定服务器绑定的本地InetSocketAddress</p></li><li><p>调用ServerBootstrap.bind()方法来绑定服务器</p></li></ul><h3 id="4-编写Echo客户端"><a href="#4-编写Echo客户端" class="headerlink" title="4. 编写Echo客户端"></a>4. 编写Echo客户端</h3><p>Echo客户端主要任务：</p><ul><li>连接到服务端</li><li>发送一个或多个消息；</li><li>对于每个消息，等待并接收从服务器发回的消息；</li><li>关闭连接</li></ul><p>客户端所涉及到的两个主要代码部分也是业务逻辑和引导</p><h4 id="4-1-通过ChannelHandler实现客户端逻辑"><a href="#4-1-通过ChannelHandler实现客户端逻辑" class="headerlink" title="4.1 通过ChannelHandler实现客户端逻辑"></a>4.1 通过ChannelHandler实现客户端逻辑</h4><p>客户端也拥有一个用来处理数据的ChannelInboundHandler，这里我们扩展SimpleChannelInboundHandler类来处理所有必须的任务，重写以下方法：</p><ul><li><p>channelActive()：在到服务器的连接已经建立之后将被调用</p></li><li><p>channelRead0()：当从服务器接收到一条消息时被调用</p></li><li><p>exceptionCaught()：在处理过程中引发异常时被调用</p></li></ul><p>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;    <span class="hljs-comment">/** 连接服务器后调用该方法 **/</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">"Netty rocks!"</span>, CharsetUtil.UTF_8));    &#125;    <span class="hljs-comment">/** 从服务器接收到消息后调用该方法 **/</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">"Client received: "</span>+ byteBuf.toString(CharsetUtil.UTF_8));    &#125;    <span class="hljs-comment">/** 发生异常时，记录错误并关闭Channel **/</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre></div><p>注意： 从服务器发送的消息可能会被分块接收，channelRead0()方法因此有可能被调用多次。</p><p>还有一点值得注意的是Echo 服务端使用的ChannelHandler是 ChannelInboundHandlerAdapter，而 Echo 客户端使用的却是 SimpleChannelInboundHandler，其实它们是继承关系。</p><p><img src="https://img-blog.csdnimg.cn/20200531232251632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>既然是继承关系，也就是说，”你有的我也有，你没有的我还有。” 那么 SimpleChannelInboundHandler 里面肯定重写或者新增了 ChannelInboundHandlerAdapter 里面的方法功能 - channelRead0 和 channelRead()。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, I msg)</span> <span class="hljs-keyword">throws</span> Exception</span>;</code></pre></div><p>至于为什么会这样设计，原因是在客户端，当 channelRead0() 方法完成时，你已经有了传入消息，并且已经处理完它了。当该方法返回时，SimpleChannelInboundHandler负责<strong>释放指向保存该消息的ByteBuf的内存引用</strong>。而在服务端，你仍然需要将传入消息回送给发送者，而 write() 操作是异步的，直到 channelRead() 方法返回后可能仍然没有完成。为此，EchoServerHandler扩展了 ChannelInboundHandlerAdapter ，其在这个时间点上不会释放消息。</p><h4 id="4-2-引导客户端"><a href="#4-2-引导客户端" class="headerlink" title="4.2 引导客户端"></a>4.2 引导客户端</h4><p>客户端使用主机和端口号来连接远程地址</p><p>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoClient</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String host;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EchoClient</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port)</span> </span>&#123;        <span class="hljs-keyword">this</span>.host = host;        <span class="hljs-keyword">this</span>.port = port;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">if</span>(args.length != <span class="hljs-number">2</span>)&#123;            System.err.println("Usage: "+ EchoClient.class.getSimpleName()+"&lt;host&gt; &lt;port&gt;");            <span class="hljs-keyword">return</span>;        &#125;        String host = args[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> port = Integer.parseInt(args[<span class="hljs-number">1</span>]);        <span class="hljs-keyword">new</span> EchoClient(host,port).start();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            Bootstrap b = <span class="hljs-keyword">new</span> Bootstrap();            b.group(group)                    .channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                    .<span class="hljs-title">remoteAddress</span>(<span class="hljs-title">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-title">host</span>,<span class="hljs-title">port</span>))</span><span class="hljs-class">                    //在创建<span class="hljs-title">Channel</span>时向<span class="hljs-title">ChannelPipeline</span>中添加一个<span class="hljs-title">EchoClientHandler</span>实例</span><span class="hljs-class">                    .<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> EchoClientHandler());                        &#125;                    &#125;);            ChannelFuture f = b.connect().sync();            f.channel().closeFuture().sync();        &#125;<span class="hljs-keyword">finally</span> &#123;            group.shutdownGracefully().sync();        &#125;    &#125;&#125;</code></pre></div><h3 id="5-构建和运行Echo服务器和客户端"><a href="#5-构建和运行Echo服务器和客户端" class="headerlink" title="5. 构建和运行Echo服务器和客户端"></a>5. 构建和运行Echo服务器和客户端</h3><p>目录如下：</p><p><img src="https://img-blog.csdnimg.cn/20200531231945351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>注意要在pom.xml文件中引入netty依赖以及编译maven模板需要的插件。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.netty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>netty-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.42.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.mojo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>exec-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>                  <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>                      <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                          <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>                      <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>                  <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                  <span class="hljs-comment">&lt;!--指定main文件,不指定会报错，如果是client就要变成EchoClient--&gt;</span>                  <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>EchoServer<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><p>先执行<code>mvn clean package</code>来清除指定的包，然后<code>cd server</code>，执行<code>exec:java -Dexec.args=&quot;1&quot;</code>,接下来点击右下角的加号新建一个终端，然后<code>cd client</code>，执行<code>exec:java -Dexec.args=&quot;0 1&quot;</code>，即可看到效果。一定一定要先开启服务器然后再开客户端，否则会报错。</p><p>效果：</p><p><img src="https://img-blog.csdnimg.cn/20200531231925350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>补充一个遇到的坑：</p><p><img src="https://img-blog.csdnimg.cn/20200531231845780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>如果在执行<code>mvn exec:java -Dexec.args=&quot;0 1&quot;</code>的时候出现上面错误，首先去自己的maven的目录下查看配置文件setting.xml</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\Software\apache-maven-3.6.1\repository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span></code></pre></div><p>看路径是否正确，其次检查IDEA中的MAVEN配置。</p><p><img src="https://img-blog.csdnimg.cn/20200531232454527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>微服务分布式架构</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.Netty--异步和事件驱动</title>
    <link href="/2020/05/30/1-Netty-%E5%BC%82%E6%AD%A5%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/"/>
    <url>/2020/05/30/1-Netty-%E5%BC%82%E6%AD%A5%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本系列文章主要来自《Netty IN ACTION》</p><p>本章主要内容：</p><ul><li><p>Java网络编程</p></li><li><p>Netty简介</p></li><li><p>Netty核心组件</p></li></ul></blockquote><h2 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h2><p>首先来看一个典型的阻塞I/O示例：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//创建一个新的ServerSocket，用于监听指定端口上的连接请求</span>ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(portNumber);<span class="hljs-comment">//1</span><span class="hljs-comment">//以阻塞的方式来调用accept()方法，直到一个连接建立</span>Socket clientSocket = serverSocket.accept();<span class="hljs-comment">//2</span><span class="hljs-comment">//BufferedReader和PrintWriter分别用于从字符输入流中读取文本和将对象格式化到文本输出流</span>BufferedReader in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(clientSocket.getInputStream()));PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(clientSocket.getOutputStream(),<span class="hljs-keyword">true</span>);String request,response;<span class="hljs-comment">//循环对输入流进行判断处理</span><span class="hljs-keyword">while</span>((request = in.readLine()) != <span class="hljs-keyword">null</span>)&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-string">"Done"</span>.equals(request))&#123;        <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-comment">//服务器处理客户端的请求，并作出响应</span>    response = processRequest(request);    <span class="hljs-comment">//输出响应</span>    out.println(response);</code></pre></div><p>这里<code>ServerSocket</code>的作用是监听某一路端口是否有连接，如果有连接就会创建一个新的<code>Socket</code>用于客户端和服务器进行通信，而此时<code>ServerSocket</code>并不会断开连接，而是会继续监听传入的连接。</p><p><img src="https://img-blog.csdnimg.cn/20200531231530747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>这里就体现出弊端了，如果有多个并发客户端，那就需要为每个客户端Socket创建一个Thread，弊端有三：</p><ul><li>资源浪费，并不是每时每刻都有数据在传输，大部分情况下线程都处在休眠状态；</li><li>内存消耗，需要为每个线程的调度栈分配内存；</li><li>上下文切换带来的开销大；</li></ul><h3 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h3><p>使用setSockopt()方法配置套接字，以便读/写调用在没有数据的时候立即返回。</p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>使用<code>java.nio.channels.Selector</code>这个类，利用事件通知API来确定在一组非阻塞套接字中有哪些已经就绪能够进行I/O相关的操作。</p><p><img src="https://img-blog.csdnimg.cn/20200531231550220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="Netty简介"><a href="#Netty简介" class="headerlink" title="Netty简介"></a>Netty简介</h2><p>Netty是一个<strong>NIO</strong>客户端/服务器<strong>框架</strong>，支持快速、简单地开发网络应用，如协议服务器和客户端。</p><h2 id="Netty核心组件"><a href="#Netty核心组件" class="headerlink" title="Netty核心组件"></a>Netty核心组件</h2><p>Netty的主要构建块：</p><ul><li>Channel</li><li>回调</li><li>Future</li><li>事件和Channelhandler</li></ul><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>简单理解就是<strong>传入或者传出数据的载体</strong>，可以被打开或者被关闭，连接或者断开连接。</p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>回调其实就是一个方法，回调函数不是由该函数的实现方直接调用，而是<strong>在特定的事件或条件发生时由另外的一方调用</strong>的，用于对该事件或条件进行响应。Netty内部使用了回调来处理事件，当一个回调被触发时，相关的事件被一个ChannelHandler的实现来处理，</p><p>看下面一段代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(channelHandlerContect ctx)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        System.out.println(<span class="hljs-string">"Client "</span> + ctx.channel().remoteAddress() + <span class="hljs-string">" connected"</span>);    &#125;&#125;</code></pre></div><p>当一个新的连接已经被建立时，ChannelHandler的channelActive()回调方法将会被调用，并将打印一条信息。</p><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>可以看作是一个异步操作的结果的占位符，可以在未来提供对其结果的访问；</p><p>Netty提供了自己的ChannelFuture，用于<strong>在执行异步操作的时候使用</strong>。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectExample</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Channel CHANNEL_FROM_SOMEWHERE = <span class="hljs-keyword">new</span> NioSocketChannel();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">()</span> </span>&#123;        Channel channel = CHANNEL_FROM_SOMEWHERE;         <span class="hljs-comment">//异步地连接到远程节点</span>        ChannelFuture future = channel.connect(                <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"192.168.0.1"</span>, <span class="hljs-number">25</span>));        <span class="hljs-comment">//注册一个 ChannelFutureListener，以便在操作完成时获得通知</span>        future.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> </span>&#123;                <span class="hljs-comment">//检查操作的状态</span>                <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;                    <span class="hljs-comment">//如果操作是成功的，则创建一个 ByteBuf 以持有数据</span>                    ByteBuf buffer = Unpooled.copiedBuffer(                            <span class="hljs-string">"Hello"</span>, Charset.defaultCharset());                    <span class="hljs-comment">//将数据异步地发送到远程节点。返回一个 ChannelFuture</span>                    ChannelFuture wf = future.channel()                            .writeAndFlush(buffer);                    <span class="hljs-comment">// ...</span>                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">//如果发生错误，则访问描述原因的 Throwable</span>                    Throwable cause = future.cause();                    cause.printStackTrace();                &#125;            &#125;        &#125;);    &#125;&#125;</code></pre></div><p>可以看到，回调和Future是相互补充的机制，而ChannelFutureListener可以看作是回调的一个更加精细的版本。</p><h3 id="事件和Channelhandler"><a href="#事件和Channelhandler" class="headerlink" title="事件和Channelhandler"></a>事件和Channelhandler</h3><p>Netty使用不同的事件来通知我们状态的改变或者是操作的状态，因此我们可以利用事件来进行相应的处理，比如：</p><ul><li>记录日志</li><li>数据转换</li><li>流控制</li><li>应用程序逻辑</li></ul><p>Netty作为一个网络编程框架，主要事件分为入站事件和出站事件，入站事件包括：</p><ul><li>连接已被激活或者连接失活</li><li>数据读取</li><li>用户事件  </li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务分布式架构</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(9)--角色继承</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-9-%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-9-%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<p>在本节中，补充下<strong>角色继承</strong>的知识点。角色继承其实是一个十分常见的需求，因为一般系统中角色权限呈金字塔型，高层用户拥有底层用户的权限。</p><p>例如存在以下角色：普通用户、VIP 用户、SVIP 用户、星悦会员，那么对应的权限可以是“星悦会员 &gt; SVIP 用户 &gt; VIP 用户 &gt; 普通用户”。那么如何在 Spring Security 中实现这样的功能呢？</p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>为了简便起见，我直接使用<a href="https://www.jitwxs.cn/5f5715e6.html" target="_blank" rel="noopener">《SpringBoot 集成 Spring Security（1）——入门程序》</a> 的代码。</p><p>在该章中，我们存在两个角色，<code>ROLE_ADMIN</code> 和 <code>ROLE_USER</code>，并且经过我们的实验，<code>/admin</code> 接口只有 ROLE_ADMIN 有权限，<code>/user</code> 接口只有 ROLE_USER 有权限。</p><p>但是如果我想让 ROLE_ADMIN 用户继承 ROLE_USER 用户的所有权限，该如何做呢？</p><h3 id="RoleHierarchy"><a href="#RoleHierarchy" class="headerlink" title="RoleHierarchy"></a>RoleHierarchy</h3><p>这里就需要引入 <code>RoleHierarch</code>了，我们只需要自定义一个 RoleHierarchy，并将其注入容器即可。修改 <code>WebSecurityConfig</code>，在其中注入 RoleHierarchy：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> RoleHierarchy <span class="hljs-title">roleHierarchy</span><span class="hljs-params">()</span></span>&#123;    RoleHierarchyImpl roleHierarchy = <span class="hljs-keyword">new</span> RoleHierarchyImpl();    String hierarchy = <span class="hljs-string">"ROLE_ADMIN &gt; ROLE_USER"</span>;    roleHierarchy.setHierarchy(hierarchy);    <span class="hljs-keyword">return</span> roleHierarchy;&#125;</code></pre></div><p><code>roleHierarchy.setHierarchy()</code> 指定了角色的继承关系，参数就是一个字符串，比大小即可，是不是非常简单？</p><p>让我们使用 ROLE_ADMIN 账号登陆，发现原本无法访问的 <code>/user</code> 接口也可以访问了：</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>角色关系的实现也比较简单，本质就是将字符串使用正则切分，并将角色关系存放进一个 Map 中，map 的 key 是大的角色，value 是一个 Set，存放所有比它小的角色。然后交由后续处理，有兴趣的可以继续阅读源码。</p><p><img src="https://www.jitwxs.cn/images/posts/20190902233900717.png" srcset="/img/loading.gif" alt="buildRolesReachableInOneStepMap()"></p><p>如果有多个继承关系，在 SpringBoot 2.1 中，就应该改写为：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> RoleHierarchy <span class="hljs-title">roleHierarchy</span><span class="hljs-params">()</span> </span>&#123;    String separator = System.lineSeparator();        RoleHierarchyImpl roleHierarchy = <span class="hljs-keyword">new</span> RoleHierarchyImpl();    String hierarchy = <span class="hljs-string">"ROLE_ADMIN &gt; ROLE_USER "</span> + separator + <span class="hljs-string">" ROLE_USER &gt; ROLE_TOURISTS"</span>;    roleHierarchy.setHierarchy(hierarchy);    <span class="hljs-keyword">return</span> roleHierarchy;&#125;</code></pre></div><p>另外换行符大家都知道在不同系统中表示不一样，例如 Windows 中为 <code>\r\n</code>，Mac 为 <code>\r</code>，Linux 为 <code>\n</code>，因此以上代码我是用的 <code>java.lang</code> 包的 System 类中封装的方法，不用判断当前操作系统。</p>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(8)--短信验证码登录</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-8-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E5%BD%95/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-8-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一、理论说明"><a href="#一、理论说明" class="headerlink" title="一、理论说明"></a>一、理论说明</h2><p>在开始编码前，先理解下短信验证码的实现流程。如果你能对<a href="https://www.jitwxs.cn/a28c0db7.html" target="_blank" rel="noopener">《SpringBoot集成Spring Security（7）——认证流程》</a>这篇文章有一定的了解的话，那么这篇文章的学习你会轻松许多。</p><h3 id="1-1-用户名密码登录逻辑"><a href="#1-1-用户名密码登录逻辑" class="headerlink" title="1.1 用户名密码登录逻辑"></a>1.1 用户名密码登录逻辑</h3><p>废话不多说，在上一篇文章中，以标准的用户名密码登录为例，讲解了整个认证流程。大致流程如下：</p><ol><li><p>先进入 <code>UsernamePasswordAuthenticationFilter</code> 中，根据输入的用户名和密码信息，构造出一个暂时没有鉴权的 <code>UsernamePasswordAuthenticationToken</code>，并将 UsernamePasswordAuthenticationToken 交给 <code>AuthenticationManager</code>处理。</p></li><li><p><code>AuthenticationManager</code>本身并不做验证处理，他通过 for-each 遍历找到符合当前登录方式的一个 AuthenticationProvider，并交给它进行验证处理，对于用户名密码登录方式，这个 Provider 就是 <code>DaoAuthenticationProvider</code>。</p></li><li><p>在这个 Provider 中进行一系列的验证处理，如果验证通过，就会重新构造一个添加了鉴权的 <code>UsernamePasswordAuthenticationToken</code>，并将这个 token 传回到 <code>UsernamePasswordAuthenticationFilter</code> 中。</p></li><li><p>在该 Filter 的父类 <code>AbstractAuthenticationProcessingFilter</code> 中，会根据上一步验证的结果，跳转到 successHandler 或者是 failureHandler。</p><p><img src="https://www.jitwxs.cn/images/posts/20181202095539982.png" srcset="/img/loading.gif" alt="img"></p><p>​                                                    Spring Security 认证流程（部分）</p></li></ol><h3 id="1-2-短信验证码登录逻辑"><a href="#1-2-短信验证码登录逻辑" class="headerlink" title="1.2 短信验证码登录逻辑"></a>1.2 短信验证码登录逻辑</h3><p>我们可以仿照用户名密码登录的逻辑，来实现短信验证码的登录逻辑。</p><ol><li>用户名密码登录有个 <code>UsernamePasswordAuthenticationFilter</code> ，我们搞一个 <code>SmsAuthenticationFilter</code>，代码粘过来改一改。</li><li>用户名密码登录需要 <code>UsernamePasswordAuthenticationToken</code>，我们搞一个 <code>SmsAuthenticationToken</code>，代码粘过来改一改。</li><li>用户名密码登录需要 <code>DaoAuthenticationProvider</code>，我们模仿它也implenments AuthenticationProvider，叫做 <code>SmsAuthenticationProvider</code>。</li></ol><p><img src="https://www.jitwxs.cn/images/posts/2019010916114182.png" srcset="/img/loading.gif" alt="短信登录验证逻辑"></p><p>​                                                                                短信登录验证逻辑</p><p>我们自己搞了上面三个类以后，想要实现的效果如上图所示。当我们使用短信验证码登录的时候：</p><ol><li>先经过 <code>SmsAuthenticationFilter</code>，构造一个没有鉴权的 <code>SmsAuthenticationToken</code>，然后交给 AuthenticationManager 处理。</li><li>AuthenticationManager 通过 for-each 挑选出一个合适的 provider 进行处理，当然我们希望这个 provider 要是 <code>SmsAuthenticationProvider</code>。</li><li>验证通过后，重新构造一个有鉴权的 <code>SmsAuthenticationToken</code>，并返回给 <code>SmsAuthenticationFilter</code>。</li><li>filter 根据上一步的验证结果，跳转到成功或者失败的处理逻辑。</li></ol><h2 id="二、代码实战"><a href="#二、代码实战" class="headerlink" title="二、代码实战"></a>二、代码实战</h2><p>请通过 github 链接下载第一章代码，或者参看<a href="https://www.jitwxs.cn/5f5715e6.html" target="_blank" rel="noopener">《SpringBoot集成Spring Security（1）——入门程序》</a>初始化项目，这里就不再赘述了。</p><h3 id="2-1-SmsAuthenticationToken"><a href="#2-1-SmsAuthenticationToken" class="headerlink" title="2.1 SmsAuthenticationToken"></a>2.1 SmsAuthenticationToken</h3><p>首先我们编写 <code>SmsAuthenticationToken</code>，这里直接参考 <code>UsernamePasswordAuthenticationToken</code> 源码，直接粘过来，改一改。</p><p><strong>步骤：</strong></p><ol><li><code>principal</code> 原本代表用户名，这里保留，只是代表了手机号码。</li><li><code>credentials</code> 原本代码密码，短信登录用不到，直接删掉。</li><li><code>SmsCodeAuthenticationToken()</code> 两个构造方法一个是构造没有鉴权的，一个是构造有鉴权的。</li><li>剩下的几个方法去除无用属性即可。</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsAuthenticationToken</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAuthenticationToken</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-comment">/** 表示用户的手机号 **/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object principal;    <span class="hljs-comment">/** 构建一个没有鉴权的SmsAuthenticationToken **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmsAuthenticationToken</span><span class="hljs-params">(Object principal)</span></span>&#123;        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">null</span>);        <span class="hljs-keyword">this</span>.principal = principal;        setAuthenticated(<span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-comment">/** 构建一个有鉴权的SmsAuthenticationToken **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmsAuthenticationToken</span><span class="hljs-params">(Collection&lt;? extends GrantedAuthority&gt; authorities, Object principal)</span> </span>&#123;        <span class="hljs-keyword">super</span>(authorities);        <span class="hljs-keyword">this</span>.principal = principal;        <span class="hljs-keyword">super</span>.setAuthenticated(<span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getPrincipal</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.principal;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getCredentials</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthenticated</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isAuthenticated)</span></span>&#123;        <span class="hljs-keyword">if</span>(isAuthenticated)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Cannot set this token to trusted-user constructor which takes a GrantedAuthority list instead"</span>);        &#125;        <span class="hljs-keyword">super</span>.setAuthenticated(<span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eraseCredentials</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.eraseCredentials();    &#125;&#125;</code></pre></div><h3 id="2-2-SmsAuthenticationFilter"><a href="#2-2-SmsAuthenticationFilter" class="headerlink" title="2.2 SmsAuthenticationFilter"></a>2.2 SmsAuthenticationFilter</h3><p>然后编写 <code>SmsAuthenticationFilter</code>，参考 UsernamePasswordAuthenticationFilter 的源码，直接粘过来，改一改。</p><p><strong>步骤：</strong></p><ol><li><p>原本的静态字段有 username 和 password，都干掉，换成我们的手机号字段。</p></li><li><p><code>SmsCodeAuthenticationFilter()</code> 中指定了这个 filter 的拦截 Url，我指定为 post 方式的 <code>/sms/login</code>。</p></li><li><p>剩下来的方法把无效的删删改改就好了。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsAuthenticationFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAuthenticationProcessingFilter</span> </span>&#123;    <span class="hljs-comment">/** form表单中手机号码的字段name **/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SPRING_SECURITY_FORM_MOBILE_KEY = <span class="hljs-string">"mobile"</span>;    <span class="hljs-keyword">private</span> String mobileParameter = SPRING_SECURITY_FORM_MOBILE_KEY;    <span class="hljs-comment">/** 是否仅为post方式 **/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> postOnly = <span class="hljs-keyword">true</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmsAuthenticationFilter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//短信登录请求post方式的/sms/login</span>        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> AntPathRequestMatcher(<span class="hljs-string">"/sms/login"</span>,<span class="hljs-string">"POST"</span>));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException, IOException, ServletException </span>&#123;        <span class="hljs-keyword">if</span>(postOnly &amp;&amp; !request.getMethod().equals(<span class="hljs-string">"POST"</span>))&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">"Authentication method not support:"</span>+request.getMethod());        &#125;        String mobile = obtainMobile(request);                <span class="hljs-keyword">if</span>(mobile == <span class="hljs-keyword">null</span>)&#123;            mobile = <span class="hljs-string">""</span>;        &#125;        mobile = mobile.trim();        SmsAuthenticationToken authRequest = <span class="hljs-keyword">new</span> SmsAuthenticationToken(mobile);        setDetails(request,authRequest);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDetails</span><span class="hljs-params">(HttpServletRequest request, SmsAuthenticationToken authRequest)</span> </span>&#123;        authRequest.setDetails(authenticationDetailsSource.buildDetails(request));    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">obtainMobile</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;        <span class="hljs-keyword">return</span> request.getParameter(mobileParameter);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMobileParameter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> mobileParameter;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMobileParameter</span><span class="hljs-params">(String mobileParameter)</span> </span>&#123;        Assert.hasText(mobileParameter,<span class="hljs-string">"Mobile parameter must not be empty or null"</span>);        <span class="hljs-keyword">this</span>.mobileParameter = mobileParameter;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPostOnly</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> postOnly;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPostOnly</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> postOnly)</span> </span>&#123;        <span class="hljs-keyword">this</span>.postOnly = postOnly;    &#125;&#125;</code></pre></div></li></ol><h3 id="2-3-SmsAuthenticationProvider"><a href="#2-3-SmsAuthenticationProvider" class="headerlink" title="2.3 SmsAuthenticationProvider"></a>2.3 SmsAuthenticationProvider</h3><p>这个方法比较重要，这个方法首先能够在使用短信验证码登录时候被 <code>AuthenticationManager</code> 挑中，其次要在这个类中处理验证逻辑。</p><p><strong>步骤：</strong></p><ol><li><p>实现 AuthenticationProvider 接口，实现 authenticate() 和 supports() 方法。</p></li><li><p><code>supports()</code>方法决定了这个 Provider 要怎么被 AuthenticationManager 挑中，</p><p>我这里通过 <code>return SmsCodeAuthenticationToken.class.isAssignableFrom(authentication)</code>，处理所有 SmsCodeAuthenticationToken 及其子类或子接口。</p></li><li><p><code>authenticate()</code>方法处理验证逻辑。</p><ol><li>首先将 authentication 强转为 <code>SmsCodeAuthenticationToken</code>。</li><li>从中取出登录的 principal，也就是手机号。</li><li>调用自己写的 checkSmsCode() 方法，进行验证码校验，如果不合法，抛出 AuthenticationException 异常。</li><li>如果此时仍然没有异常，通过调用 <code>loadUserByUsername(mobile)</code> 读取出数据库中的用户信息。</li><li>如果仍然能够成功读取，没有异常，这里验证就完成了。</li><li>重新构造鉴权后的 SmsCodeAuthenticationToken，并返回给 SmsCodeAuthenticationFilter 。</li></ol></li><li><p>SmsCodeAuthenticationFilter 的父类在 <code>doFilter()</code> 方法中处理是否有异常，是否成功，根据处理结果跳转到登录成功/失败逻辑。</p></li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsAuthenticationProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationProvider</span> </span>&#123;    <span class="hljs-keyword">private</span> UserDetailsService userDetailsService;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        SmsAuthenticationToken authenticationToken = (SmsAuthenticationToken) authentication;        String mobile = (String) authenticationToken.getPrincipal();        <span class="hljs-comment">//验证码校验</span>        checkSmsCode(mobile);        UserDetails userDetails = userDetailsService.loadUserByUsername(mobile);        <span class="hljs-comment">// 此时鉴权成功后，应当重新 new 一个拥有鉴权的 authenticationResult 返回</span>        SmsAuthenticationToken smsAuthenticationToken = <span class="hljs-keyword">new</span> SmsAuthenticationToken(userDetails.getAuthorities(), userDetails);        smsAuthenticationToken.setDetails(authenticationToken.getDetails());        <span class="hljs-keyword">return</span> smsAuthenticationToken;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkSmsCode</span><span class="hljs-params">(String mobile)</span> </span>&#123;        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();        String inputCode = request.getParameter(<span class="hljs-string">"smsCode"</span>);        Map&lt;String, Object&gt; smsCode = (Map&lt;String, Object&gt;) request.getSession().getAttribute(<span class="hljs-string">"smsCode"</span>);        <span class="hljs-keyword">if</span>(smsCode == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">"未检测到申请验证码"</span>);        &#125;        String applyMobile = (String) smsCode.get(<span class="hljs-string">"mobile"</span>);        <span class="hljs-keyword">int</span> code = (<span class="hljs-keyword">int</span>) smsCode.get(<span class="hljs-string">"code"</span>);        <span class="hljs-keyword">if</span>(!applyMobile.equals(mobile))&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">"申请的手机号与登录的手机号不一致"</span>);        &#125;        <span class="hljs-keyword">if</span>(code != Integer.parseInt(inputCode))&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">"验证码错误"</span>);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; authentication)</span> </span>&#123;        <span class="hljs-comment">//判断Authentication是不是SmsCodeAuthenticationToken的子类或子接口</span>        <span class="hljs-keyword">return</span>  SmsAuthenticationToken<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">isAssignableFrom</span>(<span class="hljs-title">authentication</span>)</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetailsService <span class="hljs-title">getUserDetailsService</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> userDetailsService;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserDetailsService</span><span class="hljs-params">(UserDetailsService userDetailsService)</span> </span>&#123;        <span class="hljs-keyword">this</span>.userDetailsService = userDetailsService;    &#125;&#125;</code></pre></div><h3 id="2-4-成功与失败处理逻辑"><a href="#2-4-成功与失败处理逻辑" class="headerlink" title="2.4 成功与失败处理逻辑"></a>2.4 成功与失败处理逻辑</h3><p>上面最后说到，在 SmsCodeAuthenticationFilter 的父类，会根据验证结果跳转到成功或失败处理逻辑，现在我们就编写下这个的处理。</p><p>这里之前也说过了，直接贴代码了，如果有疑问，请参考<a href="https://www.jitwxs.cn/59f4016e.html" target="_blank" rel="noopener">《SpringBoot集成Spring Security（6）——登录管理》</a>。</p><p><strong>验证成功处理：</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationSuccessHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationSuccessHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Autowired</span>    ObjectMapper objectMapper;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        logger.info(<span class="hljs-string">"登录成功"</span>);        response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);        response.getWriter().write(objectMapper.writeValueAsString(authentication));    &#125;&#125;</code></pre></div><p><strong>验证失败处理</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationFailurehandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationFailureHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Autowired</span>    ObjectMapper objectMapper;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        logger.info(<span class="hljs-string">"登陆失败"</span>);        response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);        response.getWriter().write(objectMapper.writeValueAsString(exception.getMessage()));    &#125;&#125;</code></pre></div><h3 id="2-5-SmsCodeAuthenticationSecurityConfig"><a href="#2-5-SmsCodeAuthenticationSecurityConfig" class="headerlink" title="2.5 SmsCodeAuthenticationSecurityConfig"></a>2.5 SmsCodeAuthenticationSecurityConfig</h3><p>下面我们需要把我们自己写的这么多类添加进 Spring Security 框架中，在以往，我们都是直接往 WebSecurityConfig 中加，但是这样会导致 WebSecurityConfig 内容太多，难以维护。</p><p>因此我们可以为每种登录方式都建议一个专属于它的配置文件，再把这个配置文件加入到 WebSecurityConfig 中，进行解耦。</p><p>因此建立短信验证码登录的配置文件 <code>SmsCodeAuthenticationSecurityConfig</code>:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsCodeAuthenticationSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SecurityConfigurerAdapter</span>&lt;<span class="hljs-title">DefaultSecurityFilterChain</span>, <span class="hljs-title">HttpSecurity</span>&gt; </span>&#123;    <span class="hljs-meta">@Autowired</span>    UserDetailsService userDetailsService;    <span class="hljs-meta">@Autowired</span>    CustomAuthenticationSuccessHandler customAuthenticationSuccessHandler;    <span class="hljs-meta">@Autowired</span>    CustomAuthenticationFailureHandler customAuthenticationFailureHandler;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity builder)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        SmsAuthenticationFilter smsAuthenticationFilter = <span class="hljs-keyword">new</span> SmsAuthenticationFilter();        smsAuthenticationFilter.setAuthenticationManager(builder.getSharedObject(AuthenticationManager<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;        smsAuthenticationFilter.setAuthenticationSuccessHandler(customAuthenticationSuccessHandler);        smsAuthenticationFilter.setAuthenticationFailureHandler(customAuthenticationFailureHandler);                SmsAuthenticationProvider smsAuthenticationProvider = <span class="hljs-keyword">new</span> SmsAuthenticationProvider();        smsAuthenticationProvider.setUserDetailsService(userDetailsService);                builder.authenticationProvider(smsAuthenticationProvider).addFilterAfter(smsAuthenticationFilter, UsernamePasswordAuthenticationFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;&#125;</code></pre></div><p>在这个配置文件中，首先给 SmsCodeAuthenticationFilter 指定了：</p><ol><li>AuthenticationManager：不指定这个上面的流程图就断掉了。</li><li>指定登录成功/失败处理逻辑，方便其父类调用。</li></ol><p>然后指定了 SmsCodeAuthenticationProvider，并指定了 UserDetailsService ，方便在验证处理时候通过 <code>loadUserByUsername()</code> 读取出数据库中的用户信息。</p><p>最后将 filter 和 provider 都加入 HttpSecurity 配置中。</p><p><strong>另外说两句：</strong></p><blockquote><p>开头就说过了，为了方便介绍，写最少的代码，因此这是一个假的短信登录。如果你看这里的 UserDetailsService 的代码话，你会发现它是从数据库中根据 name 获取信息的，我其实就是把用户名来当手机号用。</p><p>因此，如果你想根据数据库中其他字段，例如 phone 来得到用户信息，可以再写一个叫做 SmsUserDetailsService，在这里注入到 provider 中。</p></blockquote><h3 id="2-6-WebSecurityConfig"><a href="#2-6-WebSecurityConfig" class="headerlink" title="2.6 WebSecurityConfig"></a>2.6 WebSecurityConfig</h3><p>下面我们就需要把自己写的 SmsCodeAuthenticationSecurityConfig 加入到 WebSecurityConfig 中了。</p><p>首先将 SmsCodeAuthenticationSecurityConfig 注入进来，然后通过 <code>http.apply(xxx)</code> 添加进去。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="hljs-keyword">true</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SmsCodeAuthenticationSecurityConfig smsCodeAuthenticationSecurityConfig;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.apply(smsCodeAuthenticationSecurityConfig)            .and()            .authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span>                .antMatchers(<span class="hljs-string">"/sms/**"</span>).permitAll()                .anyRequest().authenticated()                .and()                <span class="hljs-comment">// 设置登陆页</span>                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                <span class="hljs-comment">// 设置登陆成功页</span>                .defaultSuccessUrl(<span class="hljs-string">"/"</span>).permitAll()                .and()                .logout().permitAll();        <span class="hljs-comment">// 关闭CSRF跨域</span>        http.csrf().disable();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 设置拦截忽略文件夹，可以对静态资源放行</span>        web.ignoring().antMatchers(<span class="hljs-string">"/css/**"</span>, <span class="hljs-string">"/js/**"</span>);    &#125;&#125;</code></pre></div><h3 id="2-7-接口与页面"><a href="#2-7-接口与页面" class="headerlink" title="2.7 接口与页面"></a>2.7 接口与页面</h3><p>然后在 controller 中写一个读取验证码的接口，注意这个接口在 <code>WebSecurityConfig</code> 中要放行：</p><div class="hljs"><pre><code class="hljs java">   <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/sms/code"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sms</span><span class="hljs-params">(String mobile, HttpSession session)</span></span>&#123;        <span class="hljs-keyword">int</span> code = (<span class="hljs-keyword">int</span>)Math.ceil(Math.random()*<span class="hljs-number">9000</span>+<span class="hljs-number">1000</span>);        Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">16</span>);        map.put(<span class="hljs-string">"mobile"</span>,mobile);        map.put(<span class="hljs-string">"code"</span>,code);                session.setAttribute(<span class="hljs-string">"smsCode"</span>,map);        logger.info(<span class="hljs-string">"&#123;&#125;:为&#123;&#125;设置短信验证码：&#123;&#125;"</span>,session.getId(),mobile,code);    &#125;&#125;</code></pre></div><p>然后修改 login.html 页面，添加短信登录的内容：</p><blockquote><p>注意这里的登录 Url <code>/sms/login</code> 是配置在 SmsAuthenticationFilter 中的 Url。</p></blockquote><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>欢迎来到登录页面<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>立即登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/sms/login"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        手机号：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mobile"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mobile"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jitwxs"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        验证码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"smsCode"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"javascript:;"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"sendSms()"</span>&gt;</span>获取验证码<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>立即登陆<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendSms</span><span class="hljs-params">()</span> </span>&#123;</span><span class="javascript">        <span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">'/sms/code?mobile='</span> + <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"mobile"</span>).value;</span>    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="三、测试代码"><a href="#三、测试代码" class="headerlink" title="三、测试代码"></a>三、测试代码</h2><p>因此只是测试，所以页面懒得弄了，当你输入手机号（实际上就是用户名），点击获取验证码，页面会跳转出去，然后自己再按一下浏览器的后退键退回来。</p><p>在控制台就会打印当前用户的 sessionId，以及为哪一个手机号所申请的验证码。</p>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(7)--认证流程</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-7-%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-7-%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>在前面的六章中，介绍了 Spring Security 的基础使用，在继续深入向下的学习前，有必要理解清楚 Spring Security 的认证流程，这样才能理解为什么要这样写代码，也方便后续的扩展。</p><h2 id="一、认证流程"><a href="#一、认证流程" class="headerlink" title="一、认证流程"></a>一、认证流程</h2><p><img src="https://www.jitwxs.cn/images/posts/20181202095539982.png" srcset="/img/loading.gif" alt="Spring Security 认证流程（部分）"></p><blockquote><p>上图是 Spring Security 认证流程的一部分，下面的讲解以上图为依据。</p></blockquote><p><strong>（1）</strong> 用户发起表单登录请求后，首先进入 <code>UsernamePasswordAuthenticationFilter</code>：</p><p><img src="https://www.jitwxs.cn/images/posts/2018120210045295.png" srcset="/img/loading.gif" alt="UsernamePasswordAuthenticationFilter"></p><p>​                                                                        UsernamePasswordAuthenticationFilter</p><p>在 UsernamePasswordAuthenticationFilter 中根据用户输入的用户名、密码构建了 <code>UsernamePasswordAuthenticationToken</code>，并将其交给 AuthenticationManager 来进行认证处理。</p><p>AuthenticationManager 本身不包含认证逻辑，其核心是用来管理所有的 <code>AuthenticationProvider</code>，通过交由合适的 AuthenticationProvider 来实现认证。</p><p><strong>（2）</strong> 下面跳转到了 <code>ProviderManager</code> ，该类是 AuthenticationManager 的实现类：</p><p><img src="https://www.jitwxs.cn/images/posts/20181202102203137.png" srcset="/img/loading.gif" alt="ProviderManager"></p><p>​                                                                                        ProviderManager</p><p>我们知道不同的登录逻辑它的认证方式是不一样的，比如我们表单登录需要认证用户名和密码，但是当我们使用三方登录时就不需要验证密码。</p><p>Spring Security 支持多种认证逻辑，<strong>每一种认证逻辑的认证方式其实就是一种 AuthenticationProvider</strong>。通过 <code>getProviders()</code> 方法就能获取所有的 AuthenticationProvider，通过 <code>provider.supports()</code> 来判断 provider 是否支持当前的认证逻辑。</p><p>当选择好一个合适的 AuthenticationProvider 后，通过 <code>provider.authenticate(authentication)</code> 来让 AuthenticationProvider 进行认证。</p><p><strong>（3）</strong> 传统表单登录的 AuthenticationProvider 主要是由 <code>AbstractUserDetailsAuthenticationProvider</code> 来进行处理的，我们来看下它的 <code>authenticate()</code>方法。</p><p>首先通过 <code>retrieveUser()</code> 方法读取到数据库中的用户信息：</p><div class="hljs"><pre><code class="hljs java">user = retrieveUser(username,(UsernamePasswordAuthenticationToken) authentication);</code></pre></div><p>retrieveUser() 的具体实现在 <code>DaoAuthenticationProvider</code> 中，代码如下：</p><p><img src="https://www.jitwxs.cn/images/posts/20181202103804350.png" srcset="/img/loading.gif" alt="DaoAuthenticationProvider"></p><p>​                                                                                DaoAuthenticationProvider</p><p><img src="https://www.jitwxs.cn/images/posts/20181202105844461.png" srcset="/img/loading.gif" alt="AbstractUserDetailsAuthenticationProvider"></p><p>​                                                                                AbstractUserDetailsAuthenticationProvider</p><p>在上图中，我们可以看到认证校验分为 <strong>前校验</strong>、<strong>附加校验</strong>和<strong>后校验</strong>，如果任何一个校验出错，就会抛出相应的异常。所有校验都通过后，调用 <code>createSuccessAuthentication()</code> 返回认证信息。</p><p><img src="https://www.jitwxs.cn/images/posts/20181202111353423.png" srcset="/img/loading.gif" alt="createSuccessAuthentication()"></p><p>​                                                                                        createSuccessAuthentication()</p><p>在<code>createSuccessAuthentication</code>方法中，我们发现它重新 new 了一个 <code>UsernamePasswordAuthenticationToken</code>，因为到这里认证已经通过了，所以将 authorities 注入进去，并设置 authenticated 为 true，即已经认证。</p><p>（4）至此认证信息就被传递回 UsernamePasswordAuthenticationFilter 中，在 UsernamePasswordAuthenticationFilter 的父类 <code>AbstractAuthenticationProcessingFilter</code> 的 <code>doFilter()</code> 中，会根据认证的成功或者失败调用相应的 handler：</p><p><img src="https://www.jitwxs.cn/images/posts/20181202113101881.png" srcset="/img/loading.gif" alt="AbstractAuthenticationProcessingFilter"></p><p>​                                                                            AbstractAuthenticationProcessingFilter</p><p>这里调用的 handler 实际就是在<a href="https://www.jitwxs.cn/59f4016e.html" target="_blank" rel="noopener">《SpringBoot集成Spring Security（6）——登录管理》</a>中我们在配置文件中配置的 <code>successHandler()</code> 和 <code>failureHandler()</code>。</p><h2 id="二、多个请求共享认证信息"><a href="#二、多个请求共享认证信息" class="headerlink" title="二、多个请求共享认证信息"></a>二、多个请求共享认证信息</h2><p>Spring Security 通过 <code>Session</code> 来保存用户的认证信息，那么 Spring Security 到底是在什么时候将认证信息放入 Session，又在什么时候将认证信息从 Session 中取出来的呢？</p><p>下面将 Spring Security 的认证流程补充完整，如下图：</p><p><img src="https://www.jitwxs.cn/images/posts/20180630104958316.png" srcset="/img/loading.gif" alt="Spring Security 认证流程"></p><p>​                                                                                                    Spring Security 认证流程</p><p>在上一节认证成功的 <code>successfulAuthentication()</code>方法中，有一行语句：</p><div class="hljs"><pre><code class="hljs java">SecurityContextHolder.getContext().setAuthentication(authResult);</code></pre></div><p>其实就是在这里将认证信息放入 Session 中。</p><p>查看 <code>SecurityContext</code> 源码，发现内部就是对 Authentication 的封装，提供了 equals、hashcode、toString等方法，而<code>SecurityContextHolder</code> 可以理解为线程中的 <code>ThreadLocal</code>。</p><p>我们知道一个 HTTP 请求和响应都是在一个线程中执行，因此在整个处理的任何一个方法中都可以通过 <code>SecurityContextHolder.getContext()</code>来取得存放进去的认证信息。</p><p>从 Session 中对认证信息的处理由 <code>SecurityContextPersistenceFilter</code> 来处理，它位于 Spring Security 过滤器链的最前面，它的主要作用是：</p><ul><li>当请求时，检查 Session 中是否存在 SecurityContext，如果有将其放入到线程中</li><li>当响应时，检查线程中是否存在 SecurityContext，如果有将其放入到 Session 中</li></ul><p><img src="https://www.jitwxs.cn/images/posts/20180630114216422.png" srcset="/img/loading.gif" alt="img"></p><h2 id="三、获取用户认证信息"><a href="#三、获取用户认证信息" class="headerlink" title="三、获取用户认证信息"></a>三、获取用户认证信息</h2><p>通过调用 <code>SecurityContextHolder.getContext().getAuthentication()</code> 就能够取得认证信息：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/me"</span>)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">me</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> SecurityContextHolder.getContext().getAuthentication();&#125;</code></pre></div><p><img src="https://www.jitwxs.cn/images/posts/20181202140404470.png" srcset="/img/loading.gif" alt="img"></p><p>上面的写法有点啰嗦，我们可以简写成下面这种， Spring MVC 会自动帮我们从 Spring Security 中注入：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/me"</span>)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">me</span><span class="hljs-params">(Authentication authentication)</span> </span>&#123;    <span class="hljs-keyword">return</span> authentication;&#125;</code></pre></div><p>如果你仅想获取 <code>UserDetails</code> 对象，也是可以的，写法如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/me"</span>)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">me</span><span class="hljs-params">(@AuthenticationPrincipal UserDetails userDetails)</span> </span>&#123;    <span class="hljs-keyword">return</span> userDetails;&#125;</code></pre></div><p><img src="https://www.jitwxs.cn/images/posts/20181202140702514.png" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(6)--登录管理</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-6-%E7%99%BB%E5%BD%95%E7%AE%A1%E7%90%86/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-6-%E7%99%BB%E5%BD%95%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="一、自定义认证成功、失败处理"><a href="#一、自定义认证成功、失败处理" class="headerlink" title="一、自定义认证成功、失败处理"></a>一、自定义认证成功、失败处理</h2><p>有些时候我们想要在认证成功后做一些业务处理，例如添加积分；有些时候我们想要在认证失败后也做一些业务处理，例如记录日志。</p><p>在之前的文章中，关于认证成功、失败后的处理都是如下配置的：</p><div class="hljs"><pre><code class="hljs java">http.authorizeRequests()    <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span><span class="hljs-comment">//    .antMatchers().permitAll()</span>    .anyRequest().authenticated().and()    <span class="hljs-comment">// 设置登录页</span>    .formLogin().loginPage(<span class="hljs-string">"/login"</span>)    .failureUrl(<span class="hljs-string">"/login/error"</span>)    .defaultSuccessUrl(<span class="hljs-string">"/"</span>)    .permitAll()    ...;</code></pre></div><p>即 <code>failureUrl()</code> 指定认证失败后Url，<code>defaultSuccessUrl()</code> 指定认证成功后Url。我们可以通过设置 <code>successHandler()</code> 和 <code>failureHandler()</code> 来实现自定义认证成功、失败处理。</p><blockquote><p>PS：当我们设置了这两个后，需要去除 <code>failureUrl()</code> 和 <code>defaultSuccessUrl()</code> 的设置，否则无法生效。这两套配置同时只能存在一套。</p></blockquote><h3 id="1-1-CustomAuthenticationSuccessHandler"><a href="#1-1-CustomAuthenticationSuccessHandler" class="headerlink" title="1.1 CustomAuthenticationSuccessHandler"></a>1.1 CustomAuthenticationSuccessHandler</h3><p>自定义 CustomAuthenticationSuccessHandler 类来实现 <code>AuthenticationSuccessHandler</code> 接口，用来处理认证成功后逻辑：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationSuccessHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationSuccessHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,                 Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        logger.info(<span class="hljs-string">"登录成功，&#123;&#125;"</span>,authentication);                response.sendRedirect(<span class="hljs-string">"/"</span>);    &#125;&#125;</code></pre></div><p><code>onAuthenticationSuccess()</code> 方法的第三个参数 <code>Authentication</code> 为认证后该用户的认证信息，这里打印日志后，重定向到了首页。</p><h3 id="1-2-CustomAuthenticationFailureHandler"><a href="#1-2-CustomAuthenticationFailureHandler" class="headerlink" title="1.2 CustomAuthenticationFailureHandler"></a>1.2 CustomAuthenticationFailureHandler</h3><p>自定义 CustomAuthenticationFailureHandler 类来实现 <code>AuthenticationFailureHandler</code> 接口，用来处理认证失败后逻辑：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationFailureHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationFailureHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Autowired</span>    ObjectMapper objectMapper;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        logger.info(<span class="hljs-string">"登录失败"</span>);        response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());        response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);        response.getWriter().write(objectMapper.writeValueAsString(exception.getMessage()));    &#125;&#125;</code></pre></div><p><code>onAuthenticationFailure()</code>方法的第三个参数 <code>exception</code> 为认证失败所产生的异常，这里也是简单的返回到前台。</p><h3 id="1-3-修改-WebSecurityConfig"><a href="#1-3-修改-WebSecurityConfig" class="headerlink" title="1.3 修改 WebSecurityConfig"></a>1.3 修改 WebSecurityConfig</h3><div class="hljs"><pre><code class="hljs java">    <span class="hljs-meta">@Autowired</span>    CustomAuthenticationSuccessHandler authenticationSuccessHandler;    <span class="hljs-meta">@Autowired</span>    CustomAuthenticationFailureHandler authenticationFailureHandler; <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span><span class="hljs-comment">//                .antMatchers().permitAll()</span>                .anyRequest().authenticated()                .and()                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                .successHandler(authenticationSuccessHandler)                .failureHandler(authenticationFailureHandler)            .permitAll() <span class="hljs-comment">//很关键</span><span class="hljs-comment">//                .defaultSuccessUrl("/").permitAll()</span>                .and()                .logout()                .logoutSuccessUrl(<span class="hljs-string">"/logout"</span>)                .permitAll();        <span class="hljs-comment">//关闭CRSF跨域</span>        http.csrf().disable();    &#125;</code></pre></div><ol><li>首先将 <code>customAuthenticationSuccessHandler</code> 和 <code>customAuthenticationFailureHandler</code>注入进来</li><li>配置 <code>successHandler()</code> 和 <code>failureHandler()</code></li><li>注释 <code>failureUrl()</code> 和 <code>defaultSuccessUrl()</code></li></ol><h3 id="1-4-运行程序"><a href="#1-4-运行程序" class="headerlink" title="1.4 运行程序"></a>1.4 运行程序</h3><p>运行程序，当我们成功登陆后，发现日志信息被打印出来，页面被重定向到了首页：</p><p><img src="https://www.jitwxs.cn/images/posts/20190110174809434.png" srcset="/img/loading.gif" alt="img"></p><p>当我们认证失败后，发现日志中“登陆失败”被打印出来，页面展示了认证失败的异常消息：</p><p><img src="https://www.jitwxs.cn/images/posts/20190110174827988.png" srcset="/img/loading.gif" alt="img"></p><h2 id="二、Session-超时"><a href="#二、Session-超时" class="headerlink" title="二、Session 超时"></a>二、Session 超时</h2><p>当用户登录后，我们可以设置 session 的超时时间，当达到超时时间后，自动将用户退出登录。</p><p>Session 超时的配置是 SpringBoot 原生支持的，我们只需要在 <code>application.properties</code> 配置文件中配置：</p><div class="hljs"><pre><code class="hljs java">server.servlet.session.timeout=<span class="hljs-number">60</span>s</code></pre></div><blockquote><p>Tip：<br>从用户最后一次操作开始计算过期时间。<br>过期时间最小值为 60 秒，如果你设置的值小于 60 秒，也会被更改为 60 秒。</p></blockquote><p>我们可以在 Spring Security 中配置处理逻辑，在 session 过期退出时调用。修改 WebSecurityConfig 的 <code>configure()</code> 方法，添加：</p><div class="hljs"><pre><code class="hljs java">.sessionManagement()    <span class="hljs-comment">// 以下二选一</span>    <span class="hljs-comment">//.invalidSessionStrategy()</span>    <span class="hljs-comment">//.invalidSessionUrl();</span></code></pre></div><p>Spring Security 提供了两种处理配置，一个是 <code>invalidSessionStrategy()</code>，另外一个是 <code>invalidSessionUrl()</code>。</p><p>这两个的区别就是一个是前者是在一个类中进行处理，后者是直接跳转到一个 Url。简单起见，我就直接用 <code>invalidSessionUrl()</code>了，跳转到 <code>/login/invalid</code>，我们需要把该 Url 设置为免授权访问， 配置如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http.authorizeRequests()            <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span>            .antMatchers(<span class="hljs-string">"/login/invalid"</span>).permitAll()            .anyRequest().authenticated().and()            ...            .sessionManagement()                .invalidSessionUrl(<span class="hljs-string">"/login/invalid"</span>);    <span class="hljs-comment">// 关闭CSRF跨域</span>    http.csrf().disable();&#125;</code></pre></div><p>在 controller 中写一个接口进行处理：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/login/invalid"</span>)<span class="hljs-meta">@ResponseStatus</span>(HttpStatus.UNAUTHORIZED)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">invalid</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"Session 已过期，请重新登录"</span>;&#125;</code></pre></div><p>运行程序，登录成功后等待一分钟（或者重启服务器），刷新页面：</p><p><img src="https://www.jitwxs.cn/images/posts/20190110171026663.png" srcset="/img/loading.gif" alt="session 过期"></p><h2 id="三、限制最大登录数"><a href="#三、限制最大登录数" class="headerlink" title="三、限制最大登录数"></a>三、限制最大登录数</h2><p>接下来实现限制最大登录数，原理就是限制单个用户能够存在的最大 session 数。</p><p>在上一节的基础上，修改 <code>configure()</code> 为：</p><div class="hljs"><pre><code class="hljs java">.sessionManagement()    .invalidSessionUrl(<span class="hljs-string">"/login/invalid"</span>)    .maximumSessions(<span class="hljs-number">1</span>)    <span class="hljs-comment">// 当达到最大值时，是否保留已经登录的用户</span>    .maxSessionsPreventsLogin(<span class="hljs-keyword">false</span>)    <span class="hljs-comment">// 当达到最大值时，旧用户被踢出后的操作</span>    .expiredSessionStrategy(<span class="hljs-keyword">new</span> CustomExpiredSessionStrategy())</code></pre></div><p>增加了下面三行代码，其中：</p><ul><li><code>maximumSessions(int)</code>：指定最大登录数</li><li><code>maxSessionsPreventsLogin(boolean)</code>：是否保留已经登录的用户；为true，新用户无法登录；为 false，旧用户被踢出</li><li><code>expiredSessionStrategy(SessionInformationExpiredStrategy)</code>：旧用户被踢出后处理方法</li></ul><blockquote><p><code>maxSessionsPreventsLogin()</code>可能不太好理解，这里我们先设为 false，效果和 QQ 登录是一样的，登录后之前登录的账户被踢出。</p></blockquote><p>编写 CustomExpiredSessionStrategy 类，来处理旧用户登录失败的逻辑：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomExpiredSessionStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SessionInformationExpiredStrategy</span> </span>&#123;    <span class="hljs-keyword">private</span> ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();<span class="hljs-comment">//    private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onExpiredSessionDetected</span><span class="hljs-params">(SessionInformationExpiredEvent event)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        Map&lt;String,Object&gt;map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">16</span>);        map.put(<span class="hljs-string">"code"</span>,<span class="hljs-number">0</span>);        map.put(<span class="hljs-string">"msg"</span>,<span class="hljs-string">"已经另一台机器登录，您被迫下线"</span>);        <span class="hljs-comment">//Map -&gt; json</span>        String json = objectMapper.writeValueAsString(map);        event.getResponse().setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);        event.getResponse().getWriter().write(json);                <span class="hljs-comment">//如果是跳转html页面，url代表跳转的地址</span><span class="hljs-comment">//        redirectStrategy.sendRedirect(event.getRequest(),event.getResponse(),"url");</span>    &#125;&#125;</code></pre></div><p>在 <code>onExpiredSessionDetected()</code> 方法中，处理相关逻辑，我这里只是简单的返回一句话。</p><p>执行程序，打开两个浏览器，登录同一个账户。因为我设置了 <code>maximumSessions(1)</code>，也就是单个用户只能存在一个 session，因此当你刷新先登录的那个浏览器时，被提示踢出了。</p><p><img src="https://www.jitwxs.cn/images/posts/2019011017515758.png" srcset="/img/loading.gif" alt="maxSessionsPreventsLogin 为 false"></p><p>下面我们来测试下 <code>maxSessionsPreventsLogin(true)</code> 时的情况，我们发现第一个浏览器登录后，第二个浏览器无法登录：</p><p><img src="https://www.jitwxs.cn/images/posts/20190110175325653.png" srcset="/img/loading.gif" alt="maxSessionsPreventsLogin 为 true"></p><h2 id="四、踢出用户"><a href="#四、踢出用户" class="headerlink" title="四、踢出用户"></a>四、踢出用户</h2><p>下面来看下如何主动踢出一个用户。</p><p>首先需要在容器中注入名为 <code>SessionRegistry</code> 的 Bean，这里我就简单的写在 WebSecurityConfig 中：</p><p>修改 WebSecurityConfig 的 configure() 方法，在最后添加一行 <code>.sessionRegistry()</code>：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    ...    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SessionRegistry <span class="hljs-title">sessionRegistry</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SessionRegistryImpl();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span>                .antMatchers(<span class="hljs-string">"/login/invalid"</span>).permitAll()                .anyRequest().authenticated().and()                <span class="hljs-comment">// 设置登录页</span>                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                .successHandler(customAuthenticationSuccessHandler)                .failureHandler(customAuthenticationFailureHandler)                .permitAll().and()                .logout().and()                .sessionManagement()                    .invalidSessionUrl(<span class="hljs-string">"/login/invalid"</span>)                    .maximumSessions(<span class="hljs-number">1</span>)                    <span class="hljs-comment">// 当达到最大值时，是否保留已经登录的用户</span>                    .maxSessionsPreventsLogin(<span class="hljs-keyword">false</span>)                    <span class="hljs-comment">// 当达到最大值时，旧用户被踢出后的操作</span>                    .expiredSessionStrategy(<span class="hljs-keyword">new</span> CustomExpiredSessionStrategy())                    .sessionRegistry(sessionRegistry());        <span class="hljs-comment">// 关闭CSRF跨域</span>        http.csrf().disable();    &#125;&#125;</code></pre></div><p>编写一个接口用于测试踢出用户：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SessionRegistry sessionRegistry;    ...    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/kick"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">removeUserSessionByUsername</span><span class="hljs-params">(@RequestParam String username)</span> </span>&#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 获取session中所有的用户信息</span>        List&lt;Object&gt; users = sessionRegistry.getAllPrincipals();        <span class="hljs-keyword">for</span> (Object principal : users) &#123;            <span class="hljs-keyword">if</span> (principal <span class="hljs-keyword">instanceof</span> User) &#123;                String principalName = ((User)principal).getUsername();                <span class="hljs-keyword">if</span> (principalName.equals(username)) &#123;                    <span class="hljs-comment">// 参数二：是否包含过期的Session</span>                    List&lt;SessionInformation&gt; sessionsInfo = sessionRegistry.getAllSessions(principal, <span class="hljs-keyword">false</span>);                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != sessionsInfo &amp;&amp; sessionsInfo.size() &gt; <span class="hljs-number">0</span>) &#123;                        <span class="hljs-keyword">for</span> (SessionInformation sessionInformation : sessionsInfo) &#123;                            sessionInformation.expireNow();                            count++;                        &#125;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">"操作成功，清理session共"</span> + count + <span class="hljs-string">"个"</span>;    &#125;&#125;</code></pre></div><ol><li><code>sessionRegistry.getAllPrincipals();</code> 获取所有 principal 信息</li><li>通过 <code>principal.getUsername</code>是否等于输入值，获取到指定用户的 principal</li><li><code>sessionRegistry.getAllSessions(principal, false)</code>获取该 principal 上的所有 session</li><li>通过 <code>sessionInformation.expireNow()</code> 使得 session 过期</li></ol><p>运行程序，分别使用 admin 和 jitwxs 账户登录，admin 访问 <code>/kick?username=jitwxs</code> 来踢出用户 jitwxs，jitwxs 刷新页面，发现被踢出。</p><p><img src="https://img-blog.csdnimg.cn/20200531234209914.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="五、退出登录"><a href="#五、退出登录" class="headerlink" title="五、退出登录"></a>五、退出登录</h2><p>补充一下退出登录的内容，在之前，我们直接在 WebSecurityConfig 的 configure() 方法中，配置了：</p><div class="hljs"><pre><code class="hljs java">http.logout();</code></pre></div><p>这就是 Spring Security 的默认退出配置，Spring Security 在退出时候做了这样几件事：</p><ol><li>使当前的 session 失效</li><li>清除与当前用户有关的 remember-me 记录</li><li>清空当前的 SecurityContext</li><li>重定向到登录页</li></ol><p>Spring Security 默认的退出 Url 是 <code>/logout</code>，我们可以修改默认的退出 Url，例如修改为 <code>/signout</code>：</p><div class="hljs"><pre><code class="hljs java">http.logout()    .logoutUrl(<span class="hljs-string">"/signout"</span>);</code></pre></div><p>我们也可以配置当退出时清除浏览器的 Cookie，例如清除 名为 JSESSIONID 的 cookie：</p><div class="hljs"><pre><code class="hljs java">http.logout()    .logoutUrl(<span class="hljs-string">"/signout"</span>)    .deleteCookies(<span class="hljs-string">"JSESSIONID"</span>);</code></pre></div><p>我们也可以配置退出后处理的逻辑，方便做一些别的操作：</p><div class="hljs"><pre><code class="hljs java">http.logout()    .logoutUrl(<span class="hljs-string">"/signout"</span>)    .deleteCookies(<span class="hljs-string">"JSESSIONID"</span>)    .logoutSuccessHandler(logoutSuccessHandler);</code></pre></div><p>创建类 <code>DefaultLogoutSuccessHandler</code>：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomLogoutSuccessHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LogoutSuccessHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLogoutSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        String username = ((User) authentication.getPrincipal()).getUsername();        logger.info(<span class="hljs-string">"退出成功，用户名：&#123;&#125;"</span>,username);        <span class="hljs-comment">//重定向到登录页</span>        response.sendRedirect(<span class="hljs-string">"/login"</span>);    &#125;&#125;</code></pre></div><p>最后把它注入到 WebSecurityConfig 即可：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> CustomLogoutSuccessHandler logoutSuccessHandler;</code></pre></div><p>效果：</p><p><img src="https://img-blog.csdnimg.cn/2020053123365730.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="六、Session-共享"><a href="#六、Session-共享" class="headerlink" title="六、Session 共享"></a>六、Session 共享</h2><p>在最后补充下关于 Session 共享的知识点，一般情况下，一个程序为了保证稳定至少要部署两个，构成集群。那么就牵扯到了 Session 共享的问题，不然用户在 8080 登录成功后，后续访问了 8060 服务器，结果又提示没有登录。</p><p>这里就简单实现下 Session 共享，采用 Redis 来存储。</p><h3 id="6-1-配置-Redis"><a href="#6-1-配置-Redis" class="headerlink" title="6.1 配置 Redis"></a>6.1 配置 Redis</h3><p>为了方便起见，我直接使用 Docker 快速部署，如果你需要传统方式安装，可以参考文章<a href="https://www.jitwxs.cn/e331e26a.html" target="_blank" rel="noopener">《Redis 初探（1）——Redis 的安装》</a>。</p><div class="hljs"><pre><code class="hljs applescript">docker pull redisdocker <span class="hljs-built_in">run</span> <span class="hljs-comment">--name myredis -p 6379:6379 -d redis</span>docker exec -<span class="hljs-keyword">it</span> myredis redis-cli</code></pre></div><p>这里因为我ubutun连不上网，所以用的是redis客户端</p><h3 id="6-2-配置-Session-共享"><a href="#6-2-配置-Session-共享" class="headerlink" title="6.2 配置 Session 共享"></a>6.2 配置 Session 共享</h3><p>首先需要导入依赖，因为我们采用 Redis 方式实现，因此导入：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--redis相关依赖--&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>在 <code>application.xml</code> 中新增配置指定 redis 地址以及 session 的存储方式：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-comment">#redis相关配置</span><span class="hljs-string">spring.redis.host=localhost</span><span class="hljs-string">spring.redis.port=6379</span><span class="hljs-string">spring.session.store-type=redis</span></code></pre></div><p>然后为主类添加 <code>@EnableRedisHttpSession</code> 注解。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@EnableRedisHttpSession</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringSecuriity06Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(SpringSecuriity06Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><h3 id="6-3-运行程序"><a href="#6-3-运行程序" class="headerlink" title="6.3 运行程序"></a>6.3 运行程序</h3><p>这样就完成了基于 Redis 的 Session 共享，下面来测试下。首先修改 IDEA 配置来允许项目在多端口运行，勾选 <code>Allow running in parallel</code>(2018.2版本好像没有该选项，应该是取消勾选<code>Single instance only</code>)：</p><p><img src="https://img-blog.csdnimg.cn/20200531233713573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>运行程序，然后修改配置文件，将 <code>server.port</code> 更改为 8060，再次运行。这样项目就会分别在默认的 8080 端口和 8060 端口运行。</p><p><img src="https://img-blog.csdnimg.cn/20200531233941130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>先访问 <code>localhost:8080</code>，登录成功后，再访问 <code>localhost:8060</code>，发现无需登录。</p>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(5)--权限控制</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-5-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-5-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>在第一篇中，我们说过，<strong>用户&lt;–&gt;角色&lt;–&gt;权限</strong>三层中，暂时不考虑权限，在这一篇，是时候把它完成了。</p><p>为了方便演示，这里的权限只是对角色赋予权限，也就是说同一个角色的用户，权限是一样的。当然了，你也可以精细化到为每一个用户设置权限，但是这不在本篇的探讨范围，有兴趣可以自己实验，原理都是一样的。</p><h2 id="一、数据准备"><a href="#一、数据准备" class="headerlink" title="一、数据准备"></a>一、数据准备</h2><h3 id="1-1-创建-sys-permission-表"><a href="#1-1-创建-sys-permission-表" class="headerlink" title="1.1 创建 sys_permission 表"></a>1.1 创建 sys_permission 表</h3><p>让我们先创建一张权限表，名为 <code>sys_permission</code>：</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`sys_permission`</span>(<span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,<span class="hljs-string">`url`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,<span class="hljs-string">`role_id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,<span class="hljs-string">`permission`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,PRIMARY <span class="hljs-keyword">KEY</span>(<span class="hljs-string">`id`</span>),<span class="hljs-keyword">KEY</span> <span class="hljs-string">`fk_roleId`</span>(<span class="hljs-string">`role_id`</span>),<span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-string">`fk_roleId`</span> <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span>(<span class="hljs-string">`role_id`</span>) <span class="hljs-keyword">REFERENCES</span> <span class="hljs-string">`sys_role`</span>(<span class="hljs-string">`id`</span>) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">CASCADE</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">CASCADE</span>)<span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">5</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4;</code></pre></div><p>内容就是两条数据，通过 <code>url</code> + <code>role_id</code> + <code>permission</code> 唯一标识了一个角色访问某一url时的权限，其中权限暂定为c、r、u、d，代表了增、删、改、查。</p><p><img src="https://www.jitwxs.cn/images/posts/20180515185020939.png" srcset="/img/loading.gif" alt="sys_permission 表数据"></p><h3 id="1-2-创建-Model、Mapper、Service"><a href="#1-2-创建-Model、Mapper、Service" class="headerlink" title="1.2 创建 Model、Mapper、Service"></a>1.2 创建 Model、Mapper、Service</h3><p>（1）Model</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysPermission</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String url;    <span class="hljs-keyword">private</span> Integer roleId;    <span class="hljs-keyword">private</span> String permission;    <span class="hljs-keyword">private</span> List permissions;    <span class="hljs-comment">//省略getter，setter</span>&#125;</code></pre></div><p>这里需要注意的时相比于数据库，多了一个 <code>permissions</code> 属性，该字段将 <code>permission</code> 按逗号分割为了 list。</p><p>（2）mapper</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysPermissionMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_permission WHERE role_id=#&#123;roleId&#125;"</span>)    List&lt;SysPermission&gt;listByRoleId(Integer roleId);&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysRoleMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_role WHERE id = #&#123;id&#125;"</span>)    <span class="hljs-function">SysRole <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_role WHERE name = #&#123;name&#125;"</span>)    <span class="hljs-function">SysRole <span class="hljs-title">selectByName</span><span class="hljs-params">(String name)</span></span>;&#125;</code></pre></div><p>（3）Service</p><p>SysPermissionService 中有一个方法，根据 roleId 获取所有的 <code>SysPermission</code>。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysPermissionService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysPermissionMapper permissionMapper;        <span class="hljs-comment">/**获取指定角色所有权限**/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;SysPermission&gt; <span class="hljs-title">listByRoleId</span><span class="hljs-params">(Integer roleId)</span></span>&#123;        <span class="hljs-keyword">return</span> permissionMapper.listByRoleId(roleId);    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysRoleService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysRoleMapper sysRoleMapper;        <span class="hljs-function"><span class="hljs-keyword">public</span> SysRole <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>&#123;        <span class="hljs-keyword">return</span> sysRoleMapper.selectById(id);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> SysRole <span class="hljs-title">selectByName</span><span class="hljs-params">(String name)</span></span>&#123;        <span class="hljs-keyword">return</span> sysRoleMapper.selectByName(name);    &#125;&#125;</code></pre></div><h3 id="1-3-修改接口"><a href="#1-3-修改接口" class="headerlink" title="1.3 修改接口"></a>1.3 修改接口</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;    <span class="hljs-comment">//...</span>    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/admin"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasPermission('/admin','r')"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">printAdminR</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"如果你看见这句话，说明你访问/admin路径具有r权限"</span>;    &#125;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/admin/c"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasPermission('/admin','c')"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">printAdminC</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"如果你看见这句话，说明你访问/admin路径具有c权限"</span>;    &#125;&#125;</code></pre></div><p>让我们修改下我们要访问的接口，<code>@PreAuthorize(&quot;hasPermission(&#39;/admin&#39;,&#39;r&#39;)&quot;)</code> 是关键，参数1指明了<strong>访问该接口需要的url</strong>，参数2指明了<strong>访问该接口需要的权限</strong>。</p><h2 id="二、PermissionEvaluator"><a href="#二、PermissionEvaluator" class="headerlink" title="二、PermissionEvaluator"></a>二、PermissionEvaluator</h2><p>我们需要自定义对 <code>hasPermission()</code> 方法的处理，就需要自定义 <code>PermissionEvaluator</code>，创建类 <code>CustomPermissionEvaluator</code>，实现 <code>PermissionEvaluator</code> 接口。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomPermissionEvaluator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PermissionEvaluator</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysPermissionService permissionService;    <span class="hljs-meta">@Autowired</span>    SysRoleService roleService;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPermission</span><span class="hljs-params">(Authentication authentication, Object targetUrl, Object targetPermission)</span> </span>&#123;        <span class="hljs-comment">//获得loadUserByUsername()方法的结果</span>        User user = (User) authentication.getPrincipal();        <span class="hljs-comment">//获得loadUserByUsername()中注入的角色</span>        Collection&lt;GrantedAuthority&gt; authorities = user.getAuthorities();        <span class="hljs-comment">//遍历用户所有角色</span>        <span class="hljs-keyword">for</span>(GrantedAuthority authority:authorities)&#123;            String roleName = authority.getAuthority();            Integer roleId = roleService.selectByName(roleName).getId();            <span class="hljs-comment">//得到角色所有的权限</span>            List&lt;SysPermission&gt; permissionList = permissionService.listByRoleId(roleId);            <span class="hljs-comment">//遍历permissionList</span>            <span class="hljs-keyword">for</span>(SysPermission sysPermission:permissionList)&#123;                <span class="hljs-comment">//获取权限集</span>                List permissions = sysPermission.getPermissions();                <span class="hljs-comment">//如果访问的url和权限用户符合的话，返回true</span>                <span class="hljs-keyword">if</span>(targetUrl.equals(sysPermission.getUrl()) &amp;&amp; permissions.contains(targetPermission))&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPermission</span><span class="hljs-params">(Authentication authentication, Serializable targetId, String targetType, Object permission)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><p>在 <code>hasPermission()</code> 方法中，参数 1 代表<strong>用户的权限身份</strong>，参数 2 参数 3 分别和 <code>@PreAuthorize(&quot;hasPermission(&#39;/admin&#39;,&#39;r&#39;)&quot;)</code> 中的参数对应，即<strong>访问 url 和权限</strong>。</p><p>思路如下：</p><ol><li>通过 <code>Authentication</code> 取出登录用户的所有 <code>Role</code></li><li>遍历每一个 <code>Role</code>，获取到每个<code>Role</code>的所有 <code>Permission</code></li><li>遍历每一个 <code>Permission</code>，只要有一个 <code>Permission</code> 的 <code>url</code> 和传入的url相同，且该 <code>Permission</code> 中包含传入的权限，返回 true</li><li>如果遍历都结束，还没有找到，返回false</li></ol><p>下面就是在 <code>WebSecurityConfig</code> 中注册 <code>CustomPermissionEvaluator</code>：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DefaultWebSecurityExpressionHandler <span class="hljs-title">webSecurityExpressionHandler</span><span class="hljs-params">()</span></span>&#123;        DefaultWebSecurityExpressionHandler handler = <span class="hljs-keyword">new</span> DefaultWebSecurityExpressionHandler();        handler.setPermissionEvaluator(<span class="hljs-keyword">new</span> CustomPermissionEvaluator());        <span class="hljs-keyword">return</span> handler;    &#125;&#125;</code></pre></div><h2 id="三、运行程序"><a href="#三、运行程序" class="headerlink" title="三、运行程序"></a>三、运行程序</h2><p>当我使用角色为 <code>ROLE_USER</code> 的用户仍然能访问，因为该用户访问 <code>/admin</code> 路径具有 <code>r</code> 权限：</p><p><img src="https://www.jitwxs.cn/images/posts/2018051519070954.png" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(4)--自定义表单登录</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%8D%95%E7%99%BB%E5%BD%95/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%8D%95%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="一、添加验证码"><a href="#一、添加验证码" class="headerlink" title="一、添加验证码"></a>一、添加验证码</h3><h4 id="1-1-验证码-Servlet"><a href="#1-1-验证码-Servlet" class="headerlink" title="1.1 验证码 Servlet"></a>1.1 验证码 Servlet</h4><p>验证码的 Servlet 代码，大家无需关心其内部实现，我也是百度直接捞了一个，直接复制即可。</p><div class="hljs"><pre><code class="hljs java">com.gavin.springsecurity04.common.VerifyServlet    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VerifyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123; <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">5051097528828603895L</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 验证码图片的宽度。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> width = <span class="hljs-number">100</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *  验证码图片的高度。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height = <span class="hljs-number">30</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 验证码字符个数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> codeCount = <span class="hljs-number">4</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 字体高度</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> fontHeight;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 干扰线数量</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> interLine = <span class="hljs-number">16</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 第一个字符的x轴值，因为后面的字符坐标依次递增，所以它们的x轴值是codeX的倍数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> codeX;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * codeY ,验证字符的y轴值，因为并行所以值一样</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> codeY;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * codeSequence 表示字符允许出现的序列值</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">char</span>[] codeSequence = &#123; <span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>, <span class="hljs-string">'H'</span>, <span class="hljs-string">'I'</span>, <span class="hljs-string">'J'</span>,            <span class="hljs-string">'K'</span>, <span class="hljs-string">'L'</span>, <span class="hljs-string">'M'</span>, <span class="hljs-string">'N'</span>, <span class="hljs-string">'O'</span>, <span class="hljs-string">'P'</span>, <span class="hljs-string">'Q'</span>, <span class="hljs-string">'R'</span>, <span class="hljs-string">'S'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">'U'</span>, <span class="hljs-string">'V'</span>, <span class="hljs-string">'W'</span>,            <span class="hljs-string">'X'</span>, <span class="hljs-string">'Y'</span>, <span class="hljs-string">'Z'</span>, <span class="hljs-string">'0'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'6'</span>, <span class="hljs-string">'7'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'9'</span> &#125;;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 初始化验证图片属性</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;        <span class="hljs-comment">// 从web.xml中获取初始信息</span>        <span class="hljs-comment">// 宽度</span>        String strWidth = <span class="hljs-keyword">this</span>.getInitParameter(<span class="hljs-string">"width"</span>);        <span class="hljs-comment">// 高度</span>        String strHeight = <span class="hljs-keyword">this</span>.getInitParameter(<span class="hljs-string">"height"</span>);        <span class="hljs-comment">// 字符个数</span>        String strCodeCount = <span class="hljs-keyword">this</span>.getInitParameter(<span class="hljs-string">"codeCount"</span>);        <span class="hljs-comment">// 将配置的信息转换成数值</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (strWidth != <span class="hljs-keyword">null</span> &amp;&amp; strWidth.length() != <span class="hljs-number">0</span>) &#123;                width = Integer.parseInt(strWidth);            &#125;            <span class="hljs-keyword">if</span> (strHeight != <span class="hljs-keyword">null</span> &amp;&amp; strHeight.length() != <span class="hljs-number">0</span>) &#123;                height = Integer.parseInt(strHeight);            &#125;            <span class="hljs-keyword">if</span> (strCodeCount != <span class="hljs-keyword">null</span> &amp;&amp; strCodeCount.length() != <span class="hljs-number">0</span>) &#123;                codeCount = Integer.parseInt(strCodeCount);            &#125;        &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-comment">//width-4 除去左右多余的位置，使验证码更加集中显示，减得越多越集中。</span>        <span class="hljs-comment">//codeCount+1     //等比分配显示的宽度，包括左右两边的空格</span>        codeX = (width-<span class="hljs-number">4</span>) / (codeCount+<span class="hljs-number">1</span>);        <span class="hljs-comment">//height - 10 集中显示验证码</span>        fontHeight = height - <span class="hljs-number">10</span>;        codeY = height - <span class="hljs-number">7</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ServletException</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> java.io.IOException</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, java.io.IOException </span>&#123;        <span class="hljs-comment">// 定义图像buffer</span>        BufferedImage buffImg = <span class="hljs-keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);        Graphics2D gd = buffImg.createGraphics();        <span class="hljs-comment">// 创建一个随机数生成器类</span>        Random random = <span class="hljs-keyword">new</span> Random();        <span class="hljs-comment">// 将图像填充为白色</span>        gd.setColor(Color.LIGHT_GRAY);        gd.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);        <span class="hljs-comment">// 创建字体，字体的大小应该根据图片的高度来定。</span>        Font font = <span class="hljs-keyword">new</span> Font(<span class="hljs-string">"Times New Roman"</span>, Font.PLAIN, fontHeight);        <span class="hljs-comment">// 设置字体。</span>        gd.setFont(font);        <span class="hljs-comment">// 画边框。</span>        gd.setColor(Color.BLACK);        gd.drawRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width - <span class="hljs-number">1</span>, height - <span class="hljs-number">1</span>);        <span class="hljs-comment">// 随机产生16条干扰线，使图象中的认证码不易被其它程序探测到。</span>        gd.setColor(Color.gray);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; interLine; i++) &#123;            <span class="hljs-keyword">int</span> x = random.nextInt(width);            <span class="hljs-keyword">int</span> y = random.nextInt(height);            <span class="hljs-keyword">int</span> xl = random.nextInt(<span class="hljs-number">12</span>);            <span class="hljs-keyword">int</span> yl = random.nextInt(<span class="hljs-number">12</span>);            gd.drawLine(x, y, x + xl, y + yl);        &#125;        <span class="hljs-comment">// randomCode用于保存随机产生的验证码，以便用户登录后进行验证。</span>        StringBuffer randomCode = <span class="hljs-keyword">new</span> StringBuffer();        <span class="hljs-keyword">int</span> red = <span class="hljs-number">0</span>, green = <span class="hljs-number">0</span>, blue = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 随机产生codeCount数字的验证码。</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; codeCount; i++) &#123;            <span class="hljs-comment">// 得到随机产生的验证码数字。</span>            String strRand = String.valueOf(codeSequence[random.nextInt(<span class="hljs-number">36</span>)]);            <span class="hljs-comment">// 产生随机的颜色分量来构造颜色值，这样输出的每位数字的颜色值都将不同。</span>            red = random.nextInt(<span class="hljs-number">255</span>);            green = random.nextInt(<span class="hljs-number">255</span>);            blue = random.nextInt(<span class="hljs-number">255</span>);            <span class="hljs-comment">// 用随机产生的颜色将验证码绘制到图像中。</span>            gd.setColor(<span class="hljs-keyword">new</span> Color(red,green,blue));            gd.drawString(strRand, (i + <span class="hljs-number">1</span>) * codeX, codeY);            <span class="hljs-comment">// 将产生的四个随机数组合在一起。</span>            randomCode.append(strRand);        &#125;        <span class="hljs-comment">// 将四位数字的验证码保存到Session中。</span>        HttpSession session = request.getSession();        session.setAttribute(<span class="hljs-string">"validateCode"</span>, randomCode.toString());        <span class="hljs-comment">// 禁止图像缓存。</span>        response.setHeader(<span class="hljs-string">"Pragma"</span>, <span class="hljs-string">"no-cache"</span>);        response.setHeader(<span class="hljs-string">"Cache-Control"</span>, <span class="hljs-string">"no-cache"</span>);        response.setDateHeader(<span class="hljs-string">"Expires"</span>, <span class="hljs-number">0</span>);        response.setContentType(<span class="hljs-string">"image/jpeg"</span>);        <span class="hljs-comment">// 将图像输出到Servlet输出流中。</span>        ServletOutputStream sos = response.getOutputStream();        ImageIO.write(buffImg, <span class="hljs-string">"jpeg"</span>, sos);        sos.close();    &#125;  &#125;</code></pre></div><p>然后在 Application 中注入该 Servlet：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringSecurity04Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(SpringSecurity04Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">indexServletRegistration</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//利用ServletRegistrationBean接口来使用servlet功能</span>        ServletRegistrationBean registration = <span class="hljs-keyword">new</span> ServletRegistrationBean(<span class="hljs-keyword">new</span> VerifyServlet());        registration.addUrlMappings(<span class="hljs-string">"/getVerifyCode"</span>);        <span class="hljs-keyword">return</span> registration;    &#125;&#125;</code></pre></div><h4 id="1-2-修改-login-html"><a href="#1-2-修改-login-html" class="headerlink" title="1.2 修改 login.html"></a>1.2 修改 login.html</h4><p>在原本的 login 页面基础上加上验证码字段：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>登陆<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>登陆<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"verifyCode"</span> <span class="hljs-attr">required</span>=<span class="hljs-string">"required"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"验证码"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"getVerifyCode"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"看不清，请点我"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"refresh(this)"</span> <span class="hljs-attr">onmouseover</span>=<span class="hljs-string">"mouseover(this)"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"remember-me"</span>/&gt;</span>自动登录<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>立即登陆<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">refresh</span>(<span class="hljs-params">obj</span>) </span>&#123; obj.src = <span class="hljs-string">"getVerifyCode?"</span> + <span class="hljs-built_in">Math</span>.random(); &#125;</span><span class="actionscript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mouseover</span><span class="hljs-params">(obj)</span> </span>&#123; obj.style.cursor = <span class="hljs-string">"pointer"</span>; &#125;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="1-3-添加匿名访问-Url"><a href="#1-3-添加匿名访问-Url" class="headerlink" title="1.3 添加匿名访问 Url"></a>1.3 添加匿名访问 Url</h4><p>不要忘记在 WebSecurityConfig 中允许该 Url 的匿名访问，不然没有登录是没有办法访问该 Url 的：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">//设置拦截忽略文件夹，可以对静态资源访问</span>    web.ignoring().antMatchers(<span class="hljs-string">"/css/**"</span>,<span class="hljs-string">"/js/**"</span>,<span class="hljs-string">"/css/**"</span>,<span class="hljs-string">"/getVerifyCode"</span>);&#125;</code></pre></div><p>效果如下：</p><p><img src="D:%5C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%5CBlog%5CMyBlog%5Csource_posts%5Cimage-20200523174552543.png" srcset="/img/loading.gif" alt="效果"></p><p>下面才算是这篇文章真正的部分。我们如何才能实现验证码验证呢，思考一下，应该有以下几种实现方式：</p><ol><li>登录表单提交前发送 AJAX 验证验证码</li><li>使用自定义过滤器(Filter)，在 Spring security 校验前验证验证码合法性</li><li>和用户名、密码一起发送到后台，在 Spring security 中进行验证</li></ol><h3 id="二、AJAX-验证"><a href="#二、AJAX-验证" class="headerlink" title="二、AJAX 验证"></a>二、AJAX 验证</h3><p>使用 AJAX 方式验证和我们 Spring Security 框架就没有任何关系了，其实就是表单提交前先发个 HTTP 请求验证验证码，本篇不再赘述。</p><h3 id="三、过滤器验证"><a href="#三、过滤器验证" class="headerlink" title="三、过滤器验证"></a>三、过滤器验证</h3><p>使用过滤器的思路是：<strong>在Spring Security 处理登录验证请求前，验证验证码，如果正确，放行；如果不正确，跳到异常</strong>。</p><h4 id="3-1-编写验证码过滤器"><a href="#3-1-编写验证码过滤器" class="headerlink" title="3.1 编写验证码过滤器"></a>3.1 编写验证码过滤器</h4><p>自定义一个过滤器，实现 <code>OncePerRequestFilter</code> （该 Filter 保证每次请求一定会过滤），在 <code>isProtectedUrl()</code> 方法中拦截了 POST 方式的 /login 请求。</p><p>在逻辑处理中从 request 中取出验证码，并进行验证，如果验证成功，放行；验证失败，手动生成异常。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VerifyFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OncePerRequestFilter</span> </span>&#123;    <span class="hljs-comment">/**获取路径信息**/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> PathMatcher PATH_MATCHER = <span class="hljs-keyword">new</span> AntPathMatcher();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-comment">//如果是POST请求，并且请求路径是/login，就去进行验证码校验</span>        <span class="hljs-keyword">if</span>(isProtectedUrl(httpServletRequest))&#123;            String verifyCode = httpServletRequest.getParameter(<span class="hljs-string">"verifyCode"</span>);            <span class="hljs-comment">//如果验证码错误，就抛出异常，否则正常执行</span>            <span class="hljs-keyword">if</span>(!validateVerify(verifyCode))&#123;                <span class="hljs-comment">//手动设置异常</span>                httpServletRequest.setAttribute(<span class="hljs-string">"SPRING_SECURITY_LAST_EXCEPTION"</span>,<span class="hljs-keyword">new</span> DisabledException(<span class="hljs-string">"验证码输入错误"</span>));                <span class="hljs-comment">//转发到错误url</span>       httpServletRequest.getRequestDispatcher(<span class="hljs-string">"/login/error"</span>).forward(httpServletRequest,httpServletResponse);            &#125;<span class="hljs-keyword">else</span> &#123;                filterChain.doFilter(httpServletRequest,httpServletResponse);            &#125;        &#125;<span class="hljs-keyword">else</span> &#123;            filterChain.doFilter(httpServletRequest,httpServletResponse);        &#125;    &#125;    <span class="hljs-comment">/**校验验证码**/</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validateVerify</span><span class="hljs-params">(String verifyCode)</span> </span>&#123;        <span class="hljs-comment">//获取当前线程绑定的request对象</span>        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = requestAttributes.getRequest();        <span class="hljs-comment">//下面这个validateCode是在servlet中存入session的名字</span>        String validateCode = ((String) request.getSession().getAttribute(<span class="hljs-string">"validateCode"</span>)).toLowerCase();        verifyCode = verifyCode.toLowerCase();        System.out.println(<span class="hljs-string">"验证码："</span>+validateCode+<span class="hljs-string">"用户输入："</span>+verifyCode);        <span class="hljs-keyword">return</span> validateCode.equals(verifyCode);    &#125;    <span class="hljs-comment">/**拦截/login的POST请求**/</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isProtectedUrl</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"POST"</span>.equals(request.getMethod()) &amp;&amp; PATH_MATCHER.match(<span class="hljs-string">"/login"</span>,request.getServletPath());    &#125;&#125;</code></pre></div><h4 id="3-2-注入过滤器"><a href="#3-2-注入过滤器" class="headerlink" title="3.2 注入过滤器"></a>3.2 注入过滤器</h4><p>修改 WebSecurityConfig 的 configure 方法，添加一个 <code>addFilterBefore()</code> ，具有两个参数，作用是在参数二之前执行参数一设置的过滤器。</p><p>Spring Security 对于用户名/密码登录方式是通过 <code>UsernamePasswordAuthenticationFilter</code> 处理的，我们在它之前执行验证码过滤器即可。</p><div class="hljs"><pre><code class="hljs java">.addFilterBefore(<span class="hljs-keyword">new</span> VerifyFilter(), UsernamePasswordAuthenticationFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span></code></pre></div><p>测试效果不理想，不推荐这种方式。</p><h3 id="四、Spring-Security-验证"><a href="#四、Spring-Security-验证" class="headerlink" title="四、Spring Security 验证"></a>四、Spring Security 验证</h3><p>使用过滤器就已经实现了验证码功能，但其实它和 AJAX 验证差别不大。</p><ul><li>AJAX 是在提交前发一个请求，请求返回成功就提交，否则不提交；</li><li>过滤器是先验证验证码，验证成功就让 Spring Security 验证用户名和密码；验证失败，则产生异常·。</li></ul><p>如果我们要做的需求是用户登录是需要多个验证字段，不单单是用户名和密码，那么使用过滤器会让逻辑变得复杂，这时候可以考虑自定义 Spring Security 的验证逻辑了…</p><h4 id="4-1-WebAuthenticationDetails"><a href="#4-1-WebAuthenticationDetails" class="headerlink" title="4.1 WebAuthenticationDetails"></a>4.1 WebAuthenticationDetails</h4><p>我们知道 Spring security 默认只会处理用户名和密码信息。这时候就要请出我们的主角——<code>WebAuthenticationDetails</code>。</p><blockquote><p><code>WebAuthenticationDetails</code>: 该类提供了获取用户登录时携带的额外信息的功能，默认提供了 remoteAddress 与 sessionId 信息。</p></blockquote><p>我们需要实现自定义的 <code>WebAuthenticationDetails</code>，并在其中加入我们的验证码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomWebAuthenticationDetails</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebAuthenticationDetails</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">6975601077710753878L</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String verifyCode;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Records the remote address and will also set the session Id if a session already</span><span class="hljs-comment">     * exists (it won't create one).</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request that the authentication request was received from</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomWebAuthenticationDetails</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;        <span class="hljs-keyword">super</span>(request);        verifyCode = request.getParameter(<span class="hljs-string">"verifyCode"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getVerifyCode</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.verifyCode;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        sb.append(<span class="hljs-keyword">super</span>.toString()).append(<span class="hljs-string">";VerifiCode:"</span>).append(<span class="hljs-keyword">this</span>.verifyCode);        <span class="hljs-keyword">return</span> sb.toString();    &#125;&#125;</code></pre></div><p>在这个方法中，我们将前台form表单中的verifyCode获取到，并通过get方法方便调用。</p><h4 id="4-2-AuthenticationDetailsSource"><a href="#4-2-AuthenticationDetailsSource" class="headerlink" title="4.2 AuthenticationDetailsSource"></a>4.2 AuthenticationDetailsSource</h4><p>自定义了<code>WebAuthenticationDetails</code>，我i们还需要将其放入 <code>AuthenticationDetailsSource</code> 中来替换原本的 <code>WebAuthenticationDetails</code> ，因此还得实现自定义 <code>AuthenticationDetailsSource</code> ：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>(<span class="hljs-string">"authenticationDetailsSource"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationDetailsSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationDetailsSource</span>&lt;<span class="hljs-title">HttpServletRequest</span>, <span class="hljs-title">WebAuthenticationDetails</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> WebAuthenticationDetails <span class="hljs-title">buildDetails</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CustomWebAuthenticationDetails(request);    &#125;&#125;</code></pre></div><p>该类是将原本的 <code>WebAuthenticationDetails</code> 替换为了我们的 <code>CustomWebAuthenticationDetails</code>。</p><p>接下来我们只需将 <code>CustomAuthenticationDetailsSource</code> 注入Spring Security中，替换掉默认的 <code>AuthenticationDetailsSource</code>。</p><p>通过修改 <code>WebSecurityConfig</code>将其注入，然后在config()中使用 <code>authenticationDetailsSource(authenticationDetailsSource)</code>方法来指定它。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>  AuthenticationDetailsSource&lt;HttpServletRequest, WebAuthenticationDetails&gt; authenticationDetailsSource;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;      http.authorizeRequests()      ....省略   .authenticationDetailsSource(authenticationDetailsSource)</code></pre></div><h4 id="4-3-AuthenticationProvider"><a href="#4-3-AuthenticationProvider" class="headerlink" title="4.3 AuthenticationProvider"></a>4.3 AuthenticationProvider</h4><p>至此我们通过自定义 <code>WebAuthenticationDetails</code> 和 <code>AuthenticationDetailsSource</code> 将验证码和用户名、密码一起带入了 Spring Security 中，下面我们需要将它取出来。</p><p>这里需要我们自定义 <code>AuthenticationProvider</code>，需要注意的是，<strong>如果是我们自己实现 <code>AuthenticationProvider</code>，那么我们就需要自己做密码校验了。</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationProvider</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> CustomUserDetailsService customUserDetailsService;    <span class="hljs-comment">/**用来验证用户身份**/</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        <span class="hljs-comment">//1.获取用户的用户名和密码</span>        String inputName = authentication.getName();        String inputPassword = authentication.getCredentials().toString();        CustomWebAuthenticationDetails details = (CustomWebAuthenticationDetails) authentication.getDetails();        String verifyCode = details.getVerifyCode();        <span class="hljs-keyword">if</span>(!validateVerify(verifyCode))&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisabledException(<span class="hljs-string">"验证码输入错误"</span>);        &#125;        <span class="hljs-comment">// userDetails为数据库中查询到的用户信息</span>        UserDetails userDetails = customUserDetailsService.loadUserByUsername(inputName);        <span class="hljs-comment">// 如果是自定义AuthenticationProvider，需要手动密码校验</span>        <span class="hljs-keyword">if</span>(!userDetails.getPassword().equals(inputPassword) || !userDetails.getUsername().equals(inputName))&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">"用户名或密码错误"</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(inputName,inputPassword,userDetails.getAuthorities());    &#125;    <span class="hljs-comment">/**验证码核对**/</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validateVerify</span><span class="hljs-params">(String verifiCode)</span> </span>&#123;        <span class="hljs-comment">//获取当前线程绑定的request对象</span>        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = requestAttributes.getRequest();        String validateCode = ((String) request.getSession().getAttribute(<span class="hljs-string">"validateCode"</span>)).toLowerCase();        verifiCode = verifiCode.toLowerCase();        System.out.println(<span class="hljs-string">"验证码："</span>+validateCode+<span class="hljs-string">";用户输入："</span>+verifiCode);        <span class="hljs-keyword">return</span> validateCode.equals(verifiCode);    &#125;    <span class="hljs-comment">/**判断当前的AuthenticationProvider是否支持对应的Authentication**/</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; authentication)</span> </span>&#123;        <span class="hljs-keyword">return</span> (UsernamePasswordAuthenticationToken<span class="hljs-class">.<span class="hljs-keyword">class</span></span><span class="hljs-class">                .<span class="hljs-title">isAssignableFrom</span>(<span class="hljs-title">authentication</span>))</span>;    &#125;&#125;</code></pre></div><p>最后在 <code>WebSecurityConfig</code> 中将其注入，并在 config 方法中通过 <code>auth.authenticationProvider()</code> 指定使用。</p><div class="hljs"><pre><code class="hljs java"> <span class="hljs-meta">@Autowired</span> CustomAuthenticationProvider customAuthenticationProvider; <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;     auth.authenticationProvider(customAuthenticationProvider); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(3)--异常处理</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>思考：为何登录失败自动跳转到/login?error，而且没有异常提示？</p><p><img src="https://img-blog.csdnimg.cn/20200531223128165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3NzMzMg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>因为首先 <code>/login?error</code> 是 Spring security 默认的失败 Url，其次<strong>如果你不手动处理这个异常，这个异常是不会被处理的</strong>。</p><h2 id="一、常见异常"><a href="#一、常见异常" class="headerlink" title="一、常见异常"></a>一、常见异常</h2><p>我们先来列举下一些 Spring Security 中常见的异常：</p><ul><li><code>UsernameNotFoundException</code>（用户不存在）</li><li><code>DisabledException</code>（用户已被禁用）</li><li><code>BadCredentialsException</code>（坏的凭据）</li><li><code>LockedException</code>（账户锁定）</li><li><code>AccountExpiredException</code> （账户过期）</li><li><code>CredentialsExpiredException</code>（证书过期）</li><li>…</li></ul><p>以上列出的这些异常都是 <code>AuthenticationException</code> 的子类，然后我们来看看 Spring security 如何处理 <code>AuthenticationException</code> 异常的。</p><h2 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h2><p>我们知道异常一般在过滤器中处理，在 <code>AbstractAuthenticationProcessingFilter</code> 中我们找到了对 <code>AuthenticationException</code> 的处理：</p><div class="hljs"><pre><code class="hljs jAVA">org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter#doFilter    <span class="hljs-keyword">try</span> &#123;authResult = attemptAuthentication(request, response);<span class="hljs-comment">//1.认证</span><span class="hljs-keyword">if</span> (authResult == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span>;&#125;sessionStrategy.onAuthentication(authResult, request, response); <span class="hljs-comment">//2.并发问题</span>&#125;<span class="hljs-keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;logger.error(<span class="hljs-string">"An internal error occurred while trying to authenticate the user."</span>,failed);unsuccessfulAuthentication(request, response, failed);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">catch</span> (AuthenticationException failed) &#123;unsuccessfulAuthentication(request, response, failed);<span class="hljs-comment">//3.认证失败</span><span class="hljs-keyword">return</span>;&#125;</code></pre></div><p>(1)，先是调用attemptAuthentication（）方法对请求参数进行提取</p><div class="hljs"><pre><code class="hljs java">org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter#attemptAuthentication<span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;<span class="hljs-keyword">if</span> (postOnly &amp;&amp; !request.getMethod().equals(<span class="hljs-string">"POST"</span>)) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">"Authentication method not supported: "</span> + request.getMethod());&#125;String username = obtainUsername(request);String password = obtainPassword(request);<span class="hljs-keyword">if</span> (username == <span class="hljs-keyword">null</span>) &#123;username = <span class="hljs-string">""</span>;&#125;<span class="hljs-keyword">if</span> (password == <span class="hljs-keyword">null</span>) &#123;password = <span class="hljs-string">""</span>;&#125;username = username.trim();UsernamePasswordAuthenticationToken authRequest = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(username, password);<span class="hljs-comment">// 设置“details”属性</span>setDetails(request, authRequest);<span class="hljs-comment">//认证</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);&#125;</code></pre></div><p>我们来看看<code>setDetails(request,authRequest)</code>做了些什么：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDetails</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">UsernamePasswordAuthenticationToken authRequest)</span> </span>&#123;authRequest.setDetails(authenticationDetailsSource.buildDetails(request));&#125;</code></pre></div><p>UsernamePasswordAuthenticationToken是Authentication的具体实现，所以这里实际上就是在设置details，至于details的值，则是通过authenticationDetailsSource来构建：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebAuthenticationDetailsSource</span> <span class="hljs-keyword">implements</span></span><span class="hljs-class"><span class="hljs-title">AuthenticationDetailsSource</span>&lt;<span class="hljs-title">HttpServletRequest</span>, <span class="hljs-title">WebAuthenticationDetails</span>&gt; </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> WebAuthenticationDetails <span class="hljs-title">buildDetails</span><span class="hljs-params">(HttpServletRequest context)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WebAuthenticationDetails(context);&#125;&#125;</code></pre></div><p>这里我们也就知道<code>buildDetails</code>方法返回的其实是一个<code>WebAuthenticationDetails</code>对象，而<code>WebAuthenticationDetails</code>对象默认有哪些属性呢？</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WebAuthenticationDetails</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<span class="hljs-keyword">this</span>.remoteAddress = request.getRemoteAddr();HttpSession session = request.getSession(<span class="hljs-keyword">false</span>);<span class="hljs-keyword">this</span>.sessionId = (session != <span class="hljs-keyword">null</span>) ? session.getId() : <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p>如果我们想保存更多关于Http请求的信息，可以通过自定义<code>WebAuthenticationDetails</code>来实现，同时<code>WebAuthenticationDetailsSource</code>也要一起重新定义。</p><p>接下来进入到<code>org.springframework.security.authentication.ProviderManager#authenticate</code>方法中：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;Class&lt;? extends Authentication&gt; toTest = authentication.getClass();AuthenticationException lastException = <span class="hljs-keyword">null</span>;AuthenticationException parentException = <span class="hljs-keyword">null</span>;Authentication result = <span class="hljs-keyword">null</span>;Authentication parentResult = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">boolean</span> debug = logger.isDebugEnabled();<span class="hljs-comment">//逐个遍历AuthenticationProvider，并调用他们的authenticate方法来做认证：</span><span class="hljs-keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;            <span class="hljs-comment">//首先要判断当前的AuthenticationProvider是否支持对应的Authentication</span><span class="hljs-keyword">if</span> (!provider.supports(toTest)) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (debug) &#123;logger.debug(<span class="hljs-string">"Authentication attempt using "</span>+ provider.getClass().getName());&#125;<span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//实际验证交给AuthenticationProvider来处理</span>result = provider.authenticate(authentication);<span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;copyDetails(authentication, result);<span class="hljs-keyword">break</span>;&#125;&#125;            <span class="hljs-comment">//如果验证过程中有异常，就会被捕获</span><span class="hljs-keyword">catch</span> (AccountStatusException | InternalAuthenticationServiceException e) &#123;prepareException(e, authentication);<span class="hljs-keyword">throw</span> e;&#125; <span class="hljs-keyword">catch</span> (AuthenticationException e) &#123;lastException = e;&#125;&#125;</code></pre></div><p>（2），调用 <code>attemptAuthentication</code>方法走完认证流程之后，回来之后，接下来就是调用 <code>sessionStrategy.onAuthentication</code>方法，这个方法就是用来处理 <code>session</code>的并发问题：</p><div class="hljs"><pre><code class="hljs java">org.springframework.security.web.authentication.session.ConcurrentSessionControlAuthenticationStrategy#onAuthentication<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthentication</span><span class="hljs-params">(Authentication authentication,</span></span><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<span class="hljs-comment">//1.获取当前用户的所有 session，该方法在调用时，传递两个参数，一个是当前用户的 authentication，</span><span class="hljs-comment">//另一个参数 false 表示不包含已经过期的 session（在用户登录成功后，会将用户的 sessionid 存起来，</span><span class="hljs-comment">//其中 key 是用户的主体（principal），value 则是该主体对应的 sessionid 组成的一个集合）。</span><span class="hljs-keyword">final</span> List&lt;SessionInformation&gt; sessions = sessionRegistry.getAllSessions(authentication.getPrincipal(), <span class="hljs-keyword">false</span>);<span class="hljs-comment">//接下来计算出当前用户已经有几个有效 session 了，同时获取允许的 session 并发数。</span><span class="hljs-keyword">int</span> sessionCount = sessions.size();<span class="hljs-keyword">int</span> allowedSessions = getMaximumSessionsForThisUser(authentication);<span class="hljs-comment">//如果当前 session 数（sessionCount）小于 session 并发数（allowedSessions），则不做任何处理</span><span class="hljs-keyword">if</span> (sessionCount &lt; allowedSessions) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//如果 allowedSessions 的值为 -1，表示对 session 数量不做任何限制。</span><span class="hljs-keyword">if</span> (allowedSessions == -<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (sessionCount == allowedSessions) &#123;HttpSession session = request.getSession(<span class="hljs-keyword">false</span>);<span class="hljs-keyword">if</span> (session != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 只有当这个请求与一个已经注册的会话相同时才允许它</span><span class="hljs-keyword">for</span> (SessionInformation si : sessions) &#123;<span class="hljs-keyword">if</span> (si.getSessionId().equals(session.getId())) &#123;<span class="hljs-keyword">return</span>;&#125;&#125;&#125;&#125;<span class="hljs-comment">//首先会有 exceptionIfMaximumExceeded 属性，这就是我们在 SecurityConfig 中配置的 maxSessionsPreventsLogin 的值，默认为 false，如果为 true，就直接抛出异常，禁止新的登录（参照微信），如果为 false，则对 sessions 按照请求时间进行排序，然后再使多余的 session 过期即可（参照QQ）。</span>allowableSessionsExceeded(sessions, allowedSessions, sessionRegistry);&#125;</code></pre></div><p>配置文件如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-comment">//1</span><span class="hljs-function">HttpSessionEventPub1isher <span class="hljs-title">httpSessionEventPub1isher</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HttpSessionEventPub1isher();&#125;<span class="hljs-comment">//关闭CRSF跨域</span>        http.csrf()                .disable()                .sessionManagement()                .maximumSessions(<span class="hljs-number">1</span>)                .maxSessionsPreventsLogin(<span class="hljs-keyword">true</span>);</code></pre></div><p>为什么要加这个Bean呢？因为在Spring Security中，它是通过监听session的销毁事件来及时清理session的记录的，用户从不同的浏览器登录后，都会有对应的session，当用户注销登录之后，session就会失效，但是默认的失效是通过调用<code>StandardSession#invalidate</code>方法来实现的，这一失效事件无法被Spring容器感知到，进而导致当用户注销登录之后，Spring Security没有及时清理会话信息表，以为用户还在线，进而导致用户无法重新登录进来。</p><p>为了解决这一问题，我们提供了一个HttpSessionEventPublisher，这个类实现了httpSessionListener接口，在该Bean中，可以将session创建以及销毁的事件及时感知到，并且调用Sprign中的事件机制将相关的创建和销毁事件发布出去，进而被Spring Security感知到。</p><p>(3)，当用户登录失败时，被异常捕获，转到 <code>unsuccessfulAuthentication()</code> 方法中，然后转交给了 <code>SimpleUrlAuthenticationFailureHandler</code> 类的 <code>onAuthenticationFailure()</code> 处理。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unsuccessfulAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;    SecurityContextHolder.clearContext();    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logger.isDebugEnabled()) &#123;        <span class="hljs-keyword">this</span>.logger.debug(<span class="hljs-string">"Authentication request failed: "</span> + failed.toString(), failed);        <span class="hljs-keyword">this</span>.logger.debug(<span class="hljs-string">"Updated SecurityContextHolder to contain null Authentication"</span>);        <span class="hljs-keyword">this</span>.logger.debug(<span class="hljs-string">"Delegating to authentication failure handler "</span> + <span class="hljs-keyword">this</span>.failureHandler);    &#125;    <span class="hljs-keyword">this</span>.rememberMeServices.loginFail(request, response);    <span class="hljs-keyword">this</span>.failureHandler.onAuthenticationFailure(request, response, failed);&#125;</code></pre></div><p>在 <code>onAuthenticationFailure()</code> 中，首先判断有没有设置 <code>defaultFailureUrl</code>。</p><ul><li>如果没有设置，直接返回 401 错误，即 <code>HttpStatus.UNAUTHORIZED</code> 的值。</li><li>如果设置了，首先执行 <code>saveException()</code> 方法。然后判断 <code>forwardToDestination</code> ，即是否是服务器跳转，默认使用重定向即客户端跳转。</li></ul><div class="hljs"><pre><code class="hljs java">org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler#onAuthenticationFailure<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">      HttpServletResponse response, AuthenticationException exception)</span></span><span class="hljs-function">      <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;       <span class="hljs-keyword">if</span> (defaultFailureUrl == <span class="hljs-keyword">null</span>) &#123;      logger.debug(<span class="hljs-string">"No failure URL set, sending 401 Unauthorized error"</span>);      response.sendError(HttpStatus.UNAUTHORIZED.value(),         HttpStatus.UNAUTHORIZED.getReasonPhrase());   &#125;   <span class="hljs-keyword">else</span> &#123;      saveException(request, exception);<span class="hljs-comment">//判断是转发还是重定向</span>  <span class="hljs-comment">//直接转发</span>      <span class="hljs-keyword">if</span> (forwardToDestination) &#123;         logger.debug(<span class="hljs-string">"Forwarding to "</span> + defaultFailureUrl);         request.getRequestDispatcher(defaultFailureUrl)               .forward(request, response);      &#125;      <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//重定向</span>         logger.debug(<span class="hljs-string">"Redirecting to "</span> + defaultFailureUrl);         redirectStrategy.sendRedirect(request, response, defaultFailureUrl);      &#125;   &#125;&#125;</code></pre></div><p>来到<code>org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler#saveException</code>方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveException</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">AuthenticationException exception)</span> </span>&#123;<span class="hljs-keyword">if</span> (forwardToDestination) &#123;request.setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION, exception);&#125;<span class="hljs-keyword">else</span> &#123;HttpSession session = request.getSession(<span class="hljs-keyword">false</span>);<span class="hljs-keyword">if</span> (session != <span class="hljs-keyword">null</span> || allowSessionCreation) &#123;request.getSession().setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION,exception);&#125;&#125;&#125;</code></pre></div><p>在 <code>saveException()</code> 方法中，首先判断<code>forwardToDestination</code>，如果使用服务器跳转则写入 Request，客户端跳转则写入 Session。写入名为 <code>SPRING_SECURITY_LAST_EXCEPTION</code> ，值为 <code>AuthenticationException</code>。</p><p>至此 Spring security 完成了异常处理，总结一下流程：</p><p>–&gt; AbstractAuthenticationProcessingFilter<code>.doFilter()</code></p><p>–&gt; AbstractAuthenticationProcessingFilter.<code>unsuccessfulAuthentication()</code></p><p>–&gt; SimpleUrlAuthenticationFailureHandler.<code>onAuthenticationFailure()</code></p><p>–&gt; SimpleUrlAuthenticationFailureHandler.<code>saveException()</code></p><h2 id="三、处理异常"><a href="#三、处理异常" class="headerlink" title="三、处理异常"></a>三、处理异常</h2><p>上面源码说了那么多，真正处理起来很简单，我们只需要指定错误的url，然后再该方法中对异常进行处理即可。</p><p>（1）指定错误url，<code>WebSecurityConfig</code> 中添加 <code>.failureUrl(&quot;/login/error&quot;)</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http.authorizeRequests()            .anyRequest().authenticated()            .and()            .formLogin().loginPage(<span class="hljs-string">"/login"</span>)            <span class="hljs-comment">//登录失败url</span>            .failureUrl(<span class="hljs-string">"/login/error"</span>)            <span class="hljs-comment">//登录成功url</span>            .defaultSuccessUrl(<span class="hljs-string">"/"</span>).permitAll()</code></pre></div><p>（2）在 Controller 中处理异常</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/login/error"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loginError</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;    response.setContentType(<span class="hljs-string">"text/html;charset=utf-8"</span>);    AuthenticationException exception =            (AuthenticationException)request.getSession().getAttribute(<span class="hljs-string">"SPRING_SECURITY_LAST_EXCEPTION"</span>);    <span class="hljs-keyword">try</span> &#123;        response.getWriter().write(exception.toString());    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre></div><p>我们首先获取了 session 中的 <code>SPRING_SECURITY_LAST_EXCEPTION</code> 。为了演示，我只是简单的将错误信息返回给了页面。运行程序，当我们输入错误密码时：</p><p><img src="https://img-blog.csdnimg.cn/20200531223348529.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>来到我们自己设置的错误页面，显示我们设置的错误信息。</p>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(2)--自动登录</title>
    <link href="/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-2-%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95/"/>
    <url>/2020/05/30/SpringBoot%E9%9B%86%E6%88%90Spring-Security-2-%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一、修改-login-html"><a href="#一、修改-login-html" class="headerlink" title="一、修改 login.html"></a>一、修改 login.html</h2><p>在登录页添加自动登录的选项，注意自动登录字段的 name 属性必须是 <code>remember-me</code> ：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>欢迎来到登录页面<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"remember-me"</span>&gt;</span>记住我<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>立即登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="二、两种实现方式"><a href="#二、两种实现方式" class="headerlink" title="二、两种实现方式"></a>二、两种实现方式</h2><h3 id="2-1-Cookie-存储"><a href="#2-1-Cookie-存储" class="headerlink" title="2.1 Cookie 存储"></a>2.1 Cookie 存储</h3><p>这种方式十分简单，只要在 WebSecurityConfig 中的 configure() 方法添加一个 <code>rememberMe()</code> 即可,如下所示：</p><div class="hljs"><pre><code class="hljs java"> http.authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span><span class="hljs-comment">//                .antMatchers().permitAll()</span>                .anyRequest().authenticated()                .and()                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                .defaultSuccessUrl(<span class="hljs-string">"/"</span>).permitAll()                <span class="hljs-comment">// 自定义登录用户名和密码参数，默认为username和password</span><span class="hljs-comment">//                .usernameParameter("username")</span><span class="hljs-comment">//                .passwordParameter("password")</span>                .and()                <span class="hljs-comment">// 开启自动登录</span>                .rememberMe()                .and()                .logout()                .permitAll();        <span class="hljs-comment">//关闭CRSF跨域</span>        http.csrf().disable();    &#125;</code></pre></div><p>当我们登录时勾选自动登录时，会自动在 Cookie 中保存一个名为 <code>remember-me</code> 的cookie，默认有效期为2周，其值是一个加密字符串：</p><p><img src="https://www.jitwxs.cn/images/posts/20180509100451811.png" srcset="/img/loading.gif" alt="基于缓存的自动登录"></p><h3 id="2-2-数据库存储"><a href="#2-2-数据库存储" class="headerlink" title="2.2 数据库存储"></a>2.2 数据库存储</h3><p>使用 Cookie 存储虽然很方便，但是大家都知道 Cookie 毕竟是保存在客户端的，而且 Cookie 的值还与用户名、密码这些敏感数据相关，虽然加密了，但是将敏感信息存在客户端，毕竟不太安全。</p><p>Spring security 还提供了另一种相对更安全的实现机制：<strong>在客户端的 Cookie 中，仅保存一个无意义的加密串（与用户名、密码等敏感数据无关），然后在数据库中保存该加密串-用户信息的对应关系，自动登录时，用 Cookie 中的加密串，到数据库中验证，如果通过，自动登录才算通过。</strong></p><h4 id="2-2-1-基本原理"><a href="#2-2-1-基本原理" class="headerlink" title="2.2.1 基本原理"></a>2.2.1 基本原理</h4><p>当浏览器发起表单登录请求时，当通过 <code>UsernamePasswordAuthenticationFilter</code> 认证成功后，会经过 <code>RememberMeService</code>，在其中有个 <code>TokenRepository</code>，它会生成一个 token，首先将 token 写入到浏览器的 Cookie 中，然后将 token、认证成功的用户名写入到数据库中。</p><p>当浏览器下次请求时，会经过 <code>RememberMeAuthenticationFilter</code>，它会读取 Cookie 中的 token，交给 RememberMeService 从数据库中查询记录。如果存在记录，会读取用户名并去调用 <code>UserDetailsService</code>，获取用户信息，并将用户信息放入Spring Security 中，实现自动登录。</p><p><img src="https://www.jitwxs.cn/images/posts/20181202143630639.png" srcset="/img/loading.gif" alt="实现原理"></p><p>RememberMeAuthenticationFilter 在整个过滤器链中是比较靠后的位置，也就是说在传统登录方式都无法登录的情况下才会使用自动登录。</p><p><img src="https://www.jitwxs.cn/images/posts/20181202144420871.png" srcset="/img/loading.gif" alt="spring security过滤器链"></p><h4 id="2-2-2-代码实现"><a href="#2-2-2-代码实现" class="headerlink" title="2.2.2 代码实现"></a>2.2.2 代码实现</h4><p>首先需要创建一张表来存储 token 信息：</p><div class="hljs"><pre><code class="hljs SQL"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`persistent_logins`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`persistent_logins`</span>(<span class="hljs-string">`username`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<span class="hljs-string">`series`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    <span class="hljs-string">`token`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    <span class="hljs-string">`last_used`</span> <span class="hljs-built_in">timestamp</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span>,    PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`series`</span>))<span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4;</code></pre></div><p>在 WebSecurityConfig 中注入 <code>dataSource</code> ，创建一个 <code>PersistentTokenRepository</code> 的Bean：</p><div class="hljs"><pre><code class="hljs java">    <span class="hljs-meta">@Autowired</span>    DataSource dataSource;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersistentTokenRepository <span class="hljs-title">persistentTokenRepository</span><span class="hljs-params">()</span></span>&#123;        JdbcTokenRepositoryImpl tokenRepository = <span class="hljs-keyword">new</span> JdbcTokenRepositoryImpl();        tokenRepository.setDataSource(dataSource);                <span class="hljs-comment">//如果token表不存在，使用下面语句可以初始化该表，若存在，则需要注释掉这条语句，否则会报错</span><span class="hljs-comment">//        tokenRepository.setCreateTableOnStartup(true);</span>        <span class="hljs-keyword">return</span> tokenRepository;    &#125;</code></pre></div><p>在 <code>configure()</code> 中按如下所示配置自动登录：</p><div class="hljs"><pre><code class="hljs java"> <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span><span class="hljs-comment">//                .antMatchers().permitAll()</span>                .anyRequest().authenticated()                .and()                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                .defaultSuccessUrl(<span class="hljs-string">"/"</span>).permitAll()                .and()                <span class="hljs-comment">// 开启自动登录</span>                .rememberMe()                .tokenRepository(persistentTokenRepository())                <span class="hljs-comment">//有效时间(单位；s)</span>                .tokenValiditySeconds(<span class="hljs-number">60</span>)                .userDetailsService(userDetailsService)                .and()                .logout()                .permitAll();        <span class="hljs-comment">//关闭CRSF跨域</span>        http.csrf().disable();    &#125;</code></pre></div><h2 id="三、运行程序"><a href="#三、运行程序" class="headerlink" title="三、运行程序"></a>三、运行程序</h2><p>勾选自动登录后，Cookie 和数据库中均存储了 token 信息：</p><p><img src="https://www.jitwxs.cn/images/posts/20180509102031410.png" srcset="/img/loading.gif" alt="效果"></p>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Spring Security(1)--基础入门</title>
    <link href="/2020/05/29/SpringBoot%E9%9B%86%E6%88%90Spring-Security-1-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <url>/2020/05/29/SpringBoot%E9%9B%86%E6%88%90Spring-Security-1-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一、导入依赖"><a href="#一、导入依赖" class="headerlink" title="一、导入依赖"></a>一、导入依赖</h1><p>导入 <code>spring-boot-starter-security</code> 依赖，在 SpringBoot 2.0 环境下默认使用的是 5.0 版本。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-comment">&lt;!--注意，这里必须要指定版本，MySQL5用的驱动url是com.mysql.jdbc.Driver，</span><span class="hljs-comment">      MySQL6以后用的是com.mysql.cj.jdbc.Driver。版本不匹配便会报驱动类已过时的错误。--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.15<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h1 id="二、创建数据库"><a href="#二、创建数据库" class="headerlink" title="二、创建数据库"></a>二、创建数据库</h1><p>一般权限控制有三层，即：<code>用户</code>&lt;–&gt;<code>角色</code>&lt;–&gt;<code>权限</code>，用户与角色是多对多，角色和权限也是多对多。这里我们先暂时不考虑权限，只考虑<code>用户</code>&lt;–&gt;<code>角色</code>。</p><div class="hljs"><pre><code class="hljs mysql">-- 创建用户表 sys_user： --DROP TABLE IF EXISTS &#96;sys_user&#96;;CREATE TABLE &#96;sys_user&#96;(&#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,&#96;name&#96; varchar(255) NOT NULL,&#96;password&#96; varchar(255) NOT NULL,    PRIMARY KEY (&#96;id&#96;))ENGINE&#x3D;InnoDB DEFAULT CHARSET &#x3D; utf8;-- 创建权限表 sys_role： --DROP TABLE IF EXISTS &#96;sys_role&#96;;CREATE TABLE &#96;sys_role&#96;(&#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,    &#96;name&#96; varchar(255) NOT NULL,    PRIMARY KEY (&#96;id&#96;))ENGINE&#x3D;InnoDB DEFAULT CHARSET &#x3D; utf8;-- 创建用户-角色表 sys_user_role：（外键这里有点困惑，先标记下） --DROP TABLE IF EXISTS &#96;sys_user_role&#96;;CREATE TABLE &#96;sys_user_role&#96;(&#96;user_id&#96; int(11) NOT NULL ,    &#96;role_id&#96; int(11) NOT NULL,    PRIMARY KEY (&#96;user_id&#96;,&#96;role_id&#96;),    KEY &#96;fk_role_id&#96; (&#96;role_id&#96;),    CONSTRAINT &#96;fk_role_id&#96; FOREIGN KEY (&#96;role_id&#96;) REFERENCES &#96;sys_role&#96; (&#96;id&#96;) ON DELETE CASCADE ON UPDATE CASCADE,    CONSTRAINT &#96;fk_user_id&#96; FOREIGN KEY (&#96;user_id&#96;) REFERENCES &#96;sys_user&#96; (&#96;id&#96;) ON DELETE CASCADE ON UPDATE CASCADE)ENGINE&#x3D;InnoDB DEFAULT CHARSET &#x3D; utf8;-- 添加数据：（注意：传值的时候里面是单引号，如：&#39;1&#39;） --INSERT INTO &#96;sys_role&#96; VALUES (&#39;1&#39;, &#39;ROLE_ADMIN&#39;);INSERT INTO &#96;sys_role&#96; VALUES (&#39;2&#39;, &#39;ROLE_USER&#39;);INSERT INTO &#96;sys_user&#96; VALUES (&#39;1&#39;, &#39;admin&#39;, &#39;123&#39;);INSERT INTO &#96;sys_user&#96; VALUES (&#39;2&#39;, &#39;jitwxs&#39;, &#39;123&#39;);INSERT INTO &#96;sys_user_role&#96; VALUES (&#39;1&#39;, &#39;1&#39;);INSERT INTO &#96;sys_user_role&#96; VALUES (&#39;2&#39;, &#39;2&#39;);</code></pre></div><p>注意：权限格式为 <code>ROLE_XXX</code>，是 Spring Security 的规定。</p><h1 id="三、准备页面"><a href="#三、准备页面" class="headerlink" title="三、准备页面"></a>三、准备页面</h1><p>因为是示例程序，页面越简单越好，只用于登录的 <code>login.html</code> 以及用于登录成功后的 <code>home.html</code>，将其放置在 <code>resources/static</code> 目录下：</p><p>(1)login.html</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>欢迎来到登录页面<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>立即登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>注意：用户的登录认证是由 Spring Security 进行处理的，请求路径默认为 <code>/login</code>，用户名字段默认为 <code>username</code>，密码字段默认为 <code>password</code> 。</p><p>(2)home.html</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>欢迎回家<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>登录成功<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/admin"</span>&gt;</span>检测是否具有ROLE_ADMIN角色<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/user"</span>&gt;</span>检测是否具有ROLE_USER角色<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"window.location.href='/logout'"</span>&gt;</span>退出登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h1 id="四、配置-application-properties"><a href="#四、配置-application-properties" class="headerlink" title="四、配置 application.properties"></a>四、配置 application.properties</h1><p>在配置文件中配置下数据库连接：</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">root</span><span class="hljs-comment">#JDBC连接MySQL6 （com.mysql.cj.jdbc.Driver）， 需要指定时区serverTimezone，否则会报错</span><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/spring_security?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><span class="hljs-meta">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><span class="hljs-comment">#开启下划线转驼峰命令法</span><span class="hljs-meta">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="hljs-string">true</span></code></pre></div><h1 id="五、创建Model实体、Mapper、Service-和-Controller"><a href="#五、创建Model实体、Mapper、Service-和-Controller" class="headerlink" title="五、创建Model实体、Mapper、Service 和 Controller"></a>五、创建Model实体、Mapper、Service 和 Controller</h1><h2 id="5-1-Model"><a href="#5-1-Model" class="headerlink" title="5.1 Model"></a>5.1 Model</h2><p>(1)SysUser</p><div class="hljs"><pre><code class="hljs java">com.gavin.springsecuriity01.Model.SysUser    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysUser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-comment">//这里必须是name，与数据库对应，否则运行会报错</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-comment">// 省略getter/setter</span>&#125;</code></pre></div><p>(2)SysRole</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysRole</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-comment">// 省略getter/setter</span>&#125;</code></pre></div><p>(3)SysUserRole</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysUserRole</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-keyword">private</span> Integer userId;    <span class="hljs-keyword">private</span> Integer roleId;        <span class="hljs-comment">// 省略getter/setter</span>&#125;</code></pre></div><h2 id="5-2-Mapper"><a href="#5-2-Mapper" class="headerlink" title="5.2 Mapper"></a>5.2 Mapper</h2><p>(1)SysUserMapper</p><div class="hljs"><pre><code class="hljs java">com.gavin.springsecuriity01.Mapper.SysUserMapper<span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysUserMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_user WHERE id = #&#123;id&#125;"</span>)    <span class="hljs-function">SysUser <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_user WHERE name = #&#123;name&#125;"</span>)    <span class="hljs-function">SysUser <span class="hljs-title">selectByName</span><span class="hljs-params">(String name)</span></span>;&#125;</code></pre></div><p>(2)SysRoleMapper</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysRoleMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_role WHERE id = #&#123;id&#125;"</span>)    <span class="hljs-function">SysRole <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>;&#125;</code></pre></div><p>(3)SysUserRoleMapper</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysUserRoleMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM sys_user_role WHERE user_id = #&#123;id&#125;"</span>)    <span class="hljs-function">List&lt;SysUserRole&gt; <span class="hljs-title">listByUserId</span><span class="hljs-params">(Integer userId)</span></span>; &#125;</code></pre></div><h2 id="5-3-Service"><a href="#5-3-Service" class="headerlink" title="5.3 Service"></a>5.3 Service</h2><p>(1)SysUserService</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysUserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysUserMapper sysUserMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> SysUser <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>&#123;        <span class="hljs-keyword">return</span> sysUserMapper.selectById(id);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> SysUser <span class="hljs-title">selectByName</span><span class="hljs-params">(String name)</span></span>&#123;        <span class="hljs-keyword">return</span> sysUserMapper.selectByName(name);    &#125;&#125;</code></pre></div><p>(2)SysRoleService</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysRoleService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysRoleMapper sysRoleMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> SysRole <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>&#123;        <span class="hljs-keyword">return</span> sysRoleMapper.selectById(id);    &#125;&#125;</code></pre></div><p>(3)SysUserRoleService</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysUserRoleService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysUserRoleMapper sysUserRoleMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;SysUserRole&gt; <span class="hljs-title">listByUserId</span><span class="hljs-params">(Integer userId)</span></span>&#123;        <span class="hljs-keyword">return</span> sysUserRoleMapper.listByUserId(userId);    &#125;&#125;</code></pre></div><h2 id="5-4-Controller"><a href="#5-4-Controller" class="headerlink" title="5.4 Controller"></a>5.4 Controller</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(LoginController<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">showHome</span><span class="hljs-params">()</span></span>&#123;        String name = SecurityContextHolder.getContext().getAuthentication().getName();        logger.info(<span class="hljs-string">"当前登录用户："</span>+name);        <span class="hljs-keyword">return</span> <span class="hljs-string">"home.html"</span>;    &#125;        <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/login"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">showLogin</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"login.html"</span>;    &#125;        <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/admin"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasRole('ROLE_ADMIN')"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">printAdmin</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"如果你看见这句话，说明你有ROLE_ADMIN角色"</span>;    &#125;        <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasRole('ROLE_USER')"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">printUser</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"如果你看见这句话，说明你有ROLE_USER角色"</span>;    &#125;&#125;</code></pre></div><ul><li>如代码所示，获取当前登录用户：<code>SecurityContextHolder.getContext().getAuthentication()</code></li><li><code>@PreAuthorize</code> 用于判断用户是否有指定权限，没有就不能访问</li></ul><h1 id="六、配置-SpringSecurity"><a href="#六、配置-SpringSecurity" class="headerlink" title="六、配置 SpringSecurity"></a>六、配置 SpringSecurity</h1><h2 id="6-1-UserDetailsService"><a href="#6-1-UserDetailsService" class="headerlink" title="6.1 UserDetailsService"></a>6.1 UserDetailsService</h2><p>首先我们需要自定义 <code>UserDetailsService</code> ，将用户信息和权限注入进来。</p><p>我们需要重写 <code>loadUserByUsername</code> 方法，参数是用户输入的用户名。返回值是<code>UserDetails</code>，这是一个接口，一般使用它的子类<code>org.springframework.security.core.userdetails.User</code>，它有三个参数，分别是用户名、密码和权限集。</p><blockquote><p>实际情况下，大多将 DAO 中的 User 类继承 <code>org.springframework.security.core.userdetails.User</code> 返回。</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>(<span class="hljs-string">"userDetailsService"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomUserDetailsService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysUserService sysUserService;        <span class="hljs-meta">@Autowired</span>    SysRoleService sysRoleService;        <span class="hljs-meta">@Autowired</span>    SysUserRoleService sysUserRoleService;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;        Collection&lt;GrantedAuthority&gt; authorities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();                <span class="hljs-comment">//从数据库中取出用户信息</span>        SysUser user = sysUserService.selectByName(username);                <span class="hljs-comment">//判断用户是否存在</span>        <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">"用户名不存在！！"</span>);        &#125;                <span class="hljs-comment">//如果用户存在，就添加权限给他</span>        List&lt;SysUserRole&gt; userRoles = sysUserRoleService.listByUserId(user.getId());        <span class="hljs-keyword">for</span>(SysUserRole userRole:userRoles)&#123;            SysRole role = sysRoleService.selectById(userRole.getRoleId());            authorities.add(<span class="hljs-keyword">new</span> SimpleGrantedAuthority(role.getName()));        &#125;        <span class="hljs-comment">//返回UserDetails的实现类</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(user.getName(),user.getPassword(),authorities);    &#125;&#125;</code></pre></div><h1 id="6-2-WebSecurityConfig"><a href="#6-2-WebSecurityConfig" class="headerlink" title="6.2 WebSecurityConfig"></a>6.2 WebSecurityConfig</h1><p>该类是 Spring Security 的配置类，该类的三个注解分别是标识该类是配置类、开启 Security 服务、开启全局 Securtiy 注解。</p><p>首先将我们自定义的 <code>userDetailsService</code> 注入进来，在 <code>configure()</code> 方法中使用 <code>auth.userDetailsService()</code> 方法替换掉默认的 userDetailsService。</p><p>这里我们还指定了密码的加密方式（5.0 版本强制要求设置），因为我们数据库是明文存储的，所以明文返回即可，如下所示：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="hljs-keyword">true</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    CustomUserDetailsService userDetailsService;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth.userDetailsService(userDetailsService).passwordEncoder(<span class="hljs-keyword">new</span> PasswordEncoder() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">encode</span><span class="hljs-params">(CharSequence rawPassword)</span> </span>&#123;                <span class="hljs-keyword">return</span> rawPassword.toString();            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(CharSequence rawPassword, String encodedPassword)</span> </span>&#123;                <span class="hljs-keyword">return</span> encodedPassword.equals(rawPassword.toString());            &#125;        &#125;);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//设置拦截忽略文件夹，可以对静态资源访问</span>        web.ignoring().antMatchers(<span class="hljs-string">"/css/**"</span>,<span class="hljs-string">"/js/**"</span>,<span class="hljs-string">"/css/**"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                <span class="hljs-comment">// 如果有允许匿名的url，填在下面</span><span class="hljs-comment">//                .antMatchers().permitAll()</span>                .anyRequest().authenticated()                .and()                .formLogin().loginPage(<span class="hljs-string">"/login"</span>)                .defaultSuccessUrl(<span class="hljs-string">"/"</span>).permitAll()                <span class="hljs-comment">// 自定义登录用户名和密码参数，默认为username和password</span><span class="hljs-comment">//                .usernameParameter("username")</span><span class="hljs-comment">//                .passwordParameter("password")</span>                .and()                .logout().permitAll();        <span class="hljs-comment">//关闭CRSF跨域</span>        http.csrf().disable();    &#125;&#125;</code></pre></div><h1 id="七、运行程序"><a href="#七、运行程序" class="headerlink" title="七、运行程序"></a>七、运行程序</h1><blockquote><p>ROLE_ADMIN 账户：用户名 <strong>admin</strong>，密码 <strong>123</strong><br>ROLE_USER 账户：用户名 <strong>jitwxs</strong>，密码 <strong>123</strong></p></blockquote><p>注：本系列文章来源于<a href="https://www.jitwxs.cn/categories/安全框架/Spring-Security/" target="_blank" rel="noopener">https://www.jitwxs.cn/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/Spring-Security/</a></p>]]></content>
    
    
    <categories>
      
      <category>开发框架</category>
      
      <category>安全框架</category>
      
      <category>Spring Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
