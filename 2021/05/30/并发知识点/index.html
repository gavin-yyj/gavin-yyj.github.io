<!DOCTYPE html>
<html lang="zh-CH">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="光说不做假把式">
  <meta name="author" content="杨玉杰">
  <meta name="keywords" content="">
  <title>并发知识点 - 杨玉杰|个人博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/agate.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>杨玉杰|个人博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友情链接
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bgi.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2021-05-30 18:03">
      May 30, 2021 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      107
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="一、线程状态转换"><a href="#一、线程状态转换" class="headerlink" title="一、线程状态转换"></a>一、线程状态转换</h1><p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530180609.png" srcset="/img/loading.gif" alt="image-20210530180609150"></p>
<p><strong>新建（New）</strong></p>
<p>创建后尚未启动，等到线程的<code>start()</code>方法调用时，才表示线程开始执行。</p>
<p><strong>可运行（Runnable）</strong></p>
<p>表明线程所需要的一切资源都已经准备好了，但此时线程可能正在运行，也可能正在等待<code>CPU</code>时间片。</p>
<p>包含了操作系统线程状态中的 <code>Running</code>和<code>Ready</code>。</p>
<p><strong>阻塞（Blocked）</strong></p>
<p>等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</p>
<p><strong>无限期等待（Waiting）</strong></p>
<p>等待其它线程显式地唤醒，否则不会被分配<code>CPU</code>时间片。</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530180640.png" srcset="/img/loading.gif" alt="image-20210530180640413"></p>
<p><strong>限期等待（Timed_Waiting）</strong></p>
<p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p>
<p>调用<code>Thread.sleep()</code>方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。</p>
<p>调用 <code>Object.wait()</code>方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</p>
<p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p>
<p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，它们分别通过调用<code>Object.wait()</code>和<code>Thread.sleep()</code>等方法进入。</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530180711.png" srcset="/img/loading.gif" alt="image-20210530180710818"></p>
<p>通过<code>wait()</code>方法等待的线程在等待<code>notify()</code>方法，而通过<code>join()</code>方法等待的线程则会等待目标线程的终止。</p>
<p><strong>死亡（Terminated）</strong></p>
<p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p>
<p><strong>进程和线程之间的关系：</strong></p>
<ul>
<li><p>进程是系统进行资源分配和任务调度的基本单位，是操作系统结构的基础；</p>
</li>
<li><p>线程就是轻量级进程，是程序执行的最小单位。</p>
</li>
</ul>
<h1 id="二、使用线程"><a href="#二、使用线程" class="headerlink" title="二、使用线程"></a>二、使用线程</h1><p><strong>有三种使用线程的方法：</strong></p>
<ul>
<li>实现 Runnable 接口；</li>
<li>实现 Callable 接口；</li>
<li>继承 Thread 类。</li>
</ul>
<p>实现 <code>Runnable</code> 和 <code>Callable</code>接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过<code>Thread</code>来调用。可以说任务是通过线程驱动从而执行的。</p>
<p><strong>实现 Runnable 接口</strong></p>
<p>需要实现<code>run()</code> 方法。</p>
<p>通过<code>Thread</code> 调用 <code>start()</code>方法来启动线程。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// ...</span>
    &#125;
&#125;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    MyRunnable instance = <span class="hljs-keyword">new</span> MyRunnable();
    Thread thread = <span class="hljs-keyword">new</span> Thread(instance);
    thread.start();
&#125;</code></pre></div>

<p><strong>实现 Callable 接口</strong></p>
<p>与 <code>Runnable</code>相比，<code>Callable</code>可以有返回值，返回值通过 <code>FutureTask</code>进行封装。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;
    &#125;
&#125;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;
    MyCallable mc = <span class="hljs-keyword">new</span> MyCallable();
    FutureTask&lt;Integer&gt; ft = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(mc);
    Thread thread = <span class="hljs-keyword">new</span> Thread(ft);
    thread.start();
    System.out.println(ft.get());
&#125;</code></pre></div>

<p><strong>继承 Thread 类</strong></p>
<p>同样也是需要实现 <code>run()</code>方法，因为 <code>Thread</code>类也实现了<code>Runable</code>接口。</p>
<p>当调用<code>start()</code>方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的<code>run()</code>方法。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// ...</span>
    &#125;
&#125;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    MyThread mt = <span class="hljs-keyword">new</span> MyThread();
    mt.start();
&#125;</code></pre></div>

<p><strong>实现接口 VS 继承 Thread</strong></p>
<p><strong>实现接口会更好一些，因为：</strong></p>
<ul>
<li><code>Java</code> 不支持多重继承，因此继承了 <code>Thread</code>类就无法继承其它类，但是可以实现多个接口；</li>
<li>类可能只要求可执行就行，继承整个 <code>Thread</code>类开销过大。</li>
</ul>
<h1 id="三、基础线程机制"><a href="#三、基础线程机制" class="headerlink" title="三、基础线程机制"></a>三、基础线程机制</h1><p><strong>Daemon</strong></p>
<p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p>
<p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p>
<p>main() 属于非守护线程。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyRunnable());
    thread.setDaemon(<span class="hljs-keyword">true</span>);
&#125;</code></pre></div>

<p><strong>sleep()</strong></p>
<p><code>Thread.sleep(millisec)</code>方法会<strong>休眠</strong>当前正在执行的线程，<code>millisec</code>单位为毫秒。</p>
<p><code>sleep()</code>可能会抛出<code>InterruptedException</code>，因为异常不能跨线程传播回 <code>main()</code>中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">try</span> &#123;
        Thread.sleep(<span class="hljs-number">3000</span>);
    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
&#125;</code></pre></div>

<p><strong>yield()</strong> </p>
<p>对静态方法 <code>Thread.yield()</code> 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
  Thread.yield();
&#125;</code></pre></div>

<p><strong>sleep、yield、join、wait的比较</strong></p>
<ol>
<li><code>Thread.sleep(long millis)</code>，一定是当前线程调用此方法，当前线程进入阻塞，但不释放对象锁，millis后线程自动苏醒进入可运行状态。作用：给其它线程执行机会的最佳方式。</li>
<li><code>Thread.yield()</code>，一定是当前线程调用此方法，当前线程放弃获取的cpu时间片，由运行状态变会可运行状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。</li>
<li><code>t.join()/t.join(long millis)</code>，让调用该方法的线程在执行完<code>run()</code>方法后，再执行<code>join</code>方法后面的代码。具体而言，可以通过线程t的join()方法来等待线程t的结束，或者使用线程t的<code>join(millis)</code>方法来等待线程t的结束，但最多只等待2ms。</li>
<li><code>obj.wait()</code>，当前线程调用对象的<code>wait()</code>方法，当前线程释放对象锁，进入等待队列。依靠<code>notify()</code>/<code>notifyAll()</code>唤醒或者<code>wait(long timeout)</code>，<code>timeout</code>时间到自动唤醒。</li>
<li><code>obj.notify()</code>唤醒在此对象监视器上等待的单个线程，选择是任意性的。<code>notifyAll()</code>唤醒在此对象监视器上等待的所有线程。</li>
</ol>
<h1 id="四、中断"><a href="#四、中断" class="headerlink" title="四、中断"></a>四、中断</h1><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p>
<p><strong>InterruptedException</strong></p>
<p>通过调用一个线程的<code>interrupt()</code>来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 <code>InterruptedException</code>，从而提前结束该线程。但是不能中断 I/O 阻塞和<code>synchronized</code>锁阻塞。</p>
<p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了<code>Thread.sleep()</code>方法，因此会抛出一个<code>InterruptedException</code>，从而提前结束线程，不执行之后的语句。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterruptExample</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">try</span> &#123;
                Thread.sleep(<span class="hljs-number">2000</span>);
                System.out.println(<span class="hljs-string">"Thread run"</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
    Thread thread1 = <span class="hljs-keyword">new</span> MyThread1();
    thread1.start();
    thread1.interrupt();
    System.out.println(<span class="hljs-string">"Main run"</span>);
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs oxygene">Main run
java.lang.InterruptedException: sleep interrupted
at java.lang.Thread.sleep(Native <span class="hljs-function"><span class="hljs-keyword">Method</span>)</span>
<span class="hljs-function"><span class="hljs-title">at</span> <span class="hljs-title">InterruptExample</span>.<span class="hljs-title">lambda</span>$<span class="hljs-title">main</span>$0<span class="hljs-params">(InterruptExample.java:5)</span></span>
<span class="hljs-function"><span class="hljs-title">at</span> <span class="hljs-title">InterruptExample</span>$$<span class="hljs-title">Lambda</span>$1/713338599.<span class="hljs-title">run</span><span class="hljs-params">(Unknown Source)</span></span>
<span class="hljs-function"><span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Thread</span>.<span class="hljs-title">run</span><span class="hljs-params">(Thread.java:745)</span></span></code></pre></div>

<p><strong>interrupt()、interrupted()、isInterrupted()区别</strong></p>
<ul>
<li><code>interrupt()</code>方法：用于中断线程的，<strong>调用该方法的线程的状态将被置为”中断”状态</strong>。注意：线程中断仅仅是设置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态并做处理。支持线程中断的方法（也就是线程中断后会抛出<code>InterruptedException</code>的方法，比如<code>Thread.sleep</code>，以及<code>Object.wait</code>等方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常,并将线程的中断状态为设置为false。</li>
<li><code>interrupted()</code>：返回线程是否处于已中断状态并<strong>清除</strong>中断状态</li>
<li><code>isInterrupted()</code>：返回线程是否处于已中断状态</li>
</ul>
<p><strong>interrupted()</strong></p>
<p>如果一个线程的<code>run()</code>方法执行一个无限循环，并且没有执行<code>sleep()</code>等会抛出<code>InterruptedException</code>的操作，那么调用线程的 <code>interrupt()</code>方法就无法使线程提前结束。</p>
<p>但是调用 <code>interrupt()</code>方法会设置线程的中断标记，此时调用 <code>interrupted()</code>方法会返回<code>true</code>。因此可以在循环体中使用 <code>interrupted()</code>方法来判断线程是否处于中断状态，从而提前结束线程。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterruptExample</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">while</span> (!interrupted()) &#123;
                <span class="hljs-comment">// ..</span>
            &#125;
            System.out.println(<span class="hljs-string">"Thread end"</span>);
        &#125;
    &#125;
&#125;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
    Thread thread2 = <span class="hljs-keyword">new</span> MyThread2();
    thread2.start();
    thread2.interrupt();
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs ada">Thread <span class="hljs-keyword">end</span></code></pre></div>

<p><strong>Executor 的中断操作</strong></p>
<p>调用 <code>Executor</code>的<code>shutdown()</code>方法会等待线程都执行完毕之后再关闭，但是如果调用的是 <code>shutdownNow()</code>方法，则相当于调用每个线程的 <code>interrupt()</code>方法。</p>
<p>以下使用 <code>Lambda</code>创建线程，相当于创建了一个匿名内部线程。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; &#123;
        <span class="hljs-keyword">try</span> &#123;
            Thread.sleep(<span class="hljs-number">2000</span>);
            System.out.println(<span class="hljs-string">"Thread run"</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;);
    executorService.shutdownNow();
    System.out.println(<span class="hljs-string">"Main run"</span>);
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs reasonml">Main run
java.lang.InterruptedException: sleep interrupted
at java.lang.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(Native Method)
at <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ExecutorInterruptExample</span>.</span></span>lambda<span class="hljs-constructor">$main$0(ExecutorInterruptExample.<span class="hljs-params">java</span>:9)</span>
at ExecutorInterruptExample$$Lambda$<span class="hljs-number">1</span>/<span class="hljs-number">1160460865.</span>run(Unknown Source)
at java.util.concurrent.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ThreadPoolExecutor</span>.</span></span>run<span class="hljs-constructor">Worker(ThreadPoolExecutor.<span class="hljs-params">java</span>:1142)</span>
at java.util.concurrent.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ThreadPoolExecutor$Worker</span>.</span></span>run(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ThreadPoolExecutor</span>.</span></span>java:<span class="hljs-number">617</span>)
at java.lang.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>run(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>java:<span class="hljs-number">745</span>)</code></pre></div>

<p>如果只想中断 Executor 中的一个线程，可以通过使用<code>submit()</code>方法来提交一个线程，它会返回一个<code>Future&lt;?&gt;</code> 对象，通过调用该对象的 <code>cancel(true)</code>方法就可以中断线程。</p>
<div class="hljs"><pre><code class="hljs java">Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;
    <span class="hljs-comment">// ..</span>
&#125;);
future.cancel(<span class="hljs-keyword">true</span>);</code></pre></div>

<h1 id="五、互斥同步"><a href="#五、互斥同步" class="headerlink" title="五、互斥同步"></a>五、互斥同步</h1><p><code>Java</code> 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是<code>JVM</code>实现的<code>synchronized</code>，而另一个是<code>JDK</code>实现的 <code>ReentrantLock</code>。</p>
<p><strong>synchronized</strong></p>
<p><strong>1. 同步一个代码块</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;
        <span class="hljs-comment">// ...</span>
    &#125;
&#125;</code></pre></div>

<p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p>
<p>对于以下代码，使用<code>ExecutorService</code>执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedExample</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
				System.out.print(i + <span class="hljs-string">" "</span>);
			&#125;
		&#125;
	&#125;
&#125; 
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
	SynchronizedExample e1 = <span class="hljs-keyword">new</span> SynchronizedExample();
	ExecutorService executorService = Executors.newCachedThreadPool();
	executorService.execute(() -&gt; e1.func1());
	executorService.execute(() -&gt; e1.func1());
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span></code></pre></div>

<p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
	SynchronizedExample e1 = <span class="hljs-keyword">new</span> SynchronizedExample();
	SynchronizedExample e2 = <span class="hljs-keyword">new</span> SynchronizedExample();
	ExecutorService executorService = Executors.newCachedThreadPool();
	executorService.execute(() -&gt; e1.func1());
	executorService.execute(() -&gt; e2.func1());
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">9</span></code></pre></div>

<p><strong>2. 同步一个方法</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span> <span class="hljs-params">()</span> </span>&#123;
<span class="hljs-comment">// ...</span>
&#125;</code></pre></div>

<p>它和同步代码块一样，作用于同一个对象。</p>
<p><strong>3. 同步一个类</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">synchronized</span> (SynchronizedExample<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;
    <span class="hljs-comment">// ...</span>
    &#125;
&#125;</code></pre></div>

<p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedExample</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">synchronized</span> (SynchronizedExample<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
				System.out.print(i + <span class="hljs-string">" "</span>);
			&#125;
		&#125;
	&#125;
&#125; 
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
	SynchronizedExample e1 = <span class="hljs-keyword">new</span> SynchronizedExample();
	SynchronizedExample e2 = <span class="hljs-keyword">new</span> SynchronizedExample();
	ExecutorService executorService = Executors.newCachedThreadPool();
	executorService.execute(() -&gt; e1.func2());
	executorService.execute(() -&gt; e2.func2());
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span></code></pre></div>

<p><strong>4. 同步一个静态方法</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// ... &#125;</span></code></pre></div>

<p>作用于整个类。</p>
<p><strong>ReentrantLock</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockExample</span> </span>&#123;
	<span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;
		lock.lock();
		<span class="hljs-keyword">try</span> &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
				System.out.print(i + <span class="hljs-string">" "</span>);
			&#125;
		&#125; 
		<span class="hljs-keyword">finally</span> &#123;
			lock.unlock(); <span class="hljs-comment">// 确保释放锁，从而避免发生死锁。</span>
		&#125;
	&#125;
&#125; 
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
	LockExample lockExample = <span class="hljs-keyword">new</span> LockExample();
	ExecutorService executorService = Executors.newCachedThreadPool();
	executorService.execute(() -&gt; lockExample.func());
	executorService.execute(() -&gt; lockExample.func());
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span></code></pre></div>

<p><strong>比较</strong></p>
<p><strong>1. 锁的实现</strong></p>
<p><code>synchronized</code> 是 JVM 实现的，而<code>ReentrantLock</code>是 JDK 实现的。</p>
<p><strong>2. 性能</strong></p>
<p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p>
<p><strong>3. 等待可中断</strong></p>
<p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p>
<p>ReentrantLock 可中断，而 synchronized 不行。</p>
<p><strong>4. 公平锁</strong></p>
<p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p>
<p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p>
<p><strong>5. 锁绑定多个条件</strong></p>
<p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p>
<p><strong>使用选择</strong></p>
<p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
<p><strong>六、线程之间的协作</strong></p>
<p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p>
<p><strong>join()</strong></p>
<p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p>
<p>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinExample</span> </span>&#123;
	<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;
		<span class="hljs-meta">@Override</span>
		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
			System.out.println(<span class="hljs-string">"A"</span>);
		&#125;
	&#125; 
	<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;
		<span class="hljs-keyword">private</span> A a;
		B(A a) &#123;
			<span class="hljs-keyword">this</span>.a = a;
		&#125; 
		<span class="hljs-meta">@Override</span>
		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
			<span class="hljs-keyword">try</span> &#123;
				a.join();
			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
				e.printStackTrace();
			&#125; 
			System.out.println(<span class="hljs-string">"B"</span>);
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;
		A a = <span class="hljs-keyword">new</span> A();
		B b = <span class="hljs-keyword">new</span> B(a);
		b.start();
		a.start();
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
	JoinExample example = <span class="hljs-keyword">new</span> JoinExample();
	example.test();
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs dns"><span class="hljs-keyword">A</span> 
B</code></pre></div>

<p><strong>wait() notify() notifyAll()</strong></p>
<p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p>
<p>它们都属于 Object 的一部分，而不属于 Thread。</p>
<p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。</p>
<p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitNotifyExample</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;
		System.out.println(<span class="hljs-string">"before"</span>);
		notifyAll();
	&#125; 
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">try</span> &#123;
			wait();
		&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
			e.printStackTrace();
		&#125; 
		System.out.println(<span class="hljs-string">"after"</span>);
	&#125;
&#125; 
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
	ExecutorService executorService = Executors.newCachedThreadPool();
	WaitNotifyExample example = <span class="hljs-keyword">new</span> WaitNotifyExample();
	executorService.execute(() -&gt; example.after());
	executorService.execute(() -&gt; example.before());
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs applescript"><span class="hljs-keyword">before</span> 
<span class="hljs-keyword">after</span></code></pre></div>

<p><strong>wait() 和 sleep() 的区别</strong></p>
<ul>
<li>wait()     是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li>
<li>wait() 会释放锁，sleep() 不会。</li>
</ul>
<p><strong>await() signal() signalAll()</strong></p>
<p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p>
<p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p>
<p>使用 Lock 来获取一个 Condition 对象。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AwaitSignalExample</span> </span>&#123;
	<span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();
	<span class="hljs-keyword">private</span> Condition condition = lock.newCondition();
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;
		lock.lock();
		<span class="hljs-keyword">try</span> &#123;
			System.out.println(<span class="hljs-string">"before"</span>);
			condition.signalAll();
		&#125; <span class="hljs-keyword">finally</span> &#123;
			lock.unlock();
		&#125;
	&#125; 
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;
		lock.lock();
		<span class="hljs-keyword">try</span> &#123;
			condition.await();
			System.out.println(<span class="hljs-string">"after"</span>);
		&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
			e.printStackTrace();
		&#125; <span class="hljs-keyword">finally</span> &#123;
			lock.unlock();
		&#125;
	&#125;
&#125; 
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
	ExecutorService executorService = Executors.newCachedThreadPool();
	AwaitSignalExample example = <span class="hljs-keyword">new</span> AwaitSignalExample();
	executorService.execute(() -&gt; example.after());
	executorService.execute(() -&gt; example.before());
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs pgsql"><span class="hljs-keyword">Before</span>
<span class="hljs-keyword">after</span></code></pre></div>

<h1 id="八、J-U-C-其它组件"><a href="#八、J-U-C-其它组件" class="headerlink" title="八、J.U.C - 其它组件"></a>八、J.U.C - 其它组件</h1><p><strong>FutureTask</strong></p>
<p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FutureTask</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">RunnableFuture</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">RunnableFuture</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Runnable</span>, <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt;</span></code></pre></div>

<p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FutureTaskExample</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;
		FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;Integer&gt;(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;
			<span class="hljs-meta">@Override</span>
			<span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
				<span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;
				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;
					Thread.sleep(<span class="hljs-number">10</span>);
					result += i;
				&#125; 
				<span class="hljs-keyword">return</span> result;
			&#125;
		&#125;);
		Thread computeThread = <span class="hljs-keyword">new</span> Thread(futureTask);
		computeThread.start();
		Thread otherThread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
			System.out.println(<span class="hljs-string">"other task is running..."</span>);
			<span class="hljs-keyword">try</span> &#123;
				Thread.sleep(<span class="hljs-number">1000</span>);
			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
				e.printStackTrace();
			&#125;
		&#125;);
		otherThread.start();
		System.out.println(futureTask.get());
	&#125;
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs ada">other <span class="hljs-keyword">task</span> <span class="hljs-keyword">is</span> running...
<span class="hljs-number">4950</span></code></pre></div>

<p><strong>BlockingQueue</strong></p>
<p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：</p>
<ul>
<li>FIFO 队列：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）</li>
<li>优先级队列：PriorityBlockingQueue</li>
</ul>
<p>提供了阻塞的 take() 和 put() 方法：</p>
<ul>
<li>如果队列为空 take() 将阻塞，直到队列中有内容；</li>
<li>如果队列为满 put() 将阻塞，直到队列有空闲位置。</li>
</ul>
<p><strong>使用 BlockingQueue 实现生产者消费者问题</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerConsumer</span> </span>&#123;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BlockingQueue&lt;String&gt; queue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">5</span>);
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;
		<span class="hljs-meta">@Override</span>
		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
			<span class="hljs-keyword">try</span> &#123;
				queue.put(<span class="hljs-string">"product"</span>);
			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
				e.printStackTrace();
			&#125; 
			System.out.print(<span class="hljs-string">"produce.."</span>);
		&#125;
	&#125; 
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;
		<span class="hljs-meta">@Override</span>
		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
			<span class="hljs-keyword">try</span> &#123;
				String product = queue.take();
			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
				e.printStackTrace();
			&#125; 
			System.out.print(<span class="hljs-string">"consume.."</span>);
		 &#125;
	  &#125;
   &#125;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;
		Producer producer = <span class="hljs-keyword">new</span> Producer();
		producer.start();
	&#125; 
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
		Consumer consumer = <span class="hljs-keyword">new</span> Consumer();
		consumer.start();
	&#125; 
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;
		Producer producer = <span class="hljs-keyword">new</span> Producer();
		producer.start();
	&#125;
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs routeros">produce<span class="hljs-built_in">..</span>produce<span class="hljs-built_in">..</span>consume<span class="hljs-built_in">..</span>consume<span class="hljs-built_in">..</span>produce<span class="hljs-built_in">..</span>consume<span class="hljs-built_in">..</span>produce<span class="hljs-built_in">..</span>consume<span class="hljs-built_in">..</span>produce<span class="hljs-built_in">..</span>consume<span class="hljs-built_in">..</span></code></pre></div>

<h1 id="九、线程不安全示例"><a href="#九、线程不安全示例" class="headerlink" title="九、线程不安全示例"></a>九、线程不安全示例</h1><p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</p>
<p>以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadUnsafeExample</span> </span>&#123;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;
		cnt++;
	&#125; 
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> cnt;
	&#125;
&#125; 
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
	<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threadSize = <span class="hljs-number">1000</span>;
	ThreadUnsafeExample example = <span class="hljs-keyword">new</span> ThreadUnsafeExample();
	<span class="hljs-keyword">final</span> CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(threadSize);
	ExecutorService executorService = Executors.newCachedThreadPool();
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadSize; i++) &#123;
		executorService.execute(() -&gt; &#123;
			example.add();
			countDownLatch.countDown();
		&#125;);
	&#125; 
	countDownLatch.await();
	executorService.shutdown();
	System.out.println(example.get());
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">997</span></code></pre></div>

<h1 id="十一、线程安全"><a href="#十一、线程安全" class="headerlink" title="十一、线程安全"></a>十一、线程安全</h1><p>多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。</p>
<p>线程安全有以下几种实现方式：</p>
<p>不可变</p>
<p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p>
<p>不可变的类型：</p>
<ul>
<li>final 关键字修饰的基本数据类型</li>
<li>String</li>
<li>枚举类型</li>
<li>Number 部分子类，如 Long 和 Double     等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为Number 的原子类 AtomicInteger 和     AtomicLong 则是可变的。</li>
</ul>
<p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImmutableExample</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
		Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);
		unmodifiableMap.put(<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>);
	&#125;
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs reasonml">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"main"</span> java.lang.UnsupportedOperationException
at java.util.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collections$UnmodifiableMap</span>.</span></span>put(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collections</span>.</span></span>java:<span class="hljs-number">1457</span>)
at <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ImmutableExample</span>.</span></span>main(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ImmutableExample</span>.</span></span>java:<span class="hljs-number">9</span>)</code></pre></div>

<p>Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;
	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();
&#125;</code></pre></div>

<p><strong>互斥同步</strong></p>
<p>synchronized 和 ReentrantLock。</p>
<p><strong>非阻塞同步</strong></p>
<p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p>
<p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>
<p><strong>1. CAS</strong></p>
<p>随着硬件指令集的发展，我们可以使用基于<strong>冲突检测</strong>的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取<strong>补偿</strong>措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p>
<p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是<strong>内存地址 V</strong>、<strong>旧的预期值 A</strong> 和<strong>新值 B</strong>。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p>
<p><strong>2. AtomicInteger</strong></p>
<p>J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。</p>
<p>以下代码使用了 AtomicInteger 执行了自增的操作。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">incrementAndGet</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-keyword">this</span>, valueOffset, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;
&#125;</code></pre></div>

<p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt()来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</p>
<p>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, <span class="hljs-keyword">int</span> var4)</span> </span>&#123;
	<span class="hljs-keyword">int</span> var5;
	<span class="hljs-keyword">do</span> &#123;
		var5 = <span class="hljs-keyword">this</span>.getIntVolatile(var1, var2);
	&#125; 
	<span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4))
	;
	<span class="hljs-keyword">return</span> var5;
&#125;</code></pre></div>

<p><strong>3. ABA</strong></p>
<p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p>
<p>J.U.C 包提供了一个带有标记的原子引用类 <strong>AtomicStampedReference</strong> 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p>
<p><strong>无同步方案</strong></p>
<p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p>
<p><strong>1. 栈封闭</strong></p>
<p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackClosedExample</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add100</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;
			cnt++;
		&#125; 
		System.out.println(cnt);
	&#125;
&#125; 
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
	StackClosedExample example = <span class="hljs-keyword">new</span> StackClosedExample();
	ExecutorService executorService = Executors.newCachedThreadPool();
	executorService.execute(() -&gt; example.add100());
	executorService.execute(() -&gt; example.add100());
	executorService.shutdown();
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">100</span>
<span class="hljs-number">100</span></code></pre></div>

<p><strong>2. 线程本地存储（Thread Local Storage）</strong></p>
<p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。</p>
<p>如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p>
<p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p>
<p>可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p>
<p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalExample</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		ThreadLocal threadLocal = <span class="hljs-keyword">new</span> ThreadLocal();
		Thread thread1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
			threadLocal.set(<span class="hljs-number">1</span>);
			<span class="hljs-keyword">try</span> &#123;
				Thread.sleep(<span class="hljs-number">1000</span>);
			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
				e.printStackTrace();
			&#125; 
			System.out.println(threadLocal.get());
			threadLocal.remove();
		&#125;);
		Thread thread2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
			threadLocal.set(<span class="hljs-number">2</span>);
			threadLocal.remove();
		&#125;);
		thread1.start();
		thread2.start();
	&#125;
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">1</span></code></pre></div>

<p>为了理解 ThreadLocal，先看以下代码：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalExample1</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		ThreadLocal threadLocal1 = <span class="hljs-keyword">new</span> ThreadLocal();
		ThreadLocal threadLocal2 = <span class="hljs-keyword">new</span> ThreadLocal();
		Thread thread1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
			threadLocal1.set(<span class="hljs-number">1</span>);
			threadLocal2.set(<span class="hljs-number">1</span>);
		&#125;);
		Thread thread2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
			threadLocal1.set(<span class="hljs-number">2</span>);
			threadLocal2.set(<span class="hljs-number">2</span>);
		&#125;);
		thread1.start();
		thread2.start();
	&#125;
&#125;</code></pre></div>

<p>它所对应的底层结构图为：</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530182151.png" srcset="/img/loading.gif" alt="image-20210530182151726"></p>
<p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。</p>
<p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;
	Thread t = Thread.currentThread();
	ThreadLocalMap map = getMap(t);
	<span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)
	map.set(<span class="hljs-keyword">this</span>, value);
	<span class="hljs-keyword">else</span>
	createMap(t, value);
&#125;</code></pre></div>

<p>get() 方法类似。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;
	Thread t = Thread.currentThread();
	ThreadLocalMap map = getMap(t);
	<span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;
		ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);
		<span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;
			<span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)
			T result = (T)e.value;
			<span class="hljs-keyword">return</span> result;
		&#125;
	&#125; 
	<span class="hljs-keyword">return</span> setInitialValue();
&#125;</code></pre></div>

<p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p>
<p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。</p>
<p><strong>3. 可重入代码（Reentrant Code）</strong></p>
<p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p>
<p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p>
<h1 id="十二、锁优化"><a href="#十二、锁优化" class="headerlink" title="十二、锁优化"></a>十二、锁优化</h1><p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p>
<p><strong>自旋锁</strong></p>
<p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p>
<p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p>
<p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p>
<p><strong>锁消除</strong></p>
<p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p>
<p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p>
<p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">concatString</span><span class="hljs-params">(String s1, String s2, String s3)</span> </span>&#123;
	<span class="hljs-keyword">return</span> s1 + s2 + s3;
&#125;</code></pre></div>

<p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">concatString</span><span class="hljs-params">(String s1, String s2, String s3)</span> </span>&#123; 
	StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(); 
	sb.append(s1); 
	sb.append(s2); 
	sb.append(s3); 
	<span class="hljs-keyword">return</span> sb.toString(); 
&#125;</code></pre></div>

<p>每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString()方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</p>
<p><strong>锁粗化</strong></p>
<p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p>
<p>上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p>
<p><strong>轻量级锁</strong></p>
<p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p>
<p>以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530182401.png" srcset="/img/loading.gif" alt="image-20210530182401426"></p>
<p>下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530182426.png" srcset="/img/loading.gif" alt="image-20210530182426302"></p>
<p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p>
<p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530182459.png" srcset="/img/loading.gif" alt="image-20210530182459404"></p>
<p>如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p>
<p><strong>偏向锁</strong></p>
<p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS操作也不再需要。</p>
<p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p>
<p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530182523.png" srcset="/img/loading.gif" alt="image-20210530182522807"></p>
<h1 id="十三、多线程开发良好的实践"><a href="#十三、多线程开发良好的实践" class="headerlink" title="十三、多线程开发良好的实践"></a>十三、多线程开发良好的实践</h1><ul>
<li><p>给线程起个有意义的名字，这样可以方便找 Bug。</p>
</li>
<li><p>缩小同步范围，从而减少锁争用。例如对于     synchronized，应该尽量使用同步块而不是同步方法。</p>
</li>
<li><p>多用同步工具少用 wait()     和 notify()。首先，CountDownLatch,     CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify()     很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。</p>
</li>
<li><p>使用 BlockingQueue 实现生产者消费者问题。</p>
</li>
<li><p>多用并发集合少用同步集合，例如应该使用     ConcurrentHashMap 而不是 Hashtable。</p>
</li>
<li><p>使用本地变量和不可变类来保证线程安全。</p>
</li>
<li><p>使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。</p>
</li>
</ul>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/">语言相关</a>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/Java%E8%BF%9B%E9%98%B6/">Java进阶</a>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/Java%E8%BF%9B%E9%98%B6/Java%E5%B9%B6%E5%8F%91/">Java并发</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java%E5%B9%B6%E5%8F%91/">Java并发</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2021/05/30/Executor%E6%A1%86%E6%9E%B6/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Executor框架</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2021/05/30/Spring%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
                        <span class="hidden-mobile">Spring中用到的设计模式</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <script defer src="https://utteranc.es/client.js"
          repo="gavin-yyj/commit-utterance"
          issue-term="pathname"
  
          theme="github-light"
          crossorigin="anonymous"
  >
  </script>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "并发知识点&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
