<!DOCTYPE html>
<html lang="zh-CH">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="光说不做假把式">
  <meta name="author" content="杨玉杰">
  <meta name="keywords" content="">
  <title>ConcurrentHashMap - 杨玉杰|个人博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/agate.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>杨玉杰|个人博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友情链接
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bgi.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2021-05-30 20:50">
      May 30, 2021 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      89
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <p>首先推荐下几篇不错的文章：</p>
<p><a href="https://blog.csdn.net/pcwl1206/article/details/85040309" target="_blank" rel="noopener"><strong>1、Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析</strong></a></p>
<p>这篇文章要好好读一读，全文主要包括四个部分：Java7中的HashMap和ConcurrentHashMap以及Java8中的HashMap和ConcurrentHashMap，能够很清晰的认识到HashMap和ConcurrentHashMap之间的区别、Java8在哪些地方做出了改进。</p>
<p><a href="https://mp.weixin.qq.com/s/2ychUuTwmhNgRJXtR6k3Tg" target="_blank" rel="noopener"><strong>2、ConcurrentHashMap源码分析</strong></a></p>
<p>这篇文章也是本文主要参考的文章，全文分析了Java7中主要ConcurrentHashMap部分。</p>
<p>本文主要偏重于讲ConcurrentHashMap的源码分析，至于它和HashMap的对比，后面复习Java基础集合容器时会专门的再进行讲解。这里不再做过多的赘述，但是这两者之间的对比是很重要的。另外会再写文章对Java1.7中的ConcurrentHashMap和Java1.8中的ConcurrentHashMap的区别进行讲解：<a href="https://blog.csdn.net/pcwl1206/article/details/85040309" target="_blank" rel="noopener"><strong>Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析</strong></a></p>
<p><strong>1、为什么要使用ConcurrentHashMap？</strong></p>
<p>在并发编程中使用HashMap可能导致程序死循环。而使用线程安全的HashTable效率又非常低下，基于以上两个原因，便有了ConcurrentHashMap的登场机会。</p>
<ul>
<li><strong>1、线程不安全的HashMap</strong></li>
</ul>
<p>HashMap在并发执行put操作时会发生死循环，是因为多线程会导致HashMap的Entry链表形成环型数据结构，一旦形成环型数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。</p>
<ul>
<li><strong>2、效率低下的HashTable</strong></li>
</ul>
<p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率会非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或者轮询状态。如线程1使用put进行元素的添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p>
<ul>
<li><strong>3、ConcurrentHashMap的锁分段机制可有效提高并发访问率</strong></li>
</ul>
<p>HashTable容器在竞争激烈的情况下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，假如<strong>容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问</strong>。</p>
<p><strong>2、ConcurrentHashMap的实现</strong></p>
<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成的。</p>
<p>Segment在ConcurrentHashMap中扮演锁的角色是一种可重入锁（ReentranLock）。</p>
<p>HashEntry则用于存储键值对数据。</p>
<p>一个ConcurrentHashMap包含一个Segment数组，其结构是：数组+链表的形式。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素。每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530205150.png" srcset="/img/loading.gif" alt="image-20210530205150301"></p>
<p>看下ConcurrentHashMap源码中（JDK1.7）主要的成员变量、方法和内部类：</p>
<p><strong>2.1、ConcurrentHashMap中主要的成员变量、成员方法和内部类</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentHashMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;</span>
<span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">ConcurrentMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;, <span class="hljs-title">Serializable</span> </span>&#123;
    <span class="hljs-comment">// 默认初始化容量</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">16</span>;
    <span class="hljs-comment">// 默认加载因子</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;
    <span class="hljs-comment">// 默认并发级别</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="hljs-number">16</span>;
    <span class="hljs-comment">// 集合最大容量</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;
    <span class="hljs-comment">// 分段锁的最小数量</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="hljs-number">2</span>;
    <span class="hljs-comment">// 分段锁的最大数量</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_SEGMENTS = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">16</span>;
    <span class="hljs-comment">// 加锁前的重试次数</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RETRIES_BEFORE_LOCK = <span class="hljs-number">2</span>;
    <span class="hljs-comment">// 分段锁的掩码值</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> segmentMask;
    <span class="hljs-comment">// 分段锁的移位值</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> segmentShift;
    <span class="hljs-comment">// 分段锁数组</span>
    <span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Holder</span> </span>&#123;
           <span class="hljs-comment">// ...</span>
    &#125;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashEntry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;
           <span class="hljs-comment">// ... </span>
    &#125;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Segment</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;
        <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;
          <span class="hljs-comment">// ...</span>
    &#125;
    <span class="hljs-comment">// 获取ConcurrentHashMap中元素的个数</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;&#125;
    <span class="hljs-comment">// 获取元素</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;&#125;
    <span class="hljs-comment">// 设置元素</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;&#125;
         <span class="hljs-comment">// ...</span>
&#125;</code></pre></div>

<p>其中Segment数组代表分段锁集合；并发级别则代表分段锁的数量(也意味有多少线程可以同时操作)；初始化容量代表整个容器的容量；加载因子代表容器元素可以达到多满的一种程度。</p>
<p><strong>2.2、分段锁的内部结构</strong></p>
<p>Segment是ConcurrentHashMap的内部类，它继承了ReentrantLock。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentHashMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">ConcurrentMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;, <span class="hljs-title">Serializable</span> </span>&#123;
    <span class="hljs-comment">// 分段锁</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Segment</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;
        <span class="hljs-comment">// 自旋最大次数</span>
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_SCAN_RETRIES = Runtime.getRuntime().availableProcessors() &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">64</span> : <span class="hljs-number">1</span>;
        <span class="hljs-comment">// 哈希表</span>
        <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;
        <span class="hljs-comment">// 元素总数</span>
        <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> count;
        <span class="hljs-comment">// 修改次数</span>
        <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;
        <span class="hljs-comment">// 元素阀值</span>
        <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> threshold;
        <span class="hljs-comment">// 加载因子</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;
        <span class="hljs-comment">// 构造函数</span>
        Segment(<span class="hljs-keyword">float</span> lf, <span class="hljs-keyword">int</span> threshold, HashEntry&lt;K,V&gt;[] tab) &#123;
            <span class="hljs-keyword">this</span>.loadFactor = lf;
            <span class="hljs-keyword">this</span>.threshold = threshold;
            <span class="hljs-keyword">this</span>.table = tab;
        &#125;
<span class="hljs-comment">// 省略以下内容</span>
...
    &#125;
&#125;</code></pre></div>

<p>Segment是ConcurrentHashMap的静态内部类，可以看到它继承自ReentrantLock，因此它在<strong>本质上是一个锁</strong>。它在内部持有一个HashEntry数组(哈希表)，并且保证所有对该数组的增删改查方法都是线程安全的，具体是怎样实现的后面会讲到。</p>
<p><strong>所有对ConcurrentHashMap的增删改查操作都可以委托Segment来进行，因此ConcurrentHashMap能够保证在多线程环境下是安全的。又因为不同的Segment是不同的锁，所以多线程可以同时操作不同的Segment，也就意味着多线程可以同时操作ConcurrentHashMap，这样就能避免HashTable的缺陷，从而极大的提高性能。</strong></p>
<p><strong>2.3、ConcurrentHashMap的初始化</strong></p>
<p>ConcurrentHashMap初始化方法是通过 initialCapacity、loadFactor 和 concurrencyLevel等几个参数来初始化 segment数组、段偏移量segmentShift、段掩码 segmentMask 和每个 segment 里的 HashEntry 数组。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 核心构造器</span>
<span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor, <span class="hljs-keyword">int</span> concurrencyLevel)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (!(loadFactor &gt; <span class="hljs-number">0</span>) || initialCapacity &lt; <span class="hljs-number">0</span> || concurrencyLevel &lt;= <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();
    &#125;
    <span class="hljs-comment">// 确保并发级别不大于限定值</span>
    <span class="hljs-keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS) &#123;
        concurrencyLevel = MAX_SEGMENTS;
    &#125;
    <span class="hljs-keyword">int</span> sshift = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> ssize = <span class="hljs-number">1</span>;
    <span class="hljs-comment">// 保证ssize为2的幂, 且是最接近的大于等于并发级别的数</span>
    <span class="hljs-keyword">while</span> (ssize &lt; concurrencyLevel) &#123;
        ++sshift;
        ssize &lt;&lt;= <span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-comment">// 计算分段锁的移位值</span>
    <span class="hljs-keyword">this</span>.segmentShift = <span class="hljs-number">32</span> - sshift;
    <span class="hljs-comment">// 计算分段锁的掩码值</span>
    <span class="hljs-keyword">this</span>.segmentMask = ssize - <span class="hljs-number">1</span>;
    <span class="hljs-comment">// 总的初始容量不能大于限定值</span>
    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY) &#123;
        initialCapacity = MAXIMUM_CAPACITY;
    &#125;
    <span class="hljs-comment">// 获取每个分段锁的初始容量</span>
    <span class="hljs-keyword">int</span> c = initialCapacity / ssize;
    <span class="hljs-comment">// 分段锁容量总和不小于初始总容量</span>
    <span class="hljs-keyword">if</span> (c * ssize &lt; initialCapacity) &#123;
        ++c;
    &#125;
    <span class="hljs-keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;
    <span class="hljs-comment">// 保证cap为2的幂, 且是最接近的大于等于c的数</span>
    <span class="hljs-keyword">while</span> (cap &lt; c) &#123;
        cap &lt;&lt;= <span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-comment">// 新建一个Segment对象模版</span>
    Segment&lt;K,V&gt; s0 = <span class="hljs-keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="hljs-keyword">int</span>)(cap * loadFactor), (HashEntry&lt;K,V&gt;[])<span class="hljs-keyword">new</span> HashEntry[cap]);
    <span class="hljs-comment">// 新建指定大小的分段锁数组</span>
    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Segment[ssize];
    <span class="hljs-comment">// 使用UnSafe给数组第0个元素赋值</span>
    UNSAFE.putOrderedObject(ss, SBASE, s0);
    <span class="hljs-keyword">this</span>.segments = ss;
&#125;</code></pre></div>

<p><strong>2.4、如何定位Segment(锁)和元素</strong></p>
<p>主要通过segmentForHash方法获取分段锁的位置，再根据entryForHash方法获取元素的位置。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 根据哈希码获取分段锁</span>
<span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)
<span class="hljs-function"><span class="hljs-keyword">private</span> Segment&lt;K,V&gt; <span class="hljs-title">segmentForHash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h)</span> </span>&#123;
    <span class="hljs-keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;
    <span class="hljs-keyword">return</span> (Segment&lt;K,V&gt;) UNSAFE.getObjectVolatile(segments, u);
&#125;
<span class="hljs-comment">// 根据哈希码获取元素</span>
<span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-function">HashEntry&lt;K,V&gt; <span class="hljs-title">entryForHash</span><span class="hljs-params">(Segment&lt;K,V&gt; seg, <span class="hljs-keyword">int</span> h)</span> </span>&#123;
    HashEntry&lt;K,V&gt;[] tab;
    <span class="hljs-keyword">return</span> (seg == <span class="hljs-keyword">null</span> || (tab = seg.table) == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> :
            (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile(tab, ((<span class="hljs-keyword">long</span>)(((tab.length - <span class="hljs-number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);
&#125;</code></pre></div>

<p>在JDK1.7中是通过UnSafe来获取数组元素的，因此这里比JDK1.6多了些计算数组元素偏移量的代码，这些代码我们暂时不关注，现在我们只需知道下面这两点：</p>
<p>a. 通过哈希码计算分段锁在数组中的下标：(h &gt;&gt;&gt; segmentShift) &amp; segmentMask。</p>
<p>b. 通过哈希码计算元素在数组中的下标：(tab.length - 1) &amp; h。</p>
<p>现在我们假设传给构造器的两个参数为initialCapacity=128, concurrencyLevel=16。根据计算可以得到ssize=16, sshift=4，segmentShift=28，segmentMask=15。</p>
<p>同样，算得每个分段锁内的HashEntry数组的长度为8，所以tab.length-1=7。根据这些值，我们通过下图来解释如何根据同一个哈希码来定位分段锁和元素。</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530205351.png" srcset="/img/loading.gif" alt="image-20210530205351699"></p>
<p>可以看到<strong>分段锁和元素的定位都是通过元素的哈希码来决定的</strong>。<strong>定位分段锁是取哈希码的高位值(从32位处取起)，定位元素是取的哈希码的低位值</strong>。现在有个问题，它们一个从32位的左端取起，一个从32位的右端取起，那么会在某个时刻产生冲突吗？</p>
<p>我们在成员变量里可以找到MAXIMUM_CAPACITY = 1 &lt;&lt; 30，MAX_SEGMENTS = 1 &lt;&lt; 16，这说明定位分段锁和定位元素使用的总的位数不超过30，并且定位分段锁使用的位数不超过16，所以至少还隔着2位的空余，因此是不会产生冲突的。</p>
<p><strong>2.5、查找元素get操作</strong></p>
<p>Segment的get操作实现非常简单高效。先经过一次散列，然后使用这个散列值通过散列运算定位到Segment，再通过散列算法定位到元素。共需要两次散列运算。</p>
<p>get操作的高效在于整个get过程都不用加锁，除非读到的值是空才会加锁重读。get方法中使用的共享变量都定义成了volatile类型。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 根据key获取value</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;
    Segment&lt;K,V&gt; s;
    HashEntry&lt;K,V&gt;[] tab;
    <span class="hljs-comment">// 使用哈希函数计算哈希码</span>
    <span class="hljs-keyword">int</span> h = hash(key);
    <span class="hljs-comment">// 根据哈希码计算分段锁的索引</span>
    <span class="hljs-keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;
    <span class="hljs-comment">// 获取分段锁和对应的哈希表</span>
    <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="hljs-keyword">null</span> &amp;&amp; (tab = s.table) != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-comment">// 根据哈希码获取链表头节点, 再对链表进行遍历</span>
        <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile
                (tab, ((<span class="hljs-keyword">long</span>)(((tab.length - <span class="hljs-number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);
             e != <span class="hljs-keyword">null</span>; e = e.next) &#123;
            K k;
            <span class="hljs-comment">// 根据key和hash找到对应元素后返回value值</span>
            <span class="hljs-keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k))) &#123;
                <span class="hljs-keyword">return</span> e.value;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&#125;</code></pre></div>

<p>在JDK1.6中分段锁的get方法是通过下标来访问数组元素的，而在JDK1.7中是通过UnSafe的getObjectVolatile方法来读取数组中的元素。</p>
<p><strong>为什么要这样做？</strong></p>
<p>我们知道虽然Segment对象持有的HashEntry数组引用是volatile类型的，但是数组内的元素引用不是volatile类型的，因此多线程对数组元素的修改是不安全的，可能会在数组中读取到尚未构造完成的对象。</p>
<p>在JDK1.6中是通过第二次加锁读取来保证安全的，而JDK1.7中通过UnSafe的getObjectVolatile方法来读取同样也是为了保证这一点。使用getObjectVolatile方法读取数组元素需要先获得元素在数组中的偏移量，在这里<strong>根据哈希码计算得到分段锁在数组中的偏移量为u，然后通过偏移量u来尝试读取分段锁</strong>。由于分段锁数组在构造时没进行初始化，因此可能读出来一个空值，所以需要先进行判断。</p>
<p><strong>在确定分段锁和它内部的哈希表都不为空之后，再通过哈希码读取HashEntry数组的元素</strong>，根据上面的结构图可以看到，这时获得的是链表的头结点。之后再从头到尾的对链表进行遍历查找，如果找到对应的值就将其返回，否则就返回null。以上就是整个查找元素的过程。</p>
<p><strong>2.6、插入元素put操作</strong></p>
<p>由于put方法里需要对共享变量进行写操作，所以为了线程安全，在操作共享变量时必须加锁。put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤：</p>
<p>1、判断是否需要对Segment里的HashEntry数组进行扩容；</p>
<p>2、定位添加元素的位置，然后将其放在HashEntry数组中。</p>
<ul>
<li><strong>是否需要扩容？</strong></li>
</ul>
<p>在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold），如果超过阈值，则对数组进行扩容。值得一提的是，Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断是否已经到达容量的，如果达到了就进行扩容，但是很有可能扩容之后没有新元素再插入，这时HashMap就进行了一次无效的扩容。</p>
<ul>
<li><strong>如何扩容？</strong>       </li>
</ul>
<p>在扩容的时候，首先会创建一个容量是原来容量两倍的数组，然后将原来数组里的元素进行再散列后插入到新的数组里。为了高效，ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment扩容。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 向集合中添加键值对(若存在则替换)</span>
<span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;
    Segment&lt;K,V&gt; s;
    <span class="hljs-comment">// 传入的value不能为空</span>
    <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
    <span class="hljs-comment">// 使用哈希函数计算哈希码</span>
    <span class="hljs-keyword">int</span> hash = hash(key);
    <span class="hljs-comment">// 根据哈希码计算分段锁的下标</span>
    <span class="hljs-keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;
    <span class="hljs-comment">// 根据下标去尝试获取分段锁</span>
    <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject(segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-comment">// 获得的分段锁为空就去构造一个</span>
        s = ensureSegment(j);
    &#125;
    <span class="hljs-comment">// 调用分段锁的put方法</span>
    <span class="hljs-keyword">return</span> s.put(key, hash, value, <span class="hljs-keyword">false</span>);
&#125;
<span class="hljs-comment">// 向集合添加键值对(不存在才添加)</span>
<span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">putIfAbsent</span><span class="hljs-params">(K key, V value)</span> </span>&#123;
    Segment&lt;K,V&gt; s;
    <span class="hljs-comment">// 传入的value不能为空</span>
    <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
    <span class="hljs-comment">// 使用哈希函数计算哈希码</span>
    <span class="hljs-keyword">int</span> hash = hash(key);
    <span class="hljs-comment">// 根据哈希码计算分段锁的下标</span>
    <span class="hljs-keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;
    <span class="hljs-comment">// 根据下标去尝试获取分段锁</span>
    <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject(segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-comment">// 获得的分段锁为空就去构造一个</span>
        s = ensureSegment(j);
    &#125;
    <span class="hljs-comment">// 调用分段锁的put方法</span>
    <span class="hljs-keyword">return</span> s.put(key, hash, value, <span class="hljs-keyword">true</span>);
&#125;</code></pre></div>

<p>ConcurrentHashMap中有两个添加键值对的方法，通<strong>过put方法添加时如果存在则会进行覆盖，通过putIfAbsent方法添加时如果存在则不进行覆盖，这两个方法都是调用分段锁的put方法来完成操作，只是传入的最后一个参数不同而已</strong>。在上面代码中我们可以看到首先是根据key的哈希码来计算出分段锁在数组中的下标，然后根据下标使用UnSafe类getObject方法来读取分段锁。</p>
<p>由于在构造ConcurrentHashMap时没有对Segment数组中的元素初始化，所以可能读到一个空值，这时会先通过ensureSegment方法新建一个分段锁。获取到分段锁之后再调用它的put方法完成添加操作，下面我们来看看具体是怎样操作的。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 添加键值对</span>
<span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, <span class="hljs-keyword">int</span> hash, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;
    <span class="hljs-comment">// 尝试获取锁, 若失败则进行自旋</span>
    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="hljs-keyword">null</span> : scanAndLockForPut(key, hash, value);
    V oldValue;
    <span class="hljs-keyword">try</span> &#123;
        HashEntry&lt;K,V&gt;[] tab = table;
        <span class="hljs-comment">// 计算元素在数组中的下标</span>
        <span class="hljs-keyword">int</span> index = (tab.length - <span class="hljs-number">1</span>) &amp; hash;
        <span class="hljs-comment">// 根据下标获取链表头结点</span>
        HashEntry&lt;K,V&gt; first = entryAt(tab, index);
        <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;
            <span class="hljs-comment">// 遍历链表寻找该元素, 找到则进行替换</span>
            <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;
                K k;
                <span class="hljs-keyword">if</span> ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123;
                    oldValue = e.value;
                    <span class="hljs-comment">// 根据参数决定是否替换旧值</span>
                    <span class="hljs-keyword">if</span> (!onlyIfAbsent) &#123;
                        e.value = value;
                        ++modCount;
                    &#125;
                    <span class="hljs-keyword">break</span>;
                &#125;
                e = e.next;
            <span class="hljs-comment">// 没找到则在链表添加一个结点</span>
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-comment">// 将node结点插入链表头部</span>
                <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>) &#123;
                    node.setNext(first);
                &#125; <span class="hljs-keyword">else</span> &#123;
                    node = <span class="hljs-keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);
                &#125;
                <span class="hljs-comment">// 插入结点后将元素总是加1</span>
                <span class="hljs-keyword">int</span> c = count + <span class="hljs-number">1</span>;
                <span class="hljs-comment">// 元素超过阀值则进行扩容</span>
                <span class="hljs-keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) &#123;
                    rehash(node);
                <span class="hljs-comment">// 否则就将哈希表指定下标替换为node结点</span>
                &#125; <span class="hljs-keyword">else</span> &#123;
                    setEntryAt(tab, index, node);
                &#125;
                ++modCount;
                count = c;
                oldValue = <span class="hljs-keyword">null</span>;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
    &#125; <span class="hljs-keyword">finally</span> &#123;
        unlock();
    &#125;
    <span class="hljs-keyword">return</span> oldValue;
&#125;</code></pre></div>

<p>为保证线程安全，分段锁中的put操作是需要进行加锁的，所以线程一开始就会去获取锁，如果获取成功就继续执行，若获取失败则调用scanAndLockForPut方法进行自旋，在自旋过程中会先去扫描哈希表去查找指定的key，如果key不存在就会新建一个HashEntry返回，这样在获取到锁之后就不必再去新建了，为的是在等待锁的过程中顺便做些事情，不至于白白浪费时间，可见作者的良苦用心。</p>
<p>具体自旋方法我们后面再细讲，现在先把关注点拉回来，线程在成功获取到锁之后会根据计算到的下标，获取指定下标的元素。此时获取到的是链表的头结点，如果头结点不为空就对链表进行遍历查找，找到之后再根据onlyIfAbsent参数的值决定是否进行替换。</p>
<p>如果遍历没找到就会新建一个HashEntry指向头结点，此时如果自旋时创建了HashEntry，则直接将它的next指向当前头结点，如果自旋时没有创建就在这里新建一个HashEntry并指向头结点。</p>
<p>在向链表添加元素之后检查元素总数是否超过阀值，如果超过就调用rehash进行扩容，没超过的话就直接将数组对应下标的元素引用指向新添加的node。setEntryAt方法内部是通过调用UnSafe的putOrderedObject方法来更改数组元素引用的，这样就保证了其他线程在读取时可以读到最新的值。</p>
<p><strong>2.7、删除元素的操作</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 删除指定元素(找到对应元素后直接删除)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span><span class="hljs-params">(Object key)</span> </span>&#123;
    <span class="hljs-comment">// 使用哈希函数计算哈希码</span>
    <span class="hljs-keyword">int</span> hash = hash(key);
    <span class="hljs-comment">// 根据哈希码获取分段锁的索引</span>
    Segment&lt;K,V&gt; s = segmentForHash(hash);
    <span class="hljs-comment">// 调用分段锁的remove方法</span>
    <span class="hljs-keyword">return</span> s == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : s.remove(key, hash, <span class="hljs-keyword">null</span>);
&#125;
<span class="hljs-comment">// 删除指定元素(查找值等于给定值才删除)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object key, Object value)</span> </span>&#123;
    <span class="hljs-comment">// 使用哈希函数计算哈希码</span>
    <span class="hljs-keyword">int</span> hash = hash(key);
    Segment&lt;K,V&gt; s;
    <span class="hljs-comment">// 确保分段锁不为空才调用remove方法</span>
    <span class="hljs-keyword">return</span> value != <span class="hljs-keyword">null</span> &amp;&amp; (s = segmentForHash(hash)) != <span class="hljs-keyword">null</span> &amp;&amp; s.remove(key, hash, value) != <span class="hljs-keyword">null</span>;
&#125;</code></pre></div>

<p>ConcurrentHashMap提供了两种删除操作，<strong>一种是找到后直接删除，一种是找到后先比较再删除</strong>。<strong>这两种删除方法都是先根据key的哈希码找到对应的分段锁后，再通过调用分段锁的remove方法完成删除操作</strong>。下面我们来看看分段锁的remove方法。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 删除指定元素</span>
<span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">remove</span><span class="hljs-params">(Object key, <span class="hljs-keyword">int</span> hash, Object value)</span> </span>&#123;
    <span class="hljs-comment">// 尝试获取锁, 若失败则进行自旋</span>
    <span class="hljs-keyword">if</span> (!tryLock()) &#123;
        scanAndLock(key, hash);
    &#125;
    V oldValue = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">try</span> &#123;
        HashEntry&lt;K,V&gt;[] tab = table;
        <span class="hljs-comment">// 计算元素在数组中的下标</span>
        <span class="hljs-keyword">int</span> index = (tab.length - <span class="hljs-number">1</span>) &amp; hash;
        <span class="hljs-comment">// 根据下标取得数组元素(链表头结点)</span>
        HashEntry&lt;K,V&gt; e = entryAt(tab, index);
        HashEntry&lt;K,V&gt; pred = <span class="hljs-keyword">null</span>;
        <span class="hljs-comment">// 遍历链表寻找要删除的元素</span>
        <span class="hljs-keyword">while</span> (e != <span class="hljs-keyword">null</span>) &#123;
            K k;
            <span class="hljs-comment">// next指向当前结点的后继结点</span>
            HashEntry&lt;K,V&gt; next = e.next;
            <span class="hljs-comment">// 根据key和hash寻找对应结点</span>
            <span class="hljs-keyword">if</span> ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123;
                V v = e.value;
                <span class="hljs-comment">// 传入的value不等于v就跳过, 其他情况就进行删除操作</span>
                <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span> || value == v || value.equals(v)) &#123;
                    <span class="hljs-comment">// 如果pred为空则代表要删除的结点为头结点</span>
                    <span class="hljs-keyword">if</span> (pred == <span class="hljs-keyword">null</span>) &#123;
                        <span class="hljs-comment">// 重新设置链表头结点</span>
                        setEntryAt(tab, index, next);
                    &#125; <span class="hljs-keyword">else</span> &#123;
                        <span class="hljs-comment">// 设置pred结点的后继为next结点</span>
                        pred.setNext(next);
                    &#125;
                    ++modCount;
                    --count;
                    <span class="hljs-comment">// 记录元素删除之前的值</span>
                    oldValue = v;
                &#125;
                <span class="hljs-keyword">break</span>;
            &#125;
            <span class="hljs-comment">// 若e不是要找的结点就将pred引用指向它</span>
            pred = e;
            <span class="hljs-comment">// 检查下一个结点</span>
            e = next;
        &#125;
    &#125; <span class="hljs-keyword">finally</span> &#123;
        unlock();
    &#125;
    <span class="hljs-keyword">return</span> oldValue;
&#125;</code></pre></div>

<p><strong>2.8、替换元素的操作</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 替换指定元素(CAS操作)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">replace</span><span class="hljs-params">(K key, V oldValue, V newValue)</span> </span>&#123;
    <span class="hljs-comment">// 使用哈希函数计算哈希码</span>
    <span class="hljs-keyword">int</span> hash = hash(key);
    <span class="hljs-comment">// 保证oldValue和newValue不为空</span>
    <span class="hljs-keyword">if</span> (oldValue == <span class="hljs-keyword">null</span> || newValue == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
    <span class="hljs-comment">// 根据哈希码获取分段锁的索引</span>
    Segment&lt;K,V&gt; s = segmentForHash(hash);
    <span class="hljs-comment">// 调用分段锁的replace方法</span>
    <span class="hljs-keyword">return</span> s != <span class="hljs-keyword">null</span> &amp;&amp; s.replace(key, hash, oldValue, newValue);
&#125;
<span class="hljs-comment">// 替换元素操作(CAS操作)</span>
<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">replace</span><span class="hljs-params">(K key, <span class="hljs-keyword">int</span> hash, V oldValue, V newValue)</span> </span>&#123;
    <span class="hljs-comment">// 尝试获取锁, 若失败则进行自旋</span>
    <span class="hljs-keyword">if</span> (!tryLock()) &#123;
        scanAndLock(key, hash);
    &#125;
    <span class="hljs-keyword">boolean</span> replaced = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">try</span> &#123;
        HashEntry&lt;K,V&gt; e;
        <span class="hljs-comment">// 通过hash直接找到头结点然后对链表遍历</span>
        <span class="hljs-keyword">for</span> (e = entryForHash(<span class="hljs-keyword">this</span>, hash); e != <span class="hljs-keyword">null</span>; e = e.next) &#123;
            K k;
            <span class="hljs-comment">// 根据key和hash找到要替换的结点</span>
            <span class="hljs-keyword">if</span> ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123;
                <span class="hljs-comment">// 如果指定的当前值正确则进行替换</span>
                <span class="hljs-keyword">if</span> (oldValue.equals(e.value)) &#123;
                    e.value = newValue;
                    ++modCount;
                    replaced = <span class="hljs-keyword">true</span>;
                &#125;
                <span class="hljs-comment">// 否则不进行任何操作直接返回</span>
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
    &#125; <span class="hljs-keyword">finally</span> &#123;
        unlock();
    &#125;
    <span class="hljs-keyword">return</span> replaced;
&#125;</code></pre></div>

<p>ConcurrentHashMap同样提供了两种替换操作，一种是找到后直接替换，另一种是找到后先比较再替换(CAS操作)。这两种操作的实现大致是相同的，只是CAS操作在替换前多了一层比较操作，因此我们只需简单了解其中一种操作即可。</p>
<p>这里拿CAS操作进行分析，还是老套路，首先根据key的哈希码找到对应的分段锁，然后调用它的replace方法。进入分段锁中的replace方法后需要先去获取锁，如果获取失败则进行自旋，如果获取成功则进行下一步。</p>
<p>首先根据hash码获取链表头结点，然后根据key和hash进行遍历查找，找到了对应的元素之后，比较给定的oldValue是否是当前值，如果不是则放弃修改，如果是则用新值进行替换。由于HashEntry对象的value域是volatile类型的，因此可以直接替换。</p>
<p><strong>2.9、自旋操作</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 自旋等待获取锁(put操作)</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> HashEntry&lt;K,V&gt; <span class="hljs-title">scanAndLockForPut</span><span class="hljs-params">(K key, <span class="hljs-keyword">int</span> hash, V value)</span> </span>&#123;
    <span class="hljs-comment">// 根据哈希码获取头结点</span>
    HashEntry&lt;K,V&gt; first = entryForHash(<span class="hljs-keyword">this</span>, hash);
    HashEntry&lt;K,V&gt; e = first;
    HashEntry&lt;K,V&gt; node = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">int</span> retries = -<span class="hljs-number">1</span>;
    <span class="hljs-comment">// 在while循环内自旋</span>
    <span class="hljs-keyword">while</span> (!tryLock()) &#123;
        HashEntry&lt;K,V&gt; f;
        <span class="hljs-keyword">if</span> (retries &lt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">// 如果头结点为空就新建一个node</span>
            <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;
                    node = <span class="hljs-keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>);
                &#125;
                retries = <span class="hljs-number">0</span>;
            <span class="hljs-comment">// 否则就遍历链表定位该结点</span>
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.equals(e.key)) &#123;
                retries = <span class="hljs-number">0</span>;
            &#125; <span class="hljs-keyword">else</span> &#123;
                e = e.next;
            &#125;
        <span class="hljs-comment">// retries每次在这加1, 并判断是否超过最大值</span>
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;
            lock();
            <span class="hljs-keyword">break</span>;
        <span class="hljs-comment">// retries为偶数时去判断first有没有改变</span>
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((retries &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> &amp;&amp; (f = entryForHash(<span class="hljs-keyword">this</span>, hash)) != first) &#123;
            e = first = f;
            retries = -<span class="hljs-number">1</span>;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> node;
&#125;
<span class="hljs-comment">// 自旋等待获取锁(remove和replace操作)</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scanAndLock</span><span class="hljs-params">(Object key, <span class="hljs-keyword">int</span> hash)</span> </span>&#123;
    <span class="hljs-comment">// 根据哈希码获取链表头结点</span>
    HashEntry&lt;K,V&gt; first = entryForHash(<span class="hljs-keyword">this</span>, hash);
    HashEntry&lt;K,V&gt; e = first;
    <span class="hljs-keyword">int</span> retries = -<span class="hljs-number">1</span>;
    <span class="hljs-comment">// 在while循环里自旋</span>
    <span class="hljs-keyword">while</span> (!tryLock()) &#123;
        HashEntry&lt;K,V&gt; f;
        <span class="hljs-keyword">if</span> (retries &lt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">// 遍历链表定位到该结点</span>
            <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span> || key.equals(e.key)) &#123;
                retries = <span class="hljs-number">0</span>;
            &#125; <span class="hljs-keyword">else</span> &#123;
                e = e.next;
            &#125;
        <span class="hljs-comment">// retries每次在这加1, 并判断是否超过最大值</span>
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;
            lock();
            <span class="hljs-keyword">break</span>;
        <span class="hljs-comment">// retries为偶数时去判断first有没有改变</span>
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((retries &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> &amp;&amp; (f = entryForHash(<span class="hljs-keyword">this</span>, hash)) != first) &#123;
            e = first = f;
            retries = -<span class="hljs-number">1</span>;
        &#125;
    &#125;
&#125;</code></pre></div>

<p><strong>2.10、哈希表的扩容操作</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 再哈希</span>
<span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rehash</span><span class="hljs-params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;
    <span class="hljs-comment">// 获取旧哈希表的引用</span>
    HashEntry&lt;K,V&gt;[] oldTable = table;
    <span class="hljs-comment">// 获取旧哈希表的容量</span>
    <span class="hljs-keyword">int</span> oldCapacity = oldTable.length;
    <span class="hljs-comment">// 计算新哈希表的容量(为旧哈希表的2倍)</span>
    <span class="hljs-keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="hljs-number">1</span>;
    <span class="hljs-comment">// 计算新的元素阀值</span>
    threshold = (<span class="hljs-keyword">int</span>)(newCapacity * loadFactor);
    <span class="hljs-comment">// 新建一个HashEntry数组</span>
    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) <span class="hljs-keyword">new</span> HashEntry[newCapacity];
    <span class="hljs-comment">// 生成新的掩码值</span>
    <span class="hljs-keyword">int</span> sizeMask = newCapacity - <span class="hljs-number">1</span>;
    <span class="hljs-comment">// 遍历旧表的所有元素</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; oldCapacity ; i++) &#123;
        <span class="hljs-comment">// 取得链表头结点</span>
        HashEntry&lt;K,V&gt; e = oldTable[i];
        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;
            HashEntry&lt;K,V&gt; next = e.next;
            <span class="hljs-comment">// 计算元素在新表中的索引</span>
            <span class="hljs-keyword">int</span> idx = e.hash &amp; sizeMask;
            <span class="hljs-comment">// next为空表明链表只有一个结点</span>
            <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-comment">// 直接把该结点放到新表中</span>
                newTable[idx] = e;
            &#125;<span class="hljs-keyword">else</span> &#123;
                HashEntry&lt;K,V&gt; lastRun = e;
                <span class="hljs-keyword">int</span> lastIdx = idx;
                <span class="hljs-comment">// 定位lastRun结点, 将lastRun之后的结点直接放到新表中</span>
                <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; last = next; last != <span class="hljs-keyword">null</span>; last = last.next) &#123;
                    <span class="hljs-keyword">int</span> k = last.hash &amp; sizeMask;
                    <span class="hljs-keyword">if</span> (k != lastIdx) &#123;
                        lastIdx = k;
                        lastRun = last;
                    &#125;
                &#125;
                newTable[lastIdx] = lastRun;
                <span class="hljs-comment">// 遍历在链表lastRun结点之前的元素, 将它们依次复制到新表中</span>
                <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;
                    V v = p.value;
                    <span class="hljs-keyword">int</span> h = p.hash;
                    <span class="hljs-keyword">int</span> k = h &amp; sizeMask;
                    HashEntry&lt;K,V&gt; n = newTable[k];
                    newTable[k] = <span class="hljs-keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);
                &#125;
            &#125;
        &#125;
    &#125;
    <span class="hljs-comment">// 计算传入结点在新表中的下标</span>
    <span class="hljs-keyword">int</span> nodeIndex = node.hash &amp; sizeMask;
    <span class="hljs-comment">// 将传入结点添加到链表头结点</span>
    node.setNext(newTable[nodeIndex]);
    <span class="hljs-comment">// 将新表指定下标元素换成传入结点</span>
    newTable[nodeIndex] = node;
    <span class="hljs-comment">// 将哈希表引用指向新表</span>
    table = newTable;
&#125;</code></pre></div>

<p>rehash方法在put方法中被调用，我们知道在put方法时会新建元素并添加到哈希数组中，随着元素的增多发生哈希冲突的可能性越大，哈希表的性能也会随之下降。因此每次put操作时都会检查元素总数是否超过阀值，如果超过则调用rehash方法进行扩容。因为数组长度一旦确定则不能再被改变，因此需要新建一个数组来替换原先的数组。</p>
<p>从代码中可以知道新创建的数组长度为原数组的2倍(oldCapacity &lt;&lt; 1)。创建好新数组后需要将旧数组中的所有元素移到新数组中，因此需要计算每个元素在新数组中的下标。计算新下标的过程如下图所示。</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530205709.png" srcset="/img/loading.gif" alt="image-20210530205709518"></p>
<p>我们知道下标直接取的是哈希码的后几位，由于新数组的容量是直接用旧数组容量右移1位得来的，因此掩码位数向右增加1位，取到的哈希码位数也向右增加1位。如上图，若旧的掩码值为111，则元素下标为101，扩容后新的掩码值为1111，则计算出元素的新下标为0101。</p>
<p>由于同一条链表上的元素下标是相同的，现在假设链表所有元素的下标为101，在扩容后该链表元素的新下标只有0101或1101这两种情况，因此数组扩容会打乱原先的链表并将链表元素分成两批。</p>
<p>在计算出新下标后需要将元素移动到新数组中，在HashMap中通过直接修改next引用导致了多线程的死锁。虽然在ConcurrentHashMap中通过加锁避免了这种情况，但是我们知道next域是volatile类型的，它的改动能立马被读线程读取到，因此为保证线程安全采用复制元素来迁移数组。</p>
<p>但是对链表中每个元素都进行复制有点影响性能，作者发现链表尾部有许多元素的next是不变的，它们在新数组中的下标是相同的，因此可以考虑整体移动这部分元素。具统计实际操作中只有1/6的元素是必须复制的，所以整体移动链表尾部元素(lastRun后面的元素)是可以提升一定性能的。</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/">语言相关</a>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/Java%E8%BF%9B%E9%98%B6/">Java进阶</a>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/Java%E8%BF%9B%E9%98%B6/Java%E5%B9%B6%E5%8F%91/">Java并发</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java%E5%B9%B6%E5%8F%91/">Java并发</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2021/05/30/ThreadLocal%E4%BB%8B%E7%BB%8D/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ThreadLocal介绍</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2021/05/30/Happens-Before%E5%8E%9F%E5%88%99/">
                        <span class="hidden-mobile">Happens-Before原则</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <script defer src="https://utteranc.es/client.js"
          repo="gavin-yyj/commit-utterance"
          issue-term="pathname"
  
          theme="github-light"
          crossorigin="anonymous"
  >
  </script>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "ConcurrentHashMap&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
