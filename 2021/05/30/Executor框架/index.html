<!DOCTYPE html>
<html lang="zh-CH">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="光说不做假把式">
  <meta name="author" content="杨玉杰">
  <meta name="keywords" content="">
  <title>Executor框架 - 杨玉杰|个人博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/agate.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>杨玉杰|个人博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友情链接
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bgi.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2021-05-30 20:20">
      May 30, 2021 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      75
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <p>Java中的线程即是工作单元也是执行机制，从JDK 5后，工作单元与执行机制被分离。工作单元包括Runnable和Callable，执行机制由JDK 5中增加的java.util.concurrent包中Executor框架提供。</p>
<h1 id="1、Executor-框架简介"><a href="#1、Executor-框架简介" class="headerlink" title="1、Executor 框架简介"></a>1、Executor 框架简介</h1><h2 id="1-1、Executor-框架的两级调度模型"><a href="#1-1、Executor-框架的两级调度模型" class="headerlink" title="1.1、Executor 框架的两级调度模型"></a>1.1、Executor 框架的两级调度模型</h2><p>在 HotSpot VM 的线程模型中，Java线程（java.lang.Thread）被一对一映射为本地操作系统线程。Java线程启动时会创建一个本地操作系统线程；当该Java线程终止时，这个操作系统线程也被回收。操作系统会调度所有线程并将它们分配给可用的CPU。</p>
<p>在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定的数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。这两级的调度模型的示意图如下所示：</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530202212.png" srcset="/img/loading.gif" alt="image-20210530202212035"></p>
<p>从图中可以看出，应用程序通过 Executor 框架控制上层的调度；而下层的调度由操作系统内核控制，下层的调度不受应用程序的控制。</p>
<h2 id="1-2、Executor-框架的结构与成员"><a href="#1-2、Executor-框架的结构与成员" class="headerlink" title="1.2、Executor 框架的结构与成员"></a>1.2、Executor 框架的结构与成员</h2><p><strong>1.2.1、Executor 框架的结构</strong></p>
<p>Executor 框架主要由3大部分组成如下：</p>
<p>1、任务：包括被执行任务需要实现的接口：Runnable 接口或 Callable 接口；</p>
<p>2、任务的执行：包括任务执行机制的核心接口Executor，以及继承自 Executor 的 ExecutorService 接口。Executor 框架有两个关键类实现了 ExecutorService 接口，即：ThreadPoolExecutor 和 ScheduledThreadPoolExecutor；</p>
<p>3、异步计算的结果：包括接口 Future 和实现 Future 接口的 FutureTask 类。</p>
<p>Executor 框架包含的主要类和接口如下图所示：</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530202253.png" srcset="/img/loading.gif" alt="image-20210530202253095"></p>
<p>1、Executor：是一个接口，它是 Executor 框架的基础，它将任务的提交与任务的执行分离开来；</p>
<p>2、ThreadPoolExecutor：是线程池的核心实现类，用来执行被提交的任务；</p>
<p>3、ScheduledThreadPoolExecutor：是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。ScheduledThreadPoolExecutor 比 Timer 更加灵活，功能更强大；</p>
<p>4、Future 接口和实现 Future 接口的 FutureTask 类，代表异步计算的结果；</p>
<p>5、Runnable 接口和 Callable 接口的实现类，都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。</p>
<p>Executor 框架的使用示意图如下图所示：</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530202322.png" srcset="/img/loading.gif" alt="image-20210530202322127"></p>
<ul>
<li>主线程首先要创建实现Runnable或者Callable接口的任务对象。工具类Executors可以把一个Runnable对象封装为一个Callable对象（Executors.callable(Runnable      task) 或 Executors.callable(Runnable task, Object result)）。</li>
<li>然后可以把Runnbale对象直接交给     ExecutorService 执行（ExecutorService.execute(Runnable      command)）；或者也可以把Runnable或者Callable对象提交给 ExecutorService     执行（ExecutorService.submit(Runnable task) 或 ExcutorService.submit(Callable<T>      task)）。</li>
<li>如果执行ExecutorService.submit(     … )，ExecutorService 将返回一个实现 Future 接口的对象。由于 FutureTask 实现了     Runnable，程序员也可以创建 FutureTask，然后直接交给 ExecutorService 执行。</li>
<li>最后，主线程可以执行     FutureTask.get() 方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel(boolean      mayInterruptIfRunning) 来取消此任务的执行。</li>
</ul>
<p><strong>1.2.2、Executor 框架的成员</strong></p>
<p>Executor 框架的主要成员包括：ThreadPoolExecutor、ScheduledThreadPoolExecutor、Future接口、Runnable接口、Callable接口和Executors。</p>
<p><strong>1、ThreadPoolExecutor</strong></p>
<p>ThreadPoolExecutor 通常使用工厂类 Executors 来创建。Executors 可以创建3种类型的 ThreadPoolExecutor：SingleThreadExecutor、FixedThreadPool 和 CachedThreadPool。</p>
<p><strong>2、ScheduledThreadPoolExecutor</strong></p>
<p>ScheduledThreadPoolExecutor 通常使用工厂类 Executors 来创建。Executors可以创建2种类型的 ScheduledThreadPoolExecutor，如下：</p>
<ul>
<li>ScheduledThreadPoolExecutor：包含若干个线程的ScheduledThreadPoolExecutor；</li>
<li>SingleThreadScheduledExecutor：包含一个线程的ScheduledThreadPoolExecutor。</li>
</ul>
<p><strong>3、Future接口</strong></p>
<p>Future 接口和实现 Future 接口的 FutureTask 类用来表示异步计算的结果。当我们把 Runnable 接口或 Callable 接口的实现类提交（submit）给 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 时，ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 会向我们返回一个 FutureTask 对象。</p>
<p><strong>4、Runnable 接口和 Callable 接口</strong></p>
<p>Runnable 接口和 Callable 接口的实现类，都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。它们之间的区别是 Runnable 不会返回结果，而 Callable 可以返回结果。</p>
<h1 id="2、ThreadPoolExecutor-详解"><a href="#2、ThreadPoolExecutor-详解" class="headerlink" title="2、ThreadPoolExecutor 详解"></a>2、ThreadPoolExecutor 详解</h1><p>其实关于 ThreadPoolExecutor 在上一篇文章：Java中的线程池详解已经进行了源码讲解，这里仅介绍下它的3种类型：SingleThreadExecutor、FixedThreadPool 和 CachedThreadPool。</p>
<h2 id="2-1、FixedThreadPool"><a href="#2-1、FixedThreadPool" class="headerlink" title="2.1、FixedThreadPool"></a>2.1、FixedThreadPool</h2><p>创建固定长度的线程池，每次提交任务创建一个线程，直到达到线程池的最大数量，线程池的大小不再变化。</p>
<p>这个线程池可以创建固定线程数的线程池。特点就是可以重用固定数量线程的线程池。它的构造源码如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads,nThreads,
                                  <span class="hljs-number">0L</span>,
                                  TimeUnit.MILLISECONDS,
                                  <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());
&#125;</code></pre></div>

<p>FixedThreadPool的corePoolSize和maxiumPoolSize都被设置为创建FixedThreadPool时指定的参数nThreads；</p>
<p>0L则表示当线程池中的线程数量操作核心线程的数量时，多余的线程将被立即停止；</p>
<p>最后一个参数表示FixedThreadPool使用了无界队列LinkedBlockingQueue作为线程池的做工队列，由于是无界的，当线程池的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池的线程数量不会超过corePoolSize，同时maxiumPoolSize也就变成了一个无效的参数，并且运行中的线程池并不会拒绝任务。</p>
<p>FixedThreadPool运行图如下：</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530202413.png" srcset="/img/loading.gif" alt="image-20210530202413593"></p>
<p>执行过程如下：</p>
<p>1.如果当前工作中的线程数量少于corePool的数量，就创建新的线程来执行任务。</p>
<p>2.当线程池的工作中的线程数量达到了corePool，则将任务加入LinkedBlockingQueue。</p>
<p>3.线程执行完1中的任务后会从队列中去任务。</p>
<p>注意：LinkedBlockingQueue是无界队列，所以可以一直添加新任务到线程池。</p>
<h2 id="2-2、SingleThreadExecutor"><a href="#2-2、SingleThreadExecutor" class="headerlink" title="2.2、SingleThreadExecutor"></a>2.2、SingleThreadExecutor</h2><p>SingleThreadExecutor是使用单个worker线程的Executor。特点是使用单个工作线程执行任务。它的构造源码如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService
            (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,
                                    <span class="hljs-number">0L</span>,
                                    TimeUnit.MILLISECONDS,
                                    <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));
&#125;</code></pre></div>

<p>SingleThreadExecutor 的 corePoolSize 和 maxiumPoolSize 都被设置1。其他参数均与 FixedThreadPool 相同，其运行图如下：</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530202529.png" srcset="/img/loading.gif" alt="image-20210530202529591"></p>
<p>执行过程如下：</p>
<p>1.如果当前工作中的线程数量少于corePool的数量，就创建一个新的线程来执行任务。</p>
<p>2.当线程池的工作中的线程数量达到了corePool，则将任务加入LinkedBlockingQueue。</p>
<p>3.线程执行完1中的任务后会从队列中去任务。</p>
<p>注意：由于在线程池中只有一个工作线程，所以任务可以按照添加顺序执行。</p>
<h2 id="2-3、CachedThreadPool"><a href="#2-3、CachedThreadPool" class="headerlink" title="2. 3、CachedThreadPool"></a>2. 3、CachedThreadPool</h2><p> CachedThreadPool是一个”无限“容量的线程池，它会根据需要创建新线程。特点是可以根据需要来创建新的线程执行任务，没有特定的corePool。下面是它的构造方法：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>,Integer.MAX_VALUE,
                                  <span class="hljs-number">60L</span>,
                                  TimeUnit.SECONDS,
                                  <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());
&#125;</code></pre></div>

<p>CachedThreadPool的corePoolSize被设置为0，即corePool为空；maximumPoolSize被设置为Integer.MAX_VALUE，即maximum是无界的。这里keepAliveTime设置为60秒，意味着空闲的线程最多可以等待任务60秒，否则将被回收。</p>
<p>CachedThreadPool使用没有容量的SynchronousQueue作为主线程池的工作队列，它是一个没有容量的阻塞队列。每个插入操作必须等待另一个线程的对应移除操作。这意味着，如果主线程提交任务的速度高于线程池中处理任务的速度时，CachedThreadPool会不断创建新线程。极端情况下，CachedThreadPool会因为创建过多线程而耗尽CPU资源。其运行图如下：</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530202625.png" srcset="/img/loading.gif" alt="image-20210530202625591"></p>
<p>执行过程如下：</p>
<p>1.首先执行SynchronousQueue.offer(Runnable task)。如果在当前的线程池中有空闲的线程正在执行SynchronousQueue.poll()，那么主线程执行的offer操作与空闲线程执行的poll操作配对成功，主线程把任务交给空闲线程执行。，execute()方法执行成功，否则执行步骤2；</p>
<p>2.当线程池为空(初始maximumPool为空)或没有空闲线程时，配对失败，将没有线程执行SynchronousQueue.poll操作。这种情况下，线程池会创建一个新的线程执行任务；</p>
<p>3.在创建完新的线程以后，将会执行poll操作。当步骤2的线程执行完成后，将等待60秒，如果此时主线程提交了一个新任务，那么这个空闲线程将执行新任务，否则被回收。因此长时间不提交任务的CachedThreadPool不会占用系统资源。</p>
<p>SynchronousQueue是一个不存储元素阻塞队列，每次要进行offer操作时必须等待poll操作，否则不能继续添加元素。</p>
<h2 id="2-4、具体应用案例"><a href="#2-4、具体应用案例" class="headerlink" title="2.4、具体应用案例"></a>2.4、具体应用案例</h2><p><strong>1、newCachedThreadPool</strong></p>
<p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。示例代码如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;
            <span class="hljs-keyword">try</span> &#123;
                Thread.sleep(index * <span class="hljs-number">1000</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            cachedThreadPool.execute(<span class="hljs-keyword">new</span> Runnable()&#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                    System.out.println(index);
                &#125;
            &#125;);
        &#125;
    &#125;
&#125;</code></pre></div>

<p>线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。</p>
<p><strong>2、newFixedThreadPool</strong></p>
<p>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。示例代码如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;
            fixedThreadPool.execute(<span class="hljs-keyword">new</span> Runnable()&#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                    <span class="hljs-keyword">try</span> &#123;
                        System.out.println(index);
                        Thread.sleep(<span class="hljs-number">2000</span>);
                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;);
        &#125;
    &#125;
&#125;</code></pre></div>

<p>因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()。可参考PreloadDataCache。</p>
<p><strong>3、newScheduledThreadPool</strong></p>
<p>创建一个定长线程池，支持定时及周期性任务执行。延迟执行示例代码如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="hljs-number">5</span>);
        scheduledThreadPool.schedule(<span class="hljs-keyword">new</span> Runnable()&#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                System.out.println(<span class="hljs-string">"延迟3秒"</span>);
            &#125;
        &#125;, <span class="hljs-number">3</span>, TimeUnit.SECONDS);
    &#125;
&#125;</code></pre></div>

<p>表示延迟3秒执行。定期执行示例代码如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="hljs-number">5</span>);
        scheduledThreadPool.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable()&#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                System.out.println(<span class="hljs-string">"延迟1秒，每3秒执行1次"</span>);
            &#125;
        &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS);
    &#125;
&#125;</code></pre></div>

<p>表示延迟1秒后每3秒执行一次。ScheduledExecutorService比Timer更安全，功能更强大，后面会有一篇单独进行对比。</p>
<p><strong>4、newSingleThreadExecutor</strong></p>
<p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。示例代码如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;
            singleThreadExecutor.execute(<span class="hljs-keyword">new</span> Runnable()&#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                    <span class="hljs-keyword">try</span> &#123;
                        System.out.println(index);
                        Thread.sleep(<span class="hljs-number">2000</span>);
                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;);
        &#125;
    &#125;
&#125;</code></pre></div>

<p>结果依次输出，相当于顺序执行各个任务。现行大多数GUI程序都是单线程的。Android中单线程可用于<a href="http://www.trinea.cn/android/database-performance/" target="_blank" rel="noopener">数据库操作</a>，文件操作，应用批量安装，应用批量删除等不适合并发但可能IO阻塞性及影响UI线程响应的操作。</p>
<p><strong>3、ScheduledThreadPoolExecutor 详解</strong></p>
<p>我们知道Timer与TimerTask虽然可以实现线程的周期和延迟调度，但是Timer与TimerTask存在一些缺陷，所以对于这种定期、周期执行任务的调度策略，我们一般都是推荐ScheduledThreadPoolExecutor来实现。下面就深入分析ScheduledThreadPoolExecutor是如何来实现线程的周期、延迟调度的。</p>
<p>ScheduledThreadPoolExecutor，继承ThreadPoolExecutor且实现了ScheduledExecutorService接口，它就相当于提供了“延迟”和“周期执行”功能的ThreadPoolExecutor。在JDK API中是这样定义它的：ScheduledThreadPoolExecutor，它可另行安排在给定的延迟后运行命令，或者定期执行命令。需要多个辅助线程时，或者要求 ScheduledThreadPoolExecutor具有额外的灵活性或功能时，此类要优于 Timer。 一旦启用已延迟的任务就执行它，但是有关何时启用，启用后何时执行则没有任何实时保证。按照提交的先进先出 (FIFO) 顺序来启用那些被安排在同一执行时间的任务。</p>
<p><strong>3.1、ScheduledThreadPoolExecutor 的运行机制</strong></p>
<p>ScheduledThreadPoolExecutor 的执行示意图如下图所示：</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530202849.png" srcset="/img/loading.gif" alt="image-20210530202849399"></p>
<p>DelayQueue 是一个无界队列，所以 ThreadPoolExecutor 的 maximumPoolSize 在 ScheduledThreadPoolExecutor 中没有什么意义。</p>
<p>ScheduledThreadPoolExecutor 的执行主要分为两大部分：</p>
<p>1、当调用 ScheduledThreadPoolExecutor 的 scheduleAtFixedRate() 方法或者 scheduledWithFixedDelay() 方法时，会向 ScheduledThreadPoolExecutor 的 DelayQueue 添加一个实现了 RunnableScheduledFuture 接口的 ScheduledFutureTask。</p>
<p>2、线程池中的线程从 DelayQueue 中获取 ScheduledFutureTask，然后执行任务。</p>
<p>ScheduledThreadPoolExecutor 为了实现周期性的执行任务，对 ThreadPoolExecutor 做了如下的修改：</p>
<p>1、使用 DelayQueue 作为任务队列；</p>
<p>2、获取任务的方式不同（后文会讲解到）；</p>
<p>3、执行周期任务后，增加了额外的处理（后文会讲解到）。</p>
<p><strong>3.2、ScheduledThreadPoolExecutor 的实现</strong></p>
<p>先来看下ScheduledThreadPoolExecutor类中的主要结构：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadPoolExecutor</span></span>
<span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">ScheduledExecutorService</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicLong sequencer = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledFutureTask</span>&lt;<span class="hljs-title">V</span>&gt;</span>
<span class="hljs-class">            <span class="hljs-keyword">extends</span> <span class="hljs-title">FutureTask</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">RunnableScheduledFuture</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;
...
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delayedExecute</span><span class="hljs-params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123; ... &#125;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reExecutePeriodic</span><span class="hljs-params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123; ... &#125;
    <span class="hljs-keyword">protected</span> &lt;V&gt; <span class="hljs-function">RunnableScheduledFuture&lt;V&gt; <span class="hljs-title">decorateTask</span><span class="hljs-params">(...)</span></span>&#123;...&#125;
    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,
                                       <span class="hljs-keyword">long</span> delay,
                                       TimeUnit unit) &#123;...&#125;
    <span class="hljs-keyword">public</span> &lt;V&gt; <span class="hljs-function">ScheduledFuture&lt;V&gt; <span class="hljs-title">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable,</span></span>
<span class="hljs-function"><span class="hljs-params">                                           <span class="hljs-keyword">long</span> delay,</span></span>
<span class="hljs-function"><span class="hljs-params">                                           TimeUnit unit)</span> </span>&#123;...&#125;
    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,
                                                  <span class="hljs-keyword">long</span> initialDelay,
                                                  <span class="hljs-keyword">long</span> period,
                                                  TimeUnit unit) &#123;...&#125;
    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,
                                                     <span class="hljs-keyword">long</span> initialDelay,
                                                     <span class="hljs-keyword">long</span> delay,
                                                     TimeUnit unit) &#123;...&#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;...&#125;
    <span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;...&#125;
    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Runnable task, T result)</span> </span>&#123;...&#125;
    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> </span>&#123;...&#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;...&#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span> </span>&#123;...&#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> BlockingQueue&lt;Runnable&gt; <span class="hljs-title">getQueue</span><span class="hljs-params">()</span> </span>&#123;...&#125;
    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayedWorkQueue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">Runnable</span>&gt;</span>
<span class="hljs-class">            <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">Runnable</span>&gt; </span>&#123;...&#125;
<span class="hljs-comment">//......</span>
&#125;</code></pre></div>

<p>ScheduledThreadPoolExecutor 会把调度的任务（ScheduledFutureTask）放到一个DelayQueue中。下面来看下ScheduledFutureTask主要包含的3个成员变量：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledFutureTask</span>&lt;<span class="hljs-title">V</span>&gt;</span>
<span class="hljs-class">        <span class="hljs-keyword">extends</span> <span class="hljs-title">FutureTask</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">RunnableScheduledFuture</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequenceNumber;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> time;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> period;
...
&#125;</code></pre></div>

<p>1、long型成员变量time：表示这个任务将要执行的具体时间；</p>
<p>2、long型成员变量sequenceNumber，表示这个任务被添加到ScheduledThreadPoolExecutor中的序号；</p>
<p>3、long型成员变量period，表示任务执行的间隔周期。</p>
<p>DelayQueue 封装了一个 PriorityQueue，这个 PriorityQueue 会对队列中的 ScheduledEutureTask 进行排序。排序时，time 小的排在前面（时间早的任务将被先执行）。如果两个 ScheduledFutureTask 的 time 相同，就比较 sequenceNumber，sequenceNumber 小的排在前面，也就是说，如果两个任务的执行时间相同，那么先执行提交早的任务。</p>
<p>下图所示的是：ScheduledThreadPoolExecutor 中的线程1执行某个周期任务的4个步骤：</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530203014.png" srcset="/img/loading.gif" alt="image-20210530203014524"></p>
<p>1、线程1从 DelayQueue 中获取已到期的 ScheduledFutureTask（DealyQueue.take()）。到其任务是指 ScheduledFutureTask 的 time 大于等于当前时间；</p>
<p>2、线程1执行这个 ScheduledFutureTask；</p>
<p>3、线程1修改 ScheduledFutureTask 的 time 变量为下次将要被执行的时间；</p>
<p>4、线程1把这个修改 time 之后的 ScheduledFutureTask 放回 DelayQueue 中（DelayQueue.add()）。</p>
<p>下面就看下DelayQueue.take()方法的源代码实现：【在源代码中：DelayQueue 就是 DelayedWorkQueue】</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayedWorkQueue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">Runnable</span>&gt;<span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">Runnable</span>&gt; </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> RunnableScheduledFuture <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        <span class="hljs-comment">// 获取lock</span>
        <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;
        lock.lockInterruptibly();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">for</span> (;;) &#123;
                RunnableScheduledFuture first = queue[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 获取任务</span>
                <span class="hljs-keyword">if</span> (first == <span class="hljs-keyword">null</span>)
                    available.await(); <span class="hljs-comment">// 如果队列为空，则等待</span>
                <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-keyword">long</span> delay = first.getDelay(TimeUnit.NANOSECONDS);
                    <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>)
                        <span class="hljs-keyword">return</span> finishPoll(first);
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (leader != <span class="hljs-keyword">null</span>)
                        available.await();
                    <span class="hljs-keyword">else</span> &#123;
                        Thread thisThread = Thread.currentThread();
                        leader = thisThread;
                        <span class="hljs-keyword">try</span> &#123;
                            available.awaitNanos(delay);
                        &#125; <span class="hljs-keyword">finally</span> &#123;
                            <span class="hljs-keyword">if</span> (leader == thisThread)
                                leader = <span class="hljs-keyword">null</span>;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-keyword">if</span> (leader == <span class="hljs-keyword">null</span> &amp;&amp; queue[<span class="hljs-number">0</span>] != <span class="hljs-keyword">null</span>)
                available.signal();
            lock.unlock();
        &#125;
    &#125;
&#125;</code></pre></div>

<p>DelayQueue.take()的执行示意图如下所示：</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530203108.png" srcset="/img/loading.gif" alt="image-20210530203108451"></p>
<p>如上图所示的过程，大致可以分为3个步骤：</p>
<p>1、获取Lock；</p>
<p>2、获取周期任务；</p>
<ul>
<li>2.1、如果     PriorityQueue 为空，当前线程到 Condition 中等待，否则执行下面的2.2；</li>
<li>2.2、如果     PriorityQueue 的头元素的 time 时间比当前时间大，到 Condition 中等待到 time 时间，否则执行2.3；</li>
<li>2.3、获取     PriorityQueue 的头元素，如果 PriorityQueue 不为空，则唤醒在 Condition 中等待的所有线程。</li>
</ul>
<p>3、释放Lock。</p>
<p>ScheduledThreadFutureTask 在一个循环中执行步骤2，直到线程从 PriorityQueue 获取到一个元素之后，才会退出无限循环。</p>
<p>下面看下 ScheduledThreadFutureTask 中的线程把 ScheduledFutureTask 放入 DelayQueue 中的过程。下面是 DelayQueue.add() 的源代码实现：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayedWorkQueue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">Runnable</span>&gt;<span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">Runnable</span>&gt; </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(Runnable x)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
        RunnableScheduledFuture e = (RunnableScheduledFuture)x;
        <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">int</span> i = size;
            <span class="hljs-keyword">if</span> (i &gt;= queue.length)
                grow();
            size = i + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;
                queue[<span class="hljs-number">0</span>] = e;
                setIndex(e, <span class="hljs-number">0</span>);
            &#125; <span class="hljs-keyword">else</span> &#123;
                siftUp(i, e);
            &#125;
            <span class="hljs-keyword">if</span> (queue[<span class="hljs-number">0</span>] == e) &#123;
                leader = <span class="hljs-keyword">null</span>;
                available.signal();
            &#125;
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
......
&#125;</code></pre></div>

<p>下图是 DelayQueue.add() 的执行示意图：</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530203204.png" srcset="/img/loading.gif" alt="image-20210530203204118"></p>
<p>如上图所示，添加任务分为3大步骤：</p>
<p>1、获取 Lock；</p>
<p>2、添加任务；</p>
<ul>
<li>2.1、向     PriorityQueue 添加任务；</li>
<li>2.2、如果在上面2.1     中添加的任务是 PriorityQueue 的头元素，则唤醒在 Conditon 中等待的所有线程；</li>
</ul>
<p>3、释放 Lock。</p>
<p><strong>4、FutureTask 详解</strong></p>
<p>Future 接口和实现 Future 接口的 FutureTask 类，代表异步计算的结果。</p>
<p><strong>4.1、FutureTask 简介</strong></p>
<p>FutureTask 除了实现了 Future 接口外，还实现了 Runnable接口。那么我们就先看下这两个接口的内部结构。</p>
<p><strong>Future 接口的内部结构</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">cancel</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> mayInterruptIfRunning)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCancelled</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;
    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span>
<span class="hljs-function">            <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;
&#125;</code></pre></div>

<p><strong>Runnable 接口的内部结构</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;  
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;  
&#125;</code></pre></div>

<p><strong>1、未启动：</strong>FutureTask.run()方法还没有被执行之前，FutureTask 处于未启动状态。当创建一个 FutureTask，且没有执行 FutureTask.run() 方法之前，这个 FutureTask 处于未启动状态；</p>
<p><strong>2、已启动：</strong>FutureTask.run()方法被执行的过程中，FutureTask 处于已启动状态；</p>
<p><strong>3、已完成：</strong>FutureTask.run()方法执行完成后正常结束，或被取消（FutureTask.cancel(…)），或执行FutureTask.run()方法时抛出异常而异常结束，FutureTask 处于已完成状态。</p>
<p>FutureTask 的状态迁移的示意图如下所示：</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530203308.png" srcset="/img/loading.gif" alt="image-20210530203308304"></p>
<p>FutureTask 的 get 和 cancel 的执行示意图如下所示：</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530203414.png" srcset="/img/loading.gif" alt="image-20210530203414523"></p>
<p><strong>4.2、FutureTask 的实现</strong></p>
<p>先看下 FutureTask 的内部结构：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FutureTask</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">RunnableFuture</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;

    <span class="hljs-comment">// 构造函数1 Callable</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FutureTask</span><span class="hljs-params">(Callable&lt;V&gt; callable)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (callable == <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
        sync = <span class="hljs-keyword">new</span> Sync(callable);
    &#125;

    <span class="hljs-comment">// 构造函数2 Runnable</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> </span>&#123;
        sync = <span class="hljs-keyword">new</span> Sync(Executors.callable(runnable, result));
    &#125;

    <span class="hljs-comment">// 调用的是sync中的innerCancel方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">cancel</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;
        <span class="hljs-keyword">return</span> sync.innerCancel(mayInterruptIfRunning);
    &#125;

    <span class="hljs-comment">// 调用的是sync中的innerGet方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException </span>&#123;
        <span class="hljs-keyword">return</span> sync.innerGet();
    &#125;

    <span class="hljs-comment">// 调用的是sync中的innerGet方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;
<span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;
            <span class="hljs-keyword">return</span> sync.innerGet(unit.toNanos(timeout));
        &#125;
        <span class="hljs-comment">// 调用的是sync中的innerRun方法</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span> <span class="hljs-params">()</span> </span>&#123;
            sync.innerRun();
        &#125;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;...
        &#125;
        <span class="hljs-comment">// .......</span>
    &#125;
&#125;</code></pre></div>

<p>从 FutureTask 的源码中可以看出来，它的实现是基于 AbstractQueuedSynchronizer 。AQS 是一个同步框架，它提供通用机制来原子性管理同步状态、阻塞和唤醒线程，以及维护被阻塞线程的队列。基于 AQS 实现的同步器包括：ReentrantLock、Semaphore、ReentrantReadWriteLock、CountDownLatch 和 FutureTask。</p>
<p>每一个基于 AQS 实现的同步器都会包含两种类型的操作，如下：</p>
<p>1、至少一个 acquire 操作：这个操作阻塞调用线程，除非 / 直到 AQS 的状态允许这个线程继续执行。 FutureTask 的 acquire 操作为 get() / get(long timeout, TimeUnit unit)方法调用；</p>
<p>2、至少一个 release 操作：这个操作改变 AQS 的状态，改变后的状态可允许一个或多个阻塞线程被解除阻塞。FutureTask 的 release 操作包括 run() 方法和 cancel(…) 方法。</p>
<p>基于“复合优先继承”的原则，FutureTask 声明了一个内部私有的继承于 AQS 的子类 Sync，对 FutureTask 所有公有方法的调用都会委托给这个内部子类。</p>
<p>AQS 被作为“模板方法模式”的基础类提供给 FutureTask 的内部子类 Sync，这个内部子类只需要实现状态检测和状态更新的方法即可，这些方法将控制 FutureTask 的获取和释放操作。具体来说，Sync实现了 AQS 的 tryAcquireShared(int)方法和 tryReleaseShared(int)方法，Sync 通过这两个方法来检查和更新同步状态。</p>
<p>FutureTask 的设计示意图如下图所示：</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210530203513.png" srcset="/img/loading.gif" alt="image-20210530203513078"></p>
<p>如图所示，Sync 是 FutureTask 的内部私有类，它继承自 AQS。创建 FutureTask 时会创建内部私有的成员对象 Sync，FutureTask 所有的公有方法都直接委托给了内部私有的 Sync。</p>
<p>下面对 FutureTask 中主要的几个方法进行调用过程分析：</p>
<p><strong>4.2.1、FutureTask.get() 方法</strong> </p>
<p>第1步：调用 FutureTask 中的 get() 方法</p>
<div class="hljs"><pre><code class="hljs javascript">public V <span class="hljs-keyword">get</span>() throws  InterruptedException, ExecutionException &#123;
	<span class="hljs-keyword">return</span> sync.innerGet();
&#125;</code></pre></div>

<p>从源码中很清楚的看到 get() 方法内部是由 sync 的 innerGet()方法实现的。 </p>
<p>第2步：调用 Sync 中的 innerGet()方法</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function">V <span class="hljs-title">innerGet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException </span>&#123;
    acquireSharedInterruptibly(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (getState() == CANCELLED)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CancellationException();
    <span class="hljs-keyword">if</span> (exception != <span class="hljs-keyword">null</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ExecutionException(exception);
    <span class="hljs-keyword">return</span> result;
&#125;</code></pre></div>

<p>第3步：调用 AQS.acquireSharedInterruptibly(int args)方法。 </p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
    <span class="hljs-keyword">if</span> (Thread.interrupted())
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();
    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)
        doAcquireSharedInterruptibly(arg);
&#125;</code></pre></div>

<p>第4步：调用Sync.tryAcquireShared方法</p>
<p>第5步：调用 AQS.doAcquireSharedIntrruptibly方法</p>
<p>这个方法首先会在子类 Sync 中实现的 tryAcquireShared()方法来判断 acquire 操作是否可以成功，acquire 操作可以成功的条件为：state 为执行完成状态RAN 或取消状态 CANCELLED，且 runner 不为null。</p>
<p>【至于tryAcquireShared和doAcquireSharedIntrruptibly方法，这里不再做源码分析了，前面文章已经分析过多次了】</p>
<p>如果成功则立即返回，如果失败则到线程等待队列中去等待其他线程执行 release 操作。</p>
<p>当其他线程执行 release 操作（比如：FutureTask.run() 或 FutureTask.cancel(…)）唤醒当前线程后，当前线程再次执行 tryAcquiredShared() 将返回正值 1，当前线程将离开线程等待队列，并唤醒它的后继节点线程。</p>
<p>最后返回计算的结果或者抛出异常。</p>
<p><strong>4.2.2、FutureTask.run() 方法</strong></p>
<p>第1步：调用了 FutureTask.run() 方法</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
	sync.innerRun();
&#125;</code></pre></div>

<p>第2步：调用 Sync.innerRun() 方法 </p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">innerRun</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">if</span> (!compareAndSetState(READY, RUNNING))
        <span class="hljs-keyword">return</span>;
    runner = Thread.currentThread();
    <span class="hljs-keyword">if</span> (getState() == RUNNING) &#123; <span class="hljs-comment">// recheck after setting thread</span>
        V result;
        <span class="hljs-keyword">try</span> &#123;
            result = callable.call();
        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;
            setException(ex);
            <span class="hljs-keyword">return</span>;
        &#125;
        set(result);
    &#125; <span class="hljs-keyword">else</span> &#123;
        releaseShared(<span class="hljs-number">0</span>); <span class="hljs-comment">// cancel</span>
    &#125;
&#125;</code></pre></div>

<p>第3步：调用AQS.releaseShared(int args)方法</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;
        doReleaseShared();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
&#125;</code></pre></div>

<p>AQS.releaseShared(int args)首先会回调子类 Sync 中实现的 tryReleaseShared(int args)方法来执行 release操作。</p>
<p>第4步：调用 Sync.tryReleaseShared(int args) 方法</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ignore)</span> </span>&#123;
	runner = <span class="hljs-keyword">null</span>;
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&#125;</code></pre></div>

<p>设置允许任务线程 runner 为 null，然后返回 true。</p>
<p>第5步：调用AQS.doReleaseShared() 方法</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">for</span> (;;) &#123;
        Node h = head;
        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;
            <span class="hljs-keyword">int</span> ws = h.waitStatus;
            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;
                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))
                    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop to recheck cases</span>
                unparkSuccessor(h);
            &#125;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;
                    !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))
                <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop on failed CAS</span>
        &#125;
        <span class="hljs-keyword">if</span> (h == head) <span class="hljs-comment">// loop if head changed</span>
            <span class="hljs-keyword">break</span>;
    &#125;
&#125;</code></pre></div>

<p>唤醒线程等待队列中的第一个线程。</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/">语言相关</a>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/Java%E8%BF%9B%E9%98%B6/">Java进阶</a>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/Java%E8%BF%9B%E9%98%B6/Java%E5%B9%B6%E5%8F%91/">Java并发</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java%E5%B9%B6%E5%8F%91/">Java并发</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2021/05/30/Fork-Join%E6%A1%86%E6%9E%B6/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Fork/Join框架</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2021/05/30/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9/">
                        <span class="hidden-mobile">并发知识点</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <script defer src="https://utteranc.es/client.js"
          repo="gavin-yyj/commit-utterance"
          issue-term="pathname"
  
          theme="github-light"
          crossorigin="anonymous"
  >
  </script>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Executor框架&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
