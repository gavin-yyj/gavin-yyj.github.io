<!DOCTYPE html>
<html lang="zh-CH">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="光说不做假把式">
  <meta name="author" content="杨玉杰">
  <meta name="keywords" content="">
  <title>Spring官方文档学习 - 杨玉杰|个人博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/agate.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>杨玉杰|个人博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友情链接
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bgi.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2021-06-14 08:25">
      June 14, 2021 am
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      95
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <p>官方文档链接：<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/index.html" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/reference/html/index.html</a></p>
<p>源码下载（5.3.8版本）：<a href="https://github.com/spring-projects/spring-framework/releases/tag/v5.3.8" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework/releases/tag/v5.3.8</a></p>
<p>编译前先安装gradle：<a href="https://gradle.org/releases/" target="_blank" rel="noopener">https://gradle.org/releases/</a> </p>
<p>配置环境变量</p>
<p>编译：将下载好的代码压缩包解压后，进入主目录，打开cmd运行：gradlew :spring-oxm:compileTestJava</p>
<div class="hljs"><pre><code class="hljs reasonml">Welcome <span class="hljs-keyword">to</span> Gradle <span class="hljs-number">6.8</span>.<span class="hljs-number">3</span>!

Here are the highlights <span class="hljs-keyword">of</span> this release:

 - Faster Kotlin DSL script compilation
 - Vendor selection for Java toolchains
 - Convenient execution <span class="hljs-keyword">of</span> tasks <span class="hljs-keyword">in</span> composite builds
 - Consistent dependency resolution

For more details see https:<span class="hljs-comment">//docs.gradle.org/6.8.3/release-notes.html</span>

Starting a Gradle Daemon (subsequent builds will be faster)
fatal: not a git repository (<span class="hljs-keyword">or</span> any <span class="hljs-keyword">of</span> the parent directories): .git

Deprecated Gradle features were used <span class="hljs-keyword">in</span> this build, making it incompatible <span class="hljs-keyword">with</span> Gradle <span class="hljs-number">7.0</span>.
Use '--warning-mode all' <span class="hljs-keyword">to</span> show the individual deprecation warnings.
See https:<span class="hljs-comment">//docs.gradle.org/6.8.3/userguide/command_line_interface.html#sec:command_line_warnings</span>

BUILD SUCCESSFUL <span class="hljs-keyword">in</span> <span class="hljs-number">4</span>m <span class="hljs-number">50</span>s
<span class="hljs-number">44</span> actionable tasks: <span class="hljs-number">25</span> executed, <span class="hljs-number">19</span> from cache
Build scan background action failed.
org.gradle.process.internal.ExecException: Process 'command 'git'' finished <span class="hljs-keyword">with</span> non-zero exit value <span class="hljs-number">128</span>
        at org.gradle.process.internal.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DefaultExecHandle$ExecResultImpl</span>.</span></span><span class="hljs-keyword">assert</span><span class="hljs-constructor">NormalExitValue(DefaultExecHandle.<span class="hljs-params">java</span>:414)</span>
        at org.gradle.process.internal.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DefaultExecAction</span>.</span></span>execute(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DefaultExecAction</span>.</span></span>java:<span class="hljs-number">38</span>)
        at org.gradle.process.internal.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DefaultExecActionFactory</span>.</span></span>exec(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DefaultExecActionFactory</span>.</span></span>java:<span class="hljs-number">175</span>)
        at io.spring.ge.conventions.gradle.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">WorkingDirectoryProcessOperations</span>.</span></span>exec(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">WorkingDirectoryProcessOperations</span>.</span></span>java:<span class="hljs-number">45</span>)
        at io.spring.ge.conventions.gradle.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ProcessOperationsProcessRunner</span>.</span></span>run(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ProcessOperationsProcessRunner</span>.</span></span>java:<span class="hljs-number">41</span>)
        at io.spring.ge.conventions.core.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BuildScanConventions</span>.</span></span>run(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BuildScanConventions</span>.</span></span>java:<span class="hljs-number">166</span>)
        at io.spring.ge.conventions.core.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BuildScanConventions</span>.</span></span>add<span class="hljs-constructor">GitMetadata(BuildScanConventions.<span class="hljs-params">java</span>:113)</span>
        at io.spring.ge.conventions.gradle.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GradleConfigurableBuildScan</span>.</span></span>lambda<span class="hljs-constructor">$background$0(GradleConfigurableBuildScan.<span class="hljs-params">java</span>:104)</span>
        at com.gradle.enterprise.gradleplugin.internal.extension.b<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">$3</span>.</span></span>run(SourceFile:<span class="hljs-number">101</span>)
        at java.util.concurrent.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors$RunnableAdapter</span>.</span></span>call(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span>java:<span class="hljs-number">511</span>)
        at java.util.concurrent.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FutureTask</span>.</span></span>run(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FutureTask</span>.</span></span>java:<span class="hljs-number">266</span>)
        at java.util.concurrent.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ThreadPoolExecutor</span>.</span></span>run<span class="hljs-constructor">Worker(ThreadPoolExecutor.<span class="hljs-params">java</span>:1149)</span>
        at java.util.concurrent.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ThreadPoolExecutor$Worker</span>.</span></span>run(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ThreadPoolExecutor</span>.</span></span>java:<span class="hljs-number">624</span>)
        at java.lang.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>run(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>java:<span class="hljs-number">748</span>)</code></pre></div>

<h1 id="1-IoC容器-－５-３-８"><a href="#1-IoC容器-－５-３-８" class="headerlink" title="1. IoC容器　－５.３.８"></a>1. IoC容器　－５.３.８</h1><h2 id="1-1-Spring-IoC容器和bean的介绍"><a href="#1-1-Spring-IoC容器和bean的介绍" class="headerlink" title="1.1 Spring IoC容器和bean的介绍"></a>1.1 Spring IoC容器和bean的介绍</h2><p>对象只能通过构造函数参数、工厂方法的参数或在对象实例被构造以及从工厂方法返回后设置的属性来定义它们的依赖关系(即它们使用的其他对象)。然后，容器在创建bean时注入这些依赖项。这个过程基本上是bean本身通过直接构造类或诸如Service Locator模式这样的机制来控制其依赖项的实例化或位置的逆过程(因此得名“控制反转”)。</p>
<p><code>org.springframework.beans</code>和<code>org.springframework.context</code>包是Spring框架的IoC容器的基础。BeanFactory接口提供了能够管理任何类型对象的高级配置机制。ApplicationContext是BeanFactory的一个子接口，添加了更多特定于企业的功能。</p>
<p>bean是由Spring IoC容器实例化、组装和管理的对象。bean及其之间的依赖关系反映在容器使用的配置元数据中。</p>
<h2 id="1-2-容器概述"><a href="#1-2-容器概述" class="headerlink" title="1.2 容器概述"></a>1.2 容器概述</h2><p>Applicationcontext接口表示Spring IoC容器，负责实例化、配置和组装bean。容器通过读取配置元数据获得关于实例化、配置和组装哪些对象的指令。配置元数据用XML、Java注释或Java代码表示。它可以让您表达组成应用程序的对象以及这些对象之间丰富的相互依赖关系。</p>
<p>Spring提供了ApplicationContext接口的几个实现。在独立应用程序中，通常会创建ClassPathXmlApplicationContext或FileSystemXmlApplicationContext的实例。虽然XML是定义配置元数据的传统格式，但是您可以通过提供少量XML配置以声明方式支持这些额外的元数据格式，指示容器使用Java注释或代码作为元数据格式。</p>
<p>在大多数应用程序场景中，不需要显式的用户代码来实例化Spring IoC容器的一个或多个实例。例如，在一个web应用程序场景中，在应用程序的web. XML文件中简单的8行(大约)web描述符XML样本就足够了。</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span></code></pre></div>

<p>下图显示了Spring如何工作的高级视图。应用程序类与配置元数据相结合，这样在ApplicationContext创建并初始化之后，您就拥有了一个配置完整且可执行的系统或应用程序。</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210620151320.png" srcset="/img/loading.gif" alt="image-20210620151320785"></p>
<h3 id="1-2-1-配置元数据"><a href="#1-2-1-配置元数据" class="headerlink" title="1.2.1 配置元数据"></a>1.2.1 配置元数据</h3><p>如上图所示，Spring IoC容器使用一种配置元数据形式。此配置元数据表示作为应用程序开发人员，您告诉Spring容器如何实例化、配置和组装应用程序中的对象。</p>
<p>配置元数据传统上以一种简单而直观的XML格式提供，本章的大部分内容都使用这种格式来传达Spring IoC容器的关键概念和特性。</p>
<blockquote>
<p>基于 XML 的元数据并不是唯一允许的配置元数据形式。 Spring IoC 容器本身与实际写入此配置元数据的格式完全分离。 现在，许多开发人员为他们的 Spring 应用程序选择基于 Java 的配置。</p>
</blockquote>
<ul>
<li>spring2.5引入了对基于注释的配置元数据的支持，具体使用在1.9节进行介绍。</li>
<li>Spring3.0引入了基于Java的配置，更多知识在1.12进行详细说明。</li>
</ul>
<p>Spring 配置包含至少一个容器必须管理的 bean 定义。 基于 XML 的配置元数据将这些 bean 配置为顶级&lt;beans/&gt; 元素内的 &lt;bean/&gt; 元素。 Java 配置通常在@Configuration 类中使用@Bean 注释的方法。</p>
<p>这些bean定义对应于组成应用程序的实际对象。通常，您需要定义服务层对象、数据访问对象(DAO)、表示对象(如Struts Action实例)、基础设施对象(如Hibernate SessionFactories、JMS队列)等等。通常，不会在容器中配置细粒度的域对象，因为创建和加载域对象通常是 DAO 和业务逻辑的责任。但是，您可以使用Spring与AspectJ的集成来配置在IoC容器控制之外创建的对象【见5.10】。</p>
<p>下面的例子展示了基于xml的配置元数据的基本结构:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>&gt;</span>  
        <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- more bean definitions go here --&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<ul>
<li>id属性是标识单个bean定义的字符串。</li>
<li>class属性定义bean的类型并使用完全限定的类名。</li>
</ul>
<p>id 属性的值是指协作对象。 此示例中未显示用于引用协作对象的 XML。 有关更多信息，请参阅依赖项【见1.4】。</p>
<h3 id="1-2-2-容器实例化"><a href="#1-2-2-容器实例化" class="headerlink" title="1.2.2 容器实例化"></a>1.2.2 容器实例化</h3><p>提供给 ApplicationContext 构造函数的一个或多个位置路径是资源字符串，它允许容器从各种外部资源（例如本地文件系统、Java CLASSPATH 等）加载配置元数据。</p>
<div class="hljs"><pre><code class="hljs java">ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"services.xml"</span>, <span class="hljs-string">"daos.xml"</span>);</code></pre></div>

<p>在您了解 Spring 的 IoC 容器之后，您可能想了解更多关于 Spring 的resource概念【见2】，它提供了一种从 URI 语法中定义的位置读取 InputStream 的便捷机制。特别是，资源路径用于构造应用程序上下文，如应用程序上下文和资源路径中所述【见2.8】。</p>
<p>以下示例显示了服务层对象(services.xml)配置文件:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- services --&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"petStore"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.samples.jpetstore.services.PetStoreServiceImpl"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"accountDao"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"accountDao"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"itemDao"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"itemDao"</span>/&gt;</span>
        <span class="hljs-comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- more bean definitions for services go here --&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<p>下面的例子显示了数据访问对象dao .xml文件:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountDao"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao"</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"itemDao"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.samples.jpetstore.dao.jpa.JpaItemDao"</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- more bean definitions for data access objects go here --&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<p>在上面的示例中，服务层由PetStoreServiceImpl类和JpaAccountDao和JpaItemDao(基于JPA对象关系映射标准)类型的两个数据访问对象组成。属性名元素引用JavaBean属性的名称，ref元素引用另一个bean定义的名称。id和ref元素之间的这种链接表示了协作对象之间的依赖关系。有关配置对象依赖关系的详细信息，请参见依赖关系【见1.4】。</p>
<h4 id="编写基于xml的配置元数据"><a href="#编写基于xml的配置元数据" class="headerlink" title="编写基于xml的配置元数据"></a>编写基于xml的配置元数据</h4><p>让bean定义跨越多个XML文件是很有用的。通常，每个单独的XML配置文件代表体系结构中的一个逻辑层或模块。</p>
<p>可以使用应用程序上下文构造函数从所有这些XML片段加载bean定义。此构造函数接受多个Resource位置，如前一节所示。或者，使用一次或多次&lt;import/&gt;元素从另一个或多个文件加载bean定义。下面的例子展示了如何做到这一点:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"services.xml"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"resources/messageSource.xml"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"/resources/themeSource.xml"</span>/&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bean1"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bean2"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<p>在前面的示例中，外部bean定义从三个文件加载:services.xml、messageSource.xml和themeSource.xml。</p>
<p>所有位置路径都相对于执行导入的定义文件，因此services.xml必须与执行导入的文件位于相同的目录或类路径位置，而messageSource.xml和themeSource.xml必须位于导入文件位置下面的资源位置。如您所见，前导斜杠被忽略。 但是，鉴于这些路径是相对的，最好根本不使用斜杠。 根据 Spring Schema，被导入文件的内容，包括顶级 &lt;beans/&gt; 元素，必须是有效的 XML bean 定义。</p>
<blockquote>
<p>可以使用相对的”.. /”路径来引用父目录中的文件，但不建议这样做。这样做将创建对当前应用程序之外的文件的依赖关系。特别是，不建议对classpath: url(例如，classpath:../services.xml)使用此引用，运行时解析过程选择“最近的”类路径根，然后查看其父目录。类路径配置更改可能导致选择不同的、不正确的目录。</p>
<p>您可以始终使用完全限定的资源位置，而不是相对路径:例如，文件:C:/config/services.xml或类路径:/config/services.xml。但是，请注意，您是将应用程序的配置耦合到特定的绝对位置。</p>
<p>通常，最好为这些绝对位置保留一个间接位置——例如，通过在运行时根据JVM系统属性解析的“${…}”占位符。</p>
</blockquote>
<p>命名空间本身提供了导入指令特性。除了普通bean定义之外，Spring提供的XML名称空间中还提供了更多的配置特性——例如，上下文和util名称空间。</p>
<h3 id="1-2-3-使用容器"><a href="#1-2-3-使用容器" class="headerlink" title="1.2.3 使用容器"></a>1.2.3 使用容器</h3><p>ApplicationContext是一个高级工厂的接口，该工厂能够维护不同bean及其依赖项的注册表。通过使用T getBean(String name, Class&lt;T&gt; requiredType)方法，您可以检索bean的实例。</p>
<p>ApplicationContext允许你读取并访问bean定义，如下面的例子所示:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// create and configure beans</span>
ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"services.xml"</span>, <span class="hljs-string">"daos.xml"</span>);

<span class="hljs-comment">// retrieve configured instance</span>
PetStoreService service = context.getBean(<span class="hljs-string">"petStore"</span>, PetStoreService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

<span class="hljs-comment">// use configured instance</span>
List&lt;String&gt; userList = service.getUsernameList();</code></pre></div>

<p>最灵活的变体是GenericApplicationContext与reader委托结合使用——例如，XML文件使用XmlBeanDefinitionReader，如下例所示:</p>
<div class="hljs"><pre><code class="hljs java">GenericApplicationContext context = <span class="hljs-keyword">new</span> GenericApplicationContext();
<span class="hljs-keyword">new</span> XmlBeanDefinitionReader(context).loadBeanDefinitions(<span class="hljs-string">"services.xml"</span>, <span class="hljs-string">"daos.xml"</span>);
context.refresh();</code></pre></div>

<p>您可以在相同的ApplicationContext上混合和匹配这样的读取器委托，从不同的配置源读取bean定义。</p>
<p>您可以使用 getBean 来检索 bean 的实例，ApplicationContext 接口也提供了一些其他方法来检索 bean，但理想情况下，您的应用程序代码永远不应该使用它们。实际上，您的应用程序代码根本<strong>不应该调用getBean()方法</strong>，因此根本不依赖于Spring api。</p>
<p>例如，Spring与web框架的集成为各种web框架组件(如控制器和JSF管理的bean)提供了依赖注入，允许您通过元数据(如<strong>自动装配注释</strong>)声明对特定bean的依赖。</p>
<h2 id="1-3-Bean概述"><a href="#1-3-Bean概述" class="headerlink" title="1.3 Bean概述"></a>1.3 Bean概述</h2><p>Spring IoC 容器管理一个或多个 bean。 这些 bean 是使用您提供给容器的配置元数据创建的（例如，以 XML &lt;bean/&gt; 定义的形式）。</p>
<p>在容器本身内，这些 bean 定义表示为 BeanDefinition 对象，除其他信息外，还包含以下元数据：</p>
<ul>
<li>包限定的类名:通常是定义的bean的实际实现类。</li>
<li>Bean行为配置元素，声明Bean在容器中应该如何行为(范围、生命周期回调，等等)。</li>
<li>对 bean 执行其工作所需的其他 bean 的引用，这些引用也称为协作者或依赖项。</li>
<li>要在新创建的对象中设置的其他配置 — 例如，池的大小限制或在管理连接池的 bean 中使用的连接数。</li>
</ul>
<p>此元数据转换为组成每个bean定义的一组属性。下表描述了这些属性:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>详细介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Class</td>
<td>[实例化Bean](#1.3.2 实例化Bean)</td>
</tr>
<tr>
<td>Name</td>
<td><a href="#1.3.1命名Bean">命名Bean</a></td>
</tr>
<tr>
<td>Scope</td>
<td>[Bean范围](#1.5 Bean范围)</td>
</tr>
<tr>
<td>Constructor arguments</td>
<td>[依赖注入](#1.4.1 依赖注入)</td>
</tr>
<tr>
<td>Properties</td>
<td>[依赖注入](#1.4.1 依赖注入)</td>
</tr>
<tr>
<td>Autowiring mode</td>
<td>[自动装配协作者](#1.4.5 自动装配协作者)</td>
</tr>
<tr>
<td>Lazy initialization mode</td>
<td>[延迟初始化的Bean](#1.4.4 延迟初始化的Bean)</td>
</tr>
<tr>
<td>Initialization method</td>
<td><a href="#初始化回调">初始化回调</a></td>
</tr>
<tr>
<td>Destruction method</td>
<td><a href="#破坏回调">破坏回调</a></td>
</tr>
</tbody></table>
<p>除了包含有关如何创建特定 bean 信息的 bean 定义之外，ApplicationContext 的实现类还允许注册在容器外部（由用户创建）创建的现有对象。</p>
<p>这是通过 getBeanFactory() 方法访问 ApplicationContext 的 BeanFactory 来完成的，该方法返回 BeanFactory  的实现类DefaultListableBeanFactory。DefaultListableBeanFactory 通过 registerSingleton(..) 和 registerBeanDefinition(..) 方法支持这种注册。 但是，典型的应用程序仅使用常规 bean 定义元数据来定义 bean。</p>
<blockquote>
<p>Bean 元数据和手动提供的单例实例需要尽早注册，以便容器在自动装配和其他内省步骤中正确推理它们。</p>
<p>虽然在某种程度上支持覆盖现有的元数据和现有的单例实例，但是在运行时注册新bean(与对工厂的实时访问同时进行)并没有得到官方支持，并且可能导致并发访问异常、bean容器中的不一致状态，或者两者都有。</p>
</blockquote>
<h3 id="1-3-1-命名Bean"><a href="#1-3-1-命名Bean" class="headerlink" title="1.3.1 命名Bean"></a>1.3.1 命名Bean</h3><p>每个bean都有一个或多个标识符。这些标识符在装载bean的容器中必须是唯一的。一个bean通常只有一个标识符。但是，如果需要一个以上的名字，则可以将额外的名字视为别名。</p>
<p>在基于xml的配置元数据中，可以使用id属性、name属性或两者来指定bean标识符。id属性允许您指定一个id。通常，这些名称是字母数字(‘myBean’， ‘someService’等)，但它们也可以包含特殊字符。如果希望为bean引入其他别名，还可以在name属性中指定它们，用逗号(，)、分号(;)或空格分隔。在 Spring 3.1 之前的版本中，id 属性被定义为 xsd:ID 类型，它限制了可能的字符。 从 3.1 开始，它被定义为 xsd:string 类型。 请注意，bean id 唯一性仍由容器强制执行，但不再由 XML 解析器强制执行。</p>
<p>您不需要为bean提供名称或id。如果您没有显式地提供名称或id，容器将为该bean生成唯一的名称。但是，如果希望通过使用ref元素或Service Locator样式查找按名称引用该bean，则必须提供名称。不提供名称的动机与使用<a href="#内部Bean">内部bean</a>和[自动装配协作者](#1.4.5 自动装配协作者)有关。</p>
<blockquote>
<p>Bean命名约定：</p>
<p>约定是在命名Bean时对实例字段名使用标准Java约定。也就是说，bean名称以小写字母开头，并从那里开始采用驼峰大小写。这些名称的示例包括accountManager、accountService、userDao、loginController等。</p>
<p>保持Bean命名一致性可以使您的配置更易于阅读和理解。另外，如果您使用Spring AOP，那么将通知应用到名称相关的一组bean时，它会有很大帮助。</p>
</blockquote>
<p>通过在类路径中扫描组件，Spring为未命名组件生成bean名，遵循前面描述的规则:本质上，采用简单的类名并将其初始字符转换为小写。</p>
<p>但是，在特殊情况下，当有多个字符且第一个和第二个字符都是大写时，保留原来的大小写。这些规则与java.beans.Introspector.decapitalize (Spring在这里使用的)定义的规则相同。</p>
<h4 id="在Bean定义之外对Bean进行别名处理"><a href="#在Bean定义之外对Bean进行别名处理" class="headerlink" title="在Bean定义之外对Bean进行别名处理"></a>在Bean定义之外对Bean进行别名处理</h4><p>在 bean 定义本身中，您可以为 bean 提供多个名称，方法是使用 id 属性指定的最多一个名称和 name 属性中任意数量的其他名称的组合。这些名称可以是相同bean的等效别名，在某些情况下非常有用，例如通过使用特定于该组件本身的bean名称，让应用程序中的每个组件引用公共依赖项。</p>
<p>但是，指定bean实际定义的所有别名并不总是足够的。有时需要为在其他地方定义的bean引入别名。在大型系统中，配置在每个子系统之间分割，每个子系统都有自己的对象定义集，这种情况很常见。在基于xml的配置元数据中，可以使用&lt;alias/&gt;元素来实现这一点。下面的例子展示了如何做到这一点:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"fromName"</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"toName"</span>/&gt;</span></code></pre></div>

<p>在这种情况下，在使用这个别名定义之后，命名为fromName的bean(在同一个容器中)也可以称为toName。</p>
<p>例如，子系统A的配置元数据可以通过subsystemA-dataSource的名称引用一个数据源。子系统B的配置元数据可以通过subsystemB-dataSource的名称来引用一个数据源。当组合使用这两个子系统的主应用程序时，主应用程序通过myApp-dataSource的名称引用数据源。要让这三个名称都引用同一个对象，可以在配置元数据中添加以下别名定义:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"myApp-dataSource"</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"subsystemA-dataSource"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"myApp-dataSource"</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"subsystemB-dataSource"</span>/&gt;</span></code></pre></div>

<p>现在，每个组件和主应用程序都可以通过一个唯一的名称来引用dataSource，这个名称保证不会与任何其他定义冲突(有效地创建了一个名称空间)，但它们引用的是同一个bean。</p>
<blockquote>
<p>如果使用javaconconfiguration，可以使用@Bean注释提供别名。详细信息请参见<a href="#1.12.3使用@Bean注释">使用@Bean注释</a>。</p>
</blockquote>
<h3 id="1-3-2-实例化Bean"><a href="#1-3-2-实例化Bean" class="headerlink" title="1.3.2 实例化Bean"></a>1.3.2 实例化Bean</h3><p>bean 定义本质上是创建一个或多个对象的方法。 当被询问时，容器会查看命名 bean 的配方，并使用该 bean 定义封装的配置元数据来创建（或获取）实际对象。</p>
<p>如果使用基于xml的配置元数据，则需要指定要在&lt;bean/&gt;元素的class属性，这个class属性通常是强制性的。你可以用以下两种方式之一来使用Class属性:</p>
<ul>
<li>通常，在容器本身通过反射调用构造函数直接创建bean的情况下，指定要构造的bean类，这在某种程度上相当于带有new操作符的Java代码。</li>
<li>指定包含用于创建对象的静态工厂方法的实际类，在不太常见的情况下，容器调用类上的静态工厂方法来创建 bean。 调用静态工厂方法返回的对象类型可能是同一个类，也可能完全是另一个类。</li>
</ul>
<blockquote>
<p>嵌套类命名：</p>
<p>如果您想为嵌套类配置bean定义，您可以使用嵌套类的二进制名称或源名称。</p>
<p>例如，如果您在 com.example 包中有一个名为 SomeThing 的类，并且这个 SomeThing 类有一个名为 OtherThing 的静态嵌套类，则它们可以用美元符号 ($) 或点 (.) 分隔。 因此，bean 定义中类属性的值将是 com.example.SomeThing$OtherThing 或 com.example.SomeThing.OtherThing。</p>
</blockquote>
<h4 id="使用构造函数进行实例化"><a href="#使用构造函数进行实例化" class="headerlink" title="使用构造函数进行实例化"></a>使用构造函数进行实例化</h4><p>当您通过构造函数方法创建 bean 时，所有普通类都可以被 Spring 使用并与 Spring 兼容。 也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式进行编码。 只需指定 bean 类就足够了。 但是，根据您对该特定 bean 使用的 IoC 类型，您可能需要一个默认（空）构造函数。</p>
<p>Spring IoC 容器几乎可以管理您希望它管理的任何类。 它不仅限于管理真正的 JavaBean。 大多数 Spring 用户更喜欢实际的 JavaBeans，它只有一个默认（无参数）构造函数和适当的 setter 和 getter，它们以容器中的属性为模型。 您还可以在容器中拥有更多非 bean 风格的类。 例如，如果您需要使用绝对不符合 JavaBean 规范的遗留连接池，Spring 也可以管理它。</p>
<p>使用基于xml的配置元数据，你可以如下指定你的bean类:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"exampleBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.ExampleBean"</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"anotherExample"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.ExampleBeanTwo"</span>/&gt;</span></code></pre></div>

<p>有关向构造函数提供参数(如果需要)和在对象构造后设置对象实例属性的机制的详细信息，请参见[注入依赖项](＃1.4.1 依赖注入)。</p>
<h4 id="使用静态工厂方法进行实例化"><a href="#使用静态工厂方法进行实例化" class="headerlink" title="使用静态工厂方法进行实例化"></a>使用静态工厂方法进行实例化</h4><p>定义使用静态工厂方法创建的 bean 时，使用 class 属性指定包含静态工厂方法的类，并使用名为 factory-method 的属性指定工厂方法本身的名称。 您应该能够调用此方法（带有可选参数，如下所述）并返回一个活动对象，随后将其视为通过构造函数创建的。 这种 bean 定义的一种用途是在遗留代码中调用静态工厂。</p>
<p>以下 bean 定义指定通过调用工厂方法来创建 bean。 定义中没有指定返回对象的类型（类），只指定包含工厂方法的类。 在这个例子中，createInstance() 方法必须是一个静态方法。 以下示例显示了如何指定工厂方法：</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"clientService"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.ClientService"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"createInstance"</span>/&gt;</span></code></pre></div>

<p>下面的例子展示了一个可以使用前面的bean定义的类:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientService</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ClientService clientService = <span class="hljs-keyword">new</span> ClientService();
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ClientService</span><span class="hljs-params">()</span> </span>&#123;&#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClientService <span class="hljs-title">createInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> clientService;
    &#125;
&#125;</code></pre></div>

<p>有关为工厂方法提供(可选)参数和在从工厂返回对象后设置对象实例属性的机制的详细信息，请参见<a href="#直接值（原语、字符串等）">详细信息中的依赖关系和配置</a>。</p>
<h4 id="使用实例工厂方法进行实例化"><a href="#使用实例工厂方法进行实例化" class="headerlink" title="使用实例工厂方法进行实例化"></a>使用实例工厂方法进行实例化</h4><p>与通过静态工厂方法进行实例化类似，使用实例工厂方法进行实例化会从容器中调用现有 bean 的非静态方法来创建新 bean。 要使用此机制，请将 class 属性留空，并在 factory-bean 属性中指定当前（或父或祖先）容器中 bean 的名称，该容器包含要调用以创建对象的实例方法。 使用 factory-method 属性设置工厂方法本身的名称。 以下示例显示了如何配置此类 bean：</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 工厂bean，它包含一个名为createInstance()的方法 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"serviceLocator"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.DefaultServiceLocator"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 要通过工厂bean创建的bean --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"clientService"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"serviceLocator"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"createClientServiceInstance"</span>/&gt;</span></code></pre></div>

<p>下面的例子显示了相应的类:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultServiceLocator</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ClientService clientService = <span class="hljs-keyword">new</span> ClientServiceImpl();

    <span class="hljs-function"><span class="hljs-keyword">public</span> ClientService <span class="hljs-title">createClientServiceInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> clientService;
    &#125;
&#125;</code></pre></div>

<p>一个工厂类也可以包含多个工厂方法，如下面的例子所示:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"serviceLocator"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.DefaultServiceLocator"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"clientService"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"serviceLocator"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"createClientServiceInstance"</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"serviceLocator"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"createAccountServiceInstance"</span>/&gt;</span></code></pre></div>

<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultServiceLocator</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ClientService clientService = <span class="hljs-keyword">new</span> ClientServiceImpl();

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AccountService accountService = <span class="hljs-keyword">new</span> AccountServiceImpl();

    <span class="hljs-function"><span class="hljs-keyword">public</span> ClientService <span class="hljs-title">createClientServiceInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> clientService;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> AccountService <span class="hljs-title">createAccountServiceInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> accountService;
    &#125;
&#125;</code></pre></div>

<p>这种方法表明工厂bean本身可以通过依赖项注入(DI)进行管理和配置。请参阅<a href="#直接值（原语、字符串等）">详细的依赖关系和配置。</a></p>
<blockquote>
<p>在 Spring 文档中，“工厂 bean”是指在 Spring 容器中配置并通过实例或静态工厂方法创建对象的 bean。 相比之下，FactoryBean（注意大写）指的是特定于 Spring 的 FactoryBean 实现类。</p>
</blockquote>
<h4 id="确定Bean的运行时类型"><a href="#确定Bean的运行时类型" class="headerlink" title="确定Bean的运行时类型"></a>确定Bean的运行时类型</h4><p>确定特定bean的运行时类型是非常重要的。bean元数据定义中的指定类只是一个初始类引用，可能与声明的工厂方法或FactoryBean类相结合，这可能导致bean的不同运行时类型，或者在实例级工厂方法的情况下，根本没有设置。此外，AOP代理可以用一个基于接口的代理来包装一个bean实例，并有限地暴露目标bean的实际类型(仅仅是实现的接口)。</p>
<p>要了解特定bean的实际运行时类型，推荐使用BeanFactory.getType来调用指定的bean名。这考虑了上述所有情况，并返回BeanFactory.getBean 调用将为相同 bean 名称返回的对象类型。</p>
<h2 id="1-4-依赖"><a href="#1-4-依赖" class="headerlink" title="1.4 依赖"></a>1.4 依赖</h2><p>典型的企业应用程序不包含单个对象（或 Spring 用语中的 bean）。 即使是最简单的应用程序也有一些对象，它们协同工作以呈现最终用户所看到的连贯应用程序。下一节将解释如何从定义大量独立的bean定义过渡到一个完全实现的应用程序，其中对象通过协作实现目标。</p>
<h3 id="1-4-1-依赖注入"><a href="#1-4-1-依赖注入" class="headerlink" title="1.4.1 依赖注入"></a>1.4.1 依赖注入</h3><p>依赖注入(DI)是一个过程，对象通过构造函数参数、工厂方法的参数或在对象实例被构造或从工厂方法返回后设置的属性来定义它们的依赖项(即它们工作的其他对象)。然后，容器在创建bean时注入这些依赖项。这个过程基本上是bean本身通过直接构造类或Service Locator模式控制其依赖项的实例化或位置的逆过程(因此得名“控制反转”)。</p>
<p>DI 原则使代码更清晰，当对象提供依赖关系时，解耦更有效。 该对象不查找其依赖项，也不知道依赖项的位置或类。 因此，您的类变得更容易测试，尤其是当依赖项位于接口或抽象基类上时，这允许在单元测试中使用stub或Mock实现。</p>
<p>依赖注入主要有两种变体:<a href="#基于构造函数的依赖注入">基于构造函数的依赖注入</a>和<a href="#基于setter的依赖注入">基于setter的依赖注入</a>。</p>
<h4 id="基于构造函数的依赖注入"><a href="#基于构造函数的依赖注入" class="headerlink" title="基于构造函数的依赖注入"></a>基于构造函数的依赖注入</h4><p>基于构造函数的DI是通过容器调用带有许多参数的构造函数来完成的，每个参数表示一个依赖项。调用带有特定参数的静态工厂方法来构造bean几乎是等价的，本文以类似的方式处理构造函数的参数和静态工厂方法的参数。下面的例子展示了一个只能通过构造函数注入进行依赖注入的类:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleMovieLister</span> </span>&#123;

    <span class="hljs-comment">// SimpleMovieLister依赖于MovieFinder</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MovieFinder movieFinder;

    <span class="hljs-comment">// 一个构造函数，这样Spring容器就可以注入一个MovieFinder</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleMovieLister</span><span class="hljs-params">(MovieFinder movieFinder)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.movieFinder = movieFinder;
    &#125;

    <span class="hljs-comment">// business logic that actually uses the injected MovieFinder is omitted...</span>
&#125;</code></pre></div>

<p>注意，这个类没有什么特别之处。它是一个不依赖于容器特定接口、基类或注释的POJO。</p>
<p><strong>构造函数参数解析</strong></p>
<p>构造函数参数解析匹配是通过使用参数的类型来实现的。如果bean定义的构造函数参数中不存在潜在的歧义，那么在bean定义中定义构造函数参数的顺序就是在实例化bean时将这些参数提供给适当的构造函数的顺序。考虑以下类:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> x.y;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThingOne</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThingOne</span><span class="hljs-params">(ThingTwo thingTwo, ThingThree thingThree)</span> </span>&#123;
        <span class="hljs-comment">// ...</span>
    &#125;
&#125;</code></pre></div>

<p>假设ThingTwo和ThingThree类没有继承关系，就不存在潜在的歧义。因此，以下配置可以正常工作，并且不需要在&lt;constructor-arg/&gt;元素中显式指定构造函数参数索引或类型。</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"beanOne"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x.y.ThingOne"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"beanTwo"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"beanThree"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"beanTwo"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x.y.ThingTwo"</span>/&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"beanThree"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x.y.ThingThree"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<p>当另一个 bean 被引用时，类型是已知的，并且可以发生匹配（就像前面的例子一样）。 当使用简单类型时，例如 &lt;value&gt;true&lt;/value&gt;，Spring 无法确定值的类型，因此无法在没有帮助的情况下按类型进行匹配。 考虑以下类：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> examples;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleBean</span> </span>&#123;

    <span class="hljs-comment">// Number of years to calculate the Ultimate Answer</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> years;

    <span class="hljs-comment">// The Answer to Life, the Universe, and Everything</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String ultimateAnswer;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ExampleBean</span><span class="hljs-params">(<span class="hljs-keyword">int</span> years, String ultimateAnswer)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.years = years;
        <span class="hljs-keyword">this</span>.ultimateAnswer = ultimateAnswer;
    &#125;
&#125;</code></pre></div>

<p><strong>构造函数参数类型匹配</strong></p>
<p>在上述场景中，如果您使用 type 属性显式指定构造函数参数的类型，则容器可以使用简单类型的类型匹配，如下例所示：</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"exampleBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.ExampleBean"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"7500000"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"java.lang.String"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"42"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p><strong>构造函数参数索引</strong></p>
<p>你可以使用index属性显式地指定构造函数参数的索引，如下面的例子所示:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"exampleBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.ExampleBean"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"7500000"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"42"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>除了解决多个简单值的歧义外，指定索引还解决了构造函数具有两个相同类型参数的歧义。</p>
<blockquote>
<p>索引是以0开始的</p>
</blockquote>
<p><strong>构造函数的参数名</strong></p>
<p>你也可以使用构造函数的参数名来消除值的歧义，如下面的例子所示:</p>
<div class="hljs"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">"exampleBean"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"examples.ExampleBean"</span>&gt;
    &lt;constructor-arg name=<span class="hljs-string">"years"</span> value=<span class="hljs-string">"7500000"</span>/&gt;
    &lt;constructor-arg name=<span class="hljs-string">"ultimateAnswer"</span> value=<span class="hljs-string">"42"</span>/&gt;
&lt;/bean&gt;</code></pre></div>

<p>请记住，要使其开箱即用，您的代码必须在启用调试标志的情况下编译，以便Spring可以从构造函数中查找参数名。如果不能或不想使用调试标志编译代码，可以使用@ConstructorProperties JDK注释显式地命名构造函数参数。样例类应该如下所示:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> examples;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleBean</span> </span>&#123;

    <span class="hljs-comment">// Fields omitted</span>

    <span class="hljs-meta">@ConstructorProperties</span>(&#123;<span class="hljs-string">"years"</span>, <span class="hljs-string">"ultimateAnswer"</span>&#125;)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ExampleBean</span><span class="hljs-params">(<span class="hljs-keyword">int</span> years, String ultimateAnswer)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.years = years;
        <span class="hljs-keyword">this</span>.ultimateAnswer = ultimateAnswer;
    &#125;
&#125;</code></pre></div>

<h4 id="基于setter的依赖注入"><a href="#基于setter的依赖注入" class="headerlink" title="基于setter的依赖注入"></a>基于setter的依赖注入</h4><h3 id="1-4-2"><a href="#1-4-2" class="headerlink" title="1.4.2"></a>1.4.2</h3><h4 id="直接值（原语、字符串等）"><a href="#直接值（原语、字符串等）" class="headerlink" title="直接值（原语、字符串等）"></a>直接值（原语、字符串等）</h4><h4 id="内部Bean"><a href="#内部Bean" class="headerlink" title="内部Bean"></a>内部Bean</h4><h3 id="1-4-4-延迟初始化的Bean"><a href="#1-4-4-延迟初始化的Bean" class="headerlink" title="1.4.4 延迟初始化的Bean"></a>1.4.4 延迟初始化的Bean</h3><h3 id="1-4-5-自动装配协作者"><a href="#1-4-5-自动装配协作者" class="headerlink" title="1.4.5 自动装配协作者"></a>1.4.5 自动装配协作者</h3><h2 id="1-5-Bean范围"><a href="#1-5-Bean范围" class="headerlink" title="1.5 Bean范围"></a>1.5 Bean范围</h2><h3 id="1-6-1-生命周期回调"><a href="#1-6-1-生命周期回调" class="headerlink" title="1.6.1 生命周期回调"></a>1.6.1 生命周期回调</h3><h4 id="初始化回调"><a href="#初始化回调" class="headerlink" title="初始化回调"></a>初始化回调</h4><h4 id="破坏回调"><a href="#破坏回调" class="headerlink" title="破坏回调"></a>破坏回调</h4><h3 id="1-12-3使用-Bean注释"><a href="#1-12-3使用-Bean注释" class="headerlink" title="1.12.3使用@Bean注释"></a>1.12.3使用@Bean注释</h3>
            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/">开发框架</a>
                    
                      <a class="hover-with-bg" href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/Spring%E6%A1%86%E6%9E%B6/">Spring框架</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Spring/">Spring</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2021/06/13/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/">
                        <span class="hidden-mobile">阿里巴巴Java开发手册</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <script defer src="https://utteranc.es/client.js"
          repo="gavin-yyj/commit-utterance"
          issue-term="pathname"
  
          theme="github-light"
          crossorigin="anonymous"
  >
  </script>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Spring官方文档学习&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
