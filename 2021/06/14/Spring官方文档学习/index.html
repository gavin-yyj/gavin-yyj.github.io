<!DOCTYPE html>
<html lang="zh-CH">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="光说不做假把式">
  <meta name="author" content="杨玉杰">
  <meta name="keywords" content="">
  <title>Spring官方文档学习 - 杨玉杰|个人博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/agate.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>杨玉杰|个人博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友情链接
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bgi.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2021-06-14 08:25">
      June 14, 2021 am
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      15.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      197
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <p>官方文档链接：<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/index.html" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/reference/html/index.html</a></p>
<p>源码下载（5.3.8版本）：<a href="https://github.com/spring-projects/spring-framework/releases/tag/v5.3.8" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework/releases/tag/v5.3.8</a></p>
<p>编译前先安装gradle：<a href="https://gradle.org/releases/" target="_blank" rel="noopener">https://gradle.org/releases/</a> </p>
<p>配置环境变量</p>
<p>编译：将下载好的代码压缩包解压后，进入主目录，打开cmd运行：gradlew :spring-oxm:compileTestJava</p>
<div class="hljs"><pre><code class="hljs reasonml">Welcome <span class="hljs-keyword">to</span> Gradle <span class="hljs-number">6.8</span>.<span class="hljs-number">3</span>!

Here are the highlights <span class="hljs-keyword">of</span> this release:

 - Faster Kotlin DSL script compilation
 - Vendor selection for Java toolchains
 - Convenient execution <span class="hljs-keyword">of</span> tasks <span class="hljs-keyword">in</span> composite builds
 - Consistent dependency resolution

For more details see https:<span class="hljs-comment">//docs.gradle.org/6.8.3/release-notes.html</span>

Starting a Gradle Daemon (subsequent builds will be faster)
fatal: not a git repository (<span class="hljs-keyword">or</span> any <span class="hljs-keyword">of</span> the parent directories): .git

Deprecated Gradle features were used <span class="hljs-keyword">in</span> this build, making it incompatible <span class="hljs-keyword">with</span> Gradle <span class="hljs-number">7.0</span>.
Use '--warning-mode all' <span class="hljs-keyword">to</span> show the individual deprecation warnings.
See https:<span class="hljs-comment">//docs.gradle.org/6.8.3/userguide/command_line_interface.html#sec:command_line_warnings</span>

BUILD SUCCESSFUL <span class="hljs-keyword">in</span> <span class="hljs-number">4</span>m <span class="hljs-number">50</span>s
<span class="hljs-number">44</span> actionable tasks: <span class="hljs-number">25</span> executed, <span class="hljs-number">19</span> from cache
Build scan background action failed.
org.gradle.process.internal.ExecException: Process 'command 'git'' finished <span class="hljs-keyword">with</span> non-zero exit value <span class="hljs-number">128</span>
        at org.gradle.process.internal.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DefaultExecHandle$ExecResultImpl</span>.</span></span><span class="hljs-keyword">assert</span><span class="hljs-constructor">NormalExitValue(DefaultExecHandle.<span class="hljs-params">java</span>:414)</span>
        at org.gradle.process.internal.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DefaultExecAction</span>.</span></span>execute(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DefaultExecAction</span>.</span></span>java:<span class="hljs-number">38</span>)
        at org.gradle.process.internal.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DefaultExecActionFactory</span>.</span></span>exec(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DefaultExecActionFactory</span>.</span></span>java:<span class="hljs-number">175</span>)
        at io.spring.ge.conventions.gradle.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">WorkingDirectoryProcessOperations</span>.</span></span>exec(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">WorkingDirectoryProcessOperations</span>.</span></span>java:<span class="hljs-number">45</span>)
        at io.spring.ge.conventions.gradle.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ProcessOperationsProcessRunner</span>.</span></span>run(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ProcessOperationsProcessRunner</span>.</span></span>java:<span class="hljs-number">41</span>)
        at io.spring.ge.conventions.core.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BuildScanConventions</span>.</span></span>run(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BuildScanConventions</span>.</span></span>java:<span class="hljs-number">166</span>)
        at io.spring.ge.conventions.core.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BuildScanConventions</span>.</span></span>add<span class="hljs-constructor">GitMetadata(BuildScanConventions.<span class="hljs-params">java</span>:113)</span>
        at io.spring.ge.conventions.gradle.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GradleConfigurableBuildScan</span>.</span></span>lambda<span class="hljs-constructor">$background$0(GradleConfigurableBuildScan.<span class="hljs-params">java</span>:104)</span>
        at com.gradle.enterprise.gradleplugin.internal.extension.b<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">$3</span>.</span></span>run(SourceFile:<span class="hljs-number">101</span>)
        at java.util.concurrent.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors$RunnableAdapter</span>.</span></span>call(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span>java:<span class="hljs-number">511</span>)
        at java.util.concurrent.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FutureTask</span>.</span></span>run(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FutureTask</span>.</span></span>java:<span class="hljs-number">266</span>)
        at java.util.concurrent.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ThreadPoolExecutor</span>.</span></span>run<span class="hljs-constructor">Worker(ThreadPoolExecutor.<span class="hljs-params">java</span>:1149)</span>
        at java.util.concurrent.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ThreadPoolExecutor$Worker</span>.</span></span>run(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ThreadPoolExecutor</span>.</span></span>java:<span class="hljs-number">624</span>)
        at java.lang.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>run(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>java:<span class="hljs-number">748</span>)</code></pre></div>

<h1 id="1-IoC容器-－５-３-８"><a href="#1-IoC容器-－５-３-８" class="headerlink" title="1. IoC容器　－５.３.８"></a>1. IoC容器　－５.３.８</h1><h2 id="1-1-Spring-IoC容器和bean的介绍"><a href="#1-1-Spring-IoC容器和bean的介绍" class="headerlink" title="1.1 Spring IoC容器和bean的介绍"></a>1.1 Spring IoC容器和bean的介绍</h2><p>对象只能通过构造函数参数、工厂方法的参数或在对象实例被构造以及从工厂方法返回后设置的属性来定义它们的依赖关系(即它们使用的其他对象)。然后，容器在创建bean时注入这些依赖项。这个过程基本上是bean本身通过直接构造类或诸如Service Locator模式这样的机制来控制其依赖项的实例化或位置的逆过程(因此得名“控制反转”)。</p>
<p><code>org.springframework.beans</code>和<code>org.springframework.context</code>包是Spring框架的IoC容器的基础。BeanFactory接口提供了能够管理任何类型对象的高级配置机制。ApplicationContext是BeanFactory的一个子接口，添加了更多特定于企业的功能。</p>
<p>bean是由Spring IoC容器实例化、组装和管理的对象。bean及其之间的依赖关系反映在容器使用的配置元数据中。</p>
<h2 id="1-2-容器概述"><a href="#1-2-容器概述" class="headerlink" title="1.2 容器概述"></a>1.2 容器概述</h2><p>Applicationcontext接口表示Spring IoC容器，负责实例化、配置和组装bean。容器通过读取配置元数据获得关于实例化、配置和组装哪些对象的指令。配置元数据用XML、Java注释或Java代码表示。它可以让您表达组成应用程序的对象以及这些对象之间丰富的相互依赖关系。</p>
<p>Spring提供了ApplicationContext接口的几个实现。在独立应用程序中，通常会创建ClassPathXmlApplicationContext或FileSystemXmlApplicationContext的实例。虽然XML是定义配置元数据的传统格式，但是您可以通过提供少量XML配置以声明方式支持这些额外的元数据格式，指示容器使用Java注释或代码作为元数据格式。</p>
<p>在大多数应用程序场景中，不需要显式的用户代码来实例化Spring IoC容器的一个或多个实例。例如，在一个web应用程序场景中，在应用程序的web. XML文件中简单的8行(大约)web描述符XML样本就足够了。</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span></code></pre></div>

<p>下图显示了Spring如何工作的高级视图。应用程序类与配置元数据相结合，这样在ApplicationContext创建并初始化之后，您就拥有了一个配置完整且可执行的系统或应用程序。</p>
<p><img src="https://gitee.com/yang_yu_jie/blog-img/raw/master/img/20210620151320.png" srcset="/img/loading.gif" alt="image-20210620151320785"></p>
<h3 id="1-2-1-配置元数据"><a href="#1-2-1-配置元数据" class="headerlink" title="1.2.1 配置元数据"></a>1.2.1 配置元数据</h3><p>如上图所示，Spring IoC容器使用一种配置元数据形式。此配置元数据表示作为应用程序开发人员，您告诉Spring容器如何实例化、配置和组装应用程序中的对象。</p>
<p>配置元数据传统上以一种简单而直观的XML格式提供，本章的大部分内容都使用这种格式来传达Spring IoC容器的关键概念和特性。</p>
<blockquote>
<p>基于 XML 的元数据并不是唯一允许的配置元数据形式。 Spring IoC 容器本身与实际写入此配置元数据的格式完全分离。 现在，许多开发人员为他们的 Spring 应用程序选择基于 Java 的配置。</p>
</blockquote>
<ul>
<li>spring2.5引入了对基于注释的配置元数据的支持，具体使用在1.9节进行介绍。</li>
<li>Spring3.0引入了基于Java的配置，更多知识在1.12进行详细说明。</li>
</ul>
<p>Spring 配置包含至少一个容器必须管理的 bean 定义。 基于 XML 的配置元数据将这些 bean 配置为顶级&lt;beans/&gt; 元素内的 &lt;bean/&gt; 元素。 Java 配置通常在@Configuration 类中使用@Bean 注释的方法。</p>
<p>这些bean定义对应于组成应用程序的实际对象。通常，您需要定义服务层对象、数据访问对象(DAO)、表示对象(如Struts Action实例)、基础设施对象(如Hibernate SessionFactories、JMS队列)等等。通常，不会在容器中配置细粒度的域对象，因为创建和加载域对象通常是 DAO 和业务逻辑的责任。但是，您可以使用Spring与AspectJ的集成来配置在IoC容器控制之外创建的对象【见5.10】。</p>
<p>下面的例子展示了基于xml的配置元数据的基本结构:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>&gt;</span>  
        <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- more bean definitions go here --&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<ul>
<li>id属性是标识单个bean定义的字符串。</li>
<li>class属性定义bean的类型并使用完全限定的类名。</li>
</ul>
<p>id 属性的值是指协作对象。 此示例中未显示用于引用协作对象的 XML。 有关更多信息，请参阅依赖项【见1.4】。</p>
<h3 id="1-2-2-容器实例化"><a href="#1-2-2-容器实例化" class="headerlink" title="1.2.2 容器实例化"></a>1.2.2 容器实例化</h3><p>提供给 ApplicationContext 构造函数的一个或多个位置路径是资源字符串，它允许容器从各种外部资源（例如本地文件系统、Java CLASSPATH 等）加载配置元数据。</p>
<div class="hljs"><pre><code class="hljs java">ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"services.xml"</span>, <span class="hljs-string">"daos.xml"</span>);</code></pre></div>

<p>在您了解 Spring 的 IoC 容器之后，您可能想了解更多关于 Spring 的resource概念【见2】，它提供了一种从 URI 语法中定义的位置读取 InputStream 的便捷机制。特别是，资源路径用于构造应用程序上下文，如应用程序上下文和资源路径中所述【见2.8】。</p>
<p>以下示例显示了服务层对象(services.xml)配置文件:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- services --&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"petStore"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.samples.jpetstore.services.PetStoreServiceImpl"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"accountDao"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"accountDao"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"itemDao"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"itemDao"</span>/&gt;</span>
        <span class="hljs-comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- more bean definitions for services go here --&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<p>下面的例子显示了数据访问对象dao .xml文件:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountDao"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao"</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"itemDao"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.samples.jpetstore.dao.jpa.JpaItemDao"</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- more bean definitions for data access objects go here --&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<p>在上面的示例中，服务层由PetStoreServiceImpl类和JpaAccountDao和JpaItemDao(基于JPA对象关系映射标准)类型的两个数据访问对象组成。属性名元素引用JavaBean属性的名称，ref元素引用另一个bean定义的名称。id和ref元素之间的这种链接表示了协作对象之间的依赖关系。有关配置对象依赖关系的详细信息，请参见依赖关系【见1.4】。</p>
<h4 id="编写基于xml的配置元数据"><a href="#编写基于xml的配置元数据" class="headerlink" title="编写基于xml的配置元数据"></a>编写基于xml的配置元数据</h4><p>让bean定义跨越多个XML文件是很有用的。通常，每个单独的XML配置文件代表体系结构中的一个逻辑层或模块。</p>
<p>可以使用应用程序上下文构造函数从所有这些XML片段加载bean定义。此构造函数接受多个Resource位置，如前一节所示。或者，使用一次或多次&lt;import/&gt;元素从另一个或多个文件加载bean定义。下面的例子展示了如何做到这一点:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"services.xml"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"resources/messageSource.xml"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"/resources/themeSource.xml"</span>/&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bean1"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bean2"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<p>在前面的示例中，外部bean定义从三个文件加载:services.xml、messageSource.xml和themeSource.xml。</p>
<p>所有位置路径都相对于执行导入的定义文件，因此services.xml必须与执行导入的文件位于相同的目录或类路径位置，而messageSource.xml和themeSource.xml必须位于导入文件位置下面的资源位置。如您所见，前导斜杠被忽略。 但是，鉴于这些路径是相对的，最好根本不使用斜杠。 根据 Spring Schema，被导入文件的内容，包括顶级 &lt;beans/&gt; 元素，必须是有效的 XML bean 定义。</p>
<blockquote>
<p>可以使用相对的”.. /”路径来引用父目录中的文件，但不建议这样做。这样做将创建对当前应用程序之外的文件的依赖关系。特别是，不建议对classpath: url(例如，classpath:../services.xml)使用此引用，运行时解析过程选择“最近的”类路径根，然后查看其父目录。类路径配置更改可能导致选择不同的、不正确的目录。</p>
<p>您可以始终使用完全限定的资源位置，而不是相对路径:例如，文件:C:/config/services.xml或类路径:/config/services.xml。但是，请注意，您是将应用程序的配置耦合到特定的绝对位置。</p>
<p>通常，最好为这些绝对位置保留一个间接位置——例如，通过在运行时根据JVM系统属性解析的“${…}”占位符。</p>
</blockquote>
<p>命名空间本身提供了导入指令特性。除了普通bean定义之外，Spring提供的XML名称空间中还提供了更多的配置特性——例如，上下文和util名称空间。</p>
<h3 id="1-2-3-使用容器"><a href="#1-2-3-使用容器" class="headerlink" title="1.2.3 使用容器"></a>1.2.3 使用容器</h3><p>ApplicationContext是一个高级工厂的接口，该工厂能够维护不同bean及其依赖项的注册表。通过使用T getBean(String name, Class&lt;T&gt; requiredType)方法，您可以检索bean的实例。</p>
<p>ApplicationContext允许你读取并访问bean定义，如下面的例子所示:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// create and configure beans</span>
ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"services.xml"</span>, <span class="hljs-string">"daos.xml"</span>);

<span class="hljs-comment">// retrieve configured instance</span>
PetStoreService service = context.getBean(<span class="hljs-string">"petStore"</span>, PetStoreService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

<span class="hljs-comment">// use configured instance</span>
List&lt;String&gt; userList = service.getUsernameList();</code></pre></div>

<p>最灵活的变体是GenericApplicationContext与reader委托结合使用——例如，XML文件使用XmlBeanDefinitionReader，如下例所示:</p>
<div class="hljs"><pre><code class="hljs java">GenericApplicationContext context = <span class="hljs-keyword">new</span> GenericApplicationContext();
<span class="hljs-keyword">new</span> XmlBeanDefinitionReader(context).loadBeanDefinitions(<span class="hljs-string">"services.xml"</span>, <span class="hljs-string">"daos.xml"</span>);
context.refresh();</code></pre></div>

<p>您可以在相同的ApplicationContext上混合和匹配这样的读取器委托，从不同的配置源读取bean定义。</p>
<p>您可以使用 getBean 来检索 bean 的实例，ApplicationContext 接口也提供了一些其他方法来检索 bean，但理想情况下，您的应用程序代码永远不应该使用它们。实际上，您的应用程序代码根本<strong>不应该调用getBean()方法</strong>，因此根本不依赖于Spring api。</p>
<p>例如，Spring与web框架的集成为各种web框架组件(如控制器和JSF管理的bean)提供了依赖注入，允许您通过元数据(如<strong>自动装配注释</strong>)声明对特定bean的依赖。</p>
<h2 id="1-3-Bean概述"><a href="#1-3-Bean概述" class="headerlink" title="1.3 Bean概述"></a>1.3 Bean概述</h2><p>Spring IoC 容器管理一个或多个 bean。 这些 bean 是使用您提供给容器的配置元数据创建的（例如，以 XML &lt;bean/&gt; 定义的形式）。</p>
<p>在容器本身内，这些 bean 定义表示为 BeanDefinition 对象，除其他信息外，还包含以下元数据：</p>
<ul>
<li>包限定的类名:通常是定义的bean的实际实现类。</li>
<li>Bean行为配置元素，声明Bean在容器中应该如何行为(范围、生命周期回调，等等)。</li>
<li>对 bean 执行其工作所需的其他 bean 的引用，这些引用也称为协作者或依赖项。</li>
<li>要在新创建的对象中设置的其他配置 — 例如，池的大小限制或在管理连接池的 bean 中使用的连接数。</li>
</ul>
<p>此元数据转换为组成每个bean定义的一组属性。下表描述了这些属性:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>详细介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Class</td>
<td>[实例化Bean](#1.3.2 实例化Bean)</td>
</tr>
<tr>
<td>Name</td>
<td><a href="#1.3.1命名Bean">命名Bean</a></td>
</tr>
<tr>
<td>Scope</td>
<td>[Bean范围](#1.5 Bean范围)</td>
</tr>
<tr>
<td>Constructor arguments</td>
<td>[依赖注入](#1.4.1 依赖注入)</td>
</tr>
<tr>
<td>Properties</td>
<td>[依赖注入](#1.4.1 依赖注入)</td>
</tr>
<tr>
<td>Autowiring mode</td>
<td>[自动装配协作者](#1.4.5 自动装配协作者)</td>
</tr>
<tr>
<td>Lazy initialization mode</td>
<td>[延迟初始化的Bean](#1.4.4 延迟初始化的Bean)</td>
</tr>
<tr>
<td>Initialization method</td>
<td><a href="#初始化回调">初始化回调</a></td>
</tr>
<tr>
<td>Destruction method</td>
<td><a href="#破坏回调">破坏回调</a></td>
</tr>
</tbody></table>
<p>除了包含有关如何创建特定 bean 信息的 bean 定义之外，ApplicationContext 的实现类还允许注册在容器外部（由用户创建）创建的现有对象。</p>
<p>这是通过 getBeanFactory() 方法访问 ApplicationContext 的 BeanFactory 来完成的，该方法返回 BeanFactory  的实现类DefaultListableBeanFactory。DefaultListableBeanFactory 通过 registerSingleton(..) 和 registerBeanDefinition(..) 方法支持这种注册。 但是，典型的应用程序仅使用常规 bean 定义元数据来定义 bean。</p>
<blockquote>
<p>Bean 元数据和手动提供的单例实例需要尽早注册，以便容器在自动装配和其他内省步骤中正确推理它们。</p>
<p>虽然在某种程度上支持覆盖现有的元数据和现有的单例实例，但是在运行时注册新bean(与对工厂的实时访问同时进行)并没有得到官方支持，并且可能导致并发访问异常、bean容器中的不一致状态，或者两者都有。</p>
</blockquote>
<h3 id="1-3-1-命名Bean"><a href="#1-3-1-命名Bean" class="headerlink" title="1.3.1 命名Bean"></a>1.3.1 命名Bean</h3><p>每个bean都有一个或多个标识符。这些标识符在装载bean的容器中必须是唯一的。一个bean通常只有一个标识符。但是，如果需要一个以上的名字，则可以将额外的名字视为别名。</p>
<p>在基于xml的配置元数据中，可以使用id属性、name属性或两者来指定bean标识符。id属性允许您指定一个id。通常，这些名称是字母数字(‘myBean’， ‘someService’等)，但它们也可以包含特殊字符。如果希望为bean引入其他别名，还可以在name属性中指定它们，用逗号(，)、分号(;)或空格分隔。在 Spring 3.1 之前的版本中，id 属性被定义为 xsd:ID 类型，它限制了可能的字符。 从 3.1 开始，它被定义为 xsd:string 类型。 请注意，bean id 唯一性仍由容器强制执行，但不再由 XML 解析器强制执行。</p>
<p>您不需要为bean提供名称或id。如果您没有显式地提供名称或id，容器将为该bean生成唯一的名称。但是，如果希望通过使用ref元素或Service Locator样式查找按名称引用该bean，则必须提供名称。不提供名称的动机与使用<a href="#内部Bean">内部bean</a>和[自动装配协作者](#1.4.5 自动装配协作者)有关。</p>
<blockquote>
<p>Bean命名约定：</p>
<p>约定是在命名Bean时对实例字段名使用标准Java约定。也就是说，bean名称以小写字母开头，并从那里开始采用驼峰大小写。这些名称的示例包括accountManager、accountService、userDao、loginController等。</p>
<p>保持Bean命名一致性可以使您的配置更易于阅读和理解。另外，如果您使用Spring AOP，那么将通知应用到名称相关的一组bean时，它会有很大帮助。</p>
</blockquote>
<p>通过在类路径中扫描组件，Spring为未命名组件生成bean名，遵循前面描述的规则:本质上，采用简单的类名并将其初始字符转换为小写。</p>
<p>但是，在特殊情况下，当有多个字符且第一个和第二个字符都是大写时，保留原来的大小写。这些规则与java.beans.Introspector.decapitalize (Spring在这里使用的)定义的规则相同。</p>
<h4 id="在Bean定义之外对Bean进行别名处理"><a href="#在Bean定义之外对Bean进行别名处理" class="headerlink" title="在Bean定义之外对Bean进行别名处理"></a>在Bean定义之外对Bean进行别名处理</h4><p>在 bean 定义本身中，您可以为 bean 提供多个名称，方法是使用 id 属性指定的最多一个名称和 name 属性中任意数量的其他名称的组合。这些名称可以是相同bean的等效别名，在某些情况下非常有用，例如通过使用特定于该组件本身的bean名称，让应用程序中的每个组件引用公共依赖项。</p>
<p>但是，指定bean实际定义的所有别名并不总是足够的。有时需要为在其他地方定义的bean引入别名。在大型系统中，配置在每个子系统之间分割，每个子系统都有自己的对象定义集，这种情况很常见。在基于xml的配置元数据中，可以使用&lt;alias/&gt;元素来实现这一点。下面的例子展示了如何做到这一点:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"fromName"</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"toName"</span>/&gt;</span></code></pre></div>

<p>在这种情况下，在使用这个别名定义之后，命名为fromName的bean(在同一个容器中)也可以称为toName。</p>
<p>例如，子系统A的配置元数据可以通过subsystemA-dataSource的名称引用一个数据源。子系统B的配置元数据可以通过subsystemB-dataSource的名称来引用一个数据源。当组合使用这两个子系统的主应用程序时，主应用程序通过myApp-dataSource的名称引用数据源。要让这三个名称都引用同一个对象，可以在配置元数据中添加以下别名定义:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"myApp-dataSource"</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"subsystemA-dataSource"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"myApp-dataSource"</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"subsystemB-dataSource"</span>/&gt;</span></code></pre></div>

<p>现在，每个组件和主应用程序都可以通过一个唯一的名称来引用dataSource，这个名称保证不会与任何其他定义冲突(有效地创建了一个名称空间)，但它们引用的是同一个bean。</p>
<blockquote>
<p>如果使用javaconconfiguration，可以使用@Bean注释提供别名。详细信息请参见<a href="#1.12.3使用@Bean注释">使用@Bean注释</a>。</p>
</blockquote>
<h3 id="1-3-2-实例化Bean"><a href="#1-3-2-实例化Bean" class="headerlink" title="1.3.2 实例化Bean"></a>1.3.2 实例化Bean</h3><p>bean 定义本质上是创建一个或多个对象的方法。 当被询问时，容器会查看命名 bean 的配方，并使用该 bean 定义封装的配置元数据来创建（或获取）实际对象。</p>
<p>如果使用基于xml的配置元数据，则需要指定要在&lt;bean/&gt;元素的class属性，这个class属性通常是强制性的。你可以用以下两种方式之一来使用Class属性:</p>
<ul>
<li>通常，在容器本身通过反射调用构造函数直接创建bean的情况下，指定要构造的bean类，这在某种程度上相当于带有new操作符的Java代码。</li>
<li>指定包含用于创建对象的静态工厂方法的实际类，在不太常见的情况下，容器调用类上的静态工厂方法来创建 bean。 调用静态工厂方法返回的对象类型可能是同一个类，也可能完全是另一个类。</li>
</ul>
<blockquote>
<p>嵌套类命名：</p>
<p>如果您想为嵌套类配置bean定义，您可以使用嵌套类的二进制名称或源名称。</p>
<p>例如，如果您在 com.example 包中有一个名为 SomeThing 的类，并且这个 SomeThing 类有一个名为 OtherThing 的静态嵌套类，则它们可以用美元符号 ($) 或点 (.) 分隔。 因此，bean 定义中类属性的值将是 com.example.SomeThing$OtherThing 或 com.example.SomeThing.OtherThing。</p>
</blockquote>
<h4 id="使用构造函数进行实例化"><a href="#使用构造函数进行实例化" class="headerlink" title="使用构造函数进行实例化"></a>使用构造函数进行实例化</h4><p>当您通过构造函数方法创建 bean 时，所有普通类都可以被 Spring 使用并与 Spring 兼容。 也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式进行编码。 只需指定 bean 类就足够了。 但是，根据您对该特定 bean 使用的 IoC 类型，您可能需要一个默认（空）构造函数。</p>
<p>Spring IoC 容器几乎可以管理您希望它管理的任何类。 它不仅限于管理真正的 JavaBean。 大多数 Spring 用户更喜欢实际的 JavaBeans，它只有一个默认（无参数）构造函数和适当的 setter 和 getter，它们以容器中的属性为模型。 您还可以在容器中拥有更多非 bean 风格的类。 例如，如果您需要使用绝对不符合 JavaBean 规范的遗留连接池，Spring 也可以管理它。</p>
<p>使用基于xml的配置元数据，你可以如下指定你的bean类:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"exampleBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.ExampleBean"</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"anotherExample"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.ExampleBeanTwo"</span>/&gt;</span></code></pre></div>

<p>有关向构造函数提供参数(如果需要)和在对象构造后设置对象实例属性的机制的详细信息，请参见[注入依赖项](＃1.4.1 依赖注入)。</p>
<h4 id="使用静态工厂方法进行实例化"><a href="#使用静态工厂方法进行实例化" class="headerlink" title="使用静态工厂方法进行实例化"></a>使用静态工厂方法进行实例化</h4><p>定义使用静态工厂方法创建的 bean 时，使用 class 属性指定包含静态工厂方法的类，并使用名为 factory-method 的属性指定工厂方法本身的名称。 您应该能够调用此方法（带有可选参数，如下所述）并返回一个活动对象，随后将其视为通过构造函数创建的。 这种 bean 定义的一种用途是在遗留代码中调用静态工厂。</p>
<p>以下 bean 定义指定通过调用工厂方法来创建 bean。 定义中没有指定返回对象的类型（类），只指定包含工厂方法的类。 在这个例子中，createInstance() 方法必须是一个静态方法。 以下示例显示了如何指定工厂方法：</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"clientService"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.ClientService"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"createInstance"</span>/&gt;</span></code></pre></div>

<p>下面的例子展示了一个可以使用前面的bean定义的类:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientService</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ClientService clientService = <span class="hljs-keyword">new</span> ClientService();
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ClientService</span><span class="hljs-params">()</span> </span>&#123;&#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClientService <span class="hljs-title">createInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> clientService;
    &#125;
&#125;</code></pre></div>

<p>有关为工厂方法提供(可选)参数和在从工厂返回对象后设置对象实例属性的机制的详细信息，请参见<a href="#直接值（原语、字符串等）">详细信息中的依赖关系和配置</a>。</p>
<h4 id="使用实例工厂方法进行实例化"><a href="#使用实例工厂方法进行实例化" class="headerlink" title="使用实例工厂方法进行实例化"></a>使用实例工厂方法进行实例化</h4><p>与通过静态工厂方法进行实例化类似，使用实例工厂方法进行实例化会从容器中调用现有 bean 的非静态方法来创建新 bean。 要使用此机制，请将 class 属性留空，并在 factory-bean 属性中指定当前（或父或祖先）容器中 bean 的名称，该容器包含要调用以创建对象的实例方法。 使用 factory-method 属性设置工厂方法本身的名称。 以下示例显示了如何配置此类 bean：</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 工厂bean，它包含一个名为createInstance()的方法 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"serviceLocator"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.DefaultServiceLocator"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 要通过工厂bean创建的bean --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"clientService"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"serviceLocator"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"createClientServiceInstance"</span>/&gt;</span></code></pre></div>

<p>下面的例子显示了相应的类:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultServiceLocator</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ClientService clientService = <span class="hljs-keyword">new</span> ClientServiceImpl();

    <span class="hljs-function"><span class="hljs-keyword">public</span> ClientService <span class="hljs-title">createClientServiceInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> clientService;
    &#125;
&#125;</code></pre></div>

<p>一个工厂类也可以包含多个工厂方法，如下面的例子所示:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"serviceLocator"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.DefaultServiceLocator"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"clientService"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"serviceLocator"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"createClientServiceInstance"</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"serviceLocator"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"createAccountServiceInstance"</span>/&gt;</span></code></pre></div>

<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultServiceLocator</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ClientService clientService = <span class="hljs-keyword">new</span> ClientServiceImpl();

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AccountService accountService = <span class="hljs-keyword">new</span> AccountServiceImpl();

    <span class="hljs-function"><span class="hljs-keyword">public</span> ClientService <span class="hljs-title">createClientServiceInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> clientService;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> AccountService <span class="hljs-title">createAccountServiceInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> accountService;
    &#125;
&#125;</code></pre></div>

<p>这种方法表明工厂bean本身可以通过依赖项注入(DI)进行管理和配置。请参阅<a href="#直接值（原语、字符串等）">详细的依赖关系和配置。</a></p>
<blockquote>
<p>在 Spring 文档中，“工厂 bean”是指在 Spring 容器中配置并通过实例或静态工厂方法创建对象的 bean。 相比之下，FactoryBean（注意大写）指的是特定于 Spring 的 FactoryBean 实现类。</p>
</blockquote>
<h4 id="确定Bean的运行时类型"><a href="#确定Bean的运行时类型" class="headerlink" title="确定Bean的运行时类型"></a>确定Bean的运行时类型</h4><p>确定特定bean的运行时类型是非常重要的。bean元数据定义中的指定类只是一个初始类引用，可能与声明的工厂方法或FactoryBean类相结合，这可能导致bean的不同运行时类型，或者在实例级工厂方法的情况下，根本没有设置。此外，AOP代理可以用一个基于接口的代理来包装一个bean实例，并有限地暴露目标bean的实际类型(仅仅是实现的接口)。</p>
<p>要了解特定bean的实际运行时类型，推荐使用BeanFactory.getType来调用指定的bean名。这考虑了上述所有情况，并返回BeanFactory.getBean 调用将为相同 bean 名称返回的对象类型。</p>
<h2 id="1-4-依赖"><a href="#1-4-依赖" class="headerlink" title="1.4 依赖"></a>1.4 依赖</h2><p>典型的企业应用程序不包含单个对象（或 Spring 用语中的 bean）。 即使是最简单的应用程序也有一些对象，它们协同工作以呈现最终用户所看到的连贯应用程序。下一节将解释如何从定义大量独立的bean定义过渡到一个完全实现的应用程序，其中对象通过协作实现目标。</p>
<h3 id="1-4-1-依赖注入"><a href="#1-4-1-依赖注入" class="headerlink" title="1.4.1 依赖注入"></a>1.4.1 依赖注入</h3><p>依赖注入(DI)是一个过程，对象通过构造函数参数、工厂方法的参数或在对象实例被构造或从工厂方法返回后设置的属性来定义它们的依赖项(即它们工作的其他对象)。然后，容器在创建bean时注入这些依赖项。这个过程基本上是bean本身通过直接构造类或Service Locator模式控制其依赖项的实例化或位置的逆过程(因此得名“控制反转”)。</p>
<p>DI 原则使代码更清晰，当对象提供依赖关系时，解耦更有效。 该对象不查找其依赖项，也不知道依赖项的位置或类。 因此，您的类变得更容易测试，尤其是当依赖项位于接口或抽象基类上时，这允许在单元测试中使用stub或Mock实现。</p>
<p>依赖注入主要有两种变体:<a href="#基于构造函数的依赖注入">基于构造函数的依赖注入</a>和<a href="#基于setter的依赖注入">基于setter的依赖注入</a>。</p>
<h4 id="基于构造函数的依赖注入"><a href="#基于构造函数的依赖注入" class="headerlink" title="基于构造函数的依赖注入"></a>基于构造函数的依赖注入</h4><p>基于构造函数的DI是通过容器调用带有许多参数的构造函数来完成的，每个参数表示一个依赖项。调用带有特定参数的静态工厂方法来构造bean几乎是等价的，本文以类似的方式处理构造函数的参数和静态工厂方法的参数。下面的例子展示了一个只能通过构造函数注入进行依赖注入的类:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleMovieLister</span> </span>&#123;

    <span class="hljs-comment">// SimpleMovieLister依赖于MovieFinder</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MovieFinder movieFinder;

    <span class="hljs-comment">// 一个构造函数，这样Spring容器就可以注入一个MovieFinder</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleMovieLister</span><span class="hljs-params">(MovieFinder movieFinder)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.movieFinder = movieFinder;
    &#125;

    <span class="hljs-comment">// business logic that actually uses the injected MovieFinder is omitted...</span>
&#125;</code></pre></div>

<p>注意，这个类没有什么特别之处。它是一个不依赖于容器特定接口、基类或注释的POJO。</p>
<p><strong>构造函数参数解析</strong></p>
<p>构造函数参数解析匹配是通过使用参数的类型来实现的。如果bean定义的构造函数参数中不存在潜在的歧义，那么在bean定义中定义构造函数参数的顺序就是在实例化bean时将这些参数提供给适当的构造函数的顺序。考虑以下类:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> x.y;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThingOne</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThingOne</span><span class="hljs-params">(ThingTwo thingTwo, ThingThree thingThree)</span> </span>&#123;
        <span class="hljs-comment">// ...</span>
    &#125;
&#125;</code></pre></div>

<p>假设ThingTwo和ThingThree类没有继承关系，就不存在潜在的歧义。因此，以下配置可以正常工作，并且不需要在&lt;constructor-arg/&gt;元素中显式指定构造函数参数索引或类型。</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"beanOne"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x.y.ThingOne"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"beanTwo"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"beanThree"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"beanTwo"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x.y.ThingTwo"</span>/&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"beanThree"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x.y.ThingThree"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<p>当另一个 bean 被引用时，类型是已知的，并且可以发生匹配（就像前面的例子一样）。 当使用简单类型时，例如 &lt;value&gt;true&lt;/value&gt;，Spring 无法确定值的类型，因此无法在没有帮助的情况下按类型进行匹配。 考虑以下类：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> examples;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleBean</span> </span>&#123;

    <span class="hljs-comment">// Number of years to calculate the Ultimate Answer</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> years;

    <span class="hljs-comment">// The Answer to Life, the Universe, and Everything</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String ultimateAnswer;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ExampleBean</span><span class="hljs-params">(<span class="hljs-keyword">int</span> years, String ultimateAnswer)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.years = years;
        <span class="hljs-keyword">this</span>.ultimateAnswer = ultimateAnswer;
    &#125;
&#125;</code></pre></div>

<p><strong>构造函数参数类型匹配</strong></p>
<p>在上述场景中，如果您使用 type 属性显式指定构造函数参数的类型，则容器可以使用简单类型的类型匹配，如下例所示：</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"exampleBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.ExampleBean"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"7500000"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"java.lang.String"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"42"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p><strong>构造函数参数索引</strong></p>
<p>你可以使用index属性显式地指定构造函数参数的索引，如下面的例子所示:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"exampleBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.ExampleBean"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"7500000"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"42"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>除了解决多个简单值的歧义外，指定索引还解决了构造函数具有两个相同类型参数的歧义。</p>
<blockquote>
<p>索引是以0开始的</p>
</blockquote>
<p><strong>构造函数的参数名</strong></p>
<p>你也可以使用构造函数的参数名来消除值的歧义，如下面的例子所示:</p>
<div class="hljs"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">"exampleBean"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"examples.ExampleBean"</span>&gt;
    &lt;constructor-arg name=<span class="hljs-string">"years"</span> value=<span class="hljs-string">"7500000"</span>/&gt;
    &lt;constructor-arg name=<span class="hljs-string">"ultimateAnswer"</span> value=<span class="hljs-string">"42"</span>/&gt;
&lt;/bean&gt;</code></pre></div>

<p>请记住，要使其开箱即用，您的代码必须在启用调试标志的情况下编译，以便Spring可以从构造函数中查找参数名。如果不能或不想使用调试标志编译代码，可以使用@ConstructorProperties JDK注释显式地命名构造函数参数。样例类应该如下所示:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> examples;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleBean</span> </span>&#123;

    <span class="hljs-comment">// Fields omitted</span>

    <span class="hljs-meta">@ConstructorProperties</span>(&#123;<span class="hljs-string">"years"</span>, <span class="hljs-string">"ultimateAnswer"</span>&#125;)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ExampleBean</span><span class="hljs-params">(<span class="hljs-keyword">int</span> years, String ultimateAnswer)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.years = years;
        <span class="hljs-keyword">this</span>.ultimateAnswer = ultimateAnswer;
    &#125;
&#125;</code></pre></div>

<h4 id="基于setter的依赖注入"><a href="#基于setter的依赖注入" class="headerlink" title="基于setter的依赖注入"></a>基于setter的依赖注入</h4><p>基于 Setter 的 DI 是通过容器在调用无参数构造函数或无参数静态工厂方法来实例化 bean 后调用 bean 上的 setter 方法来完成的。</p>
<p>下面的例子展示了一个只能通过使用纯setter注入来进行依赖注入的类。这个类是传统的Java。它是一个不依赖于容器特定接口、基类或注释的POJO。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleMovieLister</span> </span>&#123;

    <span class="hljs-comment">// SimpleMovieLister依赖于MovieFinder</span>
    <span class="hljs-keyword">private</span> MovieFinder movieFinder;

    <span class="hljs-comment">// a setter method so that the Spring container can inject a MovieFinder</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMovieFinder</span><span class="hljs-params">(MovieFinder movieFinder)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.movieFinder = movieFinder;
    &#125;

    <span class="hljs-comment">// business logic that actually uses the injected MovieFinder is omitted...</span>
&#125;</code></pre></div>

<p>ApplicationContext为它管理的bean支持基于构造函数和基于setter的DI。在通过构造函数方法注入了一些依赖项之后，它还支持基于setter的DI。您可以以BeanDefinition的形式配置依赖项，可以与PropertyEditor实例一起使用，将属性从一种格式转换为另一种格式。</p>
<p>但是，大多数Spring用户并不是直接使用这些类(即通过编程方式)，而是使用XML bean定义、带注释的组件(即使用@Component、@Controller等带注释的类)，或者基于java的@Configuration类中的@Bean方法。然后，这些源在内部转换为BeanDefinition的实例，并用于加载整个Spring IoC容器实例。</p>
<blockquote>
<p>基于构造函数还是基于setter的DI?</p>
<p>由于可以混合使用基于构造函数和基于setter的DI，因此对于强制依赖项使用构造函数，对于可选依赖项使用setter方法或配置方法是一条很好的经验法则。注意，在setter方法上使用@Required注释可以使属性成为必需的依赖项;然而，使用编程式验证参数的构造函数注入更可取。</p>
<p>Spring团队通常提倡构造函数注入，因为它允许您将应用程序组件实现为不可变对象，并确保所需的依赖项不为空。此外，构造函数注入的组件总是在完全初始化状态下返回给客户端(调用)代码。顺便说一下，大量构造函数参数是一种糟糕的代码味道，这意味着类可能有太多的职责，应该进行重构以更好地解决关注事项的适当分离。</p>
<p>Setter注入应该主要用于可选的依赖项，这些依赖项可以在类中分配合理的默认值。否则，必须在代码使用依赖项的任何地方执行非空检查。setter注入的一个好处是，setter方法使该类的对象能够在以后重新配置或重新注入。因此，通过JMX mbean进行管理是setter注入的一个引人注目的用例。</p>
<p>使用对特定类最有意义的DI风格。有时，当您处理没有源代码的第三方类时，您可以自行选择。例如，如果第三方类没有公开任何setter方法，那么构造函数注入可能是DI的唯一可用形式。</p>
</blockquote>
<h4 id="依赖解析过程"><a href="#依赖解析过程" class="headerlink" title="依赖解析过程"></a>依赖解析过程</h4><p>容器执行bean依赖关系解析如下:</p>
<ul>
<li>使用描述所有bean的配置元数据创建并初始化ApplicationContext。配置元数据可以通过XML、Java代码或注释指定。</li>
<li>对于每个 bean，它的依赖关系以属性、构造函数参数或静态工厂方法的参数（如果您使用它而不是普通构造函数）的形式表示。 在实际创建 bean 时，将这些依赖关系提供给 bean。</li>
<li>每个属性或构造函数参数都要设置值的实际定义，或者是对容器中另一个 bean 的引用。</li>
<li>作为值的每个属性或构造函数参数都将从其指定的格式转换为该属性或构造函数参数的实际类型。默认情况下，Spring可以将字符串格式提供的值转换为所有内置类型，比如int、long、string、boolean等等。</li>
</ul>
<p>Spring容器在创建容器时验证每个bean的配置。但是，在实际创建bean之前，不会设置bean属性本身。在创建容器时将创建单例作用域且设置为预实例化(默认)的bean。作用域在Bean作用域中定义。否则，仅在请求bean时才创建它。创建一个bean可能会导致创建一个bean图，因为创建并分配了bean的依赖项及其依赖项的依赖项(等等)。请注意，这些依赖项之间的解析不匹配可能会在后期出现——即在受影响bean的第一次创建时出现。</p>
<blockquote>
<p>循环依赖</p>
<p>如果主要使用构造函数注入，可能会创建不可解析的循环依赖项场景。</p>
<p>例如：A类通过构造函数注入需要B类的实例，B类通过构造函数注入需要A类的实例。 如果您将类 A 和 B 的 bean 配置为相互注入，则 Spring IoC 容器在运行时检测到此循环引用，并抛出 BeanCurrentlyInCreationException。</p>
<p>一种可能的解决方案是编辑一些由setter而不是构造函数配置的类的源代码。或者，避免构造函数注入，只使用setter注入。换句话说，尽管不推荐这样做，但您可以使用setter注入配置循环依赖项。</p>
<p>与典型情况(没有循环依赖项)不同，bean a和bean B之间的循环依赖项迫使一个bean在完全初始化自己之前被注入到另一个bean中(典型的先有鸡还是先有蛋的场景)。</p>
</blockquote>
<p>您通常可以相信 Spring 会做正确的事情。 它在容器加载时检测配置问题，例如对不存在的 bean 的引用和循环依赖。 Spring 在真正创建 bean 时尽可能晚地设置属性并解析依赖项。</p>
<p>这意味着，如果创建该对象或其某个依赖项出现问题时，则已正确加载的 Spring 容器稍后可以在您请求对象时生成异常，例如，bean会由于缺少或无效的属性而抛出异常。这可能会延迟一些配置问题的可见性，这就是为什么ApplicationContext实现默认情况下会预先实例化单例bean。</p>
<p>在实际需要这些bean之前创建这些bean需要花费一些前期时间和内存，因此在创建ApplicationContext时发现配置问题，而不是稍后。您仍然可以覆盖这个默认行为，以便单例bean可以延迟初始化，而不是急切地预先实例化。    </p>
<p>如果不存在循环依赖项，那么当一个或多个协作bean被注入到依赖bean中时，每个协作bean在被注入到依赖bean之前都会被完全配置。这意味着，如果bean A依赖于bean B，那么Spring IoC容器在调用bean A的setter方法之前将完全配置bean B。换句话说，bean被实例化(如果它不是一个预先实例化的单例)，它的依赖关系被设置，相关的生命周期方法(例如<a href="#初始化回调">配置的init方法</a>或<a href="#初始化回调">InitializingBean回调方法</a>)被调用。</p>
<h4 id="依赖注入的例子"><a href="#依赖注入的例子" class="headerlink" title="依赖注入的例子"></a>依赖注入的例子</h4><p>下面的示例为基于setter的DI使用基于xml的配置元数据。Spring XML配置文件的一小部分指定了一些bean定义，如下所示:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"exampleBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.ExampleBean"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- setter injection using the nested ref element --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"beanOne"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"anotherExampleBean"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- setter injection using the neater ref attribute --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"beanTwo"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"yetAnotherBean"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"integerProperty"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"anotherExampleBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.AnotherBean"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"yetAnotherBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.YetAnotherBean"</span>/&gt;</span></code></pre></div>

<p>下面的例子显示了相应的ExampleBean类:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleBean</span> </span>&#123;

    <span class="hljs-keyword">private</span> AnotherBean beanOne;

    <span class="hljs-keyword">private</span> YetAnotherBean beanTwo;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanOne</span><span class="hljs-params">(AnotherBean beanOne)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.beanOne = beanOne;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanTwo</span><span class="hljs-params">(YetAnotherBean beanTwo)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.beanTwo = beanTwo;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setIntegerProperty</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.i = i;
    &#125;
&#125;</code></pre></div>

<p>在前面的示例中，setter被声明为与XML文件中指定的属性相匹配。下面的例子使用了基于构造函数的DI:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"exampleBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.ExampleBean"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- constructor injection using the nested ref element --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"anotherExampleBean"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- constructor injection using the neater ref attribute --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"yetAnotherBean"</span>/&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"anotherExampleBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.AnotherBean"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"yetAnotherBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.YetAnotherBean"</span>/&gt;</span></code></pre></div>

<p>下面的例子显示了相应的ExampleBean类:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleBean</span> </span>&#123;

    <span class="hljs-keyword">private</span> AnotherBean beanOne;

    <span class="hljs-keyword">private</span> YetAnotherBean beanTwo;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ExampleBean</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="hljs-keyword">int</span> i)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.beanOne = anotherBean;
        <span class="hljs-keyword">this</span>.beanTwo = yetAnotherBean;
        <span class="hljs-keyword">this</span>.i = i;
    &#125;
&#125;</code></pre></div>

<p>在bean定义中指定的构造函数参数被用作ExampleBean的构造函数的参数。</p>
<p>现在考虑这个例子的一个变体，这里不使用构造函数，而是告诉Spring调用一个静态工厂方法来返回对象的实例:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"exampleBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.ExampleBean"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"createInstance"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"anotherExampleBean"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"yetAnotherBean"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"anotherExampleBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.AnotherBean"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"yetAnotherBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.YetAnotherBean"</span>/&gt;</span></code></pre></div>

<p>对应的ExampleBean类：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleBean</span> </span>&#123;

    <span class="hljs-comment">// a private constructor</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ExampleBean</span><span class="hljs-params">(...)</span> </span>&#123;
        ...
    &#125;

    <span class="hljs-comment">// a static factory method; the arguments to this method can be</span>
    <span class="hljs-comment">// considered the dependencies of the bean that is returned,</span>
    <span class="hljs-comment">// regardless of how those arguments are actually used.</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExampleBean <span class="hljs-title">createInstance</span> <span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="hljs-keyword">int</span> i)</span> </span>&#123;

        ExampleBean eb = <span class="hljs-keyword">new</span> ExampleBean (...);
        <span class="hljs-comment">// some other operations...</span>
        <span class="hljs-keyword">return</span> eb;
    &#125;
&#125;</code></pre></div>

<p>静态工厂方法的参数由 &lt;constructor-arg/&gt; 元素提供，与实际使用构造函数完全相同。 工厂方法返回的类的类型不必与包含静态工厂方法的类的类型相同（尽管在本示例中是）。 实例工厂方法可以以基本相同的方式使用（除了使用 factory-bean 属性而不是 class 属性），因此我们不在这里讨论这些细节。</p>
<h3 id="1-4-2-依赖和配置的细节"><a href="#1-4-2-依赖和配置的细节" class="headerlink" title="1.4.2 依赖和配置的细节"></a>1.4.2 依赖和配置的细节</h3><p>如上一节所述，您可以将 bean 属性和构造函数参数定义为对其他托管 bean（协作者）的引用或作为内联定义的值。 为此，Spring 的基于 XML 的配置元数据支持其&lt;property/&gt; 和 &lt;constructor-arg/&gt; 元素中的子元素类型。</p>
<h4 id="直接值（原语、字符串等）"><a href="#直接值（原语、字符串等）" class="headerlink" title="直接值（原语、字符串等）"></a>直接值（原语、字符串等）</h4><p>&lt;property/&gt; 元素的 value 属性将属性或构造函数参数指定为人类可读的字符串表示形式。 Spring 的转换服务用于将这些值从 String 转换为属性或参数的实际类型。 以下示例显示了正在设置的各种值：</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"myDataSource"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.commons.dbcp.BasicDataSource"</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">"close"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- results in a setDriverClassName(String) call --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClassName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.jdbc.Driver"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql://localhost:3306/mydb"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"misterkaoli"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>下面的例子使用p名称空间来进行更简洁的XML配置:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">"http://www.springframework.org/schema/p"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">    https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"myDataSource"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.commons.dbcp.BasicDataSource"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">"close"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">p:driverClassName</span>=<span class="hljs-string">"com.mysql.jdbc.Driver"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">p:url</span>=<span class="hljs-string">"jdbc:mysql://localhost:3306/mydb"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">p:username</span>=<span class="hljs-string">"root"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">p:password</span>=<span class="hljs-string">"misterkaoli"</span>/&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<p>前面的XML更简洁。然而，打字错误是在运行时而不是设计时发现的，除非您使用支持创建bean定义时自动完成属性的IDE(如IntelliJ IDEA或用于Eclipse的Spring Tools)。强烈推荐这样的IDE帮助。</p>
<p>您也可以配置一个java.util.Properties实例，如下所示:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mappings"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.context.support.PropertySourcesPlaceholderConfigurer"</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- typed as a java.util.Properties --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"properties"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>
            jdbc.driver.className=com.mysql.jdbc.Driver
            jdbc.url=jdbc:mysql://localhost:3306/mydb
        <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>通过使用JavaBeans的PropertyEditor机制，Spring容器将&lt;value/&gt;元素中的文本转换为java.util.Properties实例。这是一个很好的快捷方式，也是Spring团队喜欢使用嵌套&lt;value/&gt;元素而不是value属性样式的少数地方之一。</p>
<p><strong>idref元素</strong></p>
<p>idref元素只是将容器中另一个bean的id(字符串值——而不是引用)传递给&lt;constructor-arg/&gt;或&lt;property/&gt;元素的一种防止错误的方法。下面的例子展示了如何使用它:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"theTargetBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"theClientBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"targetName"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">idref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"theTargetBean"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>前面的bean定义片段(在运行时)与下面的片段完全相同:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"theTargetBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span> /&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"client"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"targetName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"theTargetBean"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>第一种形式比第二种形式更可取，因为使用idref标记可以让容器在部署时验证所引用的已命名bean实际存在。在第二个变体中，对传递给客户机bean的targetName属性的值不执行任何验证。只有在实际实例化客户端bean时才会发现打字错误(很可能导致致命的结果)。如果客户端bean是一个原型bean，那么这个输入错误和由此产生的异常可能要在容器部署很久之后才会被发现。</p>
<blockquote>
<p>在4.0 bean XSD中不再支持idref元素的local属性，因为它不再提供常规bean引用之上的值。升级到4.0模式时，将现有的idref local更改为idref bean。</p>
</blockquote>
<p>&lt;idref/&gt;元素带来值的一个常见地方(至少在Spring 2.0之前的版本中)是在ProxyFactoryBean bean定义中的AOP拦截器配置中。在指定拦截器名称时使用&lt;idref/&gt;元素可以防止你拼错拦截器ID。</p>
<h4 id="对其他bean-合作者-的引用"><a href="#对其他bean-合作者-的引用" class="headerlink" title="对其他bean(合作者)的引用"></a>对其他bean(合作者)的引用</h4><p>ref元素是&lt;constructor-arg/&gt;或&lt;property/&gt;定义元素中的最后一个元素。在这里，您将一个bean的指定属性的值设置为对容器管理的另一个bean(合作者)的引用。被引用的bean是要设置其属性的bean的依赖项，在设置属性之前，根据需要对其进行初始化。(如果合作者是一个单例bean，它可能已经被容器初始化了。)所有引用最终都是对另一个对象的引用。范围和验证取决于您是通过bean还是父属性指定其他对象的ID或名称。</p>
<p>通过&lt;ref/&gt;标记的bean属性指定目标bean是最通用的形式，允许在同一容器或父容器中创建对任何bean的引用，而不管它是否在同一XML文件中。bean属性的值可以与目标bean的id属性相同，也可以与目标bean的name属性中的某个值相同。下面的例子展示了如何使用ref元素:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"someBean"</span>/&gt;</span></code></pre></div>

<p>通过 parent 属性指定目标 bean 会创建对当前容器的父容器中的 bean 的引用。 parent 属性的值可能与目标 bean 的 id 属性或目标 bean 的 name 属性中的值之一相同。 目标 bean 必须在当前容器的父容器中。当您有一个容器层次结构，并且您想用与父bean同名的代理将现有bean包装在父容器中时，您应该主要使用这个bean引用变体。以下清单显示了如何使用 parent 属性：</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- in the parent context --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.something.SimpleAccountService"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- insert dependencies as required as here --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-comment">&lt;!-- in the child (descendant) context --&gt;</span>
&lt;bean id="accountService" &lt;!-- bean name is the same as the parent bean --&gt;
    class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"target"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">"accountService"</span>/&gt;</span> <span class="hljs-comment">&lt;!-- notice how we refer to the parent bean --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- insert other configuration and dependencies as required here --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<h4 id="内部Bean"><a href="#内部Bean" class="headerlink" title="内部Bean"></a>内部Bean</h4><p>&lt;property/&gt;或&lt;constructor-arg/&gt;元素中的&lt;bean/&gt;元素定义了一个内部bean，如下所示:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"outer"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"target"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.Person"</span>&gt;</span> <span class="hljs-comment">&lt;!-- this is the inner bean --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Fiona Apple"</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"25"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>内部 bean 定义不需要定义的 ID 或名称。 如果指定，容器不会使用这样的值作为标识符。 容器在创建时也会忽略范围标志，因为内部 bean 始终是匿名的，并且始终与外部 bean 一起创建。 不可能独立访问内部 bean 或将它们注入除封闭 bean 之外的协作 bean 中。</p>
<p>作为一种极端情况，可以从自定义范围 接收销毁回调—— 例如，对于包含在单例 bean 中的请求范围内的 bean。 内部 bean 实例的创建与其包含的 bean 相关联，但销毁回调让它参与请求范围的生命周期。 这不是一个常见的场景。 内部 bean 通常只是共享它们包含的 bean 的作用域。</p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>&lt;list/&gt;， &lt;set/&gt;， &lt;map/&gt;，和&lt;props/&gt;元素分别设置Java集合类型list、set、map和properties的属性和参数。下面的例子展示了如何使用它们:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"moreComplexObject"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"example.ComplexObject"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"adminEmails"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"administrator"</span>&gt;</span>administrator@example.org<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"support"</span>&gt;</span>support@example.org<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"development"</span>&gt;</span>development@example.org<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- results in a setSomeList(java.util.List) call --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"someList"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>a list element followed by a reference<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"myDataSource"</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- results in a setSomeMap(java.util.Map) call --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"someMap"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"an entry"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"just some string"</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span> =<span class="hljs-string">"a ref"</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">"myDataSource"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- results in a setSomeSet(java.util.Set) call --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"someSet"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>just some string<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"myDataSource"</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>map键或值或set值的值也可以是以下元素中的任何一个:</p>
<div class="hljs"><pre><code class="hljs xml">bean | ref | idref | list | set | map | props | value | null</code></pre></div>

<p><strong>集合合并</strong></p>
<p>Spring容器还支持合并集合。应用程序开发人员可以定义父元素&lt;list/&gt;、&lt;map/&gt;、&lt;set/&gt;或&lt;props/&gt;，并让子元素&lt;list/&gt;、&lt;map/&gt;、&lt;set/&gt;或&lt;props/&gt;继承和覆盖父元素集合中的值。也就是说，子集合的值是父集合和子集合的元素合并的结果，子集合的元素覆盖父集合中指定的值。</p>
<p>关于合并的这一节讨论父-子bean机制。不熟悉父bean和子bean定义的读者可能希望在继续之前阅读相关部分。</p>
<p>下面的例子演示了集合合并:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"parent"</span> <span class="hljs-attr">abstract</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"example.ComplexObject"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"adminEmails"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"administrator"</span>&gt;</span>administrator@example.com<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"support"</span>&gt;</span>support@example.com<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"child"</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">"parent"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"adminEmails"</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- the merge is specified on the child collection definition --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">props</span> <span class="hljs-attr">merge</span>=<span class="hljs-string">"true"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"sales"</span>&gt;</span>sales@example.com<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"support"</span>&gt;</span>support@example.co.uk<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<p>请注意在子 bean 定义的 adminEmails 属性的 &lt;props/&gt; 元素上使用了 merge=true 属性。 当容器解析并实例化子 bean 时，生成的实例有一个 adminEmails Properties 集合，其中包含将子 bean 的 adminEmails 集合与父级的 adminEmails 集合合并的结果。 以下清单显示了结果：</p>
<div class="hljs"><pre><code class="hljs xml">administrator=administrator@example.com
sales=sales@example.com
support=support@example.co.uk</code></pre></div>

<p>子属性集合的值集继承了父属性&lt;props/&gt;的所有属性元素，并且子属性的支持值覆盖了父集合中的值。</p>
<p>这种合并行为同样适用于&lt;list/&gt;、&lt;map/&gt;和&lt;set/&gt;集合类型。在&lt;list/&gt;元素的特定情况下，将维护与list集合类型(即值的<strong>有序</strong>集合的概念)相关联的语义，父列表的值在所有子列表的值之前。对于Map、Set和Properties集合类型，不存在排序。因此，对于容器内部使用的关联Map、Set和Properties实现类型的集合类型，没有有效的排序语义。</p>
<p><strong>收集合并的限制</strong></p>
<p>您不能合并不同的集合类型(例如Map和List)。如果您试图这样做，则抛出一个适当的Exception。必须在较低的继承子定义上指定merge属性。在父集合定义上指定merge属性是多余的，并且不会导致所需的合并。</p>
<p><strong>强类型集合</strong></p>
<p>通过在Java 5中引入泛型类型，您可以使用强类型集合。也就是说，可以声明一个Collection类型，使它只能包含(例如)String元素。如果使用Spring将强类型Collection依赖注入到bean中，那么可以利用Spring的类型转换支持，在将强类型Collection实例的元素添加到Collection之前，将其转换为适当的类型。下面的Java类和bean定义展示了如何做到这一点:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span> </span>&#123;

    <span class="hljs-keyword">private</span> Map&lt;String, Float&gt; accounts;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAccounts</span><span class="hljs-params">(Map&lt;String, Float&gt; accounts)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.accounts = accounts;
    &#125;
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"something"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x.y.SomeClass"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"accounts"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"one"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"9.99"</span>/&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"two"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"2.75"</span>/&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"six"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"3.99"</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<p>当something bean 的accounts 属性准备注入时，关于强类型Map&lt;String, Float&gt; 元素类型的泛型信息可通过反射获得。 因此，Spring 的类型转换基础结构将各种值元素识别为 Float 类型，并将字符串值（9.99、2.75 和 3.99）转换为实际的 Float 类型。</p>
<h4 id="Null和空字符串值"><a href="#Null和空字符串值" class="headerlink" title="Null和空字符串值"></a><strong>Null和空字符串值</strong></h4><p>Spring将属性等的空参数视为空字符串。以下基于xml的配置元数据片段将email属性设置为空String值(“”)。</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ExampleBean"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"email"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">""</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>上述示例相当于以下Java代码:</p>
<div class="hljs"><pre><code class="hljs java">exampleBean.setEmail(<span class="hljs-string">""</span>);</code></pre></div>

<p>&lt;null/&gt;元素处理空值。下面的清单显示了一个示例:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ExampleBean"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"email"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">null</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>等价于：</p>
<div class="hljs"><pre><code class="hljs java">exampleBean.setEmail(<span class="hljs-keyword">null</span>);</code></pre></div>

<h4 id="使用p-名称空间的XML快捷方式"><a href="#使用p-名称空间的XML快捷方式" class="headerlink" title="使用p-名称空间的XML快捷方式"></a>使用p-名称空间的XML快捷方式</h4><p>p-namespace允许您使用bean元素的属性(而不是嵌套的&lt;property/&gt;元素)来描述协作bean的属性值，或者两者都使用。</p>
<p>Spring 支持具有命名空间的可扩展配置格式，这些格式基于 XML 模式定义。 本章讨论的 bean 配置格式是在 XML Schema 文档中定义的。 但是，p 命名空间并未在 XSD 文件中定义，仅存在于 Spring 的核心中。</p>
<p>下面的例子显示了两个XML片段(第一个使用标准XML格式，第二个使用p-namespace)，它们解析到相同的结果:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">"http://www.springframework.org/schema/p"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"classic"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.ExampleBean"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"email"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"someone@somewhere.com"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"p-namespace"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.ExampleBean"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">p:email</span>=<span class="hljs-string">"someone@somewhere.com"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<p>该示例显示了在 bean 定义中名为 email 的 p 命名空间中的一个属性。 这告诉 Spring 包含一个属性声明。 如前所述，p 命名空间没有模式定义，因此您可以将属性的名称设置为属性名。</p>
<p>下一个示例包括另外两个bean定义，它们都有对另一个bean的引用:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">"http://www.springframework.org/schema/p"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"john-classic"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.Person"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"John Doe"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"spouse"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"jane"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"john-modern"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.Person"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">p:name</span>=<span class="hljs-string">"John Doe"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">p:spouse-ref</span>=<span class="hljs-string">"jane"</span>/&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"jane"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.Person"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Jane Doe"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<p>这个示例不仅包含使用p-namespace的属性值，而且还使用一种特殊的格式来声明<strong>属性引用</strong>。第一个bean定义使用&lt;property name=”spouse” ref=”jane”/&gt;来创建从bean john到bean jane的引用，第二个bean定义使用p:spouse-ref=”jane”作为属性来完成完全相同的工作。在本例中，spouse是属性名，而<code>-ref</code>部分表示这不是一个直接值，而是对另一个bean的引用。</p>
<blockquote>
<p>p-namespace不像标准XML格式那样灵活。例如，声明属性引用的格式与以Ref结尾的属性冲突，而标准XML格式不会。我们建议您谨慎地选择您的方法，并与您的团队成员进行沟通，以避免生成同时使用所有三种方法的XML文档。</p>
</blockquote>
<h4 id="使用c-namespace的XML快捷方式"><a href="#使用c-namespace的XML快捷方式" class="headerlink" title="使用c-namespace的XML快捷方式"></a>使用c-namespace的XML快捷方式</h4><p>与带有p-namespace的XML快捷方式类似，Spring 3.1中引入的c-namespace允许内联属性来配置构造函数参数，而不是嵌套的构造函数-参数元素。</p>
<p>下面的例子使用c: namespace做了与基于构造函数的依赖注入相同的事情:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xmlns:c</span>=<span class="hljs-string">"http://www.springframework.org/schema/c"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"beanTwo"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x.y.ThingTwo"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"beanThree"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x.y.ThingThree"</span>/&gt;</span>

    <span class="hljs-comment">&lt;!-- traditional declaration with optional argument names --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"beanOne"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x.y.ThingOne"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"thingTwo"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"beanTwo"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"thingThree"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"beanThree"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"email"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"something@somewhere.com"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- c-namespace declaration with argument names --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"beanOne"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x.y.ThingOne"</span> <span class="hljs-attr">c:thingTwo-ref</span>=<span class="hljs-string">"beanTwo"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">c:thingThree-ref</span>=<span class="hljs-string">"beanThree"</span> <span class="hljs-attr">c:email</span>=<span class="hljs-string">"something@somewhere.com"</span>/&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<p>命名空间使用与p: one (bean引用的末尾-ref)相同的约定，通过名称设置构造函数参数。类似地，它需要在XML文件中声明，即使它没有在XSD模式中定义(它存在于Spring核心中)。</p>
<p>对于构造函数参数名不可用的罕见情况(通常是在没有调试信息的情况下编译的字节码)，你可以使用回退参数索引，如下所示:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- c-namespace index declaration --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"beanOne"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x.y.ThingOne"</span> <span class="hljs-attr">c:_0-ref</span>=<span class="hljs-string">"beanTwo"</span> <span class="hljs-attr">c:_1-ref</span>=<span class="hljs-string">"beanThree"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">c:_2</span>=<span class="hljs-string">"something@somewhere.com"</span>/&gt;</span></code></pre></div>

<blockquote>
<p>由于XML语法的原因，索引表示法要求出现前导_，因为XML属性名不能以数字开头(尽管有些ide允许)。对于&lt;constructor-arg&gt;元素也可以使用相应的索引表示法，但不常用，因为声明的简单顺序通常就足够了。</p>
</blockquote>
<p>在实践中，构造函数解析机制在匹配参数方面非常有效，所以除非真的需要，否则我们建议在整个配置中使用名称表示法。</p>
<h4 id="复合属性名"><a href="#复合属性名" class="headerlink" title="复合属性名"></a>复合属性名</h4><p>在设置bean属性时，可以使用复合或嵌套属性名，只要路径的所有组件(最终属性名除外)不为空。考虑以下bean定义:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"something"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"things.ThingOne"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"fred.bob.sammy"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"123"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>这个bean有一个fred属性，它有一个bob属性，它有一个sammy属性，最后一个sammy属性被设置为123。为了使其工作，在构造bean之后，something的fred属性和fred的bob属性不能为空。否则，抛出NullPointerException。</p>
<h3 id="1-4-3-使用depends-on"><a href="#1-4-3-使用depends-on" class="headerlink" title="1.4.3 使用depends-on"></a>1.4.3 使用depends-on</h3><p>如果一个bean是另一个bean的依赖项，这通常意味着一个bean被设置为另一个bean的属性。通常使用基于xml的配置元数据中的&lt;ref/&gt;元素来实现这一点。但是，有时bean之间的依赖关系不是那么直接。例如，当需要触发类中的静态初始化器时，例如数据库驱动程序注册时。<strong>depends-on可以显式地在使用此元素的bean初始化之前强制初始化一个或多个bean。</strong>下面的示例使用depends-on属性表示对单个对象的依赖关系:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"beanOne"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ExampleBean"</span> <span class="hljs-attr">depends-on</span>=<span class="hljs-string">"manager"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"manager"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ManagerBean"</span> /&gt;</span></code></pre></div>

<p>要表示对多个bean的依赖，请提供一个bean名列表作为依赖属性的值(逗号、空格和分号是有效的分隔符):</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"beanOne"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ExampleBean"</span> <span class="hljs-attr">depends-on</span>=<span class="hljs-string">"manager,accountDao"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"manager"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"manager"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"manager"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ManagerBean"</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountDao"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x.y.jdbc.JdbcAccountDao"</span> /&gt;</span></code></pre></div>

<p>depends-on 属性可以指定初始化时间依赖项，并且在仅单例 bean 的情况下，可以指定相应的销毁时间依赖项。 在给定 bean 本身被销毁之前，首先销毁与给定 bean 定义依赖关系的从属 bean。 因此，depends-on 也可以控制关闭顺序。</p>
<h3 id="1-4-4-延迟初始化的Bean"><a href="#1-4-4-延迟初始化的Bean" class="headerlink" title="1.4.4 延迟初始化的Bean"></a>1.4.4 延迟初始化的Bean</h3><p>默认情况下，ApplicationContext 实现会在初始化过程中创建和配置所有单例 bean。 通常，这种预实例化是可取的，因为可以立即发现配置或周围环境中的错误，而不是在几小时甚至几天之后。 当这种行为不可取时，您可以通过将 bean 定义标记为延迟初始化来防止单例 bean 的预实例化。 一个延迟初始化的 bean 告诉 IoC 容器在它第一次被请求时创建一个 bean 实例，而不是在启动时。</p>
<p>在XML中，这种行为由&lt;bean/&gt;元素上的lazy-init属性控制，如下面的例子所示:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"lazy"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.something.ExpensiveToCreateBean"</span> <span class="hljs-attr">lazy-init</span>=<span class="hljs-string">"true"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"not.lazy"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.something.AnotherBean"</span>/&gt;</span></code></pre></div>

<p>当 ApplicationContext 使用前面的配置时，当 ApplicationContext 启动时，lazy bean 不会被预先实例化，而 not.lazy bean 会被预先实例化。</p>
<p>然而，当一个惰性初始化的bean是一个非惰性初始化的单例bean的依赖项时，ApplicationContext会在启动时创建惰性初始化的bean，因为它必须满足单例bean的依赖项。惰性初始化的bean被注入到其他未惰性初始化的单例bean中。</p>
<p>你也可以通过在&lt;beans/&gt;元素上使用default-lazy-init属性来控制容器级的惰性初始化，如下面的例子所示:</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">default-lazy-init</span>=<span class="hljs-string">"true"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- no beans will be pre-instantiated... --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<h3 id="1-4-5-自动装配协作者"><a href="#1-4-5-自动装配协作者" class="headerlink" title="1.4.5 自动装配协作者"></a>1.4.5 自动装配协作者</h3><p>Spring容器可以自动装配协作bean之间的关系。通过检查ApplicationContext的内容，您可以让Spring自动为您的bean解析协作者(其他bean)。自动装配具有以下优点:</p>
<ul>
<li>自动装配可以显著减少指定属性或构造函数参数的需要。</li>
<li>自动装配可以随着对象的发展更新配置。例如，如果您需要向类添加依赖项，则无需修改配置即可自动满足该依赖项。因此，在开发过程中，自动装配尤其有用，当代码库变得更加稳定时，不会否定切换到显式装配的选项。</li>
</ul>
<p>当使用基于xml的配置元数据时(请参阅[依赖注入](#1.4.1 依赖注入))，您可以使用&lt;bean/&gt;元素的autotowire属性为bean定义指定自动装配模式。自动装配功能有四种模式。您可以指定每个bean的自动装配，因此可以选择自动装配哪些bean。下表描述了四种自动装配模式:</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>no</td>
<td>(默认)没有自动装配。Bean引用必须由ref元素定义。对于较大的部署，不建议更改默认设置，因为明确指定协作者可以提供更大的控制和清晰度。在某种程度上，它记录了系统的结构。</td>
</tr>
<tr>
<td>byName</td>
<td>通过属性名自动装配。Spring查找与需要自动连接的属性同名的bean。例如，如果一个bean定义被设置为按名称自动装配，并且它包含一个主属性(也就是说，它有一个setMaster(..)方法)，Spring会寻找一个名为master的bean定义，并使用它来设置该属性。</td>
</tr>
<tr>
<td>byType</td>
<td>如果容器中正好存在一个属性类型的bean，则让属性自动连接。如果存在多个，则抛出致命异常，这表明您不能为该bean使用byType自动装配。如果没有匹配的bean，则不会发生任何事情(属性没有设置)。</td>
</tr>
<tr>
<td>constructor</td>
<td>类似于byType，但应用于构造函数参数。如果容器中没有一个构造函数参数类型的bean，则会引发致命错误。</td>
</tr>
</tbody></table>
<h2 id="1-5-Bean范围"><a href="#1-5-Bean范围" class="headerlink" title="1.5 Bean范围"></a>1.5 Bean范围</h2><h3 id="1-6-1-生命周期回调"><a href="#1-6-1-生命周期回调" class="headerlink" title="1.6.1 生命周期回调"></a>1.6.1 生命周期回调</h3><h4 id="初始化回调"><a href="#初始化回调" class="headerlink" title="初始化回调"></a>初始化回调</h4><h4 id="破坏回调"><a href="#破坏回调" class="headerlink" title="破坏回调"></a>破坏回调</h4><h3 id="1-12-3使用-Bean注释"><a href="#1-12-3使用-Bean注释" class="headerlink" title="1.12.3使用@Bean注释"></a>1.12.3使用@Bean注释</h3>
            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/">开发框架</a>
                    
                      <a class="hover-with-bg" href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/Spring%E6%A1%86%E6%9E%B6/">Spring框架</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Spring/">Spring</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2021/06/27/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">IDEA常用快捷键</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2021/06/13/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/">
                        <span class="hidden-mobile">阿里巴巴Java开发手册</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <script defer src="https://utteranc.es/client.js"
          repo="gavin-yyj/commit-utterance"
          issue-term="pathname"
  
          theme="github-light"
          crossorigin="anonymous"
  >
  </script>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Spring官方文档学习&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
